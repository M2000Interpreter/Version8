25
ΓΡΑΦΙΚΑ 2Δ, DRAWING 2D
ΒΑΣΕΙΣ ΔΕΔΟΜΕΝΩΝ, DATABASES
ΡΟΗ ΠΡΟΓΡΑΜΜΑΤΟΣ, FLOW CONTROL
ΕΝΤΟΛΕΣ ΕΙΚΟΝΩΝ, BITMAP COMMANDS
ΗΧΟΙ ΚΑΙ ΤΑΙΝΙΕΣ, SOUNDS AND MOVIES
ΕΝΤΟΛΕΣ ΔΕΙΚΤΗ, MOUSE COMMANDS
ΟΡΙΣΜΟΙ, DEFINITIONS
ΕΝΤΟΛΕΣ ΚΟΝΣΟΛΑΣ, CONSOLE COMMANDS
ΕΝΤΟΛΕΣ ΣΩΡΟΥ, STACK COMMANDS
ΕΝΤΟΛΕΣ ΙΣΤΟΥ, BROWSER COMMANDS
ΧΕΙΡΙΣΜΟΣ ΑΡΧΕΙΩΝ, FILE OPERATIONS
ΚΟΙΝΕΣ ΦΟΡΜΕΣ, COMMON DIALOGUES
ΣΤΟΧΟΙ ΚΑΙ ΕΠΙΛΟΓΗ, TARGET AND MENU
ΔΙΕΡΜΗΝΕΥΤΗΣ, INTERPRETER
ΧΕΙΡΙΣΜΟΣ ΤΜΗΜΑΤΩΝ, MODULE COMMANDS
ΟΘΟΝΗ ΚΑΙ ΑΡΧΕΙΑ, SCREEN AND FILES
ΕΚΤΥΠΩΣΕΙΣ, PRINTINGS

ΑΡΙΘΜΗΤΙΚΑ, ARITHMETIC FUNCTIONS
ΑΛΦΑΡΙΘΜΗΤΙΚΑ, STRING FUNCTIONS
ΜΕΤΑΒΛΗΤΕΣ ΣΥΣΤΗΜΑΤΟΣ, VARS READ ONLY
ΓΕΝΙΚΑ, GENERAL
ΣΤΑΘΕΡΕΣ, CONSTANTS
ΧΕΙΡΙΣΤΕΣ ΤΗΣ ΤΥΠΩΣΕ, OPERATORS IN PRINT
ΕΓΓΡΑΦΑ, DOCUMENTS
580
EN:#SUM(\r\nΤύπωσε (1,2,3)#αθρ()\r\nΠίνακα Α(10)=1\r\nΤύπωσε Α()#αθρ()=10\r\nμ=(1,2,3,4)\r\nΤύπωσε μ#αθρ()=10\r\nΣτη α=1, β=2, γ=3\r\nΤύπωσε (α,β,γ)#αθρ()\r\n\r\n\\\\ δεν μπορούμε να βάλουμε πριν τον αυτόματο πίνακα πρόσημο (πχ το -(1,2,3)#αθρ()  βγάζει λάθος )\r\n\\\\ όμως μπορούμε αν χρησιμοποιήσουμε δείκτη, όπως ο μ, ή πίνακας όπως το Α()\r\n\r\n
EN:#REV(\r\n\r\nΤύπωσε (1,2,3)#αναπ()\r\n     3      2     1\r\n
EN:#MAP(\r\n\r\nα=(1,2,3,4,5,6,7,8,9)\r\nπακ2=λάμδα ->{\r\n\tφερε 2\r\n\tβάλε γραμμα$+\"-\"+γραμμα$\r\n}\r\nμονός=λάμδα (χ)->χ υπόλοιπο 2=1\r\nβ=α#φίλτρο(μονός, (,))\r\nΤύπωσε β ' 1,3,5,7,9\r\nαντ1=λάμδα ->{\r\n\tΒάλε ΧαρΚωδ$(αριθμός+64)\r\n}\r\nζ=α#φίλτρο(μονός)#αντ(αντ1)\r\nΤύπωσε ζ  ' A C E G I\r\nΤύπωσε \"[\"+α#φίλτρο(μονός)#αντ(αντ1)#πακ$(πακ2, \"CODE\")+\"]\"=\"[CODE-A-C-E-G-I]\"\r\n
EN:#EVAL$(\r\nΔες την #Εκφρ()\r\n\r\nΚλάση άλφα$ {\r\n\tΑξία (χ) {\r\n\t\t=Γραφή$(500*χ)\r\n\t}\r\n}\r\nζ$=άλφα$()\r\nΤύπωσε ζ$(5)\r\nμ=(άλφα$(), άλφα$())\r\nκ$=μ#Τιμή$(0)\r\nΤύπωσε κ$(5)\r\nΤύπωσε μ#Εκφρ$(0, 5)\r\nΤύπωσε \"έγινε\"\r\n\r\n\r\n\r\n
EN:#EVAL(\r\nΗ #εκφρ() χρησιμοποιείται σε πίνακες πχ Α() ή δείκτες σε πίνακες. Μπορεί να προστεθεί σε υπάρχουσες εντολές τύπου #χχ(). Διαφέρει από την #Τιμή() σε σχέσει με πίνακες γιατί η #Τιμή() γυρίζει αντίγραφο πίνακα ενώ η #εκφρ() γυρνάει τον κανονικό δείκτη. Αν θέλουμε τιμές αλφαριθμητικών τότε χρησιμοποιούμε την #Εκφρ$(). Αν στην θέση που ζητάμε υπάρχει λάμδα συνάρτηση ή αντικείμενο που γυρνάει τιμή και ίσως ζητούν και δεδομένα, τότε η #Εκφρ() αφενός οφείλει να παρέχει τα δεδομένα και αφετέρου εκτελεί (κάτι που δεν κάνει η #Τιμη()). Επιπλέον αν το αντικείμενο είναι Πίνακας ή Κατάσταση ή Σωρός τότε αν δώσουμε παράμετρο θα δώσει ότι βρει στη θέση που δείχνει η παράμετρος, και αν δώσουμε περισσότερες τότε εφόσον αυτό που βρίσκει είναι αντικείμενο προχωράει το ίδιο. Αν δώσουμε παράμετρο και δεν υπάρχει αντικείμενο θα βγει λάθος - το πιθανότερο να κάνει έξοδο το τμήμα στο οποίο εκτλείται, ή στο μπλοκ που εκτελείται.\r\n\r\n\r\nμ=(1,2,(100,(200,201,202),300),4)\r\nΤύπωσε μ#Εκφρ(2,1,2)=202\r\nΤύπωσε μ#Τιμή(2)#Τιμή(1)#Τιμή(2)=202\r\nΚλάση Άλφα {\r\n\tΑξία (x){\r\n\t\t=500*x\r\n\t}\r\n}\r\nμ=(1,2,(Λάμδα (x)->500*x), Άλφα())\r\nΤύπωσε μ#Εκφρ(2,3)=500*3, μ#Εκφρ(3,3)=500*3\r\nΚατάσταση Ουρά κ=1,2,3:=300,4\r\nμ=(1,2,κ)\r\nΤύπωσε κ(3)=300, κ(2!)=300, μ#Εκφρ(2,2)=300\r\n\\\\ η απλή Κατάσταση δεν εγγυάται τη θέση των στοιχείων (αλλάζουν μετά από διαγραφή)\r\n\\\\ στη Κατάσταση τύπου ουρά, διαγράφουμε μόνο από το τέλος, οπότε η θέση όσων υπάρχουν δεν αλλάζει.\r\n\\\\ και στις δυο περιπτώσεις η ταξινόμηση αλλάζει θέση, αλλά στην τύπου ουρά, γίνεται σταθερή ταξινόνηση, και τα όμοια κλειδιά δεν αλλάζουν μεταξύ τους θέση. Στην κανονική Κατάσταση δεν μπαίνουν όμοια κλειδιά.\r\nΚατάσταση κ1=1,2,3:=1000,4,5\r\nμ=(1,2,κ1)\r\nΑφαίρεση κ1, 2, 4\r\nΑν Υπάρχει(κ1, 3) Τότε κ1_θέση_στοιχείου=Εκφρ(κ1!)\r\nΤύπωσε μ#Εκφρ(2,κ1_θέση_στοιχείου)=1000\r\n\\\\ για να δούμε με κλειδί από το μ χρειάζεται μια ένωση με άλλου τύπου διεπαφή\r\nΈνωσε μ στο μ()\r\nΤύπωσε μ(2)(3)=1000\r\n\r\n\r\n\r\n\r\n
EN:#POS(\r\nΔεν μπορούμε να βάλουμε και αριθμούς και αλφαριθμητικά στην λίστα αναζήτησης\r\n\r\nα=(1,1,0,1,1,1,1,0,1,1,0)\r\nΤύπωσε α#θέση(1,0,1) ' 1  σημαίνει 2η θέση\r\nΤύπωσε α#θέση(5->1,0,1) ' 6  σημαίνει 7η θέση\r\nα=(\"hello\",\"1\", \"hello\",\"2\")\r\nΤύπωσε α#θέση(0->\"hello\", \"2\")=2 ' δίνει τη 3η ΄θέση\r\n\r\n\r\n
EN:#MAX$(\r\n\r\nα=(\"α\",\"β\",\"γ\")\r\nΤύπωσε α#μεγ$()=\"γ\"\r\nζ=-1\r\nΤύπωσε α#μεγ$(ζ)=\"γ\", ζ=2\r\n\r\n
EN:#MAX(\r\nα=(1,2,3)\r\nΤύπωσε α#μεγ()=3\r\nζ=-1\r\nΤύπωσε (1,2,3,-3)#μεγ(ζ)=3, ζ=2\r\n\r\n
EN:#SLICE(\r\nα=(1,2,3,4,5)\r\nΤύπωσε α#μερος(1,2)  '  2 3\r\nΤύπωσε α#μερος(1,2)#αναπ()  ' 3 2\r\nΤύπωσε α#μερος(2) ' 3 4 5\r\nΤύπωσε α#μερος(,2) ' 1 2 3\r\n\r\n
EN:#MIN$(\r\nα=(\"α\",\"β\",\"γ\")\r\nΤύπωσε α#μικ$()=\"α\"\r\nζ=-1\r\nΤύπωσε α#μικ$(ζ)=\"α\", ζ=0\r\n\r\n
EN:#MIN(\r\nΤύπωσε (1,2,3)#μικ()=1\r\nα=(1,2,3)\r\nΤύπωσε α#μικ()=1\r\nΠίνακας α(3)\r\nα(0)=1,2,3\r\nΤύπωσε α()#μικ()\r\nζ=-1\r\nΤύπωσε α()#μικ(ζ)=1, ζ=0\r\n\r\n
EN:#FOLD$(\r\nα=(\"α\",\"β\",\"γ\")\r\nπακ1=λάμδα μ=1 ->{\r\n      φέρε 2  :\r\n      αν μ=1 τότε\r\n            μ=0\r\n            πέτα\r\n            Βάλε \"\"\"\"+κεφ$(γράμμα$)+\"\"\"\"\r\n      αλλιώς\r\n            βάλε γραμμα$+\",\"+\"\"\"\"+κεφ$(γράμμα$)+\"\"\"\"\r\n      τέλος αν\r\n}\r\nΤύπωσε \"[\"+α#πακ$(πακ1)+\"]\" ={[\"Α\",\"Β\",\"Γ\"]}\r\n\r\n
EN:#FOLD(\r\nα=(1,2,3,4,5,6,7,8,9)\r\nπακέτο1=Λάμδα ->{\r\n      Βάλε αριθμός+αριθμός\r\n}\r\nΤύπωσε α#πακ(πακέτο1)=α#αθρ()\r\nΤύπωσε α#πακ(πακέτο1,10)=α#αθρ()+10\r\n\r\nΔες φίλτρο(), #αντ(), #πακ$(), #θέση()\r\n
EN:#SORT(\r\nΤύπωσε (10,3,4,1)#ΤΑΞΙΝΟΜΗΣΗ(1)\r\n10 3 4 1\r\nΤύπωσε (10,3,4,1)#ΤΑΞΙΝΟΜΗΣΗ()\r\n1 4 3 10\r\nΤύπωσε (10,3,4,1)#ΤΑΞΙΝΟΜΗΣΗ(0,1,3)\r\n10 1 3 4\r\n
EN:#VAL$(\r\n\r\nα=(1,\"Α\", 2, \"Β\")\r\nΤύπωσε α#Τιμή$(1)=\"Α\"\r\n\r\n\r\n
EN:#VAL(\r\nα=(1,2,3)\r\nΤύπωσε α#Τιμή(0)=1\r\n\r\n
EN:#FILTER(\r\n\r\nα=(1,2,3,4,5,6,7,8,9)\r\nπακ1=λάμδα ->{\r\n      βάλε αριθμός+αριθμός\r\n}\r\nζυγός=λάμδα (χ)->χ υπόλοιπο 2=0\r\nβ=α#φίλτρο(ζυγός, (,))\r\nΤύπωσε β ' 2 4 6 8\r\nΤύπωσε α#φίλτρο(ζυγός)#πακ(πακ1)=20\r\n
EN:FLUSH\r\nΑΔΕΙΑΣΕ ' Αδειάζει ο σωρός\r\nΥπάρχουν δυο παραλλαγές: \r\nΑΔΕΙΑΣΕ ΛΑΘΟΣ      ' καθαρίζει το τελευταίο μήνυμα λάθους\r\n      και\r\n\\\\ Δεν χρησιμοποιείται από την 9.4 ΑΔΕΙΑΣΕ ΣΚΟΥΠΙΔΙΑ   ' ενεργοποιεί άμεσα ον συλλέκτη σκουπιδιών\r\n\r\n\r\n\r\nΟ σωρός δεν σβήνει παρά μόνο με δυο τρόπους:\r\n1) Τερματισμός του μεταφραστή (γιατί απλά δεν υπάρχει μετά)\r\n2) Με την ΑΔΕΙΑΣΕ\r\n\r\n\r\nΜπορούμε να δούμε αν είναι ΚΕΝΟΣ με την μεταβλητή ΚΕΝΟ (EMPTY) που παίρνει τιμές -1 και 0 (ΑΛΗΘΕΣ, ΨΕΥΔΕΣ)\r\n\r\nΕπίσης αν δεν είναι ΚΕΝΟ δηλαδή έχει τιμές μπορούμε να δούμε αν είναι αριθμός ή γράμματα με τις ΕΙΝΑΡ (ISNUM) και ΕΙΝΓΡ (ISLET)\r\n\r\nΟι τιμές του σωρού διαβάζονται με δυο τρόπους: με την εντολή ΔΙΑΒΑΣΕ αλλά και με τις μεταβλητές ΤΙΜΗ και ΓΡΑΜΜΑ$ (αν όμως έχουμε αριθμό και γράψουμε Β$=ΓΡΑΜΜΑ$ τότε θα βγει ΛΑΘΟΣ)\r\n\r\nΑπό την έκδοση 6 έχουμε και άλλο τρόπο να δούμε το σωρο:\r\nΒαλε 1,2,\"ααα\"\r\nΤυπωσε Φακελος$()\r\nμας δίνει\r\nSNN\r\nΠου σημαίνει αλφαριθμητικό, αριθμός, αριθμός\r\n
EN:INT(\r\n>ΤΥΠΩΣΕ ΑΚ(12.5)\r\n           12\r\nΔίνει πάντα το μικρότερο ή ίσο ακέραιο.\r\n\r\nγια 1.9 δίνει 1\r\nγια 1.1 δίνει 1\r\nγια -1.9 δίνει -2\r\nγια -1.1 δίνει -2\r\n\r\nΑυτή η συνάρτηση δεν συνδέεται με την στρογγυλοποίηση\r\nείτε την αυτόματη όπως εδώ\r\nα%=-1.2\r\nΘα πάρει το -1\r\nα%=-1.8\r\nΘα πάρει το -2\r\nείτε την κατ ΄απαίτηση με την Στρογγ()\r\nΤύπωσε Στρογγ(-1.8, 0) δίνει -2\r\nΜπορούμε να κάνουμε στρογγυλοποιήσεις άμεσα στην εμφάνιση\r\nΜπορούμε να ορίσουμε τη μορφή του σημείου των δεκαδικών\r\nμε την Τοπικό. Πχ Τοπικό 1032 θα βάλε το κόμμα\r\nΠάντα όμως στο κώδικα το σημείο δεκαδικών είναι η τελεία.\r\nΤύπωσε Μορφή$(\"{0:0} {0:1} {0:2:-8}\", -1.8)\r\n\r\n
EN:SINT(\r\nα=0xFAAA\r\nΤύπωσε ΑΚΕΡΑΙΟ.ΔΥΑΔΙΚΟ(α), ΑΚΕΡΑΙΟ.ΔΥΑΔΙΚΟ(α,2)  ' το δεύτερο είναι αρνητικός\r\nα=0xFFFFFAAA\r\nΤύπωσε ΑΚΕΡΑΙΟ.ΔΥΑΔΙΚΟ(α)  ' αρνητικός\r\nΤύπωσε α ' ως ακέραιος αριθμός χωρίς πρόσημο\r\nΔεκαεξ ΔΥΑΔΙΚΟ.ΑΚΕΡΑΙΟ(ΑΚΕΡΑΙΟ.ΔΥΑΔΙΚΟ(α))\r\n\r\n\\\\ Χρησιμοποίησε το ΔΥΑΔΙΚΟ.ΑΚΕΡΑΙΟ() για το ανάποδο\r\n\r\n
EN:INTEGER\r\nΧρησιμοποιείται στην εντολή ΑΡΧΕΙΟ\r\n\r\n
EN:TRUE _2\r\nΔΙΝΕΙ -1 \r\nΟΠΩΣ Η ΑΛΗΘΗΣ\r\n\r\n\r\n
EN:TRUE\r\nΔίνει τιμή -1\r\n(υπάρχει και η ΨΕΥΔΕΣ εκδ 4.)\r\n\r\n
EN:CHANGE\r\nΤα ορίσματα δίνονται με όνομα και τιμή. Μπορούν να δοθούν και ανακατωμένα:\r\nΠΕΝΑ, ΦΡΑΣΗ, ΦΟΝΤΟ, ΠΛΑΙΣΙΟ, ΟΔΗΓΙΑ\r\nΗ μεταβλητή ΕΔ κρατάει το νούμερο του ΣΤΟΧΟΥ (πρώτο νούμερο το 0)\r\nΔώστε:\r\nΑΛΛΑΓΗ ΕΔ, ΦΡΑΣΗ \"οκ\"\r\nΑΛΛΑΓΗ ΕΔ, ΦΟΝΤΟ 2\r\nΑΛΛΑΓΗ ΕΔ, ΠΛΑΙΣΙΟ 15\r\nΑΛΛΑΓΗ ΕΔ, ΠΕΝΑ 15, ΠΛΑΙΣΙΟ 7, ΦΟΝΤΟ 3, ΦΡΑΣΗ \"ΟΛΑ ΚΑΛΑ\"\r\nΑΛΛΑΓΗ ΕΔ, ΟΔΗΓΙΑ \"ΟΘΟΝΗ\"\r\n---------------\r\nΔΕΣ ΣΤΟΧΟΣ\r\n\r\n
EN:REPLACE$(\r\nΤΥΠΩΣΕ ΑΛΛΑΓΗ$(\"Α\",\"Β\",\"ΑΑΒΑΑΑΒΒΒΒΑΑΑ\")\r\nBBBBBBBBBBBBB\r\n\r\n
EN:SWAP\r\nΑΛΛΑΞΕ Α$, Β$\r\nΑΛΛΑΞΕ Α%,Β%\r\nΑΛΛΑΞΕ Α(3), Α(5)\r\nΑΛΛΑΞΕ Α, Α(5)\r\nΑΛΛΑΞΕ Α, Β\r\n\r\nη ΑΛΛΑΞΕ είναι δυο φορές και παραπάνω πιο γρήγορη από την απλή μετακίνηση με τρίτη μεταβλητή.\r\nΕσωτερικά όλες οι μεταβλητές και οι πίνακες είναι τύπου Variant, με 16 byte. Η swap αλλάζει αυτά τα 16 Byte.\r\n\r\n
EN:ELSE\r\nΔΕΣ ΑΝ, ΕΠΕΛΕΞΕ\r\n\r\n\r\n
EN:ELSE.IF\r\nδες Αν\r\n\r\n
EN:HALT\r\nΜπορούμε οπουδήποτε στο πρόγραμμα να δώσουμε το ΑΛΤ\r\nΘα μας βγάλει στη κονσόλα, και μπορούμε να συνεχίσουμε με το Συνέχισε\r\nΣτη κονσόλα με το Λίστα βλέπουμε όλες τις μεταβλητές και μπορούμε να τις αλλάξουμε. Τις βλέπουμε με το πρόθεμά τους (αν είναι τοπικές)\r\n\r\n
EN:STRING FUNCTIONS\r\nΑΛΦΑΡΙΘΜΗΤΙΚΑ\r\n#ΕΚΦΡ$(, #ΜΕΓ$(, #ΜΙΚ$(, #ΠΑΚ$(, #ΤΙΜΗ$(, ΑΛΛΑΓΗ$(, ΑΝ$(, ΑΝΑΠ$(, ΑΠΟΚ$(, ΑΠΟΚ.ΑΡ$(, ΑΠΟΚ.ΔΕ$(, ΑΡΙΣ$(, ΑΡΙΣΤΕΡΟΜΕΡΟΣ$(, ΑΡΧΕΙΟ$(, ΑΥΛΟΣ$(, ΒΑΛΕ.ΑΔΕΙΑ$(, ΓΡΑΦΗ$(, ΔΕΚΑΕΞ$(, ΔΕΞΙ$(, ΔΕΞΙΜΕΡΟΣ$(, ΕΙΚ$(, ΕΙΣΑΓΩΓΗ$(, ΕΚΦΡ$(, ΕΝΩΣΗ.ΣΕΙΡΑΣ$(, ΕΠΑΝ$(, ΕΠΙΛΟΓΗ$(, ΕΦΑΡΜΟΓΗ.ΑΡΧΕΙΟΥ$(, ΗΜΕΡΑ$(, ΗΧΟ$(, ΙΔΙΟΤΗΤΑ$(, ΙΣΧΝΗ$(, ΚΕΦ$(, ΚΡΥΦΟ$(, ΛΟΓΟΣ$(, ΜΕΓΑΛΟ.ΣΕΙΡΑΣ$(, ΜΕΛΟΣ$(, ΜΕΛΟΥΣ.ΤΥΠΟΣ$(, ΜΕΡΟΣ$(, ΜΕΣ$(, ΜΙΚΡΟ.ΣΕΙΡΑΣ$(, ΜΙΚΡΟΣ.ΚΑΤΑΛΟΓΟΣ$(, ΜΟΡΦΗ$(, ΟΔΗΓΟΣ$(, ΟΚΝ$(, ΟΜΑΔΑ$(, ΟΝΟΜΑ.ΑΡΧΕΙΟΥ$(, ΟΝΟΜΑ.ΑΡΧΕΙΟΥ.ΜΟΝΟ$(, ΠΑΡΑΓΡΑΦΟΣ$(, ΠΑΡΑΘΕΣΗ$(, ΠΑΡΑΜ$(, ΠΕΔΙΟ$(, ΠΕΖ$(, ΠΙΝΑΚΑΣ$(, ΡΩΤΑ$(, ΣΥΝΑΡΤΗΣΗ$(, ΣΧΔ$(, ΣΩΡΟΣ$(, ΣΩΡΟΥΤΥΠΟΣ$(, ΤΙΜΗΣΩΡΟΥ$(, ΤΙΤΛΟΣ$(, ΤΙΤΛΟΣ.ΑΡΧΕΙΟΥ$(, ΤΟΠΙΚΟ$(, ΤΟΠΟΣ$(, ΤΟΠΟΣ.ΑΡΧΕΙΟΥ$(, ΤΥΠΟΣ$(, ΤΥΠΟΣ.ΑΡΧΕΙΟΥ$(, ΦΑΚΕΛΟΣ$(, ΦΑΝΕΡΟ$(, ΦΙΛΤΡΟ$(, ΦΩΤΟ$(, ΧΑΡ$(, ΧΑΡΚΩΔ$(, ΧΡΟΝΟΣ$(\r\n
EN:IF\r\n1)\r\n  Αν συνθήκη Τότε { εντολές σε μια γραμμή }\r\n  για μια εντολή μπορεί να δοθεί  το παρακάτω\r\n  Αν Ι>Κ Τότε Τύπωσε Ι : Τύπωσε \"και κάτι ακόμα\"  \\\\ και ότι συνεχίζει στην ίδια γραμμή θα είναι η συνέχεια του Τότε\r\n  Αν υπάρχει μια Αλλιώς τότε πρέπει να υπάρχει μπλοκ στην Τότε (ή να μην υπάρχει η Τότε)\r\n  Αν Ι>Κ Τότε {Τύπωσε Ι} Αλλιώς Τύπωσε Κ\r\n  Από 9.5 μπορεί να γίνει και έτσι (χωρίς μπλοκ)\r\n  Αν Ι>Κ Τότε Τύπωσε Ι Αλλιώς Τύπωσε Κ\r\n  \r\n  Αν Ι>10 Αλλιώς Τύπωσε \"Μικρό ή ίσο με 10\"\r\n  Αν Σημαία Τότε 400   \\\\ είναι το ίδιο με Αν Σημαία=Αληθής Τότε Προς 400\r\n  Αν Σημαία Αλλιώς 400   \\\\ είναι το ίδιο με Αν Σημαία=Αληθής Τότε Προς 400\r\n  Αν Σημαία Τότε Προς Εκεί\r\n  \\\\ το Εκεί είναι ετικέτα \r\n  Εκεί:\r\n2)\r\nΑν συνθήκη Τότε {\r\n      εντολές πολλών γραμμών\r\n}\r\n\r\n3)\r\nΑν συνθήκη Τότε { εντολές μιας γραμμής } Αλλιώς { εντολές μιας γραμμής}\r\n\r\n4)\r\nΑν συνθήκη Τότε {\r\n      εντολές πολλών γραμμών\r\n} Αλλιώς {\r\n      εντολές πολλών γραμμών\r\n}\r\n\r\n5) Προσθήκη από 6.4\r\nΑν συνθήκη Τότε {\r\n      εντολές πολλών γραμμών\r\n} Αλλιώς.Αν συνθήκη Τότε {\r\n      εντολές πολλών γραμμών\r\n} Αλλιώς {\r\n      εντολές πολλών γραμμών\r\n}\r\n\r\n6) Απλοποιημένη σύνταξη (από έκδοση 8.9 - αναθεώρηση 12)\r\n\r\nΑν συνθήκη Τότε εντολές πολλών γραμμών\r\nΑλλιώς.Αν συνθήκη Τότε  εντολές πολλών γραμμών\r\nΑλλιώς εντολές πολλών γραμμών\r\n\r\nή και αυτό ή όπως θέλουμε με κενές γραμμές\r\nΑν συνθήκη Τότε {εντολές πολλών γραμμών }\r\nΑλλιώς.Αν συνθήκη Τότε  {εντολές πολλών γραμμών}\r\nΑλλιώς {εντολές πολλών γραμμών}\r\n\r\n7) Από την 9.5 έκδοση προστέθηκε η χωρίς μπλοκ ανάπτυξη σε μια γραμμή\r\nΑν Ι>Κ Τότε Τύπωσε Ι Αλλιώς.Αν Ι>Δ Τότε Τύπωσε Δ  Αλλιώς Τύπωσε Κ\r\n\r\n8) Από την 9.6 έκδοση προστέθηκε και η ανάπτυξη Αν  Τέλος Αν\r\nΑν συνθήκη Τότε  \r\n\r\nΑλλιώς.Αν Τότε\r\n\r\nΑλλιώς.Αν Αλλιώς\r\n\r\nΑλλιώς.Αν Τότε\r\n\r\nΑλλιώς\r\n\r\nΤέλος Αν\r\n\r\n\r\nΑν συνθήκη Αλλιώς\r\nΤέλος Αν\r\n\r\n\r\nΜπορούμε να βάζουμε όσα ΑΛΛΙΩΣ.ΑΝ θέλουμε!  Μπορούμε στο τελευταίο μέρος (εδώ είναι το Αλλιώς) να βάλουμε στην ίδια γραμή σειρά με εντολές που θα χωρίζουν με άνω και κάτω τελεία.\r\n\r\n\r\nΌπως είναι το Όχι είναι και το Δεν\r\nΗ συνθήκη μπορεί να περιλαμβάνει τα λογικά ΟΧΙ, ΚΑΙ, Η, ΑΠΟ,  συγκρίσεις > < = >= <= παρενθέσεις, συγκρίσεις αλφαριθμητικών, αριθμητικών κ.λ.π. Αν το αποτέλεσμα είναι ΨΕΥΔΕΣ δηλαδή 0 τότε πάμε στην Αλλιώς (Αν έχει δηλωθεί) όλα τα άλλα τα λαμβάνει ως αληθές (κανονικά τιμή -1)\r\nΤύπωσε ΑΛΗΘΕΣ, ΨΕΥΔΕΣ, ΟΧΙ ΑΛΗΘΕΣ, ΑΛΗΘΕΣ Η ΨΕΥΔΕΣ, ΑΛΗΘΕΣ ΚΑΙ ΑΛΗΘΕΣ, ΑΛΗΘΕΣ ΑΠΟ ΨΕΥΔΕΣ\r\nδίνει\r\n-1   0    0    -1   -1   -1\r\n\r\nΤύπωσε 2<4 Και \"Α\"=\"Α\"            αυτό από την έκδοση 6.4 είναι σωστό! (παλιά ήταν ΛΑΘΟΣ)\r\n\r\nΜπορούμε να φωλιάζουμε τα Αν (μέσα να βάλουμε ότι εντολές θέλουμε όπως άλλα Αν, ΓΙΑ , ΕΩΣ κλπ).\r\nΜπορούμε να κάνουμε έξοδο από ένα μπλοκ μέσα στην Αν αλλά Αν θέλουμε την Αν να την χρησιμοποιήσουμε για να καλέσουμε κάτι που θα αλλάξει τη ροή στο μπλοκ εντολών που βρίσκεται η Αν τότε δεν πρέπει να χρησιμοποιήσουμε τους τύπους της Αν με τις αγκύλες.\r\nπαίζει και η Αν συνθήκε Αλλιώς  όπως και το παρακάτω που δίνει \"σωστά\"\r\n\r\nμε τα παρακάτω Αν μια συνθήκη δεν είναι Οκ τότε οι άλλες δεν θα υπολογιστούν...ο μεταφραστής θα αλλάξει γραμμή!\r\nΑν ψευδες αλλιως.αν ψευδες αλλιως.αν ψευδες Αλλιώς Τύπωσε \"σωστά\"\r\nοι συνθήκες δεν χρειάζονται αγκύλες!\r\nΑν αληθες Τότε Αν αληθες Τότε Αν αληθες Τότε Τύπωσε \"σωστά\"\r\nΠΡΟΣΟΧΗ  στις συνθήκες δεν μπορούμε να χρησιμοποιήσουμε την μορφή των αλφαριθμητικών με αγκύλες.\r\n\r\n\r\n\r\n
EN:IF$(\r\nternary operator\r\nΔες Αν()\r\n\\\\ πέρνει -1 και 0\r\nΤύπωσε Αν$(αληθές -> \"αληθές\", \"ψευδές\")\r\n\\\\ πέρνει τιμές 1,2,3,4... (εδώ μέχρι 4)\r\nΤύπωσε Αν$(3 -> \"ένα\", \"δύο\",\"τρία\",\"τέσσερα\")\r\n\r\n\r\n
EN:IF(\r\n1) Ternary operator\r\n  1.1 Με τιμές -1 και 0  (Αληθές και Ψευδές), θέλει μόνο δυο στοιχεία, μπορούμε να έχουμε κενά. Εκτελεί μόνο μια έκφραση μετά το ->\r\n      Κ=5  : Ν=3\r\n      Τύπωσε Αν(Κ>Ν -> 100, 200)\r\n      \r\n      Μ=Αληθές \\\\ Ψευδές\r\n      Συναρτηση ΔυοΤιμές (Χ,Υ) {\r\n            =Χ**Υ\r\n      }\r\n      \\\\ Αν το Μ είναι αληθές τα Χ και Υ θα γίνουν 10 και 20, αλλιώς θα γίνουν 30 και 40\r\n      \\\\ το !(1,2,3,4) σημαίνει να γραφεί ο πίνακας (1,2,3,4) στο σωρό τιμών κατά τη κλήση της συνάρτησης.\r\n      \\\\ εδώ το Αν() γυρνάει έναν δείκτη σε πίνακα, το ! παίρνει το δείκτη και αντιγράφει όλα τα στοιχεία του πίνακα στο σωρό τιμών.\r\n      Τύπωσε ΔυοΤιμές(!Αν(Μ -> (10,2), (30,4)))\r\n      \r\n      \r\n   1.2 Με τιμή από 1, εκτελεί την Νιοστή έκφραση (τις άλλες τις προσπερνάει χωρίς να τις εκτελέσει)\r\n   Τύπωσε Αν(Τυχαίος(1,5) -> 10, 30, 45, 55, 60)\r\n   \r\n2) Elvis operatror  \r\n    2.1 για αντικείμενα\r\n    Α(3)=Αν(Α(3)->,Μ) \\\\ όταν το A(3) είναι 0 ή άδειο, τότε θα πάρει τιμή το αντίγραφο του Μ (ή αν είναι δείκτης σε κάτι θα πάρει το δείκτη)\r\n   2.2 για συναρτήσεις, λάμδα συναρτήσεις ή αντικείμενα τύπου ομάδα που γυρνούν τιμές, όπως στο παράδειγμα.\r\nΚλάση μετρητής {\r\n      χ, μέγιστο\r\n      Αξία {\r\n       Αν .χ>=.μέγιστο Τότε Έξοδος\r\n       .χ++\r\n       =Αληθές\r\n      }\r\nΚλάση:\r\n      Τμήμα μετρητής (.χ, .μέγιστο) {}\r\n}\r\nΑ=μετρητής(1,2)  ' 1\r\nΒ=μετρητής(10,18)  ' 8\r\nΓ=μετρητής(5,6)    ' 1\r\nΔ=μετρητής(1,3)  ' 2\r\nμετρητής=1\r\n\\\\ μέτρημα 1+8+1+2= 12 φορές\r\nΕνώ Αν(Α->,Αν(Β->,Αν(Γ->,Δ))) {\r\n      Τύπωσε Β.χ, Γ.χ, Δ.χ, μετρητής\r\n      μετρητής++\r\n}\r\n\r\nΥπάρχει το Αν$() που γυρνάει αλφαριθμητικά.\r\n
EN:SEARCH\r\nΑΝΑΖΗΤΗΣΗ ονομα_βασης$, πινακας$,1,\"πεδιο\",\"like\",\"τιμη\"\r\nΑΝΑΖΗΤΗΣΗ ονομα_βασης$, πινακας$,1,\"πεδιο\",\">=\",12044\r\n\r\nδουλεύει όπως η ανάκτηση αλλά εδώ βάζουμε και τον τρόπο που θα συγκριθεί το πεδίο με την τιμή\r\nΠΡΟΣΟΧΗ στην LIKE σε ερωτήματα SQL δεν χρησιμοποιείται το * αλλά το % (λειτουργούσε παλιά λόγω του DAO, αλλά λόγω της χρήσης του αντικειμένου ADO θέλει αυτή την αλλαγή, διαφορετκά το * θα το βλέπει ως χαρακτήρα, οπότε δεν θα γυρνάει κάτι)\r\n\r\n\r\n\r\n
EN:COMMIT\r\nη εντολή Ανάθεσε λειτουργεί σαν την Διάβασε αλλά για ειδικό σκοπό\r\nΕνώ η Διάβασε δεν βάζει δεύτερη αναφορά σε υπάρχουσα αναφορά, η Ανάθεσε το κάνει αν το στοιχείο είναι μέλος ομάδας.\r\n\r\nΟμάδα άλφα {\r\n\tΠίνακας α()\r\n\tΤμήμα κ {\r\n\t\tΑνέθεσε .α()\r\n\t}\t\r\n}\r\nΠίνακες μ(20)=1, μ1(30)=100\r\nΆλφα.κ  &μ()\r\nΤύπωσε Άλφα.α(19)=1\r\nΆλφα.κ  &μ1()\r\nΤύπωσε Άλφα.α(19)=100\r\n\r\n\r\n\r\n\r\n
EN:RETRIEVE\r\nΑΝΑΚΤΗΣΗ ονομα_βασης$, πινακας$, εγγραφή1, ονομα_πεδιου$, τιμη_πεδίου$\r\nΟ πίνακας μπορεί να είναι ερώτημα SQL\r\nπ.χ.\r\nΠρώτη Εγγραφή\r\n1) ΑΝΑΚΤΗΣΗ ονομα_βασης$, πινακας$,1,\"\",\"\"\r\n2) ΑΝΑΚΤΗΣΗ ΒΑΣ$,\"SELECT * FROM [ΕΓΓΡΑΦΗ] WHERE (month(ΗΜΕΡΑ)=\"+ΓΡΑΦΗ$(ΜΝ)+\") AND (year(ΗΜΕΡΑ)=\"+ΓΡΑΦΗ$(ΕΤ)+\")\",1,\"\",\"\"\r\n3) ΑΝΑΚΤΗΣΗ \"HELP2000\",\"COMMANDS\",1,\"DESCRIPTION\",\"HELP\"\r\nΔίνει στην κορυφή του σωρού τον αριθμό εγγραφών, και μια εγγραφή (την 1 που ζητήσαμε), όπου το DESCRIPTION είναι το HELP \r\n4) ΑΝΑΚΤΗΣΗ \"HELP2000\",\"GROUP\",1,\"GROUPNUM\",20\r\nΔίνει στην κορυφή του σωρού τον αριθμό εγγραφών, και μια εγγραφή (την 1 που ζητήσαμε), όπου το GROUPNUM ισούται με 20.\r\n      Η βάση HELP2000 είναι η βάση δεδομένων της βοήθειας της γλώσσας. Από εκεί ήρθε αυτό το κείμενο!\r\n      Η SQL μας δίνει πολλές δυνατότητες, παρακάτω μας φτιάχνει έναν πίνακα με μια μόνο εγγραφή με ένα μόνο πεδίο το TOTAL το οποίο είναι το άθροισμα όλων των πεδίων ΠΟΣΟ από τον πίνακα-αρχείο ΕΓΓΡΑΦΗ που σε συνδυασμό με τον πίνακα-αρχείο ΛΟΓΑΡΙΑΣΜΟΙ επιλέγει μόνο αυτές τις εγγραφές που έχουν λογαριασμούς με θετικό πρόσημο αλλά και τις εγγραφές που έχουν κοινό μήνα και έτος, δηλαδή βγάζει το σύνολο των εσόδων τον συγκεκριμένο μήνα του έτους!\r\n\r\nΑΝΑΚΤΗΣΗ ΒΑΣ$,\"SELECT SUM(ΠΟΣΟ) AS TOTAL FROM [ΕΓΓΡΑΦΗ] INNER JOIN [ΛΟΓΑΡΙΑΣΜΟΙ] ON ΛΟΓΑΡΙΑΣΜΟΙ.ΚΩΔ=ΕΓΓΡΑΦΗ.ΚΩΔ WHERE ΛΟΓΑΡΙΑΣΜΟΙ.ΠΡΟΣΗΜΟ='+' AND month(ΕΓΓΡΑΦΗ.ΗΜΕΡΑ)=\"+ΓΡΑΦΗ$(ΜΝ)+\" AND year(ΕΓΓΡΑΦΗ.ΗΜΕΡΑ)=\"+ΓΡΑΦΗ$(ΕΤ),1,\"\",\"\"\r\n\r\nΤο αποτέλεσμα της ανάκτησης δίνεται στον σωρό\r\nΔες ΣΩΡΟΣ\r\nΣτο όνομα βάσης μπορούμε να δώσουμε μονοπάτι (ο τόπος που βρίσκεται...π.χ. c:\\onoma) αλλά δεν χρειάζεται o τύπος αρχείο (mdb), μπαίνει αυτόματα.\r\nΟι βάσεις δεδομένων που διαχειρίζεται η Μ2000 έχουν κλείδωμα, όχι για να μην ανοίγουν αλλά για να ξέρει η Μ2000 ότι είναι δικές τις βάσεις.\r\nΠΡΟΣΟΧΗ στην LIKE σε ερωτήματα SQL δεν χρησιμοποιείται το * αλλά το % (λειτουργούσε παλιά λόγω του DAO, αλλά λόγω της χρήσης του αντικειμένου ADO θέλει αυτή την αλλαγή, διαφορετκά το * θα το βλέπει ως χαρακτήρα, οπότε δεν θα γυρνάει κάτι)\r\n\r\n
EN:BROWSER\r\n1) ΕΜΦΑΝΙΣΗ\r\nΑΝΑΛΟΓΙΟ \"www.google.gr\"\r\n2) ΕΜΦΑΝΙΣΗ σε θέση που θέλουμε\r\nΑΝΑΛΟΓΙΟ \"www.youtube.com\",1000,1000,5000,3000\r\n3) ΑΚΥΡΩΣΗ\r\nΑΝΑΛΟΓΙΟ \"\"\r\n4) ΑΝΑΛΟΓΙΟ \"αλφα\"\r\n    φορτώνει  αρχείο που έχει σωθεί στον προσωρινό φάκελο των WINDOWS\r\n    η μεταβλητή ΠΡΟΣΩΡΙΝΟ$ ή TEMPORARY$ μας δίνει την διεύθυνση του προσωρινού φακέλου των windows. Π.χ. ΚΑΤΑΛΟΓΟΣ ΠΡΟΣΩΡΙΝΟ$: ΑΡΧΕΙΑ \"tmp\" \r\nΔες ΚΕΙΜΕΝΟ και  ΓΕΝΙΚΑ για ΙΣΤΟΣΕΛΙΔΕΣ\r\n\r\n
EN:BROWSER$\r\nΤΥΠΩΣΕ ΑΝΑΛΟΓΙΟ$\r\nΔίνει τον τίτλο της σελίδας που εμφανίζουμε στο ΑΝΑΛΟΓΙΟ\r\n\r\n
EN:PROFILER\r\nΚατά την ροή του προγράμματος μπορούμε να κάνουμε αναλύσεις ταχύτητας. Ο Αναλυτής ξεκινάει όπου εμείς θέλουμε και κατόπιν μετράμε όπου θέλουμε τον φόρτο, το πόσα χιλιοστά δευτερολέπτου \"κόστησε\".\r\n\r\nΑναλυτης\r\nεντολές............\r\nΤύπωσε Φορτος\r\n\r\nΟυσιαστικά κάθε σειρά εντολών είναι κοστοβόρα σε επεξεργαστικό χρόνο. Έτσι η αναζήτηση του χρόνου είναι πολλές φορές ζωτικής σημασίας (ειδικά όταν έχουμε επαναλήψεις σε μεγάλο αριθμό). Η διαδικασία του αναλυτή φανερώνει το φορτίο του επεξεργαστή. Έτσι φόρτος εδώ είναι ο χρόνος εργασίας. Ο αναλυτής βάζει μπροστά τον μετρητή....(η μέτρηση γίνεται από το λειτουργικό σύστημα). Η μεταβλητή Φορτος δεν σταματάει τον μετρητή. Πρέπει να δώσουμε πάλι την εντολή ΑΝΑΛΥΤΗΣ για να ξεκινήσουμε νέα μέτρηση, διαφορετικά η επόμενη Φορτος θα μας δώσει την μέτρηση από την εντολή ΑΝΑΛΥΤΗΣ.\r\n\r\n\r\n\r\n\r\n
EN:WAIT\r\nANAMONH 100\r\nWait 100\r\nΠεριμένει το πρόγραμμα για 100 χιλιοστά του δευτερολέπτου, δίνοντας χρόνο στο λειτουργικό να κάνει κάτι άλλο. \r\n\r\nΜετα 200 {\r\n      Τυπωσε \"Ειμαι εδώ\"\r\n}\r\nΑναμονη 500\r\n\r\nΗ δομή Μετα φτιάχνει ένα νήμα που θα τρέξει μια φορά σε 200 χιλιοστά του δευτερολέπτου. Αν δεν βάλουμε κάτι να κάνει το τμήμα να περιμένει τότε θα τερματίσει με συνέπεια να εξαφανίσει το νήμα, να μην τρέξει δηλαδή.\r\nΆλλες εντολές που κάνουν αναμονή χωρίς όμως να βγαίνουν άμεσα από αυτήν είναι η ΚΑΘΕ και η ΚΥΡΙΟ.ΕΡΓΟ οι οποίες είναι η πρώτη δομή επανάληψης (κάθε διάστημα σε χιλιοστά που δίνουμε) χωρίς συνθήκη τερματισμού (μπορούμε να εκτελέσουμε την Έξοδος για να βγούμε από αυτή) και η δεύτερη ένα νήμα σαν την Μετα, που όμως όταν τερματίσει τερματίζει όλα τα νήματα, αλλά και αυτή δεν εκτελείται με κάποια συνθήκη..(ή μάλλον τερματίζει αν δεν υπάρχει άλλο νήμα εκτός από το δικό της).\r\n\r\n\r\n\r\n \r\n \r\n 
EN:REFRESH\r\nΑπό την τελευταία έκδοση δεν ισχύει αυτό \"Όταν αλλάζει η γραμμή εκτύπωσης μετά από μια τύπωσε τότε αυτόματα γίνεται ανανέωση οθόνης\", εκτός και αν έχουμε εκτελέσει την καθολική εντολή ΘΕΣΕ ΑΡΓΑ\r\nΜπορούμε να προκαλέσουμε όποτε θέλουμε ανανέωση της οθόνης με την εντολή ΑΝΑΝΕΩΣΗ και τις παραλλαγές της:\r\n\r\n1) ΑΝΑΝΕΩΣΗ\r\nΑυτή είναι η απλή μορφή που  κάνει αυτόματη ανανέωση της οθόνης\r\n\r\n2) ΑΝΑΝΕΩΣΗ 0\r\nΜηδενίζει τον μετρητή ανανέσωσης οθόνης\r\n\r\n3) ΑΝΑΝΕΩΣΗ 100\r\nΟρίζει τον χρόνο που θα γίνονται ανανεώσεις αυτόματα. Κάθε φορά που το σύστημα ζητάει ανανέωση ελέγχεται αν έχει περάσει το οριζόμενο χρονικό διάστημα και αν ναι τότε γίνεται ανανέωση. ΠΡΟΣΟΧΗ δεν σχετίζεται με την ΑΝΑΜΟΝΗ όπου η ροή στο συγκεκριμένο νήμα διακόπτεται για λίγα δευτερόλεπτα. Και οι δύο εντολές αποσκοπούν στο να δώσουν χρόνο στο σύστημα, αλλά η δεύτερη (η ΑΝΑΜΟΝΗ) γίνεται με καθυστέρηση ανεξάρτητα αν υπάρχει κάτι να γίνει στο παρασκήνιο ή όχι.\r\n\r\n
EN:STRREV$(\r\nΤύπωσε Αναπ$(\"αβγδ\")=\"δγβα\"\r\n\r\n
EN:REPORT\r\nΑΝΑΦΟΡΑ!4  ' βάζει το πλάτος του TAB (χαρακτήρας 9) στους 4 χαρακτήρες - για κάθε επίπεδο κρατάει διαφορετικό πλάτος.\r\nΑΝΑΦΟΡΑ \"ΚΕΙΜΕΝΟ ΜΕ ΑΛΛΑΓΕΣ ΓΡΑΜΜΩΝ\"\r\nΑΝΑΦΟΡΑ τροπος_αναφορας, \"ΚΕΙΜΕΝΟ ΜΕ ΑΛΛΑΓΕΣ ΓΡΑΜΜΩΝ\"\r\nΑΝΑΦΟΡΑ τροπος_αναφορας, \"ΚΕΙΜΕΝΟ ΜΕ ΑΛΛΑΓΕΣ ΓΡΑΜΜΩΝ\", πλατος_Δες_πως\r\nΑΝΑΦΟΡΑ τροπος_αναφορας, \"ΚΕΙΜΕΝΟ ΜΕ ΑΛΛΑΓΕΣ ΓΡΑΜΜΩΝ\", πλατος_Δες_πως, Γραμμες_Για_Τυπωμα\r\nΑΝΑΦΟΡΑ τρ_αναφορας, \"ΚΕΙ....Ν\", πλατος_Δες_πως, Γραμμες_Για_Τυπωμα  ΓΡΑΜΜΗ αρχική_γραμμή\r\nΝέες παραλλαγές:\r\nΑΝΑΦΟΡΑ τρ_αναφορας, \"ΚΕΙ....Ν\", πλατος_Δες_πως, Γραμμες_Για_Τυπωμα Ως Μεταβλητή$\r\nΑΝΑΦΟΡΑ τρ_αναφορας, \"ΚΕΙ....Ν\", πλατος_Δες_πως, Γραμμες_Για_Τυπωμα  ΓΡΑΜΜΗ αρχική_γραμμή Ως Μεταβλητή$\r\n* οι νέες παραλλαγές  δουλεύουν με αρνητικό νούμερο στις γραμμές_για_τύπωμα και δεν τυπώνουν αλλά βάζουν τις γραμμές στη μεταβλητή.\r\n\r\nΗ αναφορά ξεκινάει από τη στήλη που καθορίζει ο δρομέας. Το αριστερό διάστημα που ορίζει ο δρομέας θα μείνει κενό.\r\nΤρόπος αναφοράς είναι:\r\n0 Στοίχιση Αριστερά και Δεξια\r\n1 Στοίχηση Δεξιά\r\n2 Στοίχηση Κέντρο\r\n3 Στοίχηση Αριστερά\r\n\r\nΜπορούμε λοιπόν πριν καλέσουμε την ΑΝΑΦΟΡΑ να ξέρουμε το αριστερό όριο (left margin), αλλά πρέπει να έχουμε και έναν τρόπο να ορίσουμε το δεξιό περιθώριο (right margin). Για το λόγο αυτό δίνουμε το πλάτος_Δες_πως ως αριθμό, με προσοχή όμως γιατί αν ο αριθμός είναι μικρότερος από το Πλατος (της οθόνης) τότε η εντολή τον λαμβάνει ως πλάτος σε χαρακτήρες (της Οθόνης), αν είναι μεγάλος τότε η εντολή τον θεωρεί ως twips (1440 twips είναι μια ιντσα). \r\n\r\nΣε κάθε περίπτωση γίνεται μεταφορά λέξης στην επόμενη γραμμή αν δεν χωράει, όμως δεν είναι σίγουρο ότι θα τυπωθεί γιατί μπορεί να είναι την δηλώσουμε μη εκτυπωσιμη. Οι εκτυπώσιμες γραμμές είναι αυτές που ξεκινάνε από την αρχική_γραμμή (ή αν δεν δώσουμε αρχική τότε θεωρείται η πρώτη γραμμή, η 1),  και συνολικά φθάνουν τις γραμμές_για_τύπωμα. Αν δώσουμε αρνητικό νούμερο τότε η εντολή δεν τυπώνει αλλά υπολογίζει πόσες γραμμές θα τυπωθούν (αν τυπώναμε). Την απάντηση την λαμβάνουμε σε μια μεταβλητή, ανάγνωσης μόνο, την  ΓΡΑΜΜΕΣΑΝΑΦΟΡΑΣ ή REPORTLINES\r\n\r\nΜπορούμε να χρησιμοποιήσουμε την Αναφορά στον ΕΚΤΥΠΩΤΗ για να τυπώσουμε κείμενο. Αρκεί να την βάλουμε σε μια δομή ΕΚΤΥΠΩΤΗΣ  { \r\n\r\n      Αναλογική γραφή μπορούμε να τυπώσουμε με την ΤΥΠΩΣΕ αλλά δεν έχει σχέση με την ΑΝΑΦΟΡΑ\r\n      δείτε το παράδειγμα:\r\n      FORM 48,32\r\n      FOR I=0 TO 8 {\r\n      PRINT $(I, 8),145355,34.23432,34.222\r\n      }\r\n      \r\nΗ εντολή ΑΝΑΦΟΡΑ είναι μια σύνθετη εντολή για  να φτιάξει κανείς στήλες κειμένου (με παράγραφους) στην οθόνη με αναλογική γραφή και με αυτόματο γύρισμα λέξης στην επόμενη γραμμή, προσαρμόζοντας κατάλληλα τα κενά των λέξεων στην κάθε γραμμή.\r\nΗ εντολή έχει δυο καταστάσεις λειτουργίας...μια που πράγματι τυπώνει και μια άλλη που υπολογίζει τις γραμμές που χρειάζεται και απλά ενημερώνει μια εσωτερική μεταβλητή. Στην πρώτη κατάσταση μπορούμε να ορίσουμε πόσες γραμμές θα προσπεράσει και πόσες θα τυπώσει. Έτσι αν ξέρουμε πόσες γραμμές είναι όλο το κείμενο που θέλουμε να τυπώσουμε με την εντολή αναφορά υπολογίζοντας τη μισή οθόνη και κάτι λιγότερο, τότε μπορούμε να φτιάξουμε δυο στήλες με δυο εντολές, μια για κάθε στήλη, όπου θα δώσουμε τον αριθμό των γραμμών που θα αφήσουμε και τον αριθμό των γραμμών που θα γράψουμε. Στη περίπτωση που δεν δώσουμε αυτούς τους αριθμούς τότε η αναφορά τρέχει σε όλη την οθόνη και σταματάει για να διαβάσουμε και πατώντας το διάστημα προχωράει στο επόμενο κομμάτι. Μπορούμε να δώσουμε πολλαπλές αναφορές αλλάζοντας σε ορισμένες τον τρόπο στοίχισης, και πάλι θα καταμετρηθούν οι τυπωμένες γραμμές ώστε να δουλεύει σωστά το κράτημα της αναφοράς για να πάρει χρόνο ο αναγνώστης και να διαβάσει τι γράφει!\r\n\r\nΜπορούμε να δώσουμε ένα κείμενο σε ένα αλφαριθμητικό:\r\nΑ$={Πρώτη γραμμή\r\nΔεύτερη γραμμή\r\nΤρίτη Γραμμή}\r\nΑναφορα Α$\r\nΑναφορα 1, Α$\r\nΑναφορα 2, Α$\r\nΑναφορα 3, Α$\r\n\r\nΜια εξήγηση εδώ:\r\nΚάθε γραμμή στο αλφαριθμητικό τερματίζει με δυο χαρακτήρες, εκτός από την τελευταία γραμμή, που όμως δεν αναφέρονται αυτά στις γραμμές εκτύπωσης (αυτές καθορίζονται από το πλάτος εκτύπωσης). Δηλαδή υπάρχουν στο αλφαριθμητικό σημάδια χαρακτήρες που δηλώνουν την αλλαγή παραγράφου (και όχι γραμμής). Μια  παράγραφος είναι μια ομάδα λέξεων που τερματίζει σε μια συγκεκριμένη ακολουθία χαρακτήρων ή στο πέρας του αρχείου ή το πέρας του αλφαριθμητικού (το οποίο δουλεύει εδώ σαν αρχείο).\r\nΠαρακάτω έχουμε ένα παράδειγμα ( μπορούμε να το αντιγράψουμε σε ένα τμήμα), όπου σε ένα αλφαριθμητικό βάζουμε ένα κείμενο. Μετά κάνουμε μια επανάληψη για 20 φορές όπου η μεταβλητή i χρησιμοποιείται στην εντολή ΑΝΑΦΟΡΑ ή REPORT ως το πλάτος σε χαρακτήρες οθόνης. \r\n\r\nσ$={σ\r\nΑ\r\nβ.\r\n. \r\n..\r\n. .... ....\r\n}\r\nγια i=1 εως 20 {\r\nοθονη\r\nδρομεας 10,10\r\nτυπωσε \"*1234567890\";\r\nαναφορα 2, σ$,ι,-1000 \r\nδρομεας 10,11\r\nτυπωσε \"*\";\r\nκ= ΓΡΑΜΜΕΣΑΝΑΦΟΡΑΣ\r\nτυπωσε @(θεση,γραμμη, θεση+ι,θεση+κ, 5,8);\r\nαναφορα 2, σ$,ι,κ\r\nτυπωσε ι , κ\r\nκ$=ενκομ$\r\n}\r\n\r\nH ΓΡΑΜΜΕΣΑΝΑΦΟΡΑΣ δίνει το αποτέλεσμα από την ΑΝΑΦΟΡΑ με αρνητικό αριθμό γραμμών για εκτύπωση (εδώ -1000), η οποία δεν τυπώνει έτσι παρά μόνο υπολιγίζει αυτό το νούμερο.\r\n\r\n
EN:SHOW\r\nΑΝΑΨΕ\r\nΜας δείχνει το πλαίσιο γραφικών και κειμένου (την οθόνη). Ενεργοποιείται αυτόματα σε εντολές που θα γράψουμε χαρακτήρες με πληκτρολόγηση πάνω στο πλαίσιο αυτό.\r\nΑντίθετη εντολή ΣΒΗΣΕ \r\nΌταν κάνουμε διπλό κλικ (ή μονό σε κάποιες περιπτώσεις) πάνω σε ένα αρχείο gsb τότε θα εμφανιστεί το περιθώριο αλλά όχι η οθόνη. Αυτή θα εμφανιστεί αν δώσουμε ΑΝΑΨΕ ή μια εντολή που αυτόματα ανάβει την οθόνη.\r\nΥπάρχει η μεταβλητή μόνο για ανάγνωση ΟΘΟΝΗ η οποία είναι -1 όταν η φόρμα είναι στο προσκήνιο\r\n\r\n
EN:OPEN.FILE\r\nΑΝΟΙΓΜΑ.ΑΡΧΕΙΟΥ\r\nΑΝΟΙΓΜΑ.ΑΡΧΕΙΟΥ ενα.ονομα$\r\nΑΝΟΙΓΜΑ.ΑΡΧΕΙΟΥ ένα.ονομα$, κατάλ$\r\nΑΝΟΙΓΜΑ.ΑΡΧΕΙΟΥ ένα.ονομα$, κατάλ$, τίτλος$\r\nΑΝΟΙΓΜΑ.ΑΡΧΕΙΟΥ ένα.ονομα$, κατάλ$, τίτλος$, τυποςαρχείων$\r\nTο αποτέλεσμα θα είναι στον σωρό\r\n\r\nΥπάρχει και η ΑΡΧΕΙΟ$() που παίρνει από κανένα μέχρι δυο παραμέτρους, με πρώτη το τίτλο του διαλόγου και δεύτερη τον ή τους τύπους των αρχείων (τους διαχωρίζουμε με τη κάθετο |)\r\n\r\nΤΜΗΜΑ ΑΡ {\r\nΠΑΡΑΘΥΡΟ 12,5000;\r\nΟΘΟΝΗ 0,0\r\nΑΝΑΨΕ\r\n{\r\n' Και στην νέα έκδοση λειτουργεί ο παλιός τρόπος που ορίζαμε τους τύπους αρχείων\r\n'   ΑΝΟΙΓΜΑ.ΑΡΧΕΙΟΥ \"\",ΚΑΤ$+\"..\\media\\\",\"Ανοιγμα Αρχείου Εικόνας\",\"Εικόνα (*.bmp)|*.bmp|Φωτογραφία (*.jpg)|*.jpg\"\r\n'  Η νέα φόρμα επιλογής αρχείου έχει πιο απλοποιημένο αλφαριθμητικό για να δηλώσουμε τύπους αρχείων\r\n' Αυτό δεν θα είναι συμβατό με παλιές εκδόσεις\r\n  ΑΝΟΙΓΜΑ.ΑΡΧΕΙΟΥ \"\",ΚΑΤ$+\"..\\media\\\",\"Ανοιγμα Αρχείου Εικόνας\",\"bmp|jpg\"\r\nΔΙΑΒΑΣΕ ΕΙΚ$\r\nΑΝ ΕΙΚ$<>\"\" ΤΟΤΕ {\r\nΕΝΩ ΔΕΙΚΤΗΣ=1 {}\r\nΕΙΚΟΝΑ ΕΙΚ$,Χ.ΣΗΜΕΙΑ,Υ.ΣΗΜΕΙΑ\r\nΑΝΑΝΕΩΣΗ\r\nΕΝΩ (ΔΕΙΚΤΗΣ=0) ΚΑΙ (ΕΝΚΟΜ$=\"\") {}\r\n} ΑΛΛΙΩΣ ΕΞΟΔΟΣ\r\nΚΥΚΛΙΚΑ\r\n}\r\nΜΠΙΠ\r\n}\r\nΑΡ\r\n
EN:OPEN.IMAGE\r\nΑΝΟΙΓΜΑ.ΕΙΚΟΝΑΣ\r\nΑΝΟΙΓΜΑ.ΕΙΚΟΝΑΣ ενα.ονομα$\r\nΑΝΟΙΓΜΑ.ΕΙΚΟΝΑΣ ένα.ονομα$, κατάλ$\r\nΑΝΟΙΓΜΑ.ΕΙΚΟΝΑΣ ένα.ονομα$, κατάλ$, τίτλος$\r\nΑΝΟΙΓΜΑ.ΕΙΚΟΝΑΣ ένα.ονομα$, κατάλ$, τίτλος$, τυποςαρχείων$\r\nTο αποτέλεσμα θα είναι στον σωρό\r\n\r\nο τυποςαρχείων$ εξ ορισμού είναι \"BMP|JPG|GIF|WMF|EMF|DIB|ICO|CUR\"\r\n\r\nΟ συγκεκριμένος διάλογος δείχνει τις εικόνες και τα σχέδια σε προεπισκόπηση.\r\n\r\n\r\n
EN:OPEN\r\nΕΝΑ BYTE ανά χαρακτήρα (χρησιμοποιεί την κωδικοσελίδα του συστήματος)\r\nΗ εντολή μπορεί να ορίσει μεταβλητή χειρισμού αν δεν έχει οριστεί.\r\nΤο ΑΠΟΚΛΕΙΣΤΙΚΑ είναι προαιρετικό και σημαίνει για αποκλειστική χρήση\r\nΤο # είναι προαιρετικό\r\nΑΝΟΙΞΕ ονομα_αρχειου$ ΓΙΑ ΕΙΣΑΓΩΓΗ ΑΠΟΚΛΕΙΣΤΙΚΑ ΩΣ #μεταβλητη_χειρισμου_αρχειου\r\nΑΝΟΙΞΕ ονομα_αρχειου$ ΓΙΑ ΕΞΑΓΩΓΗ ΑΠΟΚΛΕΙΣΤΙΚΑ ΩΣ #μεταβλητη_χειρισμου_αρχειου\r\n\\\\ αν στην ΕΞΑΓΩΓΗ δώσουμε όνομα αρχείου το κενό αλφαριθμητικό τότε η Τύπωσε # θα δίνει στην οθόνη\r\n\\\\ αυτό το θέλουμε για να δούμε σε δοκιμές τι δίνουμε!\r\nΑΝΟΙΞΕ ονομα_αρχειου$ ΓΙΑ ΣΥΜΠΛΗΡΩΣΗ ΑΠΟΚΛΕΙΣΤΙΚΑ ΩΣ #μεταβλητη_χειρισμου_αρχειου\r\nΑΝΟΙΞΕ ονομα_αρχειου$ ΓΙΑ ΠΕΔΙΑ ΑΠΟΚΛΕΙΣΤΙΚΑ ΩΣ #μεταβλητη_χειρισμου_αρχειου ΜΗΚΟΣ=συνολικο_μηκος_γραμμης_πεδιων_σε_χαρακτήρες\r\nΜέγιστο μήκος για πεδία 32766\r\n\r\nΔΥΟ BYTE ανά χαρακτήρα (Unicode WIDE 16bit)\r\nΗ εντολή μπορεί να ορίσει μεταβλητή χειρισμού αν δεν έχει οριστεί.\r\nΤο ΑΠΟΚΛΕΙΣΤΙΚΑ είναι προαιρετικό και σημαίνει για αποκλειστική χρήση\r\nΤο # είναι προαιρετικό\r\nΑΝΟΙΞΕ ονομα_αρχειου$ ΓΙΑ ΕΥΡΙΑ ΕΙΣΑΓΩΓΗ ΑΠΟΚΛΕΙΣΤΙΚΑ ΩΣ #μεταβλητη_χειρισμου_αρχειου\r\nΑΝΟΙΞΕ ονομα_αρχειου$ ΓΙΑ ΕΥΡΙΑ ΕΞΑΓΩΓΗ ΑΠΟΚΛΕΙΣΤΙΚΑ ΩΣ #μεταβλητη_χειρισμου_αρχειου\r\n\\\\ αν στην ΕΞΑΓΩΓΗ δώσουμε όνομα αρχείου το κενό αλφαριθμητικό τότε η Τύπωσε # θα δίνει στην οθόνη\r\n\\\\ αυτό το θέλουμε για να δούμε σε δοκιμές τι δίνουμε!\r\nΑΝΟΙΞΕ ονομα_αρχειου$ ΓΙΑ ΕΥΡΙΑ ΣΥΜΠΛΗΡΩΣΗ ΑΠΟΚΛΕΙΣΤΙΚΑ ΩΣ #μεταβλητη_χειρισμου_αρχειου\r\nΑΝΟΙΞΕ ονομα_αρχειου$ ΓΙΑ ΕΥΡΙΑ ΠΕΔΙΑ ΑΠΟΚΛΕΙΣΤΙΚΑ ΩΣ #μεταβλητη_χειρισμου_αρχειου ΜΗΚΟΣ=συνολικο_μηκος_γραμμης_πεδιων_σε_χαρακτήρες\r\n\r\nΜέγιστο μήκος για πεδία 32766/2  (σε χαρακτήρες είναι οι μισοί από τους 32766)\r\nΣυναρτήσεις\r\nΤΕΛΟΣ()   ' δίνει αληθές αν φθάσαμε στο τέλος του \r\nΕΓΓΡΑΦΕΣ()  ' δίνει το μήκος σε χαρακτήρες ή τον αριθμό πεδίων αν ανοίξουμε ΓΙΑ ΠΕΔΙΑ ένα αρχείο\r\nΕντολέ για ΠΕΔΙΑ μόνο\r\nΠΑΡΕ   'διαβάζουμε  μια εγγραφή από μια θέση\r\nΔΩΣΕ  ' γράφουμε  μια εγγραφή σε μια θέση (στη θέση Εγγραφες()+1 προσθέτουμε εγγραφή\r\nΜια εγγραφή είναι ένα αλφαριθμητικό το οποίο δεν το έχουμε \"τεμαχισμένο\" με σύμβολα αλλά μπορούμε να το χωρίσουμε σε πεδία\r\nαπλά με την ΜΕΣ$(  και για να τη δώσουμε πίσω να την συννενώσουμε με το +  (Πεδιο1$+Πεδιο2$) αλλά πρέπει να έχουμε συνολικό μήκος το μήκος της εγγραφής. Δες εντολές ΠΕΔΙΟ και ΠΕΔΙΟ()\r\nΕντολές μετακίνσης (Εκτός τύπου ΠΕΔΙΩΝ)\r\nΕΔΩ=ΜΕΤΑΘΕΣΗ(#Α)   ' Διαβάζουμε πριν γράψουμε το σημείο που θα γράψουμε\r\nΜΕΤΑΘΕΣΗ #Α, ΕΔΩ     ' Μεταθέτουμε τον δρομέα του αρχείου στο σημείο που θέλουμε να διαβάσουμε\r\n\r\nΣτα αρχεία τύπου ΕΙΣΑΓΩΓΗ, ΕΞΑΓΩΓΗ και ΣΥΜΠΛΗΡΩΣΗ (όπως η ΕΙΣΑΓΩΓΗ αλλά δεν σβήνει το αρχείο και μεταθέτει το δρομέα στο τέλος), έχουμε τους παρακάτω τρόπους να διαβάζουμε και να γράφουμε\r\n\r\nΔιαβάζουμε με τα ΕΙΣΑΓΩΓΗ, ΓΡΑΜΜΗ ΕΙΣΑΓΩΓΗΣ και ΕΙΣΑΓΩΓΗ$()\r\nΓράφουμε με την ΤΥΠΩΣΕ και την ΓΡΑΨΕ\r\n\r\nοτιδηποτε$=ΕΙΣΑΓΩΓΗ$(#Α, 20)  ' Διαβάζουμε 20 χαρακτήρες ANSI ή UNICODE ανάλογα με το δηλώσαμε στην ΑΝΟΙΞΕ την ΕΥΡΙΑ μορφή χαρακτήρων (2 Bytes για κάθε γράμμα).\r\nΤΥΠΩΣΕ #Α, γρ$  ' τυπώνει μια γραμμή κειμένου στο αρχείο. Με σύμβολο ; τυπώνουμε χωρίς την αλλαγή γραμμής.\r\n' Ουσιαστικά φτιάχνουμε γραμμές που θα διαβαστούν αργότερα με την ΓΡΑΜΜΗ ΕΙΣΑΓΩΓΗΣ ή την ΕΙΣΑΓΩΓΗ$()\r\nΓΡΑΜΗ ΕΙΣΑΓΩΓΗΣ #Α, γρ$ ' διαβάζει μια γραμμή από αρχείο κειμένου μέχρι να βρει χαρακτήρα που να δηλώνει αλλαγή γραμμής, και αφήνει τον δρομέα στην αρχή της επόμενης γραμμής.\r\n\r\nΓΡΑΨΕ #Α, a$, B  ' Βάζει γραμμές με δεδομένα έτσι: \"λέξη\", 1213 μπορεί να γράψει μέσα στο αλφαριθμητικό και εισαγωγικά και αλλαγές γραμμών. Όμως ο κατάλληλος τρόπος να διαβαστούν τα δεδομένα είναι η ΕΙΣΑΓΩΓΗ\r\nΕΙΣΑΓΩΓΗ #Α, Α$, Β  ' Εισάγει στις μεταβλητές δεδομένα που έχουμε γράψει πρώτα με τη ΓΡΑΨΕ\r\nΜπορούμε να χρησιμοποιούμε ότι θέλουμε αρκεί να γνωρίζουμε τι κάνουμε!\r\n\r\nΓράψε σε ένα ΤΜΗΜΑ το παρακάτω...δοκίμασέ το χωρίς το ΕΥΡΙΑ (στα δυο ΑΝΟΙΞΕ)\r\n\r\nΑ$={1η γραμμή\r\n      \"περιεχόμενο σε εισαγωγικά\" και \"εδώ\"\r\n      τρίτη γραμμή\r\n      }  ' το περιθώριο αριστερά δεν θα μπει στην Α$\r\n K=0\r\n ΑΝΟΙΞΕ ΚΑΤ$+\"αυτο.ααα\"  ΓΙΑ ΕΥΡΙΑ ΕΞΑΓΩΓΗ ΩΣ Κ\r\n ΓΡΑΨΕ #Κ, 100,1,2,Α$\r\n ΓΡΑΨΕ #Κ, 20\r\n ΓΙΑ Ι=1 ΕΩΣ 20 {\r\n      ΓΡΑΨΕ #Κ,  2*Ι+1\r\n }\r\n ΚΛΕΙΣΕ #Κ\r\n ΑΝΟΙΞΕ ΚΑΤ$+\"αυτο.ααα\" ΓΙΑ ΕΥΡΙΑ ΕΙΣΑΓΩΓΗ ΩΣ Κ\r\n ΕΙΣΑΓΩΓΗ #Κ, Α,Β,Μ, Α$\r\nΤΥΠΩΣΕ Α, Β, Μ\r\nΑΝΑΦΟΡΑ Α$\r\nΕΙΣΑΓΩΓΗ #Κ, ΤΟΣΑ\r\nΠΙΝΑΚΑΣ Λ(ΤΟΣΑ)\r\nΓΙΑ Ι=0 ΕΩΣ ΤΟΣΑ-1 {\r\n     ΕΙΣΑΓΩΓΗ #Κ, Λ(Ι)\r\n     ΤΥΠΩΣΕ Λ(Ι)\r\n}\r\n ΚΛΕΙΣΕ #Κ\r\n\r\nΕπίσης φτιάξε ένα ακόμα τμήμα (πρόσεξε και εδώ τη χρήση της μορφής ΕΥΡΙΑ να είναι ίδια και στο ΑΝΟΙΞΕ που έφτιαξε το αρχείο\r\nΚ=0\r\nΑΝΟΙΞΕ ΚΑΤ$+\"αυτο.ααα\" ΓΙΑ ΕΥΡΙΑ ΕΙΣΑΓΩΓΗ ΩΣ Κ\r\nΕΝΩ ΟΧΙ ΤΕΛΟΣ(#Κ) {\r\n       ΓΡΑΜΜΗ ΕΙΣΑΓΩΓΗΣ #Κ, Α$\r\n       ΤΥΠΩΣΕ Α$\r\n}\r\nΚΛΕΙΣΕ #Κ\r\nτώρα διαβάζουμε το αρχείο, γραμμή προς γραμμή χωρίς να τοποθετούμε τα δεδομένα σε ειδικές μεταβλητές.\r\n \r\n     \r\n
EN:COPY\r\nAπό το σημείο του δρομέα μπορούμε να αντιγράψουμε εικόνες \r\n1) Άμεση αντιγραφή\r\nΑΝΤΙΓΡΑΨΕ Χ.προορισμού, Υ.προορισμού, Πλάτος, Ύψος\r\n2) Αντιγραφή ολόκληρης της οθόνης στον δίσκο (δεν παίζει ρόλο ο δρομέας)\r\nΑΝΤΙΓΡΑΨΕ \"όνομα αρχείου\"\r\n3) Αντιγραφή σε μεταβλητή\r\nΑΝΤΙΓΡΑΨΕ πλάτος, ύψος ΣΤΟ αλφαριθμητικό$\r\n4) Αντιγραφή από μεταβλητή\r\nΑΝΤΙΓΡΑΨΕ θέσηΧ, θέσηΥ ΜΕ αλφαριθμητικό$\r\n5) Αντιγραφή με περιστροφή και αυξομείωση μεγέθους (γίνεται και εξομάλυνση) \r\nΑΝΤΙΓΡΑΨΕ θέσηΧ, θέσηΥ ΜΕ αλφαριθμητικό$, γωνία\r\nΑΝΤΙΓΡΑΨΕ θέσηΧ, θέσηΥ ΜΕ αλφαριθμητικό$, γωνία, μέγεθος\r\n6)Αντιγραφή όπως το 5 αλλά στις περιστροφές φαίνεται στις γωνίες η εικόνα από κάτω\r\nΑΝΤΙΓΡΑΨΕ  θέσηΧ, θέσηΥ ΕΠΑΝΩ αλφαριθμητικό$, γωνία\r\nΑΝΤΙΓΡΑΨΕ  θέσηΧ, θέσηΥ ΕΠΑΝΩ αλφαριθμητικό$, γωνία, μέγεθος\r\n\r\nτο αλφαριθμητικό μπορεί να είναι από πίνακα, π.χ. α$(4) \r\n\r\nΗ εντολή δεν μετακινεί τον δρομέα γραφικών\r\n\r\n\r\nΦΟΡΜΑ 60, 32  \r\nΟΘΟΝΗ 7\r\nΠΕΝΑ 15\r\nΤΥΠΩΣΕ \"Αυτή είναι η πρώτη γραμμή\" \r\nΤΥΠΩΣΕ \"Αυτή είναι η δεύτερη γραμμή\"\r\nΤΥΠΩΣΕ \"Αυτή είναι η τρίτη γραμμή\"\r\nΤΥΠΩΣΕ \"Αυτή είναι η τέταρτη γραμμή\"\r\nΘΕΣΗ 0,0\r\nΚΑΘΑΡΟ α$\r\nΑΝΤΙΓΡΑΨΕ 3000,2000 ΣΤΟ α$\r\nΦΟΝΤΟ 3, 5   ' βάζει χρώμα με διαβάθμιση στο φόντο.\r\nΑΝΤΙΓΡΑΨΕ 6000,4000 ΕΠΑΝΩ α$, 30, 200\r\nΑΝΤΙΓΡΑΨΕ 6000,4000 ΕΠΑΝΩ α$, 45\r\nΑΝΤΙΓΡΑΨΕ 2000,2000 ΜΕ α$, 45\r\n\r\n\r\n
EN:ENUM\r\n\\\\ μπορούμε να βάζουμε ότι αριθμό θέλουμε ακόμα και πραγματικούς\r\n\\\\ Εξ ορισμού Σκύλος=1 και Γάτα=2\r\n\\\\ Μπορούμε να δώσουμε τ ο Σκύλος=0, Γάτα και το Γάτα θα γίνει 1\r\n\\\\ ή Σκύλος=100, Γάτα=200\r\n\\\\ αντί για κόμμα μπορούμε να αλλάζουμε γραμμή\r\n\\\\ ή μπορούμε να βάζουμε  αλλαγή γραμμής μετά το κόμμα\r\n\\\\ δεν μπορούμε να αφήσουμε ένα κόμμα στο τέλος\r\nΑπαρ Κατοικίδια {Σκύλος, Γάτα}\r\nα=Σκύλος\r\nΤύπωσε α=1  ' αληθές\r\nα++\r\nΤύπωσε Εκφρ$(α)=\"Γάτα\", α=2\r\nκ=Κάθε(Κατοικίδια)\r\nΕνώ κ {\r\n      Τύπωσε Εκφρ$(κ), Εκφρ(κ)\r\n      α=Εκφρ(κ)\r\n      Τύπωσε α<Γάτα\r\n      Αλφα(α)\r\n}\r\nα=Σκύλος\r\nΑλφαΜεΑναφορά(&α)\r\nΤύπωσε α=Γάτα\r\n\r\nΡουτίνα Αλφα(β ως Κατοικίδια)\r\n      Τύπωσε β\r\nΤέλος Ρουτίνας\r\nΡουτίνα ΑλφαΜεΑναφορά(&β ως Κατοικίδια)\r\n      Τύπωσε β\r\n      β++\r\nΤέλος Ρουτίνας\r\n\r\nΔες Απαρίθμηση\r\n_
EN:ENUMERATION\r\n\\\\ μπορούμε να βάζουμε ότι αριθμό θέλουμε ακόμα και πραγματικούς\r\n\\\\ Εξ ορισμού Σκύλος=1 και Γάτα=2\r\n\\\\ Μπορούμε να δώσουμε τ ο Σκύλος=0, Γάτα και το Γάτα θα γίνει 1\r\n\\\\ ή Σκύλος=100, Γάτα=200\r\n\\\\ αντί για κόμμα μπορούμε να αλλάζουμε γραμμή\r\n\\\\ ή μπορούμε να βάζουμε  αλλαγή γραμμής μετά το κόμμα\r\n\\\\ δεν μπορούμε να αφήσουμε ένα κόμμα στο τέλος\r\nΑπαρίθμηση Κατοικίδια {\r\n      Σκύλος\r\n      Γάτα\r\n}\r\nα=Σκύλος\r\nΤύπωσε α=1  ' αληθές\r\nα++\r\nΤύπωσε Εκφρ$(α)=\"Γάτα\", α=2\r\nκ=Κάθε(Κατοικίδια)\r\nΕνώ κ {\r\n      Τύπωσε Εκφρ$(κ), Εκφρ(κ)\r\n      α=Εκφρ(κ)\r\n      Τύπωσε α<Γάτα\r\n      Αλφα(α)\r\n}\r\nα=Σκύλος\r\nΑλφαΜεΑναφορά(&α)\r\nΤύπωσε α=Γάτα\r\n\r\nΡουτίνα Αλφα(β ως Κατοικίδια)\r\n      Τύπωσε β\r\nΤέλος Ρουτίνας\r\nΡουτίνα ΑλφαΜεΑναφορά(&β ως Κατοικίδια)\r\n      Τύπωσε β\r\n      β++\r\nΤέλος Ρουτίνας\r\n\r\n\r\nΔες Απαρ\r\n\r\n
EN:REFER\r\nΗ απέδωσε είναι μια παραλλαγή της Διάβασε, που φτιάχνει αναφορές χωρίς να χρειάζεται το & στα ονόματα. Επίσης χρησιμοποιείται για να φτιάχνουμε αναφορές σε μέλη ομάδων Οι αναφορές είναι μιας χρήσης, δεν μπορούμε να δώσουμε άλλη αναφορά, εκτός  και αν το κάνουμε αυτό σε ένα μπλοκ προσωρινών ορισμών (Για αντικείμενο  { }) όπου κάθε φορά που βγαίνουμε από το μπλοκ οι αναφορές σβήνονται, και έτσι ο διερμηνευτής μπορεί να τις φτιάξει με νέα είσοδο στο μπλοκ.\r\n\r\nΟμάδα Άλφα {\r\nΙδιωτικό:\r\n\tμ=1, λ$=\"ok\"\r\nΔημόσιο:\r\n\tΤμήμα Τύπωσε {\r\n\t\tΤύπωσε .μ, .λ$\r\n\t}\r\n}\r\nΆλφα.Τύπωσε\r\n\\\\ τώρα θα απδώσουμε μεταβλητές στις\r\n\\\\ ιδιωτικές που δεν έχουμε κανονικά θέαση\r\nΑπέδωσε από Άλφα, μ1, λ1$\r\nΤύπωσε μ1, λ1$\r\nμ1++\r\nλ1$+=\"....\"\r\nΆλφα.Τύπωσε\r\n\r\n\r\n\r\n
EN:INFINITY\r\nΤύπωσε ΑΠΕΙΡΟ, -ΑΠΕΙΡΟ\r\n           1.#INF    -1.#INF\r\n\r\n
EN:SINGLE\r\nχρησιμοποιείται στην εντολή ΑΡΧΕΙΟ\r\n\r\n
EN:ON\r\nΑΠΟ μεταβλητή ΠΡΟΣ ετικετα1, ετικετα2, ετικετα3\r\n\r\nΠρέπει να υπάρχουν στο ίδιο τμήμα οι ετικέτες\r\n\r\nΠροσοχή γιατί μπορεί να γίνει και άλμα προς τα πίσω και αν δεν αλλάξει στο μεταξύ η τιμή της μεταβλητής μπορεί να κολλήσει ο μεταφραστής (στις δοκιμές βάλτε πριν από την εντολή ΑΠΟ μια εντολή ΑΝΑΝΕΩΣΗ η οποία δίνει τον έλεγχο στιγμιαία στο σύστημα και μπορούμε να διακόψουμε ομαλά το πρόγραμμα με το ESC)\r\n\r\n\r\n\r\n\r\n
EN:SAVE.AS\r\nΑΠΟΘΗΚΕΥΣΗ.ΩΣ \r\nΑΠΟΘΗΚΕΥΣΗ.ΩΣ ένα.ονομα$\r\nΑΠΟΘΗΚΕΥΣΗ.ΩΣ ένα.ονομα$, κατάλογος$\r\nΑΠΟΘΗΚΕΥΣΗ.ΩΣ ένα.ονομα$, κατάλογος$, τίτλος$\r\nΑΠΟΘΗΚΕΥΣΗ.ΩΣ ένα.ονομα$, κατάλογος$, τίτλος$, τυποςαρχείων$\r\nTο αποτέλεσμα θα είναι στον σωρό\r\nΌπως και το προηγούμενο έτσι και εδώ απλά ζητάμε το όνομα (με το μονοπάτι) ενός αρχείου.\r\n\r\n\r\n\r\n
EN:TRIM$(\r\nΤΥΠΩΣΕ \"<\"+ΑΠΟΚ$(\"        ΑΑΑ         \")+\">\"\r\n<ΑΑΑ>\r\nαποκόπτει τα διαστήματα σε ένα αλφαριθμητικό και από τις δύο πλευρές\r\nΤοπικο 1032\r\nΑ$=Γραφη$(\" Γιώργος \")  ' μετατροπή σε ANSI κατά  τοπικό1032 (ελληνικά)\r\nΤύπωσε Μήκος(Α$)=4.5\r\nΒ$=Αποκ$(Α$ ως ψηφίο)\r\nΤύπωσε Χαρ$(Β$)=\"Γιώργος\"  ' μετατροπή σε UTF-16LE κατά 1032\r\n\r\n\r\n
EN:LTRIM$(\r\n\r\nΤύπωσε ΑΠΟΚ.ΑΡ$(\"  123\")=\"123\"\r\nκ$=Γραφή$(\"  123\")\r\nΤύπωσε Χαρ$(ΑΠΟΚ.ΑΡ$(κ$ ως ψηφιο))=\"123\"\r\nΤύπωσε ΑΠΟΚ.ΑΡ$(κ$ ως ψηφιο)=Γραφή$(\"123\")\r\n\r\n
EN:RTRIM$(\r\n\r\nΤύπωσε ΑΠΟΚ.ΔΕ$(\"123  \")=\"123\"\r\nκ$=Γραφή$(\"123  \")\r\nΤύπωσε Χαρ$(ΑΠΟΚ.ΔΕ$(κ$ ως ψηφιο))=\"123\"\r\nΤύπωσε ΑΠΟΚ.ΔΕ$(κ$ ως ψηφιο)=Γραφή$(\"123\")\r\n\r\n
EN:ABS(\r\nΤΥΠΩΣΕ ΑΠΟΛ(-5)+5\r\n    10\r\n\r\nΔίνει την απόλυτη τιμή.\r\n\r\n
EN:SLOW\r\nΑΡΓΑ\r\n\r\nΜέσα σε πρόγραμμα πρέπει να δώσουμε: ΘΕΣΕ ΑΡΓΑ\r\nΔίνει χρόνο στο σύστημα, οπότε έχει μια μικρή καθυστέρηση.\r\n\r\n
EN:ARITHMETIC FUNCTIONS\r\nΑΡΙΘΜΗΤΙΚΑ\r\n#ΑΘΡ(, #ΑΝΑΠ(, #ΑΝΤ(, #ΕΚΦΡ(, #ΘΕΣΗ(, #ΜΕΓ(, #ΜΕΡΟΣ(, #ΜΙΚ(, #ΠΑΚ(, #ΤΑΞΙΝΟΜΗΣΗ(, #ΤΙΜΗ(, #ΦΙΛΤΡΟ(, ΑΚ(, ΑΚΕΡΑΙΟ.ΔΥΑΔΙΚΟ(, ΑΝ(, ΑΠΟΛ(, ΑΡΙΘΜΟΣ.ΠΑΡΑΓΡΑΦΟΥ(, ΑΡΧΕΙΟΥ.ΜΗΚΟΣ(, ΑΡΧΕΙΟΥ.ΣΤΑΜΠΑ(, ΒΑΣΗ(, ΔΑΠΕΔ(, ΔΕΙΚΤΗΣ(, ΔΕΚ(, ΔΕΝ, ΔΙΑΡΘΡΩΣΗ(, ΔΙΑΣΤΑΣΗ(, ΔΟΚΙΜΗ(, ΔΥΑΔΙΚΗ.ΠΕΡΙΣΤΡΟΦΗ(, ΔΥΑΔΙΚΟ(, ΔΥΑΔΙΚΟ.ΑΚΕΡΑΙΟ(, ΔΥΑΔΙΚΟ.ΑΝΤΙ(, ΔΥΑΔΙΚΟ.ΑΠΟ(, ΔΥΑΔΙΚΟ.Η(, ΔΥΑΔΙΚΟ.ΚΑΙ(, ΔΥΑΔΙΚΟ.ΟΛΙΣΘΗΣΗ(, ΔΥΑΔΙΚΟ.ΟΧΙ(, ΔΥΑΔΙΚΟ.ΠΡΟΣΘΕΣΗ(, ΔΥΟΜΙΣΑ(, ΕΓΓΡΑΦΕΣ(, ΕΓΓΡΑΦΟΥ.ΛΕΞΕΙΣ(, ΕΓΓΡΑΦΟΥ.ΜΗΚΟΣ(, ΕΓΓΡΑΦΟΥ.ΜΟΝΑΔΙΚΕΣ.ΛΕΞΕΙΣ(, ΕΓΓΡΑΦΟΥ.ΠΑΡ(, ΕΓΓΡΑΨΙΜΟ(, ΕΓΚΥΡΟ(, ΕΙΚΟΝΑ(, ΕΙΚΟΝΑ.Υ(, ΕΙΚΟΝΑ.Υ.ΣΗΜΕΙΑ(, ΕΙΚΟΝΑ.Χ(, ΕΙΚΟΝΑ.Χ.ΣΗΜΕΙΑ(, ΕΚΦΡ(, ΕΝΚΟΜ(, ΕΝΩΣΗ(, ΕΠΟΜΕΝΑ(, ΕΤΟΙΜΟ(, ΕΦΑΠ(, ΗΜ(, ΗΜΕΡΑ(, ΘΕΣΗ(, ΘΕΣΗΔΕΞΙΑ(, ΙΔΙΟΤΗΤΑ(, ΚΑΘΕ(, ΚΑΤΩΜΙΣΟ(, ΚΩΔ(, ΛΑΒΗ(, ΛΑΒΗ.ΑΝΑΛΟΓΙΚΟ.Υ(, ΛΑΒΗ.ΑΝΑΛΟΓΙΚΟ.Χ(, ΛΑΒΗ.ΚΑΤΕΥΘΥΝΣΗ(, ΛΟΓ(, ΛΦ(, ΜΕΓΑΛΟ(, ΜΕΓΑΛΟ.ΣΕΙΡΑΣ(, ΜΕΓΕΘΟΣ.Υ(, ΜΕΓΕΘΟΣ.Χ(, ΜΕΤΑΘΕΣΗ(, ΜΗΚΟΣ(, ΜΗΚΟΣ.ΕΜΦ(, ΜΙΚΡΟ(, ΜΙΚΡΟ.ΣΕΙΡΑΣ(, ΜΠΡΟΣΤΑ(, ΟΜΑΔΑ(, ΟΜΑΔΑ.ΣΥΝΟΛΟ(, ΟΡΟΦ(, ΟΧΙ, ΠΑΝΩΜΙΣΟ(, ΠΑΡΑΓΡΑΦΟΣ(, ΠΑΡΑΜ(, ΠΑΤΗΜΕΝΟ(, ΠΙΝΑΚΑΣ(, ΠΙΣΩ(, ΠΡΩΤΟ(, ΡΙΖΑ(, ΡΩΤΑ(, ΣΕΙΡΙΑΚΟΣ.ΔΙΣΚΟΥ(, ΣΗΜ(, ΣΗΜΕΙΟ(, ΣΤΗΛΗ(, ΣΤΡΟΓΓ(, ΣΥΓΚΡΙΝΕ(, ΣΥΓΚΡΟΥΣΗ(, ΣΥΝ(, ΣΥΝΑΡΤΗΣΗ(, ΣΥΧΝΟΤΗΤΑ(, ΣΩΡΟΣ(, ΤΑΞΗ(, ΤΑΥΤΙΣΗ(, ΤΕΛΟΣ(, ΤΙΜΗ(, ΤΙΜΗΣΩΡΟΥ(, ΤΜΗΜΑ(, ΤΟΞ.ΕΦ(, ΤΟΠΙΚΟ(, ΤΡΑΠ(, ΤΥΧΑΙΟΣ(, ΥΠΑΡΧΕΙ(, ΥΠΑΡΧΕΙ.ΚΑΤΑΛΟΓΟΣ(, ΥΠΜΕΡ(, ΥΠΩΡΑ(, ΧΑΡΚΩΔ(, ΧΚΦ(, ΧΡΟΝΟΣ(, ΧΡΩΜΑ(\r\n
EN:PARAGRAPH.INDEX(\r\n\r\nΑΡΙΘΜΟΣ.ΠΑΡΑΓΡΑΦΟΥ(αντικείμενο_έγγραφο, μεταβλητή)\r\nΕπιστρέφει από το κωδικό παραγράφου τον αριθμό (δίνει το 1 αν ο κωδικός αντιστοιχεί στη πρώτη παράγραφο)\r\nΔες Παράγραφος()\r\n\r\n\r\n
EN:LEFT$(\r\nΤΥΠΩΣΕ ΑΡΙΣ$(\"ΑΒΓΔΕΖ\",2)\r\nΑΒ\r\n\r\nΔίνει ένα αριστερό τμήμα ενός αλφαριθμητικού, έτσι δίνουμε ένα αλφαριθμητικό και το μήκος του τμήματος αυτού. Αν δώσουμε μεγαλύτερο μήκος από αυτό του αλφαριθμητικού τότε δίνει όλο το αλφαριθμητικό\r\n\r\nΤοπικο 1032\r\nΑ$=Γραφη$(\"Γιώργος\")  ' μετατροπή σε ANSI κατά  τοπικό1032 (ελληνικά)\r\nΤύπωσε Χαρ$(Αρισ$(Α$,3 ως Ψηφίο))=\"Γιώ\"  ' το Χαρ$() μετατροπή σε UTF-16LE κατά 1032\r\n\r\n\r\n
EN:LEFTPART$(\r\nΤύπωσε ΔεξίΜέρος$(\"123456789\",\"5\")  ' μετά το 5\r\nΤύπωσε ΑριστερόΜέρος$(\"123456789\",\"5\") ' πριν το 5\r\n\r\n
EN:FILES\r\nΑΡΧΕΙΑ                           (δίνει όλα τα txt αρχεια)\r\nΑΡΧΕΙΑ \"mdb\"                 (δίνει όλα τα αρχεία με επέκταση mdb)\r\nΑΡΧΕΙΑ + \"jpg\"                \\ Με τις δυο αυτές εντολές εμφανίζουμε λίστα με όλα τα αρχεία jpg και \r\nΕΠΙΛΟΓΗ !                      / επιλέγουμε με το ποντίκι ή τα βελάκια και το enter\r\n\r\nΑΡΧΕΙΑ \"gsb\", \"ΤΥΠΩΣΕ \"   \\βρίσκει όλα τα αρχεία GSB που περιέχουν την ΤΥΠΩΣΕ\r\nΑΡΧΕΙΑ \"gsb\", \"ΤΥΠΩΣΕ | ΠΙΝΑΚΑΣ\" \\βρίσκει όλα τα αρχεία GSB που περιέχουν την ΤΥΠΩΣΕ και την ΠΙΝΑΚΑΣ\r\n\r\n\r\nΑΡΧΕΙΑ !! \"*\" ' δίνει όλα τα αρχεία ταξινομημένα κατά τύπο.\r\n\r\n
EN:TABLE\r\nΑΡΧΕΙΟ ονομα_βασης$, ονομα_πινακα$, ονομα_πεδιου1$, τυπος_πεδιου, μηκος_πεδιου, ... άλλα πεδία\r\nΔεν πάνε όλοι οι τύποι για όλους τους τύπους βάσεων δεδομένων.\r\nπ.χ. για αριθμούς βάλτε το ΛΟΓΙΣΤΙΚΟ.\r\nΤύποι πεδίου: ΛΟΓΙΚΟΣ, ΨΗΦΙΟ, ΑΚΕΡΑΙΟΣ, ΜΑΚΡΥΣ\r\nΛΟΓΙΣΤΙΚΟ, ΑΠΛΟΣ, ΔΙΠΛΟΣ, ΗΜΕΡΟΜΗΝΙΑ\r\nΔΥΑΔΙΚΟ, ΚΕΙΜΕΝΟ,  ΥΠΟΜΝΗΜΑ\r\nΑγγλικά:\r\nBOOLEAN, BYTE INTEGER, LONG\r\nCURRENCY, SINGLE, DOUBLE, DATEFIELD\r\nBINARY, TEXT, MEMO\r\n\r\nΠαράδειγμα:\r\nκ$=\"βαση1\"\r\nΒΑΣΗ κ$\r\nΑΡΧΕΙΟ κ$, \"ΛΟΓΑΡΙΑΣΜΟΙ\", \"ΚΩΔ\", ΜΑΚΡΥΣ, 0, \"ΤΙΤΛΟΣ\", ΚΕΙΜΕΝΟ, 40, \"ΠΡΟΣΗΜΟ\", ΚΕΙΜΕΝΟ, 1\r\nΤΑΞΗ κ$, \"ΛΟΓΑΡΙΑΣΜΟΙ\", \"ΤΙΤΛΟΣ\",ΑΥΞΟΥΣΑ\r\nΑΔΕΙΑΣΕ\r\nΣΕΙΡΑ \"ΒΕΝΖΙΝΕΣ\",\"-\",\"ΑΓΟΡΕΣ ΥΛΙΚΩΝ\" ,\"-\", \"ΑΤΟΜΙΚΑ\",\"-\",\"ΜΙΣΘΟΙ\",\"-\",\"ΕΞΩΤΕΡΙΚΑ\",\"+\",\"ΚΑΤΑΘΕΣΗ\",\"-\",\"ΑΝΑΛΗΨΗ\",\"+\",\"*\",\"*\"\r\nΔΙΑΒΑΣΕ Α$,Β$\r\nΚ=1\r\nΕΝΩ Α$<>\"*\" {\r\nΠΡΟΣΘΗΚΗ κ$, \"ΛΟΓΑΡΙΑΣΜΟΙ\", Κ,Α$, Β$\r\nΔΙΑΒΑΣΕ Α$,Β$\r\nΚ=Κ+1\r\n}\r\n\r\n\r\n\r\n\r\n\r\n
EN:FILE$(\r\nΤΥΠΩΣΕ ΑΡΧΕΙΟ$(\"ΚΕΙΜΕΝΟ\",\"TXT\")\r\nΦΟΡΤΩΣΕ ΑΡΧΕΙΟ$()    'Επιλέγουμε αρχείο GSB\r\nΗ συνάρτηση ΑΡΧΕΙΟ$()  παίρνει από κανένα μέχρι δυο παραμέτρους, με πρώτη το τίτλο του διαλόγου και δεύτερη τον ή τους τύπους των αρχείων (τους διαχωρίζουμε με τη κάθετο |)\r\n\r\n\r\n
EN:FILELEN(\r\n\\\\ Παράδειγμα\r\nΈγγραφο Α$={πρώτη σειρά\r\n      δεύτερη\r\n      τρίτη\r\n      τέταρτη\r\n      }\r\nUTF_16LE=0     \r\nΣώσε.Έγγραφο Α$, \"checkme.doc\", UTF_16LE\r\nΑν Υπάρχει(\"checkme.doc\") τότε {\r\n      Τύπωσε Αρχείου.Μήκος(\"checkme.doc\")\r\n}\r\n\r\n\r\n\r\n
EN:FILE.STAMP(\r\nΆνοιξε \"one.txt\" Για Ευρεία Εξαγωγή Αποκλειστικά ως #κ\r\n      Τύπωσε #κ, \"Γεια χαρά\"\r\n      Τύπωσε #κ, \"Γεια χαρά2\"\r\nΚλείσε #κ\r\nΤύπωσε Γραφη$(Αρχείου.Στάμπα(\"one.txt\"),\"hh:nn:ss dd/mm/yyyy\") , \"utc χρονοσήμανση δημιουργίας\"\r\nΤύπωσε Γραφη$(Αρχείου.Στάμπα(\"one.txt\" ,1),\"hh:nn:ss dd/mm/yyyy\") , \"utc χρονοσήμανση δημιουργίας, 1\"\r\nΤύπωσε  Γραφη$(Αρχείου.Στάμπα(\"one.txt\" ,-1),\"hh:nn:ss dd/mm/yyyy\"), \"Τοπική χρονοσήμανση δημιουργίας, -1\"\r\nΤύπωσε Γραφη$(Αρχείου.Στάμπα(\"one.txt\" ,2),\"hh:nn:ss dd/mm/yyyy\"), \"utc χρονοσήμανση εγγραφής, 2\"\r\nΤύπωσε  Γραφη$(Αρχείου.Στάμπα(\"one.txt\" ,-2),\"hh:nn:ss dd/mm/yyyy\"), \"Τοπική χρονοσήμανση εγγραφής, -2\"\r\n\r\n
EN:START\r\n1) Επανεκκίνηση Ψυχρή (COLD RESTART)\r\nΑΡΧΗ\r\n2) Επανεκκίνηση (WARM RESTART)\r\nΑΡΧΗ \"\",\"\"\r\n3) Όπως η (2) αλλά με αλλαγή βασικής γραμματοσειράς \r\nΑΡΧΗ \"COURIER\"\r\n4) Όπως η (2) αλλά με εκτέλεση εντολών\r\nΑΡΧΗ \"\",\"ΜΠΙΠ:ΜΠΙΠ\"\r\nΠαρατήρηση\r\n1) Αν δώσουμε όνομα γραμματοσειράς, τέτοιο που να μην υπάρχει στην λίστα γραμματοσειρών του υπολογιστή που τρέχουμε την γλώσσα, τότε επανέρχεται η εξ ορισμού γραμματοσειρά.\r\n2) η εντολή αυτή σε καμία περίπτωση δεν αλλάζει το μέγεθος του περιθωρίου καθώς και των γραμμάτων. Γι' αυτές τις περιπτώσεις δες ΤΥΠΟΣ & ΠΑΡΑΘΥΡΟ\r\n3) Σε καμία περίπτωση από της παραπάνω δεν σβήνει ο σωρός τιμών, δες την ΑΔΕΙΑΣΕ\r\n\r\n
EN:PIPE\r\n\r\nΑΥΛΟΣ ΟΝΟΜΑΑΥΛΟΥ$, ΤΙΜΗ1, ΤΙΜΗ2$, ΤΙΜΗ3\r\n\r\nPIPE PIPENAME, DATATOSEND1, DATATOSEND2$, DATATOSENDN....\r\n\r\nMODULE B {WINDOW 12, 6000,4000\r\n      FORM 32, 25\r\n      FORM\r\n      SHOW\r\n      MOTION.W 500,2000\r\n      PRINT \"THIS IS THE BASE\"\r\n      ' θα χρησιμοποιήσω το TRG.GSB σαν πελάτη. Του στέλνω και μερικές πληροφορίες (μια που δεν φαίνεται είναι το όνομα του αυλού για να μου στείλει κάτι\r\n      USE TRG.GSB 1,\"MESSAGETXT\",3 TO K$ AS L\r\n      THREAD L INTERVAL 200\r\n      C=0\r\n      PAR$=\"\"\r\n      NM$=\"\"\r\n      GETOUT=FALSE\r\n      EVERY 200 {\r\n                              C=C+1\r\n                              PRINT C\r\n                              IF INKEY$=\" \" THEN EXIT\r\n                              IF C=1000 THEN EXIT\r\n                              ' K$ παίρνει τιμή από το νήμα L και περιέχει \r\n                              IF K$<>\"\" THEN {\r\n                                                STACK K$ ' εδώ ρίχνω τον σωρό K$ στον κύριο σωρό τιμών\r\n                                                STACK  ' εδώ μου δείχνει τι τιμές έχει ο σωρός\r\n                                                READ NM$, PAR$\r\n                                                FLUSH ' εδώ καθαρίζω τον σωρό\r\n                                                IF PAR$=\"N\" THEN GETOUT =TRUE\r\n                                                C=0\r\n                              }\r\n                              IF GETOUT THEN EXIT \r\n         }\r\nPRINT \"FINISH\"\r\n}\r\n\r\nΠαρακάτω είναι το πρόγραμμα TRG.GSB ή ο πελάτης.\r\nΑπλή περιγραφή:\r\nΤρέχει το C και βγαίνει στην γραμμή εντολών όπου μπορούμε να γράψουμε FEED (να ταϊσουμε...δηλαδή να επιστρέψουμε τιμές στο αρχικό πρόγραμμα (την βάση, ή τον εξυπηρετητή). Δείτε ότι κάνει έλεγχο δοκιμής σφάλματος. Η επικοινωνία είναι ασύγχρονη. Εμείς στέλνουμε αλλά το πρόγραμμα δεν λαμβάνει πάντα...και ορισμένες φορές απορρίπτει τα δεδομένα. Κάποια στιγμή όμως θα λάβει. Όμως μπορούμε να χρησιμοποιήσουμε μια μεταβλητή που θα μετράει τον χρόνο, ώστε σε ένα μέγιστο χρονικό διάστημα να αποφασίσουμε πως το άλλο πρόγραμμα δεν μπορεί να λάβει τα δεδομένα!\r\nΑν γράψουμε TERM τότε στέλνουμε ένα μήνυμα τέλους στον εξυπηρετητή \r\nΑυτό που δεν έχω γράψει εδώ (είναι άσκηση) είναι το πως ο εξυπηρετητής θα ξαναστείλει και άλλα δεδομένα πέρα από τα αρχικά. Η λύση είναι να δημιουργήσουμε στον πελάτη έναν αυλό και να στείλουμε το αναγωριστικό του στον εξυπηρετητή (αφού αυτό μπορεί να γίνει). Όταν λοιπόν πάρει ο εξυπηρετητής το αναγνωριστικό του αυλού τότε στέλνει και αυτός με σύστημα δοκιμής σφάλματος.\r\nΑν έχουμε να στείλουμε ένα μεγάλο αλφαριθμητικό θα πρέπει να αλλάξουμε στρατηγική. Οι αυλοί δεν μπορούν να δεχτούν μεγάλα αλφαριθμητικά, επειδή το σύστημα δημιουργεί έναν ενδιάμεσο σταθμό καταχώρησης με το μέγιστο που ορίζουμε σε μνήμη και παραμένει διαθέσιμος συνέχεια, που σημαίνει ότι η μνήμη αυτή αφαιρείται από το σύστημα. Έτσι ένας αυλός με μεγάλη καταχώρηση μνήμης θα έφερνε μάλλον δυστυχία στο σύστημα..(θα αργούσε  ή θα κόλλαγε).\r\n
EN:PIPENAME$(\r\n? ΑΥΛΟΣ$(αλφα)\r\nΑν δώσουμε νούμερο (το νήμα για τον αυλό) τότε θα μας δώσει τον \"τόπο\" του (όλο το μονοπάτι του, αφού ο αυλός λειτουργεί σαν αρχείο)\r\nΑν δώσουμε μόνο το όνομα σε αλφαριθμητικό τότε δίνει το υπόλοιπο για να είναι σωστό μαζί με τον τόπο του.\r\n\r\nΟι αυλοί λειτουργικά γίνονται γνωστοί σε ένα δίκτυο, επειδή συστατικό τους στοιχείο είναι το όνομα του υπολογιστή που εμφανίζεται στο δίκτυο. Εφόσον θέλει κάποιος να επικοινωνήσει από έναν άλλο υπολογιστή στο δίκτυο, τότε στο όνομα του αυλού πρέπει να βάλει το όνομα του υπολογιστή που κατέχει τον αυλό. Ο κάθε άλλος (η κάθε άλλη εφαρμογή εκτός του υπολογιστή αυτού) θα μπορεί να χρησιμοποιεί την εντολή ΑΥΛΟΣ και να στέλνει δεδομένα στον αυλό που έχει γνωστοποιηθεί.\r\n\r\n\r\n
EN:ASCENDING\r\nΔίνει τιμή 0\r\nχρησιμοποιείται στην εντολή TΑΞΗ (ORDER)\r\n\r\n\r\n
EN:THIS\r\n1. το ΑΥΤΟ δηλώνει την ομάδα\r\nΟμάδα Αλφα {\r\n      Χ=10\r\n      Τμήμα Βήτα {\r\n            Τύπωσε Αυτό.Χ, Χ\r\n      }\r\n}\r\nΑλφα.Βήτα\r\n2. Αυτό στο Για Αυτό {}\r\nΗ Για Αυτό {} χρησιμοποιείται προσωρινούς ορισμούς.\r\n\r\n
EN:AUTO_ARRAYS\r\nΑυτόματοι Πίνακες είναι οι πίνακες που δεν χρειάζεται να οριστούν με την Πίνακας και δίνουν έναν δείκτη σε αυτούς.\r\n\r\nα=(,)      μηκος(α)=0\r\nα=(1,)    μηκος(α)=1\r\n\r\n\\\\ χρήση επάλληλων συναρτήσεων\r\n\\\\ κάθε #συνάρτηση() παίρνει το αποτέλεσμα της προγούμενης\r\nΑ=(1,2,3,4,5,6,7,8)\r\n\\\\ #αθρ() δίνει το άθροισμα\r\nΤύπωσε Α#αθρ()=36\r\n\\\\ συνδυάζονται ορισμένες έτοιμες συναρτήσεις με λάμδα συναρτήσεις\r\nΖυγοί=Λάμδα ->Αριθμός υπολ 2 = 0\r\n\\\\ γράφεται και με μεταβλητή\r\n\\\\ σε πολλές γραμμές\r\nΖυγοί=Λάμδα ->{\r\n      Διάβασε χ ' το Διάβασε χ μπορεί να γίνει (χ) όπως παρακάτω\r\n      =χ υπολ 2 = 0\r\n}\r\n\\\\ ή σε μία γραμμή\r\nΖυγοί=Λάμδα (χ)->χ υπολ 2 = 0\r\n\\\\ Στην αντιστοίχιση η λάμδα καλείται ως τμήμα\r\n\\\\ οπότε η εξαγωγή γίνεται στον ίδιο σωρό που γίνεται η εισαγωγή.\r\nΤετράγωνο=Λάμδα -> {\r\n            Βάλε Αριθμός**2\r\n}\r\n\\\\ #Φιλτρο(λάμδα συνάρτηση [, εναλλακτική πηγή])\r\n\\\\ αν το φίλτρο δεν δώσει πίνακα τότε δεν βγαίνει λάθος και θα γίνει η σύγκριση\r\nΣημ : Ζυγοί=Λάμδα (χ)->χ>5000 ' θα τυπώσει μονο το \"οκ\"\r\nΤύπωσε Α#Φίλτρο(Ζυγοί)#Αντ(Τετράγωνο)#Αθρ()=120, \"οκ\"\r\n\\\\ μπορούμε να δώσουμε άμεσα τη λάμδα (αν δε έχει πολλές γραμμές)\r\n\\\\ αλλά αν ακολουθεί παράμετρος τότε πρέπει να την βάλουμε μέσα σε παρενθέσεις.\r\nΤύπωσε Α#Φίλτρο(λάμδα->αριθμός υπολ 2=0)#Αντ(Τετράγωνο)#Αθρ()=120, \"οκ\"\r\nΤύπωσε Α#Αντ((λάμδα ->{Βάλε Αριθμός**2}))#Αθρ()=204\r\nΤύπωσε Α#Πακ((λάμδα ->{Βάλε Αριθμός+Αριθμός}), 0)=Α#αθρ()\r\n\\\\ το 1033 λέει να έχουν οι αριθμοί τη τελεία (όπως στα αγγλικά)\r\n\\\\ δοκίμασε με 1032. Υπάρχει η εντολή Τοπικό που βάζει το νούμερο που θέλουμε για κάθε εμφάνιση\r\nΤύπωσε Α#Πακ$((λάμδα (α,β$) ->{Βάλε β$+\" \"+Γραφή$(α, 1033)}), \"Δεδομένα:\")=\"Δεδομένα: 1 2 3 4 5 6 7 8\"\r\n\r\n
EN:DELETE\r\nΑΦΑΙΡΕΣΗ ονομα_βασης$, ονομα_πινακα$, ονομα_πεδιου$, τιμη_πεδιου$\r\nΑΦΑΙΡΕΣΗ ονομα_βασης$ διαγράφει την βάση\r\n\r\nΕδώ δεν δίνουμε αριθμό εγγραφής, ούτε SQL, πρέπει να δώσουμε όνομα και τιμή πεδίου\r\nΑΦΑΙΡΕΣΗ \"πρωτη\", \"ενα\", \"ΟΝΟΜΑ\", \"ALFA BETA FROM DELTA\"\r\n\r\nΓια την δεύτερη περίπτωση:\r\nΠρώτα κοιτάει το σύστημα αν η βάση δεδομένων είναι δική του, αν έχει δηλαδή το σωστό κωδικό και μετά τη σβήνει. Δεν μπορεί να σβήσει οποιαδήποτε βάση!\r\n\r\nΜπορούμε με μια εντολή ΕΚΤΕΛΕΣΗ να σβήσουμε πολλαπλές εγγραφές\r\nΕκτελεση  \"HELP2000\", \"DELETE FROM COMMANDS WHERE GROUPNUM =22;\"\r\n\r\n
EN:RELEASE\r\nΑΦΗΣΕ\r\nΑφήνει την προηγούμενα κρατημένη οθόνη (πρέπει να προηγηθεί η ΚΡΑΤΗΣΕ)\r\n\r\n\r\n
EN:PUSH\r\nΣτο σωρό βάζουμε τιμές αριθμητικές και αλφαριθμητικές όπως θέλουμε.\r\nΑπό το σωρό μπορούμε να διαβάσουμε τιμές με την ΔΙΑΒΑΣΕ\r\n\r\nΒ$=\"ΑΑΑΑ\"\r\nΒΑΛΕ 12,Β$,34+45\r\nΣΩΡΟΣ\r\n\r\nΤο τελευταίο θα βγει πρώτο: Ουρά τύπου  LIFO\r\nΕκτός από την ΒΑΛΕ μπορούμε να βάλουμε και με άλλο τρόπο τιμές στο Σωρό!\r\nΜε την ΣΕΙΡΑ όπου το πρώτο που θα μπει θα είναι το πρώτο που θα βγεί (FIFO τύπος)\r\nΜε την ΣΩΡΟΣ ΑλφαριθμητικήΜεταβλητή$ όπου έχουμε βάλει σε ένα Αλφαριμθητικό μια δομή ΣΩΡΟΥ\r\n\r\nΣημαντικό:\r\n\r\nΠέρασμα μεταβλητών στο Σωρό με αναφορά στη τιμή!\r\n\r\n      Μέχρι και την έκδοση 5 οι μεταβλητές άφηναν τις τιμές τους στον σωρό και με ΔΙΑΒΑΣΕ μπορούσαμε να πάρουμε αυτές τις τιμές σε άλλες μεταβλητές. Αυτό ήταν χρήσιμο για να βάλουμε παράμετρους σε ένα τμήμα ή συνάρτηση. Δεν γινόταν να περάσει πίνακας άμεσα, αφού θα έπρεπε να περάσουν ολες οι τιμές και μετά να αντιγραφούν από το σωρό όλες οι τιμές στο πίνακα πάλι από εκεί που καλέσαμε το τμήμα ή τη συνάρτηση.\r\n      Στην έκτη έκδοση το θέμα λύθηκε. Μπορούμε να περνάμε πίνακες και μεταβλητές γενικότερα με δείκτες στο σωρό. Ο δείκτης λέει στη ΔΙΑΒΑΣΕ να φτιάξει μια μεταβλητή χωρίς να της δώσει νέο χώρο, αλλά να πάρει αυτόν που δείχνει ο δείκτης.\r\nΧρησιμοποιούμε το χαρακτήρα & μόνο στις ΒΑΛΕ, ΣΕΙΡΑ και ΔΙΑΒΑΣΕ καθώς και στις κλήσεις των Τμημάτων και των Συναρτήσεων\r\n      ΠΙΝΑΚΑΣ ππ(10)\r\n      ππ(4)=1234\r\n      ΒΑΛΕ &ππ()\r\n      ΔΙΑΒΑΣΕ &κλ() ' Εδώ φτιάξαμε τον πίνακα κλ() που δείχνει στον ίδιο χώρο, αυτό του ππ()\r\n      ΤΥΠΩΣΕ κλ(4)\r\n      ονομα$=\"Κολόμβος\"\r\n      ΤΜΗΜΑ ΑΑ {\r\n            ΔΙΑΒΑΣΕ &κκ(), &κ$ \r\n            κ$=\"Ωραίος ο \"+κ$   'Αλλάζουμε τις τιμές για να δούμε ότι θα αλλάξουν\r\n            κκ(4)=κκ(4)*2          'και έξω από το τμήμα!\r\n      }\r\n      ΑΑ &ππ(), &ονομα$\r\n      print ονομα$\r\n      print ππ(4)\r\n      \r\n      Επίσης με την προσθήκη αυτή φάνηκε και μια άλλη ιδιότητα που δεν είχε προβλεφθεί. Οι πίνακες και οι μεταβλητές εσωτερικά έχουν τιμές τύπου variant (ειδικός τύπος που υποστηρίζουν τα Windows). Δηλαδή μπορεί κάθε στοιχείο να είναι ή αριθμός ή αλφαριθμητικό. Όμως επειδή ο διερμηνευτής διαβάζει τον τύπο του πίνακα από την παρουσία των % και $ (και εξ ορισμού χωρίς αυτά είναι αριθμητική τιμή), δίνει τον τύπο που ζητάμε. Με την μεταβλητή που δημιουργούμε ως αναφορά στη τιμή μπορούμε να αλλάξουμε τύπο:\r\n\r\n      πινακας α(20)  ΄ο πίνακας πέρνει αριθμητικές τιμές\r\n      βαλε &α()     ' βάζουμε το δείκτη του στο σωρό\r\n      διαβασε &γ$()  ' δημιουργούμε έναν πίνακα με ίδιες τιμές με τον α() αλλά με άλλο τύπο\r\n      γ$(4)=\"1023\"   ' βάζουμε αλφαριθμητικό και εδώ βάζουμε αριθμό (θα δούμε γιατί)\r\n      τυπωσε α(2), γ$(4), α(4)\r\n      \r\nΤι μας τυπώνει τώρα:\r\nτο α(2) είναι 0\r\nτο γ$(4) είναι το στοιχείο α(4) αλλά τυπώνεται ως αλφαριθμητικό\r\nτο α(4) έχει τον αριθμό 1023 γιατί εσωτερικά ο διερμηνευτής διάβασε την τιμή του α(4) ως αριθμό\r\nαν είχαμε δώσει γ$(4)=\"αααα\" θα μας έδινε τιμή στο α(4) το μηδέν\r\n\r\nΆλλο παράδειγμα με μεταβλητές:\r\n\r\n      α=1\r\n      βαλε &α\r\n      διαβασε &γ$\r\n      γ$=\"1023\"\r\n      τυπωσε α, γ$\r\n      \r\n      β$=\"1234\"\r\n      βαλε &β$\r\n      διαβασε &δ\r\n      τυπωσε δ\r\n   \r\n      \r\n  
EN:ADD.LICENSE$(\r\nπροσθέτει άδεια για χρήση αντικειμένου (με την όρισε)\r\nΠαίρνει ένα ή δυο ορίσματα. Το πρώτο είναι το αντικείμενο όπως ονομάζεται ή το νούμερό του, και το δεύτερο η άδεια\r\n(είναι η συνάρτηση licence.add της VB6)\r\nInfo: https://msdn.microsoft.com/en-us/library/aa277583(v=vs.60).aspx\r\n\r\n
EN:DATABASES\r\nΒΑΣΕΙΣ ΔΕΔΟΜΕΝΩΝ\r\nΑΝΑΖΗΤΗΣΗ, ΑΝΑΚΤΗΣΗ, ΑΡΧΕΙΟ, ΑΦΑΙΡΕΣΗ, ΒΑΣΗ, ΒΑΣΗ.ΠΑΡΟΧΟΣ, ΒΑΣΗ.ΧΡΗΣΤΗΣ, ΔΕΙΞΕ, ΔΟΜΗ, ΕΚΤΕΛΕΣΗ, ΕΠΙΣΤΡΟΦΗ, ΠΡΟΣΘΗΚΗ, ΣΥΜΠΙΕΣΗ, ΤΑΞΗ\r\n
EN:BASE\r\n1) Χρήση με αριθμητική παράμετρο (βάση πινάκων)\r\nΒΑΣΗ 1 πίνακες με βάση 1\r\nΒΑΣΗ 0 πίνακες με βάση 0\r\n2) Χρήση με αλφαριθμητική παράμετρο (δημιουργία ή διαγραφή και δημιουργία κενής βάσης)\r\nΒΑΣΗ ονομα_βασης$\r\nη βάση θα είναι στο KAT$+ονομα_βασης$+\".mdb\"\r\n\r\nΔημιουργεί μια βάση διαγράφοντας όμως εκείνη που θα βρει με το ίδιο όνομα\r\nΗ βάση θα είναι κενή από αρχεία (πίνακες αλλά εδώ για να ξεχωρίσουμε από τους πίνακες στη μνήμη θα λέμε αρχεία τους πίνακες της βάσης). Κάθε αρχείο μπορεί να έχει αρκετά πεδία και μπορούμε να ορίσουμε ποια πεδία θα αποτελούν την τάξη ταξινόμησης.\r\n\r\nδες εντολές\r\n\r\nΑΡΧΕΙΟ  για να φτιάξεις τη δομή του αρχείου στη βάση\r\nΤΑΞΗ για να φτιάξεις τη δομή της ταξινόμησης\r\n\r\nΜε την ΔΟΜΗ διαβάζουμε τη δομή της Βάσης σε Αρχεία, και τη δομή των Αρχείων σε πεδία και πεδία τάξης.\r\nΜε την ΠΡΟΣΘΗΚΗ προσθέτουμε στοιχεία σε σειρές (εγγραφές)\r\nΜε την ΕΚΤΕΛΕΣΗ εκτελούμε μια εντολή για τη βάση (δεν περιμένουμε να μας επιστρέψει πεδία)\r\nΜε την ΑΝΑΚΤΗΣΗ διαβάζουμε στοιχεία (από εγγραφή)\r\nΜε την ΔΙΑΓΡΑΦΗ διαγράφουμε  εγγραφή\r\nΜε την ΑΝΑΖΗΤΗΣΗ διαβάζουμε με επιλογή φίλτρου\r\nΜε την ΔΕΙΞΕ μεταφέρουμε μέρος στήλης στο μενού επιλογής.\r\nΜε την ΣΥΜΠΙΕΣΗ επισκευάζουμε και τακτοποιούμε την βάση\r\nΜε την ΚΛΕΙΣΕ ΒΑΣΗ κλείνουμε την σύνδεση με τη βάση\r\n' προσθήκη από την έκδοση 7\r\nΑπό την έκδοση 7 έχουμε αλλαγή του τύπου της βάσης mdb από Access 7 σε ADO αντικείμενα, προσαρμοσμένο όμως στην ίδια λειτουργία με τις άλλες εκδόσεις. Παράλληλα αυτή η έκδοση υποστηρίζει πεδία Unicode.\r\n\r\nΜε την ΚΛΕΙΣΕ ΒΑΣΗ  ονομαβασης αποδεσμεύουμε μη αυτόματα το ADO αντικείμενο.\r\n\r\n
EN:MDB(\r\nΤΥΠΩΣΕ ΒΑΣΗ(\"HELP2000\")\r\nΔίνει -1\r\nΣημαίνει ότι η βάση HELP2000.MDB είναι μια βάση της Μ2000 (έχει δηλαδή Password που ισοδυναμεί με ταυτότητα)\r\n\r\n\r\n
EN:DB.PROVIDER\r\nΒΑΣΗ.ΠΑΡΟΧΟΣ  \"Microsoft.Jet.OLEDB.4.0\", \"Jet OLEDB\", \"PASSWORD\"\r\nτο password είναι για τη κρυπτογράφηση της βάσης\r\n\r\n
EN:DB.USER\r\nΒΑΣΗ.ΧΡΗΣΤΗΣ \"dbusername\",\"dbpassword\"\r\n\r\n
EN:FILL\r\n1) ΒΑΨΕ πλατος.χ, υψος.ψ, χρώμα1, χρώμα2,  διευθυνση, τμημα\r\n    ΒΑΨΕ πλατος.χ, υψος.ψ, χρώμα1, χρώμα2,  διευθυνση\r\n    ΒΑΨΕ πλατος.χ, υψος.ψ, χρώμα1, χρώμα2\r\n    ΒΑΨΕ πλατος.χ, υψος.ψ, χρώμα1\r\n    ΒΑΨΕ πλατος.χ, υψος.ψ,\r\n    Επεξήγηση:\r\n    Δίνουμε πάντα πλάτος και ύψος (θα βαφτεί ένα παραλληλόγραμμο από την τελευταία θέση του δρομέα γραφικών - δες ΘΕΣΗ)\r\n    Χωρίς να δώσουμε το χρώμα (0 ..15 βασικά χρώματα των Windows, αρνητικές τιμές -1 έως -16777216 RGB), χρησιμοποιείται το χρώμα πένας (δες ΠΕΝΑ)\r\n    Με δεύτερο χρώμα το βάψιμο γίνεται με διαβάθμιση (όπως στην ΦΟΝΤΟ)\r\n    Η διεύθυνση μπορεί να πάρει τιμές 0 ή 1\r\n    Το τμήμα παίρνει τιμές 0 ή 1\r\n    Ο δρομέας γραφικών μεταφέρεται στην νέα θέση (προηγούμενη.χ +πλάτος.χ, προηγούμενη.ψ +υψος.ψ)\r\n2) ΒΑΨΕ @ πλατος.χ, υψος.ψ, τροπος, αριθμος , περιθωριο_σε_twips\r\n    ΒΑΨΕ @ πλατος.χ, υψος.ψ, , αλφαριθμητικό$\r\n    Επεξήγηση:\r\n    Με αυτήν την παραλλαγή μπορούμε να εμφανίζουμε στοιχεία των Windows:\r\n    Τρόπος:\r\n    0 - Σχεδιάζει πλαίσια\r\n    1 - Σχεδιάζει φόντο για γράμματα\r\n    2 - Σχεδιάζει\r\n    3 - Πλαίσιο εστίασης (ΒΑΨΕ @1000,1000,3,1 με δεύτερη όμοια εντολή φεύγει το πλαίσιο)\r\n    4 - Διάφορα τετράπλευρα (όπως τα στοιχεία ελέγχου των windows)\r\n    5 - Κεντράρει και τυπώνει μια λέξη ή έναν αριθμό\r\n    6 - Όπως η (4) αλλά μπορούμε να τυπώνουμε κάποιες πλευρές ( 1+2+4+8 όλο το τετράπλευρο)\r\n    Ο δρομέας γραφικών δεν αλλάζει θέση.\r\n    3D πλαίσια - ΒΑΨΕ @ 2000,2000,4,1\r\n    \r\n    
EN:STEP\r\nΟι τιμές των συντεταγμένων είναι σε twips\r\nΗ εντολή ΒΗΜΑ μεταφέρει τον δρομέα γραφικών σε σχετική θέση (ενώ η ΘΕΣΗ μετακινεί τον δρομέα σε απόλυτη θέση)\r\n1) Καρτεσιανές συντεταγμένες\r\nΒΗΜΑ 1000,500  (μεταφορά του δρομέα γραφικών κατά 1000 στον οριζόντιο άξονα και κατά 500 στον κατακόρυφο - προς τα δεξιά και προς τα κάτω)\r\nΒΗΜΑ ,-500 (μεταφορά δρ. γρ. προς τα άνω κατά 500 twips)\r\nΒΗΜΑ -1000 (μεταφορά δρ. γρ. προς τα αριστερά κατά 1000 twips)\r\n2) Πολικές Συντεταγμένες\r\nΒΗΜΑ ΓΩΝΙΑ πι/4,1000 (μεταφορά του δρομέα γραφικών κατά 1000 twips απόσταση σε γωνία π/4 δηλ. 45 μοίρες από τον ορίζοντα)\r\n\r\nΜε πολικές συντεταγμένες δουλεύουν και οι εντολές ΧΑΡΑΞΕ,  ΠΟΛΥΓΩΝΟ, ΚΑΜΠΥΛΗ. Οι πολικές συντεταγμένες είναι πάντα σχετικές.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
EN:HELP\r\n1) Εμφάνιση βοήθειας \r\nCTRL+F1\r\nΒΟΗΘΕΙΑ\r\n\r\n2)\r\nΒΟΗΘΕΙΑ φραση$\r\n πχ \"ΕΝΤΟΛΕΣ\" ή \"ΣΥΝΑΡΤΗΣΕΙΣ\"\r\n3)\r\nΒΟΗΘΕΙΑ εντολη\r\n\r\n4) Ανάγνωση από το αρχείο βοήθειας mdb (αν το έχουμε, αλλιώς δείτε το 5)\r\n\r\n\\\\ Όλα τα αναγνωριστικά σε αλφαβητική σειρά\r\nΦόρμα 80,50\r\nΆδειασε\r\nΈγγραφο Όλα$\r\nΝέαΓραμμή$={\r\n}\r\nΚατάλογος Εφαρμογή.Κατ$ \\\\ AppDir$ δίνει το φάκελο που βρίσκεται η εφαρμογή του διερμηνευτή\r\n\\\\ ετοιμάζουμε το όνομα της βάσης για το κλείσιμο στο τέλος\r\n\\\\ είναι προαιρετικό, δηλαδή μπορούμε να μη το βάλουμε,και να μην φτιάξουμε την Βάση$\r\nΒάση$=Κατ$+Πεζ$(\"HELP2000\")+\".mdb\"\r\nΑνάκτηση \"HELP2000\", \"SELECT * FROM COMMANDS ORDER BY DESCRIPTION\"\r\nΔιάβασε Ν\r\nΓια ι=1 έως Ν {\r\n      Ανάκτηση \"HELP2000\", \"SELECT * FROM COMMANDS ORDER BY DESCRIPTION\", ι\r\n      Πέτα  \\\\ διώχνει ένα στοιχείο από το σωρό (από τη κορυφή)\r\n      Διάβασε Ελλ$, Κείμενο$, Αγγ$, νούμερο_ομάδας\r\n      \\\\ το 22 είναι η ομάδα Γενικά - που περιλαμβάνει τις εντολές ανά ομάδα\r\n      Αν νούμερο_ομάδας<>22 Τότε {\r\n                  Ανάκτηση \"HELP2000\",\"GROUP\", 1,\"GROUPNUM \", νούμερο_ομάδας\r\n                  Πέτα 2 : Διάβασε τίτλος_ελλ_αγγ$\r\n                   Ελλ$=Αλλαγή$(\"_\",\" \", Ελλ$)\r\n                  Αν Δεξί$(Ελλ$,1)=\"(\" Τότε Ελλ$=Ελλ$+\")\"\r\n                  \\\\ ο χαρ$(160) είναι το διάστημα που δεν \"σπάει\", λογαριάζετα σαν γράμμα.\r\n                  Αναφορά Ελλ$ +  \" (\"+ΑριστερόΜέρος$(τίτλος_ελλ_αγγ$, \",\"+Χαρ$(160))+\")\"\r\n                  Όλα$=Ελλ$ +\"   (\"+ΑριστερόΜέρος$(τίτλος_ελλ_αγγ$, \",\"+Χαρ$(160))+\")\"+ΝέαΓραμμή$\r\n      }\r\n}\r\nΤύπωσε\r\nΣημ 1 : Πρόχειρο Όλα$ ' στο Πρόχειρο\r\nΚατάλογος Χρήστη \\\\ επιστροφή στο κατάλογο χρήστη\r\nΣώσε.Έγγραφο Όλα$, \"Greek.txt\"\r\nΣύστημα \"WordPad\", Παράθεση$(Κατ$+\"Greek.txt\")\r\nΚλείσε Βάση Βάση$  ' Θα κλείσει όπως και να έχει στο τερματισμό, αλλά εδώ γίνεται όταν το θέλουμε εμείς!\r\n\r\n5) Ανάγνωση από το αρχείο dat/\r\n\r\nΕγγραφο  ολα$, κειμ$\r\nΦόρτωσε.Εγγραφο ολα$, Εφαρμογή.Κατ$+\"help2000utf8.dat\"\r\nα=Τιμή(Παράγραφος$(ολα$, 1))\r\nβ=Τιμή(Παράγραφος$(ολα$, 2+α))\r\nΓια ι=1 Έως β\r\n\tμ=Τιμή(ΔεξίΜέρος$(Παράγραφος$(ολα$,2+α+ι+2*β),\"!\"))+1\r\n\tβ$=μεσ$(ΑριστερόΜέρος$(Παράγραφος$(ολα$,2+α+ι+2*β),\"!\"),2) \r\n\tΑν Δεξί$(β$,1)=\"(\" Τότε β$+=\")\"\r\n\tγραμμή$=β$+\" (\"+ ΑριστερόΜέρος$(Παράγραφος$(ολα$, μ), \",\"+χαρ$(160))+\")\"\r\n\tΤύπωσε #-2, γραμμή$\r\n\tκειμ$=γραμμή$+{\r\n\t}\r\nΕπόμενο ι\r\nΣώσε.Έγγραφο κειμ$,\"Greek.txt\"\r\nΣύστημα \"WordPad\", Παράθεση$(Κατ$+\"Greek.txt\")\r\n\r\n\r\n
EN:EVENT\r\nΈνα γεγονός είναι αντικείμενο που μπορεί να μπει στο σωρό και το βλέπουμε με Ταύτιση(\"Ε\") (Ε ελληνική ή E αγγλικό).\r\n\r\nΓενικό Γεγονός Άλφα { }\r\nΓεγονός Αλφα {\r\n      Διάβασε μήνυμα$\r\n      Διάβασε &δώσε_πίσω\r\n      Συνάρτηση {\r\n             \\\\ μπορώ και να σπάσω τις Διάβασε σε σειρά\r\n             \\\\ και εδώ πρέπει να τις αφήσω εκτός\r\n             \\\\ από αυτή τη συνάρτηση\r\n             \\\\ γιατί θα βάλει μία ο διερμηνευτής\r\n            Τύπωσε μήνυμα$\r\n      }\r\n}\r\n\r\n\r\nΓεγονός Άλφα Κράτησε\r\nΓεγονός Άλφα Καθαρό \\\\ (κάνει και κράτηση συνάμα)\r\nΓεγονός Άλφα Άφησε\r\nΓεγονός Άλφα Πέτα αααα() [, ββββ()]\r\nΓεγονός Άλφα Νέο αααα() [, ββββ()]\r\n\r\nΠαράδειγμα:\r\nΒηματιστής = λάμδα -> {\r\n      \\\\ τιμή εκκίνησης, τιμή τερματισμού (δίνει ψευδές)\r\n      Διάβασε χ,ζ\r\n      =Λάμδα χ, ζ->{\r\n            Διάβασε γ\r\n            Αν χ>=ζ Τότε Έξοδος\r\n            Κάλεσε Γεγονός γ χ\r\n            χ++\r\n            =Αληθής\r\n      }\r\n}\r\n\r\nα_από_10_μέχρι_14=Βηματιστής(10,15)\r\nβ=λάμδα->{Τύπωσε Αριθμός}  \\\\ ίδιο με { Διάβασε Χ : Τύπωσε Χ}\r\nΓεγονός γεγ {Διάβασε χ}\r\n\\\\ Πολλαπλής εκπομπής (multicast)\r\nΓεγονός γεγ Νέο β(), β(), β()\r\nΓεγονός γεγ Πέτα β()\r\n\\\\ άρα έχουμε δυο τώρα!\r\n\\\\ κλήση γεγονότος\r\nΚάλεσε Γεγονός γεγ 5\r\n\\\\ Με το βιματιστή, όπου περνάμε το γεγονός ως παράμετρο:\r\n\\\\ η παράμετρος εδώ είναι με τιμή. Δεν υπάρχει πρόβλημα!\r\n\\\\ Με αναφορά θα μπορούσαμε να χειριστούμε το γεγονός και αυτό έχει\r\n\\\\ αλλαγές μετά την επιστροφή\r\nΕνώ α_από_10_μέχρι_14(γεγ) {}\r\n\\\\ ο διακόπτης Καθαρό κάνει και Κράτησε\r\nΓεγονός γεγ Καθαρό\r\nΣυνάρτηση κ { Τυπωσε \"οκ\", αριθμός}\r\nΓεγονός γεγ Νέο κ()\r\n\\\\ πρέπει να αφήσουμε το γεγονός να λειτουργεί! (το είχαμε κρατήσει πριν)\r\nΓεγονός γεγ Άφησε\r\nΚάλεσε Γεγονός γεγ 1\r\nΓεγονός γεγ Κράτησε\r\n\\\\ η παρακάτω δεν θα εκτελεστεί ως γεγονός, αλλά η β θα τυπώσει το 2\r\n\\\\ γιατί ο έλεγχος γίνεται μετά την συγκέντρωση των παραμέτρων που δίνουμε στη γεγονός.\r\nΚάλεσε Γεγονός γεγ 5+β(2)  \r\n\r\n\r\n\r\n
EN:FLOODFILL\r\nΗ εντολή ΓΕΜΙΣΕ χρησιμοποιείται για να γεμίζουμε χρώμα ακανόνιστα σχήματα, που είτε έχουν ομοιόχρωμη περίμετρο (ένας τρόπος), είτε έχουν ένα χρώμα και θέλουμε να το αλλάξουμε.\r\n\r\n1) ΓΕΜΙΣΕ Θεση.Χ, Θεση.Υ, χρώμα    (δες ΒΑΨΕ για το χρώμα)\r\n    ΓΕΜΙΣΕ 1000,1000, 5\r\n    ΓΕΜΙΣΕ 1000,1000       (χρησιμοποιεί το χρώμα της πένας)\r\n\r\n2) ΓΕΜΙΣΕ ΧΡΩΜΑ Θεση.Χ, Θεση.Υ, χρώμα\r\n    ΓΕΜΙΣΕ ΧΡΩΜΑ 1000, 1000, 5\r\n    ΓΕΜΙΣΕ ΧΡΩΜΑ 1000, 1000\r\n\r\nΠαρατήρηση\r\nαν θέλουμε να γεμίσουμε χρώμα στην θέση του δρομέα γραφικών τότε δίνουμε\r\nΓΕΜΙΣΕ ,,5\r\nΓΕΜΙΣΕ ΧΡΩΜΑ ,,5\r\n\r\n\r\n\r\n\r\n\r\n
EN:GLOBAL\r\nΓΕΝΙΚΗ Α=10, Α(20,30)\r\nΜπορούμε να χρησιμοποιήσουμε και τα ΓΕΝΙΚΟ και ΓΕΝΙΚΕΣ\r\nΜπορούμε να φτιάχνουμε και πίνακες. Αν υπάρχει μια ίδια γενική μεταβλητή ή πίνακας τότε ξαναφτιάχνεται ένας άλλος με το ίδιο όνομα, οπότε δεν πρέπει να μπαίνει σε ένα μπλοκ επανάληψης. Αν θέλουμε να καλέσουμε ένα τμήμα και θέλουμε να βλέπει μια στατική μεταβλητή τότε μπορούμε πριν το καλέσουμε να έχουμε μια γενική ως στατική. Μια γενική θα χαθεί μόλις τερματίσει ο δημιουργός της, ένα τμήμα ή μια συνάρτηση ή μια ρουτίνα (δες ΡΟΥΤΙΝΑ) ή μια ΓΙΑ ΑΥΤΟ {}. Αν υπάρχει ήδη μια άλλη γενική με το ίδιο όνομα πριν την εκκίνηση του δημιουργού της γενικής τότε αυτή επανέρχεται στο προσκήνιο. Ουσιαστικά μια γενική εντός ενός τμήματος είναι μια τοπική με εμβέλεια όλα τα παρακάτω τμήματα εκτός αυτών που έχει οριστεί τοπική με το ίδιο όνομα ή άλλη γενική.\r\nΜια γενική αλλάζει τιμές με το <= ή χωρίς αυτό αν χρησιμοποιήσουμε τη ΣΤΗ\r\n\r\nΓενική Α=10\r\nΣτη Α=30  \\\\ δουλεύει και για γενικές.\r\nΑ+=20  \\\\ δουλεύει και για γενικές\r\nΑ<=1000 \\\\ διαφορετικά φτιάχνεται τοπική Α\r\n\r\nΟι πίνακες που ορίζουμε με την Γενική μπορούν να αλλάξουν αριθμό στοιχείων με την θέσε Πίνακας\r\nΑν θέλουμε να δώσουμε αρχική τιμή σε πίνακα τότε χρησιμοποιούμε την πίνακας και για γενικές την θέσε πίνακας\r\nόμως η Πίνακας δεν φτιάχνει νέους πίνακες με το ίδιο όνομα, αλλά τους ορίζει ξανά προσαρμόζοντας τα στοιχεία τους. Μπορούμε να αντιγράψουμε ένα πίνακα σε έναν πίνακα\r\nΠ.χ. έχουμε έναν γενικό πίνακα Α()\r\nκαι θέλουμε να πάρει τιμές από έναν τοπικό \r\nγενικο α()\r\nγια αυτό {πινακας β(30)=1 : α()=β() }   \\\\ ο β() θα σβήσει με το πέρας της για\r\nΤυπωσε α(12)\r\nλιστα\r\n\r\n
EN:FOR\r\nΜε χρήση του Θέσε Διακόπτες \"+FOR\" αλλάζουμε το τρόπο εκτέλεσης της ΓΙΑ να ταιριάζει με της BASIC, δηλαδή το πρόσημο του βήματος να μετράει, ώστε να υπάρχει περίπτωση να μην εκτελεστεί η ΓΙΑ. Με το κανονικό \"-FOR\", πάντα η Για εκτελείται μία τουλάχιστον φορά, η δε φορά αλλαγής απαρίθμισης εξαρτιέται από την αρχική και τελική τιμή. Μόνο όταν αυτές οι δυο τιμές είναι ίσες, μπορεί να καθορίσει το πρόσημο του βήματος (αν το έχουμε δώσει και μόνο τότε), την τελική τιμή μετά αυτήν τη δομή.\r\n\r\n1) Με βήμα 1\r\nΓΙΑ μεταβλητή= αρχικη_τιμη ΕΩΣ τελικη_τιμη {\r\n      εντολές\r\n}\r\n2) Με βήμα που θέλουμε\r\nΓΙΑ μεταβλητή= αρχικη_τιμη ΕΩΣ τελικη_τιμη ΑΝΑ βημα {\r\n      εντολές\r\n}\r\nΑπό  αναθεώρηση 51, έκδοση 8:\r\n3) To <= βάζει τιμή σε γενική μεταβλητή\r\n   \r\n4) Χρήση  αρνητικού βήματος για περίπτωση που αρχή και τέλος είναι ίδιο.\r\n    Το Για ν=1 εως 1 ανα -1 {} δίνει 0 μετά το πέρας στο ν\r\n    Το Για ν=1 εως 1 ανα 1 {} δίνει 2 μετά το πέρας στο ν\r\n     Το Για ν=1 εως 1 {} δίνει 1 μετά το πέρας στο ν  όπως ήταν πάντα.\r\n\r\nΤο βήμα είναι μια απόλυτη τιμή (δεν έχει σημασία το πρόσημο της) μπορεί η αρχική τιμή να είναι μεγαλύτερη της τελικής αλλά η μέτρηση θα γίνει πάντα προς τη τελική τιμή.\r\n\r\nΗ μεταβλητή μπορεί να είναι ακέραια η πραγματική  (π.χ. Α% ή Β  ή ειδικού τύπου Μακρύς) και είναι πάντα τοπική.\r\n\r\nΜπορούμε να έχουμε πολλαπλά ΓΙΑ το ένα μέσα από το άλλο (Φωλιασμένα)\r\nΠΡΟΣΟΧΗ 1\r\nΜπορούμε να αλλάξουμε την τιμή της Ι μέσα στο Για αλλά δεν θα αλλάξει ο αριθμός των επαναλήψεων και σε κάθε νέα επανάληψη η μεταβλητή θα έχει το σωστό νούμερο.\r\nΠΡΟΣΟΧΗ 2\r\nΑν η αρχiκή τιμή είναι ίδια με την τελική ΔΕΝ θα αλλάξει μετά το ΓΙΑ  (δες το 4 πάνω) αν δεν έχουμε θέσει βήμα.\r\n\r\n5) Για Επόμενο\r\nΓια ι=1 έως 100 ανά 2\r\n      Τύπωσε ι \r\nΕπόμενο ι\r\nΓια ι=1 έως 100 ανά 2\r\n      Τύπωσε ι \r\nΕπόμενο   ' χωρίς τη μεταβλητή ι\r\n\r\n\r\nΑν θέλουμε να δημιουργήσουμε μια επανάληψη με επιλογή μέσα από την επανάληψη ενός διαφορετικού βήματος ή ενός τερματισμού πριν την ολοκλήρωση του αριθμού επαναλήψεων τότε πρέπει να χρησιμοποιήσουμε μια απλή επανάληψη με το ΚΥΚΛΙΚΑ όπου θα δώσουμε εσωτερικά στην ομάδα εντολών την εντολή αύξησης ή μείωσης του βήματος\r\n\r\nΓια Ι=1 Έως 100 Ανά 2 {\r\n      Αν Ι >50 Τότε Έξοδος\r\n      Αν Ι>30 Και Ι< 45 Τοτε Συνέχισε\r\n      Τύπωσε Ι\r\n}\r\nΤύπωσε \">>>\", Ι\r\n\r\n\\\\ χωρίς χρήση Για\r\nΙ=10\r\nΑ=Τυχαίος(1,3)\r\n{\r\n      Αν Ι<30 Τότε Κυκλικά  \\\\ απλά βάζει μια σημαία στο μπλοκ\r\n      Αν Α>1 και Ι>25 Τότε Έξοδος\r\n      Τύπωσε Ι\r\n      Ι++\r\n}\r\n\r\n\\\\ χωρίς χρήση μπλοκ\r\nΙ=10\r\nΑ=Τυχαίος(1,3)\r\n090 Σημαία=Ψευδές\r\n100 Αν Ι<30 Τότε Σημαία=Αληθές\r\n110 Αν Α>1 και Ι>25 Τότε 150\r\n120 Τύπωσε Ι\r\n130 Ι++\r\n140 Αν Σημαία Τότε 90\r\n150 Τύπωσε \"ΟΚ\"\r\n\r\n\\\\ Με χρήση νήματος\r\nΟθόνη\r\nΙ=10 \r\nΑ=Τυχαίος(1,3)\r\nΕξ1=Ψευδές\r\nΝήμα {\r\n      Ι++\r\n      Αν Ι>30  ή (Α>1 και Ι>25) Τότε Εξ1=Αληθές : Νήμα Αυτό Σβήσε\r\n      Τύπωσε Ι\r\n} ως Ν κάθε 10\r\n\\\\ πάτα το πλήκτρο του ποντικιού για να τερματίσει\r\nΚύριο.Έργο 100 {\r\n      Αν Δείκτης<>0 ή Εξ1 Τότε Έξοδος   \r\n}\r\n\r\n
EN:LETTER$\r\nα$=γραμμα$\r\n\r\nΔίνει το αλφαριθμητικό που βρίσκεται στην κορυφή του σωρού και το αφαιρεί. Αν ο ΣΩΡΟΣ δεν έχει τιμές ή έχει στην κορυφή μια αριθμητική τιμή τότε βγαίνει λάθος. Ελέγχουμε με τις ΚΕΝΟ, ΕΙΝΓΡ και ΕΙΝΑΡ.\r\nνέες εντολές είναι η ΦΑΚΕΛΟΣ$() και η ΜΕΓΕΘΟΣ.ΣΩΡΟΥ\r\n\r\n
EN:FONT\r\n1) ΓΡΑΜΜΑΤΟΣΕΙΡΑ \"VERDANA\"\r\nΑλλάζουμε γραμματοσειρά. Οι γραμματοσειρές πριν την έκτη έκδοση άλλαζαν μόνο με την εντολή Αρχή για τα γράμματα που τυπώνουμε σε στήλες, ενώ μπορούσαμε με την Επιγραφη να τυπώσουμε γράμματα με οποιαδήπτε γραμματοσειρά. Αυτό που κάνει η εντολή Γραμματοσειρα είναι να αλλάξει την τρέχουσα γραμματοσειρά χωρίς όμως να επανακαθορίσει την οθόνη. Αν και δεν αλλάζει το μέγεθος γραμμάτων (αριθμητικά) μπορεί το τρέχον μέγεθος να διαφέρει σε άλλη γραμματοσειρά!\r\n\r\nΟ σκοπός αυτής της εντολής είναι να τυπώσουμε σε θέσεις χαρακτήρων με την γραμματοσειρά που θέλουμε, και να ξαναγυρίσουμε στη βασική. Υπάρχει η Γραμματοσειρα$ που κρατάει την τρέχουσα γραμματοσειρά. Θα την γράψουμε σε μια μεταβλητή, θα αλλάξουμε γραμματοσειρά και θα επανέλθουμε στην αρχική.\r\nΤύπωσε Γραμματοσειρα$\r\n2) ΓΡΑΜΜΑΤΟΣΕΙΡΑ ΦΟΡΤΩΣΕ \"path\\name.ttf\" [, \"path\\name.ttf\"]\r\nμπορούμε να δώσουμε όνομα αρχείου χωρίς μονοπάτι, θα χρησιμοποιήσει το τρέχον\r\nαυτή η εντολή φορτώνει γραμματοσειρές, δεν τις ορίζει (το όνομα του αρχείου είναι διαφορετικό από το όνομα της γραμματοσειράς)\r\nΣτο Επίλεξε.Γραμματοσειρά αν πατήσουμε το end μας πάει στη τελευταία γραμματοσειρά, αυτήν που βάλαμε!\r\n \r\n3)  ΓΡΑΜΜΑΤΟΣΕΙΡΑ ΔΙΑΓΡΑΦΗ \"path\\name.ttf\" [, \"path\\name.ttf\"]\r\n για να διαγράψουμε μια γραμματοσειρά αφενός δεν πρέπει να την χρησιμοποιούμε και αφετέρου πρέπει να δώσουμε το όνομα όπως καταχωρήθηκε στην φόρτωση. Αν δεν είχαμε δώσει το μονοπάτι πρέπει να βάλουμε το ίδιο μονοπάτι. Αν δεν τις διαγράψουμε δεν πειράζει γιατί θα διαγραφούν αυτόματα στο τέλος εκτέλεσης του διερμηνευτή. \r\n
EN:FONTNAME$\r\n? ΓΡΑΜΜΑΤΟΣΕΙΡΑ$\r\nΤΥΠΩΝΕΙ ΤΟ ΟΝΟΜΑ ΤΗΣ ΓΡΑΜΜΑΤΟΣΕΙΡΑΣ ΠΟΥ ΚΑΝΟΥΜΕ ΧΡΗΣΗ\r\n\r\nμπορούμε να αλλάζουμε το όνομα της γραμματοσειράς με την εντολή ΓΡΑΜΜΑΤΟΣΕΙΡΑ\r\n\r\nκάθε επίπεδο όπως και το φόντο μπορεί να έχει τη δική του ξεχωριστή γραμματοσειρά.\r\n\r\n
EN:REPORTLINES\r\nΕπιστρέφει τον αριθμό γραμμών που μπορεί να τυπώσει η ΑΝΑΦΟΡΑ στη δοκιμή που κάναμε σε προηγούμενη χρήση της με αρνητικό νούμερο στον αριθμό γραμμών (δεν τυπώνει)\r\nΔες την αναφορά. Δες το παράδειγμα εδώ: REPORTLINES\r\n\r\n
EN:ROW\r\nΔίνει την θέση Υ του δρομέα χαρακτήρων\r\nΔρομέας 2,2 : Τύπωσε Γραμμή\r\nθέση και Γραμμή  δίνουν το σημείο που βρίσκεται ο δρομέας χαρακτήρων.\r\nΟ δρομέας μπορεί να αλλάζει κατά ΣΤΗΛΗ (δίνει το πλάτος στήλης).\r\n\r\n
EN:LINE INPUT\r\nΓΡΑΜΜΗ ΕΙΣΑΓΩΓΗΣ #μεταβλητη_χειρισμου_αρχειου, αλφαριθμητική_μεταβλητή$\r\nΓΡΑΜΜΗ ΕΙΣΑΓΩΓΗΣ #μεταβλητη_χειρισμου_αρχειου, αλφαριθμητική_μεταβλητή$(δείκτης)\r\nΘα φορτώσει χαρακτήρες μέχρι να βρει τους χαρακτήρες αλλαγής γραμμής 13 ή 13+10\r\nτο\r\nνεαγραμμη$={\r\n}\r\nβάζει κατευθείαν στο νεαγραμμη$ μια αλλαγή γραμμής και μπορούμε αν θέλουμε να ξαναφτιάξουμε το αρχείο, από όπου με την ΓΡΑΜΜΗ ΕΙΣΑΓΩΓΗΣ διαβάζουμε μια προς μια τις γραμμές του και αν προσθέσουμε το νεαγραμμη$ τότε μπορούμε να περάσουμε όποια γραμμή θέλουμε σε ένα άλλο αρχείο.\r\n\r\nΓια να μην βγει λάθος πρέπει κάθε φορά πριν διαβάσουμε με την ΓΡΑΜΜΗ ΕΙΣΑΓΩΓΗΣ να βλέπουμε αν υπάρχει κάτι για να εισάγουμε, με την ΤΕΛΟΣ(μεταβλητή_χειρισμού)\r\n\r\nΑλλαγή γραμμής βρίσκει αν δει ένα μόνο CR (13) ή LF  (10) ή CRLF ή LFCR\r\n\r\nΔΕΣ ΤΗΝ ΕΙΣΑΓΩΓΗ ΚΑΙ ΤΟ ΕΙΣΑΓΩΓΗ$()\r\n\r\n\r\n
EN:STR$(\r\nΤΥΠΩΣΕ ΓΡΑΦΗ$(ΣΗΜΕΡΑ,\"dddd\")\r\nΗ συνάρτηση ΓΡΑΦΗ$( ) έχει τρεις μορφές:\r\n\r\nΓΡΑΦΗ$(αριθμός)  ' το σημείο των δεκαδικών είναι πάντα το \".\", στους θετικούς βάζει διάστημα στην αρχή ή - αν είναι αρνητικοί\r\nΜε Γραφή$(αριθμός, \"\") ' παίρνουμε τον αριθμό με σημείο δεκαδικών (αν χρειάζεται βγάζει το σημείο)\r\nΤύπωσε Γραφή$(.34,\"\")\r\nΓΡΑΦΗ$(αριθμός, φόρμα$)\r\nΓΡΑΦΗ$(γράμματα$, φόρμα$)\r\nΠαράδειγμα:\r\n\r\nΤΥΠΩΣΕ ΓΡΑΦΗ$(\"ΑΒΓΔΕΖ\",\"<\")\r\n\r\nΜας τυπώνει σε πεζά:\r\nαβγδεζ\r\n\r\nΗ φόρμα που εμφανίζεται στη δεύτερη παράμετρο είναι ίδια με την πρώτη παράμετρο της $(). ΔΕΣ ΤΥΠΩΣΕ\r\n\r\nΜπορούμε να κρατάμε σε ένα αλφαριθμητικό την ANSI απεικόνιση μιας Unicode σειράς. Τα αλφαριθμητικά στην Μ2000 είναι του τύπου UTF16LE, δηλαδή δυο bytes κάθε χαρακτήρας. Αν κατασκευάσουμε ένα ANSI αλφαριθμητικό θα καταχωρηθεί ένας χαρακτήρας σε μια θέση των δυο bytes. Σε ένα αρχείο ANSI κάθε χαρακτήρας ANSI έχει ένα byte θέση. Όταν διαβάσουμε από ένα ANSI αρχείο τότε το σύστημα θα μας το μετατρέψει σε UTF16LE με βάση το Τοπικό Αναγνωριστικό (1032 για Ελληνικά). Αν γνωρίζουμε ότι το αρχείο είναι από άλλη γλώσσα τότε το μετατρέπουμε σε ANSI με την ΓΡΑΦΗ$(a$,0) και το ξαναμετατρέπουμε σε UNICODE με την ΧΑΡ$( a$, 1049), ή πιο εύκολα με αλλαγή του τοπικού στο 1049. \r\n\r\n\r\nα$=Γραφή$(\"Hello\")\r\n\\\\ το α$ γράφεται σαν Ansi αλφαριθμητικό, ένα byte ανά χαρακτήρα.\r\nΤύπωσε Μήκος(α$)=2.5\r\nΤύπωσε \"Bytes:\"=Μήκος(α$)*2  ' 5 bytes\r\nΤύπωσε Μήκος(χαρ$(α$))=5\r\nΤύπωσε α$\r\n\r\n\r\n\r\n\r\nΔΕΣ [ΦΟΡΜΑΡΙΣΜΑ_ΑΛΦΑΡΙΘΜΗΤΙΚΩΝ[\r\nΔΕΣ [ΦΟΡΜΑΡΙΣΜΑ_ΑΡΙΘΜΩΝ]\r\nΔΕΣ [ΦΟΡΜΑΡΙΣΜΑ_ΗΜΕΡΟΜΗΝΙΩΝ ΚΑΙ ΩΡΑΣ]\r\nΔΕΣ [ΦΟΡΜΑΡΙΣΜΑ_ΓΙΑ ΚΑΘΕ ΤΥΠΟ]\r\n\r\n
EN:DRAWING 2D\r\nΓΡΑΦΙΚΑ 2Δ\r\nΒΑΨΕ, ΒΗΜΑ, ΓΕΜΙΣΕ, ΘΕΣΗ, ΚΑΜΠΥΛΗ, ΚΥΚΛΟΣ, ΟΜΑΛΑ, ΠΑΧΟΣ, ΠΟΛΥΓΩΝΟ, ΧΑΡΑΞΕ, ΧΡΩΜΑ, ΧΡΩΜΑΤΙΣΕ\r\n
EN:WRITE\r\nΑν χρησιμοποιήσουμε όμομα αρχείου στην Άνοιξε το \"\" για εξαγωγή τότε η έξοδος γίνεται στην οθόνη.\r\nΜπορούμε να ορίσουμε το Tab ως χαρακτήρα διαχωρισμού πεδίων και το κόμμα για διαχωρισμό δεκαδικών στα ελληνικά.\r\nΓΡΑΨΕ ΜΕ ΧΑΡ$(9), \",\"\r\nμε ΓΡΑΨΕ ΜΕ \",\",\".\" επαναφέρουμε τη ΓΡΑΨΕ στο κανονικό.\r\n\r\nΥπάρχει και τρίτη παράμετρος στην Γράψε Με προαιρετικά. Με Αληθής τα αλφαριθμητικά μετατρέπονται όπου χρειάζεται σε ακολουθίες escape (όπως κάνει το Επαν$(αλφαριθμητικό) )\r\n\r\nΓΡΑΨΕ #μεταβλητη_χειρισμου_αρχειου, μεταβλητή, μεταβλητή$, ....\r\nΓράφει σε ένα αρχείο (ΓΙΑ ΕΞΑΓΩΓΗ ή ΓΙΑ ΣΥΜΠΛΗΡΩΣΗ)  σε μια γραμμή με διαχωριστικά αριθμούς ή αλφαριθμητικά ή και τα δύο, έτσι ώστε να διαβαστούν με την εντολή ΕΙΣΑΓΩΓΗ.\r\nΕπίσης σε ένα αρχείο που το έχουμε συμπληρώσει μόνο με την ΓΡΑΨΕ, αν έχουμε δώσει κατάληξη CSV τότε μπορούμε να το ανοίξουμε με το Microsoft Excel.\r\n\r\nΜπορούμε χωρίς πρόβλημα στην ανάγνωση (με INPUT #) να γράφουμε αλφαριθμητικά με πολλές γραμμές\r\n\r\n\r\n
EN:FAST\r\nΓΡΗΓΟΡΑ\r\nΓΡΗΓΟΡΑ !\r\n\r\n\\\\ Παράδειγμα\r\nΦΟΡΜΑ 80,60\r\nΑΝΑΛΥΤΗΣ\r\nΚ=1\r\nΑΑ=10\r\nΔΙΑΒΑΣΕ ? Κ, ΑΑ\r\nΑΝ Κ=1 ΤΟΤΕ  {\r\n      ΘΕΣΕ ΑΡΓΑ\r\n      ΤΥΠΩΣΕ \"ΑΡΓΑ\"\r\n } ΑΛΛΙΩΣ.ΑΝ Κ= 2 ΤΟΤΕ {\r\n      ΘΕΣΕ ΓΡΗΓΟΡΑ\r\n      ΤΥΠΩΣΕ \"ΓΡΗΓΟΡΑ\"\r\n} ΑΛΛΙΩΣ  { \r\n      ΘΕΣΕ ΓΡΗΓΟΡΑ !\r\n      ΤΥΠΩΣΕ \"ΜΕΓΙΣΤΟ\" \r\n}\r\n\r\nΑΝΑΝΕΩΣΗ ΑΑ   ' ΟΡΙΖΟΥΜΕ ΧΡΟΝΙΚΟ ΔΙΑΣΤΗΜΑ ΚΑΙ ΓΙΝΕΤΑΙ ΚΑΙ ΣΥΓΧΡΟΝΙΣΜΟΣ\r\n' ΜΙΚΡΟ ΔΙΑΣΤΗΜΑ ΠΙΟ ΓΡΗΓΟΡΗ ΑΝΑΝΕΩΣΗ ΠΙΟ ΑΡΓΟ ΤΟ ΑΠΟΤΕΛΕΣΜΑ.\r\nΓΙΑ Ι=1 ΕΩΣ 3000 {\r\nΤΥΠΩΣΕ \"*\";\r\n}\r\nΤΥΠΩΣΕ ΦΟΡΤΟΣ\r\nΑΝΑΝΕΩΣΗ\r\nΑΝΑΜΟΝΗ 1000\r\n\r\nτρέξτε το με το ΑΡΓΑ και με το ΓΡΗΓΟΡΑ και το ΓΡΗΓΟΡΑ ! \r\nΣτην γραμμή εντολών δίνονται άμεσα οι εντολές Αργά, Γρήγορα και Γρήγορα !\r\nΔες την Θέσε \r\n\r\n
EN:FLOOR(\r\n\r\nΕίναι ίδια με την Ακ()\r\nδίνει την ακέραια τιμή, την ίδια αν είναι ακέραιος ή την κοντινότερη μικρότερη\r\nΔες Στρογγ(), Οροφ()\r\n\r\n
EN:MOUSE.ICON\r\nΔΕΙΚΤΗ.ΜΟΡΦΗ 2\r\nΔΕΙΚΤΗ.ΜΟΡΦΗ ΚΑΤ$+\"ταδε.ico\"\r\nΔΕΙΚΤΗ.ΜΟΡΦΗ ΔΕΙΞΕ\r\nΔΕΙΚΤΗ.ΜΟΡΦΗ ΚΡΥΨΕ\r\n\r\n
EN:MOUSE\r\nΤΥΠΩΣΕ ΔΕΙΚΤΗΣ, ΔΕΙΚΤΗΣ.Χ, ΔΕΙΚΤΗΣ.Υ\r\nΗ ΔΕΙΚΤΗΣ μας δίνει 1 αν πατάμε το αριστερό πλήκτρο του ποντικιού και 2 το δεξί,  επίσης 3 αν πατηθούν και τα δυο μαζί ταυτόχρονα!\r\nΥπάρχει και το Πατημένο(1) και Πατημένο(2) που διαβάζουν άμεσα αν τα πλήκτρα είναι πατημένα και δίνουν -1\r\n\r\nΑπό την έκτη έκδοση προστέθηκαν ακόμα δυο τιμές για τα Χ και Υ του δείκτη (ποντικιού). Αυτές λέγονται απόλυτες τιμές. Είναι οι τιμές σε σχέση με το περιθώριο. Όταν διαβάζουμε την Δεικτης.Χ σε ένα επίπεδο έστω το 2 τότε αυτό που παίρνουμε είναι η τιμή Χ του δείκτη σε σχέση με την αριστερή του πλευρά (σε TWIPS , μονάδα μέτρησης διάστασης οθόνης). Αν διαβάσουμε την ΔεικτηςΑ.Χ τότε θα διαβάσουμε την τιμή Χ του Δείκτη σε σχέση με την αριστερή πλευρά του περιθωρίου.\r\n\r\nΠερί twips. Στα windows τα pixels διαφέρουν από τα twips κατά μια αναλογία. Δηλαδή συγκεκριμένα pixels, εικονοστοιχεία, αντιστοιχούν σε συγκεκριμένα twips. Ουσιαστικά αυτό που έκαναν οι προγραμματιστές των windows ήταν να δώσουν μια νέα κλίμακα που να έχει σχέση με την φυσική μονάδα, τις ίντσες. Έτσι αν για παράδειγμα έχουμε μια οθόνη με 96 σημεία στην ίντσα, σημαίνει ότι έχουμε οθονη 96 dpi, ή κάθε εικονοστοιχείο θα αντιστοιχεί σε 1/96 της ίντσας. Επειδή πάλι δεν μπορούσαν να φορτώσουν το σύστημα με αριθμούς με δεκαδικά (κινητής υποδιαστολής) σκέφθηκαν να βάλουν ένα μεγάλο ακέραιο που να αντιστοιχεί σε μια ίντσα ώστε κάθε εικονοστοιχείο να αντιστοιχεί σε ένα ακέραιο αριθμό. Ο μαγικός αριθμός εδώ είναι το 1440. Καθε εικονοστοιχείο των windows στα 96dpi είναι 15 twips. Έτσι 1440 twips είναι μια ίντσα. Μια υποθετική ίντσα, γιατί σε ορισμένα μονιτορ μπορούμε να επιλέξουμε διάφορες αναλύσεις....και τα Windows δεν θα αλλάξουν τα dpi, ενώ ας πούμε το πλάτος της οθόνης θα παραμένει το ίδιο σε διαφορετικές αναλύσεις. Ωστόσο σε όλα τα συστήματα υπάρχει τρόπος να ρυθμίσουμε τα dpi εμφανίζοντας έναν χάρακα στην οθόνη και ταιριάζοντάς τον με έναν εξωτερικό χάρακα να έχουμε για 1440 twips ακριβώς μια ιντσα. Όμως αυτό δεν το κάνει κανείς γιατί τα περισσότερα προγράμματα θα έχουν πρόβλημα σε διαφορετικά  dpi (επειδή δεν σχεδιάστηκαν για τέτοιες αλλαγές). \r\nΜπορούμε να έχουμε σε έναν εκτυπωτή μια ίντσα επί μια ίντσα ή 1440  twips επί 1440 twips (και να βγαίνει επακριβώς αυτό το μέγεθος, γιατί για τους εκτυπωτές αυτό συμβαίνει), αλλά να έχουμε διαφορετικά dpi στα οριζόντια σημεία από τα κάθετα. Δηλαδή κάθε σημείο να μην είναι τετράγωνο αλλά παραλληλόγραμμο! Αν έπρεπε να υπολογίζουμε σε εικονοστοιχεία τότε θα έπρεπε να υπολογίζουμε, να κρατάμε λογαριασμό, την αναλογία ύψους προς πλάτος του σημείου εκτύπωσης, δηλαδή να πολλαπλασιάζουμε, μια χρονοβόρα διαδικασία. Αντί γι΄αυτό λοιπόν τα twips λειτουργούν με ακέραιους (άρα γρήγορα) και αφήνουν τους οδηγούς εκτύπωσης (ή το περιβάλλον όπως εδώ της Μ2000) να κάνουν τους τελικούς μετασχηματισμούς.\r\n\r\nΤα παραλληλόγραμμα εικονοστοιχεία δεν είναι νεοτερισμός αλλά μια πάγια τακτική στην τηλεόραση.  Δείτε το ΠΑΡΑΔΕΙΓΜΑ1\r\n\r\n
EN:POINTER(\r\nΔείκτες για ομάδες (αντικείμενα της Μ2000)\r\nδ=δείκτης(όνομα_ομάδας)   ' δείκτης σε επώνυμη ομάδα (η ομάδα ζει όσο το τμήμα ή η συνάρτηση που τη δημιούργησε)\r\nδ=δείκτης((όνομα_ομάδας))  ' αντίγραφο της ομάδας ως ανώνυμη ομάδα\r\nδ=δείκτης(πίνακαςΑ(1,2)) ' δείκτης σε ομάδα σε πίνακα (ανώνυμη ομάδα)\r\n\r\n\\\\ οι επώνυμε ομάδες έχουν ένα όνομα μεταβλητής και υπάρχουν μέσα στο μέρος που δημιουργήθηκαν, στο τμήμα ή τη συνάρτηση για όσο ο \"δημιουργός\" είναι ακόμη σε εκτέλεση. Αν πάρουμε δείκτη από επώνυμη ομάδα, και τον επιστρέψουμε από το τμήμα που τερμάτισε και διέγραψε την ομάδα, θα βγει λάθος αν προσπαθήσουμε να το χρησιμοποιήσουμε.\r\n\\\\ οι ανώνυμες ομάδες ζουν ή με δείκτες ή σε αποθηκευτικά μέσα όπως σωροί, καταστάσεις και πίνακες. Οι ομάδες αυτές είναι μεταφερόμενος, ή μέσω δείκτη ή μέσω των αντικείμένων (αποθηκευτικών μέσω). Τα μέσα αυτά έχουν πάντα δείκτη. Δηλαδή το όνομα μεταβλητής τους είναι δείκτης.\r\nΟι δείκτες ξεχωρίζουν από τις αναφορές επειδή μπορούν να αλλάξουν αυτό που δείχνουν. Αν περάσουμε ένα δείκτη με αναφορά τότε μπορούμε να τον αλλάξουμε και θα αλλάξει και πιο πίσω (από εκεί που τον περάσαμε), ενώ αν τον περάσουμε με τιμή, θα έχουμε έναν δεύτερο δείκτη με ίδια λειτουργία, αλλά αν αλλάξουμε αντικείμενο δεν θα αλλαχθεί πιο πίσω.\r\n\r\n\r\n\\\\ Παράδειγμα\r\nΚλάση Άλφα {\r\n      χ=10\r\n}\r\n\\\\ το δ είναι δείκτης σε ομάδα (αντικείμενο)\r\n\\\\ τώρα δείχνει ένα ανώνυμο αντικείμενο.\r\n\\\\ Τα ανώνυμα αντικείμενα \"πεθαίνουν\" όταν ο τελευταίος δείκτης χαθεί\r\n\\\\ now point to a unnamed group. The unnamed group lives untii no pointers point to it.\r\nδ=Δείκτης(Άλφα()) \r\n\\\\ Αυτό είναι το ίδιο με αυτό  δ->Άλφα()\r\nΤύπωσε δ=>χ\r\n\r\nζ=Άλφα()\r\n\\\\ now point to a named group (we can't use the pointer if ζ erased, επειδή has a reference only)\r\n\\\\ τώρα ο δείκτης δείχνει σε ένα επώνυμο αντικείμενο τύπου ομάδα. Το άλλο που έδειχνε έσβησε\r\n\\\\ Τα επώνυμα αντικείμενα \"πεθαίνουν\" όταν τερματίσει το τμήμα ή η συνάρτηση που τα δημιούργησε.\r\n\\\\ ο δείκτης θα έχει ισχύ όσο το επώνυμο αντικείμενο υπάρχει, ή εφόσον του δώσουμε άλλο αντικείμενο\r\nδ=Δείκτης(ζ)\r\n\\\\ Αυτό είναι το ίδιο με αυτό  δ->ζ\r\nΤύπωσε δ=>χ\r\nδ=>χ+=10\r\nΤύπωσε ζ.χ=δ=>χ   ' επειδή ζ.χ  είναι το ίδιο με το δ=>χ\r\nδ=Δείκτης((ζ))   ' look the ( ), we get a copy of ζ as unnamed group.\r\n\\\\ Αυτό είναι το ίδιο με αυτό   δ->(ζ)\r\nΤύπωσε δ=>χ\r\nδ=>χ+=10\r\nΤύπωσε ζ.χ<>δ=>χ   ' επειδή ζ.χ δεν είναι το ίδιο με το δ=>χ\r\nΛίστα  ' Δείχνει όλες τις μεταβλητές (εκτός από τις ιδιωτικές των ομάδων, και απ΄ ότι περιέχουν οι δείκτες)\r\n\r\n\r\n\r\n\r\n\r\n
EN:MOUSE.KEY\r\nΔίνει τον αριθμό του πλήκτρου του ποντικιού όταν πατηθεί, αλλά δεν θα το δώσει και άλλη φορά ενώ συνεχίζουμε να το κρατάμε πατημένο\r\n\r\nΔες την Δείκτης και Πατημένο()\r\n\r\n
EN:MOUSE.Y\r\nΜας δίνει την θέση Υ  του δείκτη πάνω στην ΟΘΟΝΗ\r\n\r\n
EN:MOUSE.X\r\nΜας δίνει την θέση Χ του δείκτη πάνω στην ΟΘΟΝΗ\r\n\r\n
EN:MOUSEA.Y\r\nΔίνει την απόλυτη τιμή Υ του δείκτη (ποντικιού) σε Twips, με αρχή την πάνω πλευρά του περιθωρίου.\r\nΑν βρισκόμαστε σε μια ομάδα εντολών στο περιθώριο με την ΠΕΡΙΘΩΡΙΟ τότε ο Δεικτηςα.υ ταυτίζεται με τον Δεικτης.υ\r\n\r\n\r\n
EN:MOUSEA.X\r\nΔίνει την απόλυτη τιμή Χ του δείκτη (ποντικιού) σε Twips, με αρχή την αριστερή πλευρά του περιθωρίου.\r\nΑν βρισκόμαστε σε μια ομάδα εντολών στο περιθώριο με την ΠΕΡΙΘΩΡΙΟ τότε ο Δεικτηςα.χ ταυτίζεται με τον Δεικτης.χ\r\n\r\n
EN:VIEW\r\nΔΕΙΞΕ ονομα_βασης$, ονομα_πινακα$, απο_εγγραφη, εως_εγγραφη\r\nΔΕΙΞΕ ονομα_βασης$,\"select distinct ονομα from ενα\",1,5\r\nΔΕΙΞΕ ονομα_βασης$,\"ενα\",1,5\r\nΕμφανίζει μια λίστα με στοιχεία από πίνακα ή ερώτημα SQL. ΤΑ απο_εγγραφη και εως_εγγραφη, είναι αριθμοί που δηλώνουν τις εγγραφές από τον πίνακα ή το ερώτημα που θέτουμε.\r\nΔες εντολή ΕΠΙΛΟΓΗ\r\nΠΡΟΣΟΧΗ στην LIKE σε ερωτήματα SQL δεν χρησιμοποιείται το * αλλά το % (λειτουργούσε παλιά λόγω του DAO, αλλά λόγω της χρήσης του αντικειμένου ADO θέλει αυτή την αλλαγή, διαφορετκά το * θα το βλέπει ως χαρακτήρα, οπότε δεν θα γυρνάει κάτι)\r\n\r\n\r\n
EN:FRAC(\r\nΤύπωσε Δεκ(1.234)\r\n      .234\r\nεπιστρέφει μόνο τα δεκαδικά, και πάντα θετική τιμή ή μηδέν\r\n
EN:HEX\r\nΔΕΚΑΕΞ 10, 0Χ10+0ΧAF00\r\nδουλεύει όπως η ΤΥΠΩΣΕ αλλά για εμφανίζει δεκαεξαδικά νούμερα (0 ή θετικό αριθμό). Δίνει -??? ή +??? αν είναι εκτός ορίων\r\n
EN:HEX$(\r\na=0xFF12FFFF\r\nΤΥΠΩΣΕ  ΔΕΚΑΕΞ$(a),a\r\nΝέα από την έκδοση 6.4 και μετά: Δεύτερη παράμετρος 1 έως 4 δηλώνει τα bytes που θα δείξει. Με ένα τους δυο αριστερούς χαρακτήρες.\r\n\r\n\r\nΤυπώνει το δεκαεξαδικό νούμερο \r\nFF12FFFF          4279435263\r\n\r\nΣτην έκτη έκδοση μπορούμε να δίνουμε δεκαξεδικά νούμερα με πρόθεμα 0x\r\nΗ γλώσσα μπορεί να χειριστεί αριθμούς χωρίς πρόσημο 32bit\r\nΤο 0xFFFFFFFF& είναι το -1 (32 bit long)\r\nTo 0xFFFF% είναι το  -1 (16bit integer)\r\nΔες το ΑΚΕΡΑΙΟ.ΔΥΑΔΙΚΟ().\r\n\r\n
EN:NOT_2\r\nΣυνάρτηση αναστροφής\r\nΕίναι η ΟΧΙ με αλλο ανανγωριστικό\r\n\r\nΤΥΠΩΣΕ ΟΧΙ ΑΛΗΘΕΣ\r\n\r\nΤΥΠΩΣΕ ΟΧΙ ( ΟΧΙ 2)\r\nδίνει 2\r\n\r\nΕίναι ψευδοσυνάρτηση: Βάζει στη θέση της το -1-1*....\r\nοπότε αν ακολουθεί το 0 τότε -1-1*0 δίνει -1\r\nαν ακολουθεί το -1 δίνει -1-1*(-1) δίνει 0\r\nΑν ακολουθεί αρνητικό νούμερο θα δώσει θετικό μειον ένα, αν ακολουθεί θετικο νούμερο θα δώσει αρνητικό μειον ένα...\r\nστο -5 θα δώσει 4\r\nστο 4 θα δώσει -5\r\nΆρα για οποιοδήποτε Χ υπάρχει μια F(X)  που δίνει ένα Κ όπου Χ<>Κ (το Χ είναι διάφορο του Κ) και ισχύει και το αντίστροφο ότι F(K)=X. Από αυτόν τον ορισμό είναι φανερό ότι ακόμα και για το μηδέν υπάρχει ένα μοναδικό νούμερο που δίνει το μηδέν στην ίδια συνάρτηση. Επίσης θα μπορούσε κανείς να χρησιμοποιήσει διαφορετικό τύπο και πάλι θα είχε μια συνάρτηση αναστροφής...π.χ. -2-1*(Χ)=Κ αν βάλω το -2 θα πάρω το 0 και αν βάλω το 0 θα πάρω το -2\r\n\r\nΕπειδή είναι ψευδοσυνάρτηση και γίνεται αφαίρεση δεν έχει την σειρά που έχουν οι εντολές ΚΑΙ και Η και ΑΠΟ\r\nοπότε\r\nη ΤΥΠΩΣΕ ΑΛΗΘΕΣ ΚΑΙ ΟΧΙ ΨΕΥΔΕΣ Η ΑΛΗΘΕΣ\r\nη ΤΥΠΩΣΕ -1 ΚΑΙ -1-1*(-1)  Η -1\r\nδίνει -1 (ΑΛΗΘΕΣ)\r\nΠρώτα θα γυρίσει το ...Η ΑΛΗΘΕΣ που θα βρει το ΟΧΙ ΨΕΥΔΕΣ (ως -1- -1), οποτε -1 η -1 δίνει -1 και μετά θα βρει το -1\r\nΠροσοχή πάντα από δεξιά αναλύει η γλώσσα τις εκφράσεις, αλλά τα ενδιάμεσα αποτελέσματα τα προωθεί από αριστερά προς τα δεξιά (με αναδρομική διαδικασία).\r\nη ΤΥΠΩΣΕ ΑΛΗΘΕΣ ΚΑΙ ΟΧΙ (ΨΕΥΔΕΣ Η ΑΛΗΘΕΣ)\r\nη ΤΥΠΩΣΕ -1 ΚΑΙ -1-1*( 0 Η -1)\r\nδινει 0 (ΨΕΥΔΕΣ)\r\n\r\n
EN:RIGHT$(\r\nΔέχεται δυο ορίσματα. Μας δίνει ένα νέο αλφαριθμητικό από ένα που δίνουμε με μήκος το πολύ όσο μια τιμή που επίσης δίνουμε, λαμβάνοντας χαρακτήρες από την δεξιά πλευρά του αλφαριθμητικού.\r\nΑ$=\"ΤΙΤΛΟΣ\"\r\nΑ$= ΚΕΦ$(ΑΡΙΣ$(Α$,1)) + ΜΕΣ$(ΠΕΖ$(Α$),2)\r\nΑΝ (ΔΕΞΙ$(Α$,1)=\"σ\" ΚΑΙ ΜΗΚΟΣ(Α$)>1) ΤΟΤΕ Α$=ΑΡΙΣ$(Α$,ΜΗΚΟΣ(Α$)-1)+\"ς\"\r\nΤΥΠΩΣΕ Α$\r\nΜας τυπώνει\r\nΤιτλος\r\n\r\nΤοπικο 1032\r\nΑ$=Γραφη$(\"Γιώργος\")  ' μετατροπή σε ANSI κατά  τοπικό1032 (ελληνικά)\r\nΤύπωσε Χαρ$(Δεξι$(Α$,3 ως Ψηφίο))=\"γος\"  ' το Χαρ$() μετατροπή σε UTF-16LE κατά 1032\r\n\r\n\r\n
EN:RIGHTPART$(\r\nΤύπωσε ΔεξίΜέρος$(\"123456789\",\"5\")  ' μετά το 5\r\nΤύπωσε ΑριστερόΜέρος$(\"123456789\",\"5\") ' πριν το 5\r\n
EN:TRY\r\n[ΕΝΤΟΛΕΣ ΡΟΗΣ ΤΜΗΜΑΤΩΝ]  ' έλεγχος λαθών\r\n' την μεταβλητή Β θα την δημιουργήσει η ΔΕΣ αν δεν την έχουμε ήδη δημιουργήσει\r\nΔΕΣ Β {\r\n      ΤΥΠΩΣΕ Β    ' 0\r\n}\r\nΤΥΠΩΣΕ Β     ' -1 δεν υπαρχει λάθος\r\nΔΕΣ Β {\r\n      ΛΑΘΟΣ \"Αυτό είναι ένα λάθος\"   ' δημιουργώ λάθος\r\n}\r\nΤΥΠΩΣΕ ΛΑΘΟΣ$, Β    ' το Β είναι 0 \r\nΤΥΠΩΣΕ \"Δεν σταμάτησε η ροή\"  ' δεν σταματάει η ροή εντολών.\r\n\r\nΔΕΣ Ι {\r\n' ΕΝΤΟΛΕΣ\r\n}\r\nΔες {\r\n      '  και χωρίς μεταβλητή\r\n}\r\n\r\nΑΝ ΟΙ ΕΝΤΟΛΕΣ ΒΓΑΛΟΥΝ ΛΑΘΟΣ ΤΟΤΕ Η ΜΕΤΑΒΛΗΤΗ Ι ΓΙΝΕΤΑΙ 0 ΑΛΛΙΩΣ -1\r\n\r\nΑν το λάθος βρίσκεται σε τμήμα που καλούμε μέσα από το μπλοκ της ΔΕΣ, τότε δεν επιστρέφει στη μεταβλητή που ορίζουμε το Ψευδές ( το 0) και πρέπει να κοιτάμε την ΛΑΘΟΣ ή την ΛΑΘΟΣ$.\r\nΑν κοιτάξουμε μια φορά την ΛΑΘΟΣ$ τότε αδειάζεται το λάθος, καθαρίζει δηλαδή εσωτερικά η μεταβλητή ΛΑΘΟΣ$.\r\nΥπάρχει και η Άδειασε Λάθος που μπορούμε να χρησιμοποιήσουμε χωρίς καν να κοιτάξουμε την ΛΑΘΟΣ$\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
EN:DIV\r\n\\\\ ακέραια διαίρεση\r\nΤύπωσε 10 δια 2\r\n5\r\n\r\n
EN:DIV#\r\n\\\\ Ευκλείδεια διαίρεση\r\nα=-20\r\nβ=6\r\n\\\\ Ευκλείδεια διαίρεση και υπόλοιπο\r\nγ=α Διά# β\r\nδ=α Υπόλ# β\r\nΤύπωσε γ, δ  ' -4   4\r\nΤύπωσε α=β*γ+δ\r\n\\\\ Κανονική διαίρεση και υπόλοιπο\r\nγ=α Διά β\r\nδ=α Υπόλ β\r\nΤύπωσε γ, δ ' -3  -2\r\nΤύπωσε α=β*γ+δ\r\n\r\n
EN:READ\r\nΔΙΑΒΑΣΕ Α$,Β$,Κ$\r\nΔιαβάζει τις τιμές  και τις καταχωρεί σε κάθε μεταβλητή  και αν η μεταβλητή δεν υπάρχει την δημιουργεί (εκτός από πίνακες που πρέπει να δημιουργηθούν με την ΠΙΝΑΚΑΣ)\r\n\r\nΔΙΑΒΑΣΕ Ι(1),Ι(2),Ι(3)\r\n\r\nΔεν διαβάζει μονομιάς έναν πίνακα αλλά ένα στοιχείο\r\nΠΙΝΑΚΑΣ Α(Ι)\r\nΒΑΛΕ 1,2,3,4,5,6,7,8,9,10\r\nΓΙΑ Ι=0 ΕΩΣ 9 { ΔΙΑΒΑΣΕ Α(Ι) }\r\n\r\nΗ ΔΙΑΒΑΣΕ έχει και μια άλλη χρήση:\r\nΚαλούμε ένα τμήμα με το παρακάτω:\r\nΑΛΦΑ 12, \"ααααα\", Γ$\r\n\r\nΣτον ορισμό του ΑΛΦΑ\r\n\r\nΤΜΗΜΑ ΑΛΦΑ {\r\nΔΙΑΒΑΣΕ Κ, Α$, Β$\r\n......\r\n}\r\n\r\nΑν υπάρχουν και άλλα στοιχεία στο σωρό το τμήμα ΑΛΦΑ τα βλέπει, δες το ΝΗΜΑ όμως όπου το ΝΗΜΑ βλέπει τις μεταβλητές του τμήματος που το δημιούργησε αλλά όχι το σωρό του, γιατί έχει δικό του σωρό.\r\nΕπίσης και οι συναρτήσεις που φτιάχνουμε έχουν το δικό τους σωρό.\r\nΤΜΗΜΑ ΑΛΦΑ {\r\n      ΔΙΑΒΑΣΕ Χ, Υ\r\n}\r\nΒΑΛΕ 1,2 \r\nΑΛΦΑ  'είναι τμήμα\r\n' θα διαβάσει το 2 θα το βάλει στο Χ (αν δεν υπάρχει το δημιουργεί), θα διαβάσει το 1 θα το βάλει στο Υ (ομοίως δημιουργεί αν δεν το βρίσκει)\r\nΣΕΙΡΑ 1,2\r\n' αν δεν υπάρχει από πριν τίποτα στο σωρό τότε το 1 θα γίνει κορυφή και το 2 θα ακολουθεί\r\nΑΛΦΑ\r\n' θα διαβάσει το 1 και μετά το 2\r\nΑΛΦΑ 1,2 \r\n' έτσι δεν μας νοιάζει τι έχει ο σωρός, όταν κληθεί θα υπάρχει μια ΣΕΙΡΑ στην κορυφή.\r\n\r\nΕπειδή μπορούμε να περνάμε μεταβλητές  με αναφορά, μπορούμε να περάσουμε ολόκληρο πίνακα και μάλιστα να του αλλάξουμε την διάσταση και να τον επιστρέψουμε αλλαγμένο\r\nΠΙΝΑΚΑΣ α(1)\r\nΤΜΗΜΑ ΑΛΦΑ {\r\n      ΔΙΑΒΑΣΕ &Κ()\r\n      ΠΙΝΑΚΑΣ Κ(10,10)\r\n      Κ(4,4)=2\r\n}\r\nΑΛΦΑ &α()\r\nΤΥΠΩΣΕ Α(4,4)\r\n\r\n\r\n\r\n\r\n
EN:REMOVE\r\nΔΙΑΓΡΑΦΗ\r\nΔιαγράφει το τελευταίο τμήμα που δημιουργήθηκε. Την επόμενη φορά θα διαγράψει από τα εναπομείναντα το τελευταίο που δημιουργήθηκε.\r\nΔιαγραφή φορτωμένης βιβλιοθήκης (όλο το όνομα όπως δώσαμε στην Όρισε μέχρι την τελεία, χωρίς αυτήν)\r\nΔιαγραφή \"user32\" \r\n\r\n
EN:INTERNET\r\nΤύπωσε Διαδικτυο\r\nΤυπώνει Αληθής αν ο υπολογιστής έχει σύνδεση με το διαδίκτυο\r\n\r\n
EN:INTERNET$\r\nΤύπωσε Διαδίκτυο$\r\n127.0.0.1\r\nή την δημόσια ip αν έχουμε σύνδεση\r\n
EN:STOP\r\nΑνοίγει ένα παράθυρο διαλόγου και ρωτάει αν θέλουμε προσωρινά να διακόψουμε το πρόγραμμα (δεν διακόπτει τα νήματα). Αν απαντήσουμε θετικά τότε βγαίνει στην κονσόλα και δείχνει το όνομα του χρήστη και ζητάει εντολές. Οι εντολές είναι σαν να τις δίνουμε στη γραμμή που είναι το πρόγραμμα. Με έξοδος γυρνάμε στην εκτέλεση του προγράμματος. Μπορούμε να δούμε με την Λίστα την λίστα μεταβλητών, και με το Τμήματα ? τα υπάρχοντα τμήματα. μπορούμε να ανοίξουμε τη βοήθεια ή τον έλεγχο (Δοκιμή). Στον έλεγχο υπάρχει παρόμοιος τρόπος να δώσουμε εντολές, όταν εμφανίζεται το σύμβολο > στην εισαγωγή κειμένου στο κάτω μέρος της φόρμας. Χρησιμοποιούμε το Delete για να αλλάξουμε το σύμβολο εισαγωγής σε > από ?\r\n\r\nΑπλά γράφουμε τη λέξη Διακοπή όπου θέλουμε να σταματήσει.\r\nΔΙΑΚΟΠΗ\r\nεμφανίζει \r\nονομα_χρήστη> Έξοδος   (για να επιστρέψουμε στην εκτέλεση)\r\n\r\nΗ διαφορά με το ΑΛΤ είναι ότι το τελευταίο βγάζει στον μεταφραστή γραμμής της κονσόλας, οπότε δεν μπορούμε να δώσουμε εντολές εκεί που τρέχει το πρόγραμμα. Μπορούμε όμως να πειράξουμε γενικές μεταβλητές, ή να φορτώσουμε κάποιο πρόγραμμα και να το τρέξουμε\r\n\r\n
EN:SWITCHES\r\nΣτη κονσόλα:\r\nοι αλλαγές γράφονται στη registry των Windows. Με Break, ή εντολή Αρχή ή αν ξεκινήσουμε άλλο περιβάλλον,  θα διαβαστούν πάλι, οι τιμές των διακοπτών, με τις αλλαγές που κάναμε.\r\nΔιακόπτες \"+DEC -DIV -PRI\"\r\nΣε τμήμα:\r\nοι αλλαγές συμβαίνουν μόνο για το φορτωμένο περιβάλλον. Με Break, ή εντολή Αρχή ή αν ξεκινήσουμε άλλο περιβάλλον,  θα διαβαστούν πάλι οι παλιές σωσμένες τιμές των διακοπτών.\r\nΘέσε Διακόπτες \"+DEC -DIV -PRI\"\r\n\r\nΣτην γραμμή εντολών των Windows, όταν καλούμε την Μ2000 (και σε συντομευση, στη θέση για παραμέτρους)\r\nοι αλλαγές θα είναι τοπικές.\r\n\r\nΔιακόπτες:\r\nTXT\r\n      με + οι συγκρίσεις αλφαριθμητικών γίνονται βάσει κειμένου   (> < >= >= <> =)\r\n      με -   οι συγκρίσεις αλφαριθμητικών γίνονται δυαδικά   **εξ ορισμού είναι αυτό**  (> < >= >= <> =)\r\nDEC\r\n      με - εμφανίζει την τελεία ως χαρακτήρα υποδιαστολής\r\n      με +  εμφανίζει το τοπικό χαρακτήρα υποδιαστολής (στα ελληνικά είναι το κόμμα εκτός και αν έχει αλλαχθεί)   ***εξ ορισμού είναι αυτό***\r\n      στο κώδικα είναι πάντα η τελεία.\r\n      Αν δοθεί εντολή Τοπικό 1032 θα αλλάξει προσωρινά η υποδιαστολή σε \",\" μέχρι την επόμενη Διακόπτες ή επόμενη Τοπικό, ή αν πατήσουμε το πλήκτρο Break, ή με εντολή Αρχή στη κονσόλα, ή Θέσε Αρχή στο κώδικα.\r\nDIV\r\n      αλλάζει τα mod και div ή υπόλοιπο, υπόλ και δια\r\n      με + δουλεύει όπως στην Python και έχουν το ίδιο επίπεδο με το * και το /  (στο δεξιό μέρος)\r\n      δηλαδή το 10 υπόλοιπο 2.3 *2 θα είναι αυτό: (10 υπόλοιπο 2.3) *2\r\n      με - με ακέραιους δουλεύει όπως στην VB6, ενώ με πραγματικούς (δεν υποστηρίζει η Vb6) δίνει ακέραιο στο δια και πραγματικό στο υπόλοιπο.  ***εξ ορισμού είναι αυτό***\r\n      εδώ δεν έχουμε ίδιο επίπεδο με το * και /, δηλαδή το 10 υπόλοιπο 2.3 *2 θα είναι αυτό: 10 υπόλοιπο (2.3 *2)\r\nPRI  \r\n      αλλάζει την προτεραιότητα εκτέλεσης των ΚΑΙ και H\r\n      πχ στο Τύπωσε Αληθής Η Ψευδής ΚΑΙ Ψευδής\r\n      με -  όλα εκτελούνται με τη σειρά\r\n            άρα αληθής ή ψευδής δίνει αληθής και ψευδής δίνει ψευδής   ***εξ ορισμού είναι αυτό***\r\n      με + το ΚΑΙ (λογικός πολλαπλασιασμός) εκτελείται πριν το Η (λογική πρόσθεση)\r\n            άρα το ψευδής ΚΑΙ ψευδής θα δώσει Ψευδής και θα εκτελεστεί το Αληθής Η Ψευδής άρα θα δόσει το Αληθής.\r\nREC\r\n      'οριο αναδρομής για συναρτήσεις μόνο (δες και το Όριο.Αναδρομής)\r\n      με - θέτει το όριο στο 300  (το χρησιμιοποιούμε αν θέλουμε να τρέξουμε την Μ2000 μέσα από άλλη εφαρμογή)\r\n      με + θέτει το όριο στο 3260   *** εξ ορισμού είναι αυτό***\r\n      η αλλαγή απλά αλλάζει τον κόφτη εσωτερικά, πέρα από τον οποίο δίνει σφάλμα. Η αλλαγή θα φανεί με την Monitor μετά από Break (με Αρχη ή με πάτημα του Break), και θα είναι μόνιμη, μέχρι την επόμενη αλλαγή.\r\nFOR\r\n      ' δεν αποθηκεύεται μόνιμα. με Break επανέρχεται στο -FOR\r\n      με - λειτουργία νορμάλ (όλα τα For (Για) εκτελούνται τουλάχιστον μια φορά)\r\n      με + γίνεται έλεγχος ώστε αν το βήμα δεν θα φτάσει ποτέ την τελική τιμή να μη εκτελεστεί το For (Για)\r\nDIM\r\n      ' δεν αποθηκεύεται μόνιμα. με Break επανέρχεται στο -DIM\r\n      με - λειτουργία νορμάλ, όλοι οι πίνακες δημιουργούνται με τόσα στοιχεία όσα ορίζουμε.\r\n      με +  και εφόσον η βάση πινάκων είναι 0, κάθε διάσταση του πίνακα που δεν είναι μηδενική παίρνει συν ένα στοιχείο\r\n\r\nSEC \r\n       ' Αποθηκεύεται μόνιμα    (secure names), οι κλήσεις τμημάτων γίνεται με εσωτερικά διαφορετικά ονόματα \r\n       με - λειτουργεία όπως στην έκδοση 8. ( για μικρά ονόματα μεταβλητών είναι πιο γρήγορο, αλλά έχει λάθη, αν και όχι σημαντικά)\r\n       με + λειτουργία με μέγιστη ασφάλεια (δεν έχει λάθη, ανώτερη λογική) - είναι η κανονική λειτουργία\r\n\r\n       η διαφορά φαίνεται στο πρόγραμμα στην αγγλική έκδοση εδώ: SWITCHES\r\nβλέπουμε τις ρυθμίσεις με την εντολή MONITOR από την κονσόλα ή Θέσε Monitor από τμήμα.\r\n\r\nRDB\r\n      ' δεν αποθηκεύεται μόνιμα. με BREAK δεν αλλάζει η τυχόν αλλαγή\r\n      με - σταματάει την περικοπή στο 13 δεκαδικό στους διπλούς (double)  όπως υπήρχε πριν την 9.6 έκδοση\r\n      με + ξεκιναέι  τη περικοπή στο 13 δεκαδικό στους διπλούς (double)  όπως υπήρχε πριν την 9.6 έκδοση\r\n      Εξ ορισιμού είναι στο -RDB\r\nTAB\r\n      με +ΤΑΒ ο διορθωτής χρησιμοποιεί το tab για να βάζει το χαρακτήρα 9\r\n      με -ΤΑΒ  ο διορθωτής χρησιμοποιεί το tab για να βάζει διαστήματα\r\n      το μήκος το ορίζουμε με την εντολή Σ ! 6 για 6 χαρακτήρες ή 3 \"m\" πλάτος για τον χαρακτήρα 9\r\n      ο χαρακτήρας 9 όταν μπαίνει μέσα στο κείμενο δίνει μεταβλητό μήκος ανάλογα με τη θέση στη γραμμή που ξεκίνησε\r\n\r\nSBL\r\n      +SBL δίνει Αληθής/Ψευδής ως τιμή στην Τύπωσε για αριθμούς τύπου λογικός\r\n       -SBL δίνει -1/0 για τιμή στη για αριθμούς τύπου λογικός λογικός\r\n       Οι τιμές στις σταθερές Αληθής/Αληθές/Ψευδής/Ψευδές είναι τύπου διπλός με τιμές -1/-1/0/0\r\n       Οι συγκρίσεις δίνουν πάντα τύπο λογικό.\r\n       Για να πάρουμε λογικό από μεταβλητή αριθμητική που δεν είναι λογικός θέλουμε μια σύγκριση\r\n       Α=Αληθής : Τύπωσε Α=Αληθής\r\n       θα μας δώσει Αληθής αν  ο διακόπτης είναι +SBL ή -1 αν είναι -SBL\r\n\r\nINP\r\n        με +INP η μεταβλητή ΠΕΔΙΟ γυρίζει 13 όταν πατήσουμε το enter\r\n        με -INP η μεταβλητή ΠΕΔΙΟ γυρίζει 1 όταν πατήσουμε το enter  (εξ ορισμού)\r\n\r\nMDB\r\n        με +MDB το σύστημα παίρνει τη βοήθεια από το Help2000.mdb\r\n        με -MDB το σύστημα παίρνει τη βοήθεια από το help2000utf8.dat\r\n\r\nΕιδικοί διακόπτες για την κλήση από τη γραμμή εντολών των Windows\r\nTest\r\n        +TEST  και -TEST\r\n        εφαρμόζει την διαδικασία ελέγχου με οποιοδήποτε πρόγραμμα και αν αυτό ξεκινάει άμεσα με τη φόρτωση.\r\nNorun\r\n        -NORUN φορτώνει το πρόγραμμα αλλά δεν το τρέχει (δεν τρέχει εντολές εκτός από αυτές που φορτώνουν τμήματα και συναρτήσεις)\r\n\r\nΔιακόπτες που εφαρμόζουν τις αλλαγές στην επόμενη εκτέλεση του διεμηνευτή ή αν πατήσουμε το Break, ή αν δώσουμε την εντολή Αρχή\r\nLinespace\r\n        +LINESPACE 150  ορίζει διάστιχο 10 εικονοστοιχείων (αν το εικονοστοιχείο είναι 15 twips - στα 96 dpi έχουμε 1440/96=15 όπου 1440 twips είναι η λογική ίντσα - πραγματική στον εκτυπωτή- και dpi είναι στην οθόνη τα εικονοστοιχεία στην ίντσα). Τιμές από 0 έως 600 (για 15 dpi), ακέραιες τιμές.\r\n        -LINESPACE κάνει το διάστιχο 0\r\nSize\r\n        +SIZE 12 κάνει τα γράμματα 12άρια, παίρνει τιμές από 8 έως 48 (μόνο ακέραιες τιμές)\r\n        -SIZE κάνει τα γράμματα 15άρια από οποιαδήπτε τιμή έχουν στις ρυθμίσεις\r\nFont\r\n        -FONT επιλέγει την Monospac821Greek BT γραμματοσειρά (αν υπάρχει)\r\nBold\r\n        +BOLD χρησιμοποιεί από την αρχή τα bold γράμματα της γραμματοσειράς\r\n        -BOLD  χρησιμοποιεί την κανονική γραμματοσειρά\r\nPen\r\n        +PEN 5 βάζει την τιμή 5 από τα βασικά χρώματα 0 έως 15. Αν το Paper είναι 5 τότε βάζει το 16-5\r\n        -PEN  κάνει την Πένα 0 και την Οθόνη 7\r\nPaper\r\n        +PAPER 0 βάζει την τιμή 0 από τα βασικά χρώματα 0 έως 15. Αν το Pen είναι 0 τότε βάζει το 16-0\r\n        -PAPER  κάνει την Πένα 0 και την Οθόνη 7\r\nDark\r\n       +DARK κάνει την εξαγωγή σε Html με επιλογή χρωμάων για σκούρο φόντο\r\n       +DARK κάνει την εξαγωγή σε Html με επιλογή χρωμάων για φωτεινό φόντο\r\nCasesensitive\r\n       +CASESENSITIVE όταν αναζητεί αρχεία κοιτάει αν συμπίπτουν τα πεζά/κεφαλαία\r\n       -CASESENSITIVE το αντίστροφο.\r\n       Αν δοθεί η εντολή αλλάζει άμεσα (όχι στην επόμενη εκκίνηση)\r\nGreek\r\n       +Greek κάνει τα μηνύματα στους διαλόγους του περιβάλλοντος να εμφανίζοται στα ελληνικά\r\n       -Greek κάνει τα μηνύματα στους διαλόγους του περιβάλλοντος να εμφανίζοται στα Αγγλικά\r\n\\\\ Παράδειγμα\r\nΦόρμα 80, 50\r\nΠίνακας Βάση 0, β$(2)\r\nβ$(0)=\"-DEC\",\"+DEC\"\r\nγενική αα=κάθε(β$())\r\nΕνώ αα {\r\n      Για άλλο=ψευδές έως αληθές {\r\n            Τύπωσε \"Διακόπτες \"+Παράθεση$(Πίνακας$(αα))\r\n            Θέσε Διακόπτες Πίνακας$(αα)\r\n            Κάνε μοφ1$()=\"{0:1:\"+γραφή$(-στήλη)+\"}{1:2:\"+γραφή$(-στήλη)+\"}\"\r\n            Αν άλλο Αλλιώς Τοπικό 1032 : Τύπωσε \"Τοπικό \";Τοπικό\r\n            Τύπωσε μορφή$(μοφ1$(), -1.66, 2.45)\r\n            Τύπωσε -1.66, 2.45\r\n            Αν άλλο Αλλιώς Τοπικό 1033 : Τύπωσε \"Τοπικό \";Τοπικό\r\n            Τύπωσε μορφή$(μοφ1$(), -1.66, 2.45)\r\n            Τύπωσε -1.66, 2.45\r\n            Τύπωσε $(3), γραφή$(.66), γραφή$(-.45), $(0),\" ποτέ δεν αλλάζει\"  ' χωρίς 0 και πάντα τελεία.\r\n            Τύπωσε $(3), γραφή$(.66,0), γραφή$(-.45, 0), $(0),\" ποτέ δεν αλλάζει\"   ' $(3) σημαίνει δεξιά στοίχιση\r\n            Τύπωσε $(3), γραφή$(.66,1033), γραφή$(-.45, 1033), $(0),\" ποτέ δεν αλλάζει\"   ' χρησιμοποιεί το τοπικό άμεσα\r\n            Τύπωσε $(3), γραφή$( .66,\"\") , γραφή$(-.45,\"\")\r\n            ' $(0) είναι η εξ ορισμού στολιχιση, sτα αλφαριθμητικά έχουν αριστερή στοίχιση και μπορούν να επεκταθούν σε άλλες στήλες\r\n            ' ενώ οι αριθμοί έχουν δεξιά στοίχιση\r\n            Τύπωσε $(0),.66, -.45\r\n      }\r\n}\r\n\r\n\r\n\\\\ Εδώ ελέγχουμε την εξαγωγή της μεταβλητής ΠΕΔΙΟ\r\n\\\\ αντέγραψε αυτό σε ένα τμήμα\r\n\\\\ αν θέλουμε να ξεχωρίζουμε το enter από το κάτω βελάκι πρέπει να δώσουμε αυτό:\r\nΣΗΜ :  ΘΕΣΕ ΔΙΑΚΟΠΤΕΣ \"+INP\"\r\nΟΘΟΝΗ\r\nΑ$=ΠΕΔΙΟ$(\"ΑΛΦΑ\",10)\r\nΠΕΔΙΟ 10,10 ΩΣ Α$\r\nΤΥΠΩΣΕ ΠΕΔΙΟ\r\nΤΥΠΩΣΕ Α$\r\n\r\n\r\n
EN:GOSUB\r\n1) Διαμέσου ετικέτα ή αριθμός\r\nΑπλή κλήση υπορουτίνας\r\nΚάνουμε κλήση υπορουτίνας με αριθμό ή όνομα. Δεν είναι το ίδιο με τις Ρουτίνες με παρενθέσεις (Δες ΡΟΥΤΙΝΑ)\r\n\r\n2) Διαμέσου Ρουτινα1()                               \\\\ χωρίς πέρασμα παραμέτρων\r\n2.1) Ρουτινα1()\r\nΗ εντολή Διαμέσου δεν είναι απαραίτητη για να κληθεί η ρουτίνα, αρκεί να μην υπάρχει πίνακας με ίδιο όνομα\r\nΚλήση ρουτίνας που υπάρχει στο τέλος του τμήματος\r\n      Ρουτινα Ρουτινα1()\r\n            Τύπωσε \"οκ\"\r\n      Τέλος Ρουτίνας\r\n3) Διαμέσου Ρουτινα1(100, 300, &Α(), Β)   \\\\με πέρασμα παραμέτρων\r\n3.1) Ρουτινα1(100, 300, &Α(), Β)\r\nΗ εντολή Διαμέσου δεν είναι απαραίτητη για να κληθεί η ρουτίνα, αρκεί να μην υπάρχει πίνακας με ίδιο όνομα\r\nΚλήση ρουτίνας που υπάρχει στο τέλος του τμήματος\r\n     Ρουτινα Ρουτινα1(Χ,Υ, &Αλφα(), Β)\r\n           Τύπωσε \"οκ\", Χ, Υ, Αλφα(Β)\r\n     Τέλος Ρουτίνας\r\n\r\nΟι ρουτίνες με παρενθέσεις είναι κάτι παραπάνω από απλές ρουτίνες. Ότι νέο φτιάχνεται σε ρουτίνα με παρένθεση θα πάψει να υπάρχει στο πέρας της εκτέλεσης (όπως στα τμήματα και στις συναρτήσεις) και επιπλέον κάθε ρουτίνα μπορεί να καλεί τον εαυτό της (αναδρομή). Διαφέρει από τα τμήματα και τις συναρτήσεις για δυο λόγους: Ένας είναι ότι ανήκει στο τμήμα ή συνάρτηση και δεν δημιουργείται, άρα δεν μπορεί να αλλάξει ορισμό, και συνάμα έχει πρόσβαση όπως όλος ο κώδικας εντός τμήματος, άρα και στις μεταβλητές του. Δεύτερον δεν μπορεί να κληθεί από άλλο τμήμα παρά μόνο από αυτό που τρέχει - και από αυτό που υπάρχει στον αρχικό κώδικα και είναι εντός του τμήματος (για να μην γράφουμε δυο φορές την ίδια ρουτίνα...είναι ένας τρόπος του μεταφραστή για οικονομία, αλλά δεν έχει συνέπειες στο τι μεταβλητές βλέπει η ρουτίνα).\r\n\r\n\\\\ Χρήση έμμεσης κλήσης σε ρουτίνα\r\nΔιαμέσου αλφα(100,200)  ' κανονικό\r\nb$=\"(100, 200)\"\r\nΔιαμέσου \"αλφα\"+b$\r\nβ$=\"αλφα(100,200)\"\r\nΔιαμέσου β$\r\nΠίνακας β$(10)\r\nβ$(3)=\"αλφα(100,200)\"\r\nΔιαμέσου β$(3)\r\n\r\nΡουτίνα αλφα(χ, ψ)\r\n\tΤύπωσε χ, ψ\r\nΤέλος Ρουτίνας\r\n\r\n\r\n\r\n\\\\ Απλό Διαμέσου\r\n\r\nΔιαμέσου 100 : Διαμέσου 110\r\nΔιαμέσου 100 : Διαμέσου 110\r\nΔιαμέσου όνομα : Διαμέσου Ονομα  \\\\ προσοχή οι τόνοι έχουν σημασία στις ετικέτες.\r\nΈξοδος  \\\\ Μπορούμε να γράψουμε Τέλος\r\n100 Τύπωσε \"ΟΚ\" : Επιστροφή\r\n110 Τύπωσε \"ΛΑΘΟΣ\" : Επιστροφή\r\nΌΝΟΜΑ:   \\\\ μόνο υπενθυμίσεις εδώ\r\n      Τύπωσε \"ΌΝΟΜΑ\" : Επιστροφή\r\nΟνομα:\r\n      Τύπωσε \"Ονομα\" : Επιστροφή\r\n\r\nΣύνθετο Διαμέσου\r\n\\\\ χρησιμοποιούμε πέρασμα με αναφορά για να πάρουμε στην Α$ το αποτέλεσμα από την Ν$\r\nΚΑΘΑΡΟ Α$\r\nΔιαμέσου ΕΝΑ_ΟΝΟΜΑ(\"Δώσε Όνομα\", &Α$)\r\nΤύπωσε Α$\r\nΡΟΥΤΙΝΑ ΕΝΑ_ΟΝΟΜΑ(Τ$, &Ν$)\r\n      ΕΝΩ Ν$=\"\" {\r\n            Τύπωσε Τ$;\r\n            ΕΙΣΑΓΩΓΗ \":\",Ν$\r\n      }\r\n      Τύπωσε Ν$\r\nΤέλος Ρουτίνας\r\n\r\nΓια έξοδο πριν το τέλος της ρουτίνας εκτελούμε το Τέλος Ρουτίνας, ενώ στις απλές ρουτίνες αρκεί το Επιστροφή.\r\n\r\nΠροσοχή!\r\nΕπειδή οι Ρουτίνες βλέπουν όλες τις μεταβλητές, αν θέλουμε να σκιάσουμε μια υπάρχουσα θα την κάνουμε Τοπική\r\n\\\\ Παράδειγμα\r\nΚ=100\r\nΜ=50\r\nΆλφα(30)\r\nΆλφα(60) \\\\ τίποτα\r\nΔες {\r\n      αλφα(10)  \\\\ αν ξεχάσουμε τον τόνο θα βγει λάθος\r\n}\r\nΤύπωσε Μ\r\nΤέλος\r\nΡουτίνα Άλφα(Χ)\r\n      Τοπική Κ=Τυχαίος(1,10)\r\n      Αν Χ>50 Τότε Έξοδος Ρουτίνας\r\n      Τύπωσε Χ*Κ\r\n      Μ++\r\nΤέλος Ρουτίνας\r\n\r\n\r\n  
EN:BUFFER\r\n1) φτιάχνουμε περιοχές στη μνήμη\r\nΔιάρθρωση κενή αλφα ως ακέραιος * 100\r\nΑ$=Πεδίο$(\"Γιώργος\", 100)\r\nΤύπωσε Μήκος(Α$), αλφα(0)   \\\\ 200 (σε ψηφία ή byte), η πραγματική διεύθυνση μνήμης της βάσης (0)\r\n\\\\ γράφουμε πάντα με την εντολή Επιστροφή\r\nΕπιστροφή αλφα, 0:=Α$\r\n\\\\ ανά ψηφίο\r\nΕπιστροφή αλφα, 2!:=255\r\n\\\\ βλέπουμε ότι διαβάζουμε  ακέραιο 2 byte, δηλαδή χαρακτήρα)\r\nΓια ι=0 έως 6\r\n      Τύπωσε εκφρ(αλφα, ι), χαρκωδ(Μεσ$(Α$, ι+1,1))\r\nΕπόμενο ι\r\nΤύπωσε Μήκος(αλφα)  \\\\ 200 (2*100)\r\nμ$=εκφρ$(αλφα,0,7*2)\r\nΤύπωσε μήκος(μ$), μ$\r\nΕπιστροφή αλφα, 30:=65000  \\\\ 0 .. 65535\r\n\\\\ διαβάζουμε από την θέση 30 (2*30 αν ήταν ψηφίο)\r\n\\\\ μπορούμε όμως να διαβάσουμε και ανά ψηφίο (byte)\r\n\\\\ 253*256+232=65000\r\n\\\\ στη θέση 60 είναι το 232 (Low Byte) και στη θέση 61 είναι το 253 (High Byte)\r\nΤύπωσε εκφρ(αλφα,30), εκφρ(αλφα, 60 ως ψηφίο), εκφρ(αλφα, 61 ως ψηφίο) \r\n\r\n2)  Χρήση δομής ή χρήση άμεσου: ψηφίο (byte), ακέραιος (2 byte), μακρύς (4 byte)\r\n \r\nΔομή Αλφα {\r\n      α ως ψηφίο*8\r\n      β ως ακέραιος*20 'κάνει για αλφαριθμητικό\r\n      γ ως μακρύς*4\r\n}\r\n\r\nΤύπωσε Αλφα(\"α\") \\\\ θέση 0\r\nΤύπωσε Αλφα(\"β\") \\\\ θέση 8 (+8 από την αρχή)\r\nΤυπωσε Αλφα(\"γ\") \\\\ θέση 48 (+48 από την αρχή)\r\nΤύπωσε Μήκος(Αλφα) \\\\ 64 bytes\r\nΔιάρθρωση Κάπα ως Αλφα*20\r\nΤύπωσε Μήκος(Κάπα) \\\\1280 ή 64*20 bytes\r\nΕπιστροφή Κάπα, 5 ! β :=\"Γιώργος\"\r\nΤύπωσε Εκφρ$(Κάπα, 5 ! β, 7*2) \\\\ 2 byte το γράμμα\r\nΕπιστροφή Κάπα, 3 ! β :=γραφή$(\"Γιώργος\"+χαρ$(0)) \\\\ γράφει 8 bytes\r\nΤύπωσε χαρ$(Εκφρ$(Κάπα, 3 ! β, 8)) \\\\ 1 byte (ψηφίο) το γράμμα\r\n\r\n3) Χρήση Δομής σε Δομή.\r\nΔομή γράμματα_ονόματος {\r\n      γρα ως ακέραιος*20\r\n}\r\nΔομή η_δομή_μου {\r\n      άλφα ως ψηφίο\r\n      για_στοίχιση ως ψηφίο*3\r\n      Κάπα ως μακρύς*20\r\n      όνομα ως γράμματα_ονόματος*10\r\n      Κάπα2 ως διπλός\r\n}\r\nΔιάρθρωση κενή άλφα ως η_δομή_μου*100\r\nΤύπωσε Μήκος(άλφα), Μήκος.Εμφ(άλφα)\r\nΤύπωσε 5*Μήκος(η_δομή_μου)+ η_δομή_μου(\"Κάπα\"), η_δομή_μου(\"Κάπα\")\r\nΕπιστροφή άλφα, 50!Κάπα!10:=50\r\nsLong=4\r\n\\\\Επιστροφή άλφα, 5*Μήκος(η_δομή_μου)+ η_δομή_μου(\"Κάπα\")+10*sLong! :=50 ως μακρύς\r\n\\\\Τύπωσε εκφρ(άλφα, 5*Μήκος(η_δομή_μου)+ η_δομή_μου(\"Κάπα\")+40  ως μακρύς)\r\nΤύπωσε εκφρ(άλφα, 50!Κάπα!10)\r\nΕπιστροφή άλφα, 50!όνομα!5:=\"George\", 50!όνομα!6:=\"Hello\"\r\nΤύπωσε εκφρ$(άλφα, 50!όνομα!5, 20)\r\nΤύπωσε εκφρ$(άλφα, 50!όνομα!6, 20)\r\nΤύπωσε Μήκος(άλφα), τύπος$(η_δομή_μου)\r\n\r\n4) Αριθμοί με πρόσημο και χωρίς\r\n\\\\ σε θέσεις για ψηφίο (1 byte), ακέραιο (2 byte) και μακρύ (4 byte) μπαίνουν αριθμοί χωρίς πρόσημο\r\n\\\\ σε θέση διπλού μπαίνει κανονικά ο διπλός (8 byte)\r\nΔιάρθρωση αλφα ως μακρύς * 50\r\nΕπιστροφή αλφα, 5:=240,6:=δυαδικό.ακέραιο(-5),30:=3405435354\r\nΤύπωσε εκφρ(αλφα,5), ακέραιο.δυαδικό(αλφα,6), ακέραιο.δυαδικό(αλφα,30)\r\n\r\n\\\\ μετατροπή ενός \r\nΑ=δυαδικό.ακέραιο(-500)\r\n\\\\ ανάποδη μετατροπή\r\nΤύπωσε ακέραιο.δυαδικό(Α)\r\n\\\\ μπορούμε να κρατρήσουμε ακέραιο χωρίς πρόσημο σε μακρύ.\r\nμακρύς B=ακέραιο.δυαδικό(3405435354)\r\nΤύπωσε δυαδικό.ακέραιο(B)\r\n\\\\ μπορούμε να χρησιμιοποιήσουμε τις κανονικές μεταβλητές\r\n\\\\ ως 8 ψηφία (byte) στη μνήμη\r\nAA=3405435354   \\\\\r\nΑ%=3405435354  \\\\ εσωτερικά είναι διπλός (κινητής υποδιαστολής με 8 ψηφία)\r\nΤύπωσε AA, Α%\r\nΕπιστροφή αλφα, 10 :=AA+1 ως διπλός  \\\\ 8 bytes - offset 10*4=+40\r\nΤύπωσε εκφρ(αλφα, 40 ως διπλός)  \\\\ offset  40 byte \r\nΔιάρθρωση alfa1 ως ακέραιος * 100\r\nΕπιστροφή alfa1, 10 :=AA ως διπλός  \\\\ 8 bytes - offset 10*2=+20\r\nΤύπωσε εκφρ(alfa1, 20 ως διπλός)  \\\\ offset  20 byte \r\n\r\n5) Εκτέλεση Κώδικα γλώσσας μηχανής\r\nΔείτε παράδειγμα στην Εκτέλεση για παράδειγμα της Διάρθρωση Κώδικα\r\n\r\n6) Χρήση με την βιβλιοθήκη Μαθηματικά\r\nΔομή Διάνυσμα {\r\n          x Ως Διπλός\r\n          y Ως Διπλός\r\n          z Ως Διπλός\r\n}\r\nΔομή Διανύσματα {\r\n      Vec1 Ως Διάνυσμα\r\n      Vec2 Ως Διάνυσμα\r\n}\r\nΤύπωσε Μήκος(Διάνυσμα), Μήκος(Διανύσματα)\r\nΚ=Κάθε(Διάνυσμα)\r\nΕνώ Κ {\r\n      Τύπωσε Εκφρ$(Κ, Κ^)+\" θέση στη \"+Εκφρ$(Κ)\r\n}\r\nΔιάρθρωση Κενή Άλφα ως Διανύσματα*10\r\nΤύπωσε Άλφα(0), Άλφα(0,\"Vec1\"), Άλφα(0,\"Vec2\")\r\n\r\nΤύπωσε Άλφα(0, \"Vec1\", Διάνυσμα(\"X\")) , Άλφα(0,\"Vec1\", Διάνυσμα(\"Y\")), Άλφα(0,\"Vec1\", Διάνυσμα(\"Z\"))\r\nΤύπωσε Άλφα(0, \"Vec1\", Διάνυσμα(\"X\")!) , Άλφα(0,\"Vec1\", Διάνυσμα(\"Y\")!), Άλφα(0,\"Vec1\", Διάνυσμα(\"Z\")!)\r\nΤύπωσε Άλφα(0, \"Vec1\") \r\nΤύπωσε Άλφα(0, \"Vec1\"!)  ' αφαιρούμε  τη τιμή Άλφα(0), δηλαδή δίνει μόνο η θέση σε ψηφία από την αρχή.\r\nΤύπωσε Άλφα(0!) ' προσθέτουμε ψηφία (bytes) στο Άλφα(0), πχ Άλφα(10!) δίνει Αλφα(0)+10 ως θέση μνήμης\r\n\r\nΔιαν=Λάμδα Άλφα, Διάνυσμα (ν, α$, β$) -> {\r\n      =Έκφρ(Άλφα, Άλφα(0, α$, Διάνυσμα(β$)!) Ως Διπλός)\r\n}\r\nΌρισε Μαθ Μαθηματικά\r\nΤύπωσε Άλφα(1)-Άλφα(0)\r\nx_θέση=Διάνυσμα(\"x\")\r\nFor ν=0 to 9 {\r\n      Μέθοδος Μαθ, \"Vector\",Άλφα(ν,\"Vec1\"), 1200,2500,1500\r\n      Μέθοδος Μαθ, \"Vector\",Άλφα(ν,\"Vec2\"), 3000,2000,1000\r\n      Τύπωσε Διαν(ν,\"Vec1\", \"x\")\r\n      Τύπωσε Διαν(ν,\"Vec1\", \"y\")\r\n      Τύπωσε Διαν(ν,\"Vec1\", \"z\")\r\n      Τύπωσε Έκφρ(Άλφα, Άλφα(ν, \"Vec1\", x_θέση!) Ως Διπλός )\r\n      Τύπωσε Διαν(ν,\"Vec2\", \"y\")\r\n     Τύπωσε Διαν(ν,\"Vec2\", \"z\")\r\n     Μέθοδος Μαθ, \"VecString\",  Άλφα(ν, \"Vec1\") Ως Αποτέλεσμα$\r\n     Τύπωσε Αποτέλεσμα$\r\n     Μέθοδος Μαθ, \"VecString\",  Άλφα(ν, \"Vec2\") Ως Αποτέλεσμα$\r\n     Τύπωσε Αποτέλεσμα$   \r\n}\r\nΌρισε Μαθ Τίποτα\r\n\r\n7)\r\nΔομή alfa {\r\n      a ως μακρύς\r\n      c ως γράμμα*5   '  πέντε δείκτες σε BSTR (4X5=20byte)\r\n      z ως ακέραιος*20\r\n      zero ως μακρύς\r\n}\r\n\r\nΤύπωσε Μήκος(alfa) , Τύπος$(alfa(\"c\"))\r\nΔιάρθρωση Κενή Mem ως alfa*10\r\nΕπιστροφή Mem, 2!c!4:=\"hello there\"\r\nΔεκαεξ Εκφρ(Mem, 2!c!4)    ' string address in Hex\r\nΕπιστροφή Mem, 2!z:=Πεδίο$(\"Fix String\",20) ' no zero\r\nΤύπωσε Εκφρ$(Mem, 2!z, 10*2)  ' need to pass byte number for fix string\r\n\r\n\r\n
EN:BUFFER(\r\nΔιαρθ1=Διάρθρωση( \"όνομα_αρχείου\")\r\nφορτώνει σε μια νέα δριάρθρωση μνήμης το αρχείο που θέλουμε και γυρίζει το δείκτη \r\n\r\nΜπορούμε να φορτώνουμε εικόνες png και άλλες και να τις εμφανίζουμε με το Εικόνα και το Διάφανο \r\n\r\n
EN:DURATION\r\nΤυπωσε ΔΙΑΡΚΕΙΑ\r\nΜας δίνει την διάρκεια της ΤΑΙΝΙΑΣ ή της ΜΟΥΣΙΚΗΣ που εκτελείται.\r\n\r\n
EN:DIMENSION(\r\nΠινακας Α(10,20)\r\nΤύπωσε Διασταση(α())\r\n      2\r\nΤύπωσε Διασταση(α(),1), Διασταση(α(),2)\r\n      10      20\r\nΜπορούμε να διαβάζουμε πόσες διαστάσεις έχει ένας πίνακας και κάθε διάσταση τι μέγεθος έχει.\r\nΜπορούμε να δώσουμε το πίνακα με σταθερό όνομα ή να δώσουμε αλφαριθμητικό.\r\nΤύπωσε Διασταση(\"α\",1), Διασταση(\"α\",2)\r\n\r\nΠίνακας Βάση 1, α(10)   ' από 1 έως 10  η βάση μπήκε εδώ μόνο για το α())\r\nΒάση 1  ' Εδώ άλλαξε γενικά\r\nΠίνακας Β(10)\r\nΤύπωσε Διάσταση(Β(),0) ' δίνει την βάση του πίνακα 1 ή 0, εδώ 1\r\nΤύπωσε Μήκος(Β())   ΄δίνει τον συνολικό αριθμό στοιχείων\r\nΥπάρχει δυνατότητα για δείκτη σε πίνακα\r\nA=(1,2,3,4,5)   ' αυτοί οι πίνακες έχουν βάση 0, και είναι μονοδιάσταστοι\r\nΤύπωσε Διάσταση(Α), Μήκος(Α)  \r\nΒ=((1,2),(3,4))  ' είναι μονοδιάστατος πίνακας με στοιχεία πίνακες.\r\nΟι δείκτες πάντα θα έχουν περιεχόμενο! Δεν έχουμε Null δείκτες στη Μ2000\r\nΜπορούμε να βάλουμε δείκτη και σε κανονικό πίνακα\r\nΑ=Β()\r\n' εδώ θα γίνει αντιγραφή πίνακα, γιατί το Β()  στην εκχώρηση παίρνει αντίγραφο\r\nΒ()=Β\r\n\r\nΑπό την 9.4 έκδοση, αναθ. 4 μπορούμε να βάζουμε για κάθε διάσταση από που θα ξεκινάει και που θα τερματίζει. Αν τα βάλουμε ανάποδα τα γυρνάει αυτόματα ο διερμηνευτής\r\n\r\nΠίνακας α(3 έως 10, -4 έως 8)\r\nαρχή1=Διάσταση(α(),1, 0)\r\nτέλος1=Διάσταση(α(),1, 1)\r\nαρχή2=Διάσταση(α(),2, 0)\r\nτελος2=Διάσταση(α(),2, 1)\r\nΤύπωσε \"Διαστάσεις:\"; Διάσταση(α())\r\nΤύπωσε \"Συνολικά στοιχεία:\"; Μήκος(α())\r\nΤύπωσε \"Πίνακας των \";Διάσταση(α(),1);\" γραμμών Χ \";Διάσταση(α(),2);\" στηλών\"\r\nΤύπωσε  \"Πρώτη διάσταση από \";αρχή1; \" έως \"; τέλος1\r\nΤύπωσε  \"Δεύτερη διάσταση από \";αρχή2; \" έως \"; τέλος2\r\n\r\n\r\n
EN:LINESPACE\r\nΤύπωσε διάστιχο\r\nΔιάστιχο 120   ' τιμές ανά δυο pixel (δηλαδή ανά 30 twips), το 120 είναι 8 pixels για ΠΛΑΤΟΣ.ΣΗΜΕΙΟΥ=15\r\nΦόρμα 80\r\n\r\n\r\n
EN:SPRITE$\r\nΕπιστρέφει αλφαριθμητικό με  περιεχόμενο εικόνα από μία προηγούμενη εντολή ΔΙΑΦΑΝΕΙΑ. Η εικόνα αυτή είναι το τμήμα της οθόνης πριν αλλαχθεί από την ΔΙΑΦΑΝΕΙΑ.\r\nΠαράδειγμα (έχει προηγηθεί μια εντολή ΔΙΑΦΑΝΕΙΑ)\r\nΑ$=ΔΙΑΦΑΝΕΙΑ$\r\nΒ$=ΔΙΑΦΑΝΕΙΑ$\r\nη Α$ περιέχει εικόνα η Β$ όμως δεν περιέχει εικόνα διότι η ΔΙΑΦΑΝΕΙΑ$ δίνει μία φορά μόνο την εικόνα και αποδεσμεύει την μνήμη που βάσταγε την εικόνα.\r\n\r\n\r\n
EN:SPRITE\r\nΕΝΤΟΛΕΣ ΓΡΑΦΙΚΩΝ ΕΙΚΟΝΩΝ, BITMAPS  Με αυτήν την εντολή μπορούμε να βάζουμε στην θέση του δρομέα εικόνες με διαφάνεια. Προσοχή η θέση του δρομέα γραφικών αντιστοιχεί στο μέσον της εικόνας. Η διαφάνεια μπορεί έχει δυο μορφές: Το χρώμα μασκαρίσματος, το οποίο δηλώνει ποια σημεία τις εικόνας μας δεν θα τυπωθούν και έτσι θα δείχνουν τα χρώματα του φόντου. Η διαπερατότητα (0 έως 100) μας δείχνει τα άλλα σημεία της εικόνας που θα τυπωθούν, πόσο διάφανα θα είναι έτσι ώστε να βλέπουμε και το φόντο σαν να ήταν η εικόνα μας από διαφανές πλαστικό! Η περιστροφή είναι σε μοίρες.\r\n\r\nΓια κάθε σημείο της εικόνας (και κάθε χρώμα ξεχωριστά RGB) θα γίνει ο παρακάτω υπολογισμός:\r\nΤελικό χρώμα=Χρώμα_Σημείου_Οθόνης * (100- Διαπερατότητα )/100 + Χρώμα_Σημείου_Εικόνας *  Διαπερατότητα/100\r\n\r\n\r\nΔΙΑΦΑΝΟ A$\r\nΔΙΑΦΑΝΟ Α$, χρώμα μασκαρίσματος\r\nΔΙΑΦΑΝΟ Α$, χρώμα μασκαρίσματος, Γωνία_Περιστροφής\r\n\r\nΔΙΑΦΑΝΟ Α$,χρώμα μασκαρίσματος, Γωνία_Περιστροφής, Ποσοστό_Μεγέθους\r\n\r\nΔΙΑΦΑΝΟ Α$, χρ_μασκ, Γωνία_Περιστροφής, Ποσοστό_Μεγέθους, Διαπερατότητα [, 1 ] \r\nη τελευταία παράμετρος αν δεν είναι 0 σημαίνει ότι δεν θα κρατήσει το σύστημα το χώρο που \"πατάει\" το διάφανο.\r\nΔΙΑΦΑΝΟ Α$, χρ_μασκ, Γωνία_Περιστροφής, Ποσοστό_Μεγέθους, Εικόνα_Μάσκας$ [, 1 ]  \r\n\r\nΔιάφανο Διάρθρωση_Μνήμης_με_Εικόνα [, χρ_μασκ[, Γωνία_Περιστροφής[, Ποσοστό_Μεγέθους[, Διαπερατότητα [, 1 ]]]]]\r\nΜε το Διάθρωση() φτιάχνουμε μια νέα διάρθωση από αρχείο (πχ ένα png αρχείο) και το χρησιμοποιούμε ως διάφανο. Τα png αρχεία μπορεί να έχουν και αυτά μάσκα για μερική αδιαφάνεια, και δεν χάνεται στη διάρθρωση και έτσι χρησιμοποιείται πάντα στην εμφάνιση.\r\n\r\nΣε κάθε εκτύπωση η μεταβλητή ΔΙΑΦΑΝΕΙΑ$ λαμβάνει την περιοχή που θα καλυφθεί, έτσι μπορούμε να την σώνουμε σε άλλη μεταβλητή και να επαναφέρουμε την οθόνη στο προηγούμενη όψη (εκτός αν δεν το θέλουμε, οπότε βάζουμε το , 1 στο τέλος)\r\n\r\nΌταν εργαζόμαστε με οθόνες με χρώμα μικρότερο από 24 bit (δηλαδή λιγότερα από 16 εκατομμύρια χρώματα) το χρώμα μασκαρίσματος πρέπει να δοθεί με επιλογή χρώματος από ένα σημείο της εικόνας, συντεταγμένες σε pixels:\r\n\r\nΤΥΠΩΣΕ ΧΡΩΜΑΤΑ\r\nΔΙΑΦΑΝΟ Α$, ΣΗΜΕΙΟ(Α$,0,0)\r\n\r\nΣτην έκτη έκδοση μπορούμε να χρησιμοποιήσουμε τα επίπεδα (οι παίκτες) σαν διαφάνειες. Η διαφορά τους είναι ότι δεν έχουν μερική διαφάνεια (διαπερτατότητα) αλλά όμως είναι σε ξεχωριστό επίπεδο...που σημαίνει ότι μπορούμε να κάνουμε ότι θέλουμε στο βασικό επίπεδο ή στο περιθώριο χωρίς να τα πειράξουμε! Επίσης οι παίκτες έχουν και ειδική συνάρτηση ΣΥΓΚΡΟΥΣΗ( για να ελέγχουμε αν μεταξύ τους ή  με συγκεκριμένο πλαίσιο έχουμε σύγκρουση.\r\n\r\nΠαρακάτω είναι ένα απλό πρόγραμμα που παίρνει ένα κομάτι απο την οθόνη πλάτους 3000 twips και ύψους 1000, και βάζει στο 1000,1000.\r\n\r\nανανεωση 100\r\nα$=\"\"\r\nθεση 0,0\r\nαντιγραψε 3000,1000 στο α$\r\nθεση 1000,1000\r\nδιαφανεια α$,,0   ' το τυπώνουμε εδώ για να πάρουμε το β$ μετά\r\nγια ι=1 εως 100 {\r\nανανεωση 0\r\nβ$=διαφανεια$\r\nδιαφανεια β$   ' τώρα σβήνουμε την παλιά διαφάνεια\r\nβημα 30,30\r\nδιαφανεια α$,,0\r\nανανεωση   ' τώρα εμφανίζουμε την οθόνη\r\n}\r\n\r\nΠιο γρήγορη μέθοδος για να αποδώσουμε το φόντο, είναι με τη χρήση HOLD και RELEASE\r\nΕδώ δίνουμε και περιστροφή (σε μοίρες) και το μέγεθος (από 11 μέχρι 211 τοις εκατό, δηλαδή 100 για κανονικό μέγεθος).\r\n\r\nανανεωση 10  ' αν το κάνουμε 100 θα  γίνονται λιγότερες ανανεώσεις.\r\nα$=\"\"\r\nθεση 0,0\r\nαντιγραψε 3000,1000 στο α$\r\nκρατησε\r\nθεση 1000,1000\r\nδιαφανεια α$,,0\r\nι=11\r\nκαθε  10 {\r\n      ι++\r\n      αφησε\r\n      βημα 45,30\r\n      διαφανεια α$,,ι,ι+10\r\n      ' ανανεωση  ' αφήνουμε το σύστημα να χειριστεί αυτόματα την ανανέωση\r\n      αν ι>=200 τοτε εξοδος\r\n}\r\n\r\n
EN:ESCAPE\r\nΔΙΑΦΥΓΗ ΟΧΙ\r\nΔΙΑΦΥΓΗ ΝΑΙ\r\n\r\nΗ εντολή αυτή μας επιτρέπει η όχι να μπορούμε να διακόπτουμε την ροή του προγράμματος με το πλήκτρο ESC.\r\n\r\nΓια καλύτερο έλεγχο της ροής του προγράμματός σας δοκιμάστε την εντολή ΔΟΚΙΜΗ\r\n\r\nΌταν γράφουμε κείμενο πολλών γραμμών οπου το Escape χρησιμεύει για να τερματίσουμε τον διορθωτή τότε λειτουργεί παρόλο που δεν θα λειτουργήσει για διακοπή προγράμματος.\r\n\r\n
EN:BREAK\r\nΈχει δυο χρήσεις\r\nΜία για την ΕΠΙΛΕΞΕ ΜΕ ή SELECT CASE\r\nκαι μια γενικότερη όπου διακόπτει την ροή ενός τμήματος χωρίς πρόβλημα!\r\n1)\r\na=5\r\nb=10\r\nselect case  A\r\ncase 1, 5 to 20\r\n      { print \"ok\"\r\n       if b=10 then  break\r\n      }\r\ncase 2,4\r\n      {print \"one ok\"\r\n            continue\r\n      }\r\ncase 3\r\n      { print \"that\"\r\n            print \"and that\"\r\n      }\r\nelse\r\n      print \"??\"\r\nend select\r\n\r\n2)\r\nτμημα Α {\r\n      τυπωσε $(,4)\r\n      για ι=1 εως 20 {\r\n            για κ=1 εως 10 {\r\n                  τυπωσε \"κατι\", ι, κ\r\n                  αν ι=2 και κ=2 τοτε διεκοψε\r\n            }\r\n      }\r\n      τυπωσε \"δεν τυπώνει αυτή η γραμμή\"\r\n}\r\nκαλεσε Α\r\nτυπωσε \" αλλά τυπώνει αυτή\"\r\n\r\n\r\n\r\n\r\n\r\n
EN:INTERPRETER\r\nΔΙΕΡΜΗΝΕΥΤΗΣ\r\nΑΡΓΑ, ΑΡΧΗ, ΒΟΗΘΕΙΑ, ΓΡΗΓΟΡΑ, ΔΙΑ, ΔΙΑ#, ΔΙΑΓΡΑΦΗ, ΔΙΑΚΟΠΤΕΣ, ΔΟΚΙΜΗ, ΕΙΝΑΙ, ΕΚΔΟΣΗ, ΕΛΕΓΧΟΣ, Η, ΚΑΘΑΡΟ, ΚΑΙ, ΚΛΕΙΔΙ, ΚΟΝΣΟΛΑ, ΛΙΣΤΑ, ΝΕΟ, ΟΡΙΟ.ΑΝΑΔΡΟΜΗΣ, ΠΕΡΙ, ΠΛΗΚΤΡΟΛΟΓΙΟ, ΠΡΟΧΕΙΡΟ, ΠΡΩΤΟΤΥΠΟ, ΣΕΝΑΡΙΟ, ΣΗΜ, ΣΥΓΓΡΑΦΕΑΣ, ΣΥΓΓΡΑΦΗ, ΣΥΣΤΗΜΑ, ΣΩΣΕ, ΤΑΞΙΝΟΜΗΣΗ, ΤΕΛΕΣΤΕΣ, ΤΕΛΟΣ, ΥΠΟΛ, ΥΠΟΛ#, ΦΟΡΤΩΣΕ\r\n
EN:LAN$\r\n? ΔΙΚΤΥΟ$\r\nεπιστρέφει την IP του δικτύου μας.\r\n
EN:EDIT.DOC\r\nΔιώρθωσε [κώδικα] Έγγραφο$, [θέση δρομέα],[τίτλος εγγράφου], [χρώμα φόντου]     \r\n[ ] σημαίνει προαιρετικό\r\nΠαράμετροι\r\n1. το έγγραφο πρέπει να είναι μεταβλητή τύπου [έγγραφο] ή στοιχείο πίνακα αλφαριθμητικού που έχει δηλωθεί ως έγγραφο.\r\n2. Αν θέλουμε δίνουμε δρομέα\r\n\r\nαν βάλουμε χρώμα φόντου αυτό της πένας τότε έχουμε διαφάνεια 100%\r\n\r\n\r\n\r\n
EN:DOUBLE\r\nΔΙΠΛΑ\r\nΚάνει τα γράμματα να εμφανίζονται με διπλό ύψος και πλάτος. Επίσης και η ολίσθηση γίνεται διπλής γραμμής.\r\nΑντίθετη ΚΑΝΟΝΙΚΑ\r\n\r\n\r\n
EN:DOUBLE_as constant\r\nχρησιμοποείται στην εντολή ΑΡΧΕΙΟ\r\n\r\n
EN:TEST\r\n1)  Η εντολή ΔΟΚΙΜΗ εμφανίζει μια φόρμα όπου βλέπουμε μια προς μια τις εντολές που εκτελούνται.\r\nΜπορούμε να τη δώσουμε και μέσα σε κώδικα\r\n2) Δοκιμή  όνομα_τμήματος (τρέχει το τμήμα με φόρμα ελέγχου)\r\n3) Η απενεργοποίηση γίνεται με το κλείσιμο της φόρμας η με την εντολή:\r\n      Δοκιμη !\r\n4) Δοικμή \"Όνομα στο τίτλο της φόρμας ελέγχου\"\r\n5) 'Οπως η 4 αλλά μπορούμε να βάλουμε μια σειρά παραμέτρων που θα φαίνονται στην Τύπωσε της φόρμας\r\n\r\n\\\\ Μια πιο νέα χρήση με τη χρήση της συνάρτησης δοκιμή()\r\n\\\\ απλά πατάμε το Enter και βλέπουμε το κώδικα να τρέχει μέχρι το επόμενο σημείο\r\n\\\\ όπου πάλι σταματάει η ροή.\r\nΔοκιμή \"Αρχή\", Δοκιμή(\"οκ\"), α\r\nΓια α=1 έως 100 {\r\n      Αναμονή 1\r\n      Τύπωσε α\r\n      Αν α=41 Τότε Δοκιμή \"ok\" : Δοκιμή Δοκιμή(\"ok2\")\r\n      Αν α=81 Τότε Δοκιμή \"ok2\": Δοκιμή\r\n}\r\nΔοκιμή !\r\n\r\n\r\n\r\n
EN:TEST(\r\nΜπορούμε με την εντολή Δοκιμή \"Όνομα διακοπής\" να αλλάζουμε το τίτλο της φόρμας Έλεγχος. Η Συνάρτηση Δοκιμή() μπορεί να αφήνει διακοπές ροής από εντολές Δοκιμή μέχρι να εμφανιστεί ο τίτλος που θέλουμε. Ή μέχρι να ικανοποιείται μια συνθήκη.\r\n\r\nΓια ι=1 Έως 100 {\r\n      Αν ι=5 Τότε Δοκιμή \"Start 1\", Δοκιμή(\"Point 1\"), ι\r\n      Αν ι=55 Τότε Δοκιμή \"Point 1\"\r\n      Τύπωσε ι\r\n}\r\n\r\n\r\n
EN:STRUCTURE\r\n1) ΔΟΜΗ ονομα_βασης$\r\n2) ΔΟΜΗ ονομα_βασης$, ονομα_πινακα$\r\n3) Δες τη Διάρθρωση η εντολή Δομή δημιουργεί δομές διάρθρωσης μνήμης (ως σύνθετους τύπους)\r\nΦΟΡΜΑ 80,50\r\nΒΑΣΗ.ΠΑΡΟΧΟΣ \"\"   ' ρυθμίζει τον πάροχο στον βασικό (ενδέχεται να αλλαχθεί αυτόματα αν δεν μπορεί να ανοίξει μια βάση η Μ2000)\r\nα=ΣΤΗΛΗ ' κρατάμε στο α το πλάτος νοητής στήλης στην οθόνη\r\nΤΥΠΩΣΕ $(0,8) ' ορίζουμε πλάτος 8\r\nΕΠΙΛΟΓΗ ' σβήνουμε την λίστα επιλογών\r\nΑΡΧΕΙΑ + \"mdb\"  ' βάζουμε στην λίστα επιλογών όλα τα αρχεία τύπου \"mdb\"\r\n                          ' από τον τρέχον κατάλογο\r\nΑΝ ΕΠΙΛΟΓΕΣ>0 ΤΟΤΕ {  ' αν υπάρχουν επιλογές στην λίστα\r\n      ΤΥΠΩΣΕ \"Επέλεξε ένα αρχείο:\";\r\n      ΕΠΙΛΟΓΗ !                      ' εμφάνιση της λίστας για να επιλέξουμε\r\n      ΑΝ ΕΠΙΛΟΓΗ>0 ΤΟΤΕ { \r\n            ΒΑΣΗ$=ΕΠΙΛΟΓΗ$( ΕΠΙΛΟΓΗ )\r\n            ΤΥΠΩΣΕ ΠΕΖ$(ΒΑΣΗ$)+\".mdb\"\r\n            ΤΥΠΩΣΕ \"Δομή\"\r\n            ΤΥΠΩΣΕ \"Αρχεία:\";\r\n            ΔΟΜΗ ΒΑΣΗ$\r\n            ΔΙΑΒΑΣΕ ΑΡΧΕΙΑ ' εδώ δεν έχουμε την εντολή ΑΡΧΕΙΑ\r\n                     'αλλά φτιάχνουμε μια μεταβλητή με το ίδιο όνομα και δίνουμε τιμή\r\n                     ' από τον σωρό\r\n            ΤΥΠΩΣΕ  ΓΡΑΦΗ$(ΑΡΧΕΙΑ)\r\n            ΑΝ ΑΡΧΕΙΑ>0 ΤΟΤΕ {\r\n                  ΓΙΑ Ι=1 ΕΩΣ ΑΡΧΕΙΑ {\r\n                        ΔΙΑΒΑΣΕ ΟΝΟΜΑΤΑ$, ΤΑΞΕΙΣ\r\n                        ΤΥΠΩΣΕ Ι,\") \"+ΟΝΟΜΑΤΑ$\r\n                        ΔΟΜΗ ΒΑΣΗ$, ΟΝΟΜΑΤΑ$\r\n                        ΔΙΑΒΑΣΕ ΠΕΔΙΑ, ΤΑΞΕΙΣ\r\n                                    ' αν υπάρχει αριθμός στο σωρό και όχι λέξη τότε...\r\n                        ΑΝ  ΠΕΔΙΑ>0 ΤΟΤΕ {\r\n                              ΓΙΑ Π=1 ΕΩΣ ΠΕΔΙΑ {\r\n                                    ΔΙΑΒΑΣΕ ΠΕΡΙΓΡΑΦΗ$, ΤΥΠΟΣ$, ΜΗΚΟΣ\r\n                                    ΤΥΠΩΣΕ \"\",Π,\") \"+ΠΕΔΙΟ$(ΠΕΡΙΓΡΑΦΗ$,17),\"\",ΤΥΠΟΣ$, ΜΗΚΟΣ\r\n                              }\r\n                        }\r\n                        ΑΝ ΤΑΞΕΙΣ>0 ΤΟΤΕ {\r\n                              ΤΥΠΩΣΕ \"\",\"ΤΑΞΗ:\"\r\n                              ΔΙΑΒΑΣΕ ΠΕΔΙΑ\r\n                              ΑΝ  ΠΕΔΙΑ>0 ΤΟΤΕ {\r\n                                    ΓΙΑ Π=1 ΕΩΣ ΠΕΔΙΑ {\r\n                                          ΔΙΑΒΑΣΕ ΠΕΡΙΓΡΑΦΗ$, ΤΥΠΟΣ$\r\n                                          ΤΥΠΩΣΕ \"\",Π,\") \"+ΠΕΔΙΟ$(ΠΕΡΙΓΡΑΦΗ$,17),\"\",ΤΥΠΟΣ$\r\n                                    }\r\n                              }\r\n                        }\r\n                  }\r\n            }\r\n      }\r\n}\r\nΤΥΠΩΣΕ $(0,α)\r\n\r\n\r\n\\\\ Μπορούμε να χρησιμοποιούμε μπλοκ μέσα στη δομή και κάθε φορά στο τέλος του μπλοκ επιστρέφει ο μετρητής στην αρχή του μπλοκ, ώστε να βάλουμε και άλλα με σκοπό να έχουμε για ίδια μνήμη διαφορετικό τρόπο προσπέλασης (λέγονται unions σε δομές). Είναι προχωρημένο θέμα. Εδώ ένα απλό παράδειγμα (χωρίς unions):\r\n\\\\ ψηφίο (1 byte), ακέραιος (2 byte), μακρύς (4 byte) είναι αριθμοί χωρίς πρόσημο (πχ το ψηφίο παίρνει τιμές από 0 έως 255)\r\n\\\\ ο διπλός είναι 8 byte. Χαρακτήρες γράφουμε ανά δυο byte, για Unicode. Υπάρχει τρόπος να γράψουμε και να διαβάσουμε σε Ansi, με ένα Byte ανά χαρακτήρα.\r\n\\\\ η άλφα είναι δείκτης σε διάρθρωση και μπορεί να υπάρχει σε ομάδες, σε πίνακες, σε σωρούς, σε καταστάσεις. Η διάρθρωση μνήμης μπορεί να αλλάξει μέγεθος χωρίς να αλλάξει τύπο και χωρίς να σβήσει ότι έχει. Ουσιαστικά είναι ένα αντικείμενο που κρατάει μια περιοχή μνήμης.\r\n\r\nΔομή γράμματα_ονόματος {\r\n      γρα ως ακέραιος*20\r\n}\r\nΔομή η_δομή_μου {\r\n      άλφα ως ψηφίο\r\n      για_στοίχιση ως ψηφίο*3\r\n      Κάπα ως μακρύς*20\r\n      όνομα ως γράμματα_ονόματος*10\r\n      Κάπα2 ως διπλός\r\n}\r\nΔιάρθρωση κενή άλφα ως η_δομή_μου*100\r\n\r\n\r\n
EN:CURSOR\r\nΔΡΟΜΕΑΣ θεσηΧ, θεσηΨ\r\nΔΡΟΜΕΑΣ 0,0  ' η πάνω αριστερή γωνία\r\nΤΥΠΩΣΕ \"ΓΕΙΑ\"\r\n\r\nΤΥΠΩΣΕ @(10,10),\"ΓΕΙΑ\"\r\n'Εδώ το κόμμα μετά την εσωτερική εντολή @() της ΤΥΠΩΣΕ δεν κάνει τίποτα άλλο από το να την ξεχωρίζει από τα υπόλοιπα.\r\n\r\nΤΥΠΩΣΕ \"ΑΑ\", ΘΕΣΗ, ΣΤΗΛΗ, ΓΡΑΜΜΗ\r\n'Εδώ το κόμμα μετά το \"ΑΑ\" πάει τον δρομέα στην αρχή της επόμενης στήλης\r\n'Η ΘΕΣΗ δηλώνει ότι αριστερά από τη θέση χαρακτήρα βρίσκονται τόσοι χαρακτήρες..\r\n'Η ΣΤΗΛΗ δηλώνει τον αριθμό χαρακτήρων ως πλάτος στήλης. Επειδή ξεκινάμε από αριστερά από το 0 για στήλη 10 'χαρακτήρων η θέση της δεύτερης στήλης θα είναι στο 10 (από 0 έως 9 θα είναι οι δέκα χαρακτήρες που έχει η πρώτη στήλη).\r\n\r\nΤΥΠΩΣΕ \"ΑΑ\",,\"ΒΒ\",,\"ΓΓ\"\r\n\r\n
EN:BINARY.ROTATE(\r\n\\\\ -31 έως 31\r\nα=0xFAAA000A\r\nΔεκαεξ  ΔΥΑΔΙΚΗ.ΠΕΡΙΣΤΡΟΦΗ(α, 1)\r\nΔεκαεξ  ΔΥΑΔΙΚΗ.ΠΕΡΙΣΤΡΟΦΗ(α, 2)\r\nΔεκαεξ  ΔΥΑΔΙΚΗ.ΠΕΡΙΣΤΡΟΦΗ(α, -1)\r\nΔεκαεξ  ΔΥΑΔΙΚΗ.ΠΕΡΙΣΤΡΟΦΗ(α, -2)\r\n\r\n
EN:BINARY\r\nΔΥΑΔΙΚΟ {\r\n      kwOVA5kDkQMgAKcDkQOhA5ED\r\n} ΩΣ Α$\r\nΤΥΠΩΣΕ Α$\r\n\r\nΣτις αγκύλες πρέπει να είναι δυαδικά στοιχεία κωδικοποιημένα σε BASE64. Μπορούμε να εισάγουμε στοιχεία από το μενού στο διορθωτή, ως εισαγωγή πόρου., από αρχείο Η μεταβλητή μπορεί να είναι αριθμητική ή αλφαριθμητική ή στοχείο πίνακα αριθμητικού ή αλφαριθμητικού.\r\nΣτα αριθμητικά έχουμε αυτόματα δείκτη σε διάρθρωση με τα στοιχεία, ενώ στα αλφαριθμητικά έχουμε αλφαριθμητικό με τα στοιχεία αποκωδικοποιημένα.\r\nΜετατροπή σε BASE64 γίνεται επίσης με την ΕΠΑΝ$(), η οποία εκτός από επανάληψη ενός αλφαριθμητικού κάνει \"επαναμορφωποίηση\".\r\n\r\n
EN:USGN(\r\nα=8000000000\r\nΤύπωσε Δυαδικό(α)=0xFFFFFFFF ' κόβει το α στο μέγιστο\r\nα=-34324\r\nΤύπωσε Δυαδικό(α)=0   ' κόβει το α στο ελάχιστο\r\nα=34324\r\nΤύπωσε Δυαδικό(α)=34324\r\n\r\n
EN:UINT(\r\n' Επιστρέφει έναν χωρίς πρόσημο ακέραιο με ίδια δυαδικά ψηφία\r\nα=-345\r\nΤύπωσε Δεκαεξ$(ΔΥΑΔΙΚΟ.ΑΚΕΡΑΙΟ(α))\r\nΔεκαεξ ΔΥΑΔΙΚΟ.ΑΚΕΡΑΙΟ(α), α  '  Το δεύτερο τυπώνει ???- γιατί είναι αρνητικός.\r\n\r\n
EN:BINARY.NEG(\r\nΥπάρχει και ως ΔΥΑΔΙΚΟ.ΑΝΤΙΣΤΡΟΦΟ()\r\n Δέχεται εναν αριθμό με πρόσημο 32 bit\r\n και δίνει το αντίστροφο με ίδια bits (ψηφία) σε αριθμό χωρίς πρόσημο 32 bits\r\n o β παρακάτω θα πάρει έναν αρνητικό, τον -21555\r\n Το αντίστροφό του είναι το 21554, διότι ως αναπαράσταση οι δυο αριθμοί ως δυαδικοί δίνουν το FFFFFFFF, το οποίο χωρίς πρόσημο είναι αυτό: 0xFFFFFFFF και με πρόσημο είναι αυτό: 0xFFFFFFFF& αλλά και τα δυο έχουν τα ίδια ψηφία ως δυαδική αναπαράσταση\r\n \r\n β=0xFFFFABCD&\r\nΤύπωσε α>=0=Ψευδές\r\nΤύπωσε β=-21555\r\nΤύπωσε Δυαδικό.Αντίστροφο(β)=21554\r\nΤύπωσε Ακέραιο.Δυαδικό(Δυαδικό.Αντίστροφο(β))=21554\r\nΤύπωσε  Δεκαεξ$(Δυαδικό.Ακέραιο(β))=\"FFFFABCD\", Δυαδικό.Ακέραιο(β)\r\nΤύπωσε Δεκαεξ$(Δυαδικό.Αντίστροφο(β)+Δυαδικό.Ακέραιο(β))=\"FFFFFFFF\"\r\nΤύπωσε Δυαδικό.Όχι(Δυαδικό.Ακέραιο(β))=21554\r\nΤύπωσε Δεκαεξ$(Δυαδικό.Όχι(Δυαδικό.Ακέραιο(β))+Δυαδικό.Ακέραιο(β))=\"FFFFFFFF\"\r\nβ=21555\r\nΤύπωσε Δεκαεξ$(β)=\"00005433\"\r\nΤύπωσε Δυαδικό.Αντίστροφο(β)=4294945740\r\nΤύπωσε Ακέραιο.Δυαδικό(Δυαδικό.Αντίστροφο(β))=-21556\r\nΤύπωσε  Δεκαεξ$(Δυαδικό.Ακέραιο(β))=\"00005433\", Δυαδικό.Ακέραιο(β)\r\nΤύπωσε Δεκαεξ$(Δυαδικό.Αντίστροφο(β)+Δυαδικό.Ακέραιο(β))=\"FFFFFFFF\"\r\nΤύπωσε Δυαδικό.Όχι(Δυαδικό.Ακέραιο(β))=4294945740\r\nΤύπωσε Δεκαεξ$(Δυαδικό.Όχι(Δυαδικό.Ακέραιο(β))+Δυαδικό.Ακέραιο(β))=\"FFFFFFFF\"\r\n
EN:BINARY.XOR(\r\nα=0xFAAA\r\nβ=0x5550\r\nΔεκαεξ  ΔΥΑΔΙΚΟ.ΑΠΟ(α,β)\r\n\r\n
EN:BINARY.OR(\r\nα=0xFAAA\r\nβ=0x5550\r\nΔεκαεξ  ΔΥΑΔΙΚΟ.Η(α,β)\r\n\r\n
EN:BINARY.AND(\r\nα=0xFAAA\r\nβ=0x5550\r\nΔεκαεξ  ΔΥΑΔΙΚΟ.ΚΑΙ(α,β)\r\n\r\n
EN:BINARY.SHIFT(\r\n\\\\ -31  έως 31\r\nα=0xFAAA\r\nΔεκαεξ  ΔΥΑΔΙΚΟ.ΟΛΙΣΘΗΣΗ(α, 1)\r\nΔεκαεξ  ΔΥΑΔΙΚΟ.ΟΛΙΣΘΗΣΗ(α, 2)\r\nΔεκαεξ  ΔΥΑΔΙΚΟ.ΟΛΙΣΘΗΣΗ(α, -1)\r\nΔεκαεξ  ΔΥΑΔΙΚΟ.ΟΛΙΣΘΗΣΗ(α, -2)\r\n\r\n
EN:BINARY.NOT(\r\nΠαίρνει αριθμό χωρίς πρόσημο από 0x0 έως 0xFFFFFFFF\r\nΤύπωσε Δεκαεξ$(Δυαδικό.Όχι(0xAAAAAAAA)) '55555555\r\n\r\nΔες Δυαδικό.Αντί()\r\n\r\n
EN:BINARY.ADD(\r\nΔΥΑΔΙΚΟ.ΠΡΟ() ή ΔΥΑΔΙΚΟ.ΠΡΟΣΘΕΣΗ()\r\nΚάνει πρόσθεση δυο δυαδικών αριθμών 32bit, χωρίς πρόσημο, και δίνει το υπόλοιπο από 2^32, η με άλλα λόγια αφαιρεί την τυχόν υπερχείλιση.\r\n\r\n\r\n\r\nΔΕΚΑΕΞ ΔΥΑΔΙΚΟ.ΠΡΟ(0xF0000000,0xF0000001)\r\n\t\t0xE0000001\r\n\r\n\r\n
EN:BINARY_const\r\nΔΥΑΔΙΚΟ\r\nσταθερή που χρησιμοποιείται στις βάσεις δεδομένων\r\n\r\n
EN:HILOWWORD(\r\nα=0xFAAA\r\nβ=0x5550\r\nΔεκαεξ  ΔΥΟΜΙΣΑ(α,β)\r\nΤύπωσε ΚάτωΜισό(ΔΥΟΜΙΣΑ(α,β))=β\r\nΤύπωσε ΠάνωΜισό(ΔΥΟΜΙΣΑ(α,β))=α\r\n\r\n
EN:PUT\r\nΗ εντολή αυτή δουλεύει για τα αρχεία τύπου πεδίου ως εξής:\r\nΔΩΣΕ μεταβλητη_χειρισμου_αρχειου, μεταβλητη_πεδιο$, θεση_στο_αρχειο\r\nΓια να προσθέσουμε (ΣΥΜΠΛΗΡΩΣΗ) ένα αρχείο τύπου ΠΕΔΙΑ\r\nεδω=ΕΓΓΡΑΦΕΣ(αλφα)+1\r\nΔΩΣΕ αλφα, α1$+α2$+α3$+α4$, εδω\r\nόπου τα α1$, α2$, α3$, α4$ έχουν το καθένα συγκεκριμένο μήκος λέξης\r\nΑν το σύνολο των μηκών των επιμέρους λέξεων είναι μικρότερο ή μεγαλύτερο του μήκους όλης της εγγραφής (δες μήκος στην ΑΝΟΙΞΕ ... ΓΙΑ ΠΕΔΙΑ ... ΜΗΚΟΣ=...) τότε ανάλογα προσαρμόζεται (ο μεταφραστής ή κόβει το πλεόνασμα ή προσθέτει διαστήματα)\r\n\r\n\r\nΛΙΓΑ ΛΟΓΙΑ ΓΙΑ ΤΑ ΑΡΧΕΙΑ ΤΥΠΟΥ ΠΕΔΙΑ / RANDOM\r\nΑυτά τα αρχεία λέγονται και αρχεία σταθερού μήκους εγγραφής. Πρώτα επιλέγουμε το μήκος της εγγραφής μας και κατόπιν μπορούμε να γράφουμε, να διαβάζουμε, να αλλάζουμε οποιαδήποτε εγγραφή. Για να διαγράψουμε όμως μια εγγραφή χρειάζεται λίγο κόπος παραπάνω και αυτό γιατί η μνήμη που έχει παραχωρηθεί δεν μπορεί να αφαιρεθεί (άρα να διαγραφεί) αλλά με χειρισμό μπορούμε να μην προσμετράμε κάποια εγγραφή και με μια αντιγραφή σε νέο αρχείο των έγκυρων εγγραφών μπορούμε να συμπιέσουμε το αρχείο μας διαγράφοντας τα λογικώς διαγραμμένα. Και τα λογικώς διαγραμμένα είναι αυτά που τα έχουμε μαρκάρει ως διαγραμμένα! Π.Χ. ο πρώτος χαρακτήρας της εγγραφής μπορεί να μας δείχνει αν είναι η εγγραφή διαγραμμένη ή όχι.\r\nΠρέπει να βλέπουμε ένα αρχείο τύπου ΠΕΔΙΑ / RANDOM ως ένας πίνακας αλφαριθμητικών σταθερού μήκους.\r\nΔες την εντολή ΠΑΡΕ\r\n\r\n\r\n\r\n
EN:DOCUMENTS\r\nΕΓΓΡΑΦΑ\r\nΔΙΟΡΘΩΣΕ, ΕΥΡΕΣΗ, ΚΑΤΑΧΩΡΗΣΗ, ΛΕΞΕΙΣ, ΠΑΡΕΜΒΟΛΗ, ΠΡΟΣΘΕΣΕ.ΕΓΓΡΑΦΟ, ΣΥΓΧΩΝΕΥΣΕ.ΕΓΓΡΑΦΟ, ΣΩΣΕ.ΕΓΓΡΑΦΟ, ΤΑΞΙΝΟΜΗΣΗ(ΕΓΓΡΑΦΟΥ), ΦΟΡΤΩΣΕ.ΕΓΓΡΑΦΟ\r\n
EN:RECORDS(\r\nΔέχεται ως όρισμα τον αριθμό ενός ανοιχτού αρχείου και δίνει των αριθμό εγγραφών αν είναι τύπου ΠΕΔΙΩΝ ή το μέγεθος σε χαρακτήρες αν είναι οτιδήποτε άλλο.\r\n\r\n
EN:DOCUMENT\r\n&Η εντολή ΕΓΓΡΑΦΟ φτιάχνει νέες μεταβλητές αλφαριθμητικές που διαφέρουν από τις κανονικές στο τρόπο που καταχωρούν τα δεδομένα. Ορατή διαφορά είναι ότι το = δεν κάνει αντικατάσταση αλλά προσθήκη στο τέλος.\r\nΕΓΓΡΑΦΟ Α$, Β$\r\nΜπορούμε και στοιχείο πίνακα να φτιάξουμε ωε ΕΓΓΡΑΦΟ, αλλά όχι όλο το πίνακα με μια εντολή.\r\n\r\nΑ$={ΓΕΙΑ ΧΑΡΑ\r\nΟΛΑ ΚΑΛΑ\r\n}\r\nΕΓΓΡΑΦΟ Α$, Β$\r\nΑ$=\"ΤΕΣΤ1\"\r\nΒ$=\"ΤΕΣΤ2\"\r\nΑΝΑΦΟΡΑ Α$\r\nΑΝΑΦΟΡΑ Β$\r\nΤΥΠΩΣΕ ΕΓΓΡΑΦΟΥ.ΜΗΚΟΣ(Α$), ΕΓΓΡΑΦΟΥ.ΜΗΚΟΣ(Β$)\r\n\r\n' Το = δεν κάνει αντικατάσταση αλλά προσθέτει στη τελευταία γραμμή ότι βάλουμε...\r\n'Με ΚΑΘΑΡΟ Α$ σβήνουμε τις παραγράφους\r\n\r\nΧωρίς την χρήση της ΕΓΓΡΑΦΟ\r\n\r\nΑ$={ΓΕΙΑ ΧΑΡΑ\r\nΟΛΑ ΚΑΛΑ\r\n}\r\nΑ$=Α$+\"ΤΕΣΤ1\"    ' πρέπει να δημιουργούμε αντίγραφα\r\nΒ$=\"ΤΕΣΤ2\"\r\nΑΝΑΦΟΡΑ Α$\r\nΑΝΑΦΟΡΑ Β$\r\nΤΥΠΩΣΕ ΕΓΓΡΑΦΟΥ.ΜΗΚΟΣ(Α$), ΕΓΓΡΑΦΟΥ.ΜΗΚΟΣ(Β$)   ' η συνάρτηση δουλεύει και για απλά αλφαριθμητικά.\r\n\r\nΚερδίζουμε όταν έχουμε μεγάλα κείμενα και η προσθήκη ενός μικρού μέρους  στο ενδιάμεσο ή στο τέλος απαιτεί χρονοβόρα διαδικασία ή και διαθέσιμο χώρο για αντίγραφα.\r\n\r\nΜπορούμε να χρησιμοποιήσουμε το <= για να μπορούμε να διαμορφώνουμε και σφαιρικά έγγραφα (καθολικά,  που τα βλέπουν όλα τα τμήματα). Για έγγραφα σε πίνακα (πρέπει να καθορίζουμε ξεχωριστά κάθε στοιχείο του πίνακα αλλιώς θα μένουν ότι δεν έχουμε αλλάξει σε απλά αλφαριθμητικά)\r\n\r\n
EN:DOC.WORDS(\r\nΈγγραφο α$=\"Γεια χαρά και ξανά γεια σου Κόσμε\"\r\nν=Εγγράφου.Λέξεις(α$)\r\nΛέξεις α$\r\nΓια ι=1 Έως ν\r\n      Τύπωσε Κεφ$(Γράμμα$)\r\nΕπόμενο ι\r\n\r\nΤο παράδειγμα δίνει τις λέξεις σε ταξινομημένη σειρά, χωρίς να ομαδοποιήσει τις όμοιες.\r\nΤο ν επιστρέφει τον αριθμό των λέξεων\r\nη εντολή λέξεις δίνει ανάλογα την επιλογή   Εγγράφου.Λέξεις() ή Εγγράφου.Μοναδικές.Λέξεις()\r\n\r\n
EN:DOC.LEN(\r\n\r\nΑ$={1η γραμμή\r\n            δεύτερη γραμμή\r\n            }\r\nΕΓΓΡΑΦΟ Α$\r\nΤΥΠΩΣΕ ΕΓΓΡΑΦΟΥ.ΜΗΚΟΣ(Α$)            ' υπολογιζει το μήκος χωρίς να φτιάξει αντίγραφο\r\nΤΥΠΩΣΕ ΜΗΚΟΣ(Α$)    ' εδω πρώτα φτιάχνει ένα αντίγραφο και μετά υπολογίζει το μήκος\r\n\r\nΔες εντολή ΕΓΓΡΑΦΟ\r\n
EN:DOC.UNIQUE.WORDS(\r\nΈγγραφο α$=\"Γεια χαρά και ξανά γεια σου Κόσμε\"\r\nν=Εγγράφου.Μοναδικές.Λέξεις(α$)\r\nΛέξεις α$\r\nΓια ι=1 Έως ν\r\n      Τύπωσε Κεφ$(Γράμμα$)\r\nΕπόμενο ι\r\nΤο παράδειγμα επιστρέφει ταξινομημένη τη λίστα των λέξεων και σε κάθε λέξη βάζει σε παρένθεση τον αριθμό εμφανίσεων.\r\nτο ν είναι ο αριθμός, αλλά για να πάρουμε τις λέξεις τις βάζει η εντολή Λέξεις στο σωρό τιμών\r\n\r\n
EN:DOC.PAR(\r\nΈγγραφο Α$, Β$\r\nΑ$={ααααααααααα\r\n            βββββββββ\r\n            γγγγγγγγ\r\n            }\r\nΒ$={\r\n}\r\nΤύπωσε Εγγράφου.Παρ(Α$), Εγγράφου.Παρ(Β$)\r\nΕπιστρέφει τον αριθμό παραγράφων\r\n\r\n
EN:WRITABLE(\r\nΤΥΠΩΣΕ ΕΓΓΡΑΨΙΜΟ(\"a:\")\r\n\r\n
EN:VALID(\r\n1) Έγκυρο(αριθμητική παράσταση)\r\nΤυπωσε Εγκυρο(Π(12))\r\n      Τυπώνει -1 αν υπάρχει στοιχείο πίνακα Π με δείκτη 12\r\nΤυπωσε Εγκυρο(π/ν)\r\n      αν το ν είναι μηδέν θα δώσει 0, αν δεν υπάρχουν οι μεταβλητές θα δώσει 0, αν υπάρχουν και βγαίνει αποτέλεσμα θα δώσει -1\r\n\r\n\r\nμεταξύ των παρενθέσεων της ΕΓΚΥΡΟ μπορούμε να βάλουμε ότι παράσταση θέλουμε και θα μας δώσει αντί για την τιμή αν είναι η παράσταση σωστή ή λάθος\r\n\r\nΕκτός από αυτή την συνάρτηση για να βρούμε λάθη και να τα ξεπεράσουμε, μπορούμε να χρησιμοποιήσουμε την ΔΕΣ όπου ελέγχει ολόκληρη ομάδα εντολών και μπορούμε να διαβάσουμε το λάθος σε νούμερο ΛΑΘΟΣ ή σε περιγραφή ΛΑΘΟΣ$ χωρίς να σταματήσει η ροή του προγράμματος!\r\n2) Έγκυρο(@αναγνωρισιτκό)\r\nσταθερή Μ=1000\r\nΧ=10\r\nΖ$=\"αλφα\"\r\nΠίνακας Α()\r\nΝ=(1,2,3,4,5)\r\nΛ=Σωρός:=1,2,3,4,5\r\nΟμάδα Αλφα { Χ=10, Υ=50, Α$=\"οκ\"}\r\nΤύπωσε Έγκυρο(@Χ), Έγκυρο(@Ζ$), Έγκυρο(@Α()), Έγκυρο(@Μ)\r\nΤύπωσε Έγκυρο(@Ν), Έγκυρο(@Λ), Έγκυρο(@Αλφα.Χ), Έγκυρο(@Αλφα.Α$)\r\n      δίνει -1 γιατί υπάρχει σαν αναγνωριστικό.  δεν εκτελεί παράσταση \r\nΓια αναγνωριστικά τμημάτων και συναρτήσεων χρησιμοποιούμε την Τμήμα()\r\n3) Έγκυρο(@αναγνωριστικό1 ως αναγνωριστικό2)\r\nΚοιτάει αν το αναγνωριστικό1 είναι του τύπου του αναγνωριστικό2\r\nΑν τα αναγνωριστικά είναι ομάδες τότε κοιτάει αν το πρώτο αναγνωριστικό έχει ίδια μέλη με αυτό του δεύτερου. Μπορεί το πρώτο αναγνωριστικό να έχει περισσότερα μέλη, αλλά αρκεί να έχει τα ιδια με το δεύτερο αναγνωριστικό. Η σύγκριση γίνεται σε ονόματα μόνο. Επίσης και τα ονόματα τμημάτων και συναρτήσεων, και των ομάδων στις ομάδες συμμετέχουν.\r\nΑν το αναγνωριστικό δύο έχει διαφορετική υπερικλάση από το ένα τότε δεν κοιτάει καθόλου τι μέλη υπάρχουν όμοια, και γυρίζει 0, δηλαδή ψευδές.\r\n\r\n
EN:BMP$(\r\nΔίνουμε ένα όνομα αρχείου BMP χωρίς κατάληξη και εξάγει αν υπάρχει το αρχείο το πλήρες όνομά του (με τη διεύθυνσή του και την κατάληξη BMP)\r\n\r\n
EN:IMAGE\r\n1) Εμφάνιση εικόνας στην οθόνη (bmp, wmf, emf, jpg, gif, ico)\r\nΕΙΚΟΝΑ \"αρχειο\" ,Χ[,Υ]\r\nΕικόνα Διάθρωση_Μνήμης_με_Εικόνα, Χ [,Υ]\r\n  Αν δώσουμε και Υ τότε αλλάζουμε την αναλογία Χ/Υ \r\n2) Μεταφορά εικόνας σε άλλη εικόνα. \r\nΕΙΚΟΝΑ εικόνα$ ΣΤΟ άλλη_εικόνα$  [ ( χρώμα_φόντου)]\r\nΕΙΚΟΝΑ Διάθρωση_Μνήμης_με_Εικόνα ΣΤΟ άλλη_εικόνα$\r\nΔες το Διάρθρωση() για να μεταφέρεις από αλφαριθμητικό σε νέα διάρθωση εικόνα\r\n  Η δεύτερη μπορεί να είναι μεταβλητή έτσι ώστε να φορτώνουμε εικόνες απ' ευθείας σε μεταβλητές\r\n3) Μεταφορά με αλλαγή μεγέθους\r\nΕΙΚΟΝΑ εικόνα$ ΣΤΟ άλλη_εικόνα$   [ ( χρώμα_φόντου)], ποσοστό_μεγέθους (για 100 το ίδιο μέγεθος)\r\n4) Μεταφορά με αλλαγή σχέσης πλάτους προς ύψος\r\nΕΙΚΟΝΑ εικόνα$ ΣΤΟ άλλη_εικόνα$, ποσοστό_πλάτους, ποσοστό_ύψους\r\n5) Εξαγωγή ως bmp\r\nΕΙΚΟΝΑ εικόνα$ ΕΞΑΓΩΓΗ αρχείο_εικόνας$ \r\n6) Εξαγωγή ως jpg με συμπίεση \r\nΕΙΚΟΝΑ εικόνα$ ΕΞΑΓΩΓΗ αρχείο_εικόνας$, ποσοστό_ποιότητας_συμπίεσης\r\nστο 100% έχουμε τη καλύτερη ποιότητα αλλά με μικρότερη συμπίεση (λιγότερη απώλεια)\r\n\r\n\r\n\r\n
EN:IMAGE(\r\nΠαράγει μια διάρθρωση μνήμης από μια εικόνα σε αλφαριθμητικό.\r\nΕικ1=Εικόνα(α$)\r\n\r\n
EN:IMAGE.Y(\r\nΤΥΠΩΣΕ ΕΙΚΟΝΑ.Υ(Α$)\r\nΤο Α$ πρέπει να περιέχει εικόνα. Η τιμή είναι σε twips και μας δίνει το ύψος της εικόνας.\r\n\r\nΤο Α πρέπει να είναι διάρθρωση μνήμης με εικόνα (φορτωμένο αρχείο)\r\nΤΥΠΩΣΕ ΕΙΚΟΝΑ.Υ(Α)\r\n\r\n
EN:IMAGE.Y.PIXELS(\r\nΤΥΠΩΣΕ ΕΙΚΟΝΑ.Υ.ΣΗΜΕΙΑ(Α$)\r\nΤο Α$ πρέπει να περιέχει εικόνα. Η τιμή είναι σε σημεία (pixels)  και μας δίνει το ύψος της εικόνας.\r\nΤΥΠΩΣΕ ΕΙΚΟΝΑ.Υ.ΣΗΜΕΙΑ(Α)\r\nΤο Α πρέπει να είναι διάρθρωση μνήμης με εικόνα (φορτωμένο αρχείο με Εικόνα())\r\n
EN:IMAGE.X(\r\nΤΥΠΩΣΕ ΕΙΚΟΝΑ.Χ(Α$)\r\nΤο Α$ πρέπει να περιέχει εικόνα. Η τιμή είναι σε twips και μας δίνει το πλάτος της εικόνας.\r\nΤΥΠΩΣΕ ΕΙΚΟΝΑ.Χ(Α)\r\nΤο Α πρέπει να είναι διάρθρωση μνήμης με εικόνα (φορτωμένο αρχείο με Εικόνα())\r\n
EN:IMAGE.X.PIXELS(\r\nΤΥΠΩΣΕ ΕΙΚΟΝΑ.Χ.ΣΗΜΕΙΑ(Α$)\r\nΤο Α$ πρέπει να περιέχει εικόνα. Η τιμή είναι σε σημεία (pixels)  και μας δίνει το πλάτος της εικόνας.\r\nΤΥΠΩΣΕ ΕΙΚΟΝΑ.Χ.ΣΗΜΕΙΑ(Α)\r\nΤο Α πρέπει να είναι διάρθρωση μνήμης με εικόνα (φορτωμένο αρχείο με Εικόνα())\r\n
EN:BITMAPS\r\nΕΙΚΟΝΕΣ\r\nΜας δίνει όλα τα αρχεία τύπου bmp στον τρέχον κατάλογο\r\nΊδιο με το ΑΡΧΕΙΑ \"bmp\"\r\n\r\nΚΑΤΑΛΟΓΟΣ \"C:\"\r\nΕΙΚΟΝΕΣ\r\nΕΙΚΟΝΕΣ !                     ' αλλάζει το τρόπο ταξινόμησης...το κάνει εδώ βάση ονόματος.\r\nΑΡΧΕΙΑ \"bmp\"\r\n\r\n\r\n
EN:ICON\r\nΕάν έχουμε θέσει τίτλο (δες ΤΙΤΛΟΣ) τότε μπορούμε να αλλάξουμε εικονίδιο\r\nΕΙΚΟΝΙΔΙΟ \"ταδε.ico\"\r\n\r\n
EN:IS\r\nΤελεστής Είναι\r\n\\\\ μόνο για αντικείμενα α και β\r\nΤύπωσε α είναι β\r\n\r\n
EN:ISNUM\r\nΑν υπάρχει αριθμός στην κορυφή του σωρού τότε δίνει ΑΛΗΘΕΣ\r\n\r\n
EN:ISLET\r\nΑν υπάρχει λέξη στην κορυφή του σωρού τότε δίνει ΑΛΗΘΕΣ\r\n(δεν βγαίνει λάθος αν )\r\n\r\n
EN:INPUT\r\n1)ΕΙΣΑΓΩΓΗ Α$\r\n\r\n2)ΕΙΣΑΓΩΓΗ \"Χ=\",Α\r\nμε ; ανάμεσα σε δυο αριθμητικές μεταβλητές ζητάει κόμμα ή αλλαγή γραμμής και η επιγραφή εμφανίζεται μόνο την πρώτη φορά.\r\nΣτο τέλος ενα \";\" δουλεύει όπως στην Τύπωσε, κολάει τον δρομέα στην άκρη (δεν αλλάζει γραμμή).\r\n3)ΕΙΣΑΓΩΓΗ #Α, Α$,Β,Κ$\r\nεισάγει από αρχείο σε UNICODE ή ANSI ανάλογα με την εντολή ΑΝΟΙΞΕ που έχουμε δώσει.\r\nΠαράδειγμα εξαγωγής csv αρχείου. Βγάλτε το Ευρεία για εξαγωγή/εισαγωγή με ένα Ψηφίο (byte) ανά χαρακτήρα.\r\nΓράψε με χαρ$(9), \",\", αληθές  'αληθές σημαίνει ότι τα αλφαριθμητικά θα κωδικοποιούνται κατά json\r\nΓράψε με χαρ$(9), \",\"[, αληθές [, αληθές ]  ' το δεύτερο αληθές (μη μηδεν) )σημαίνει να μην μπουν εισαγωγικά στο αλφαριθμητικά.\r\n\r\nΆνοιξε \"my.dat\" για ευρεία εξαγωγή ως #κ\r\nΓράψε  #κ, \"Row 1\", -213231313132312.23123@, -52322323.32#, -1.2121e+10\r\nΓράψε  #κ, {Line1\r\n                        Line2\r\n                        Line3\r\n                        }\r\nΚλείσε #κ\r\n\\\\ κατά json σημαίνει ότι ειδικοί χαρακτήρες κωδικοποιούνται ώστε να γράφεται\r\n\\\\ το αλφαριθμητικό με πολλές γραμμές χωρίς να έχει μέσα του αλλαγές γραμμών\r\n\\\\ και άλλοι χαρακτήρες κωδικοποιούνται αλλά εμάς μας ενδιαφέρει ότι βάζουμε \r\n\\\\ ένα κείμενο σε μια γραμμή!\r\nΕισαγωγή με χαρ$(9), \",\", αληθές  'αληθές σημαίνει ότι τα αλφαριθμητικά θα διαβάζονται κατά json\r\nΆνοιξε \"my.dat\" για ευρεία Εισαγωγή ως #κ\r\nΕισαγωγή #κ, R$, M1=0@, Z1=0#, check\r\nΕισαγωγή #κ, Txt$\r\nΚλείσε #κ\r\nΤύπωσε R$, M1, Z1, check\r\nΤύπωσε Τύπος$(M1), Τύπος$(Z1)\r\nΤύπωσε M1\r\nΤύπωσε Z1\r\nΑναφορά txt$  ' η αναφορά τυπώνει κείμενα\r\n\\\\ αν το κείμενο έχει πολλές γραμμές σταματάει...\r\n\\\\ για να μας δείξει μέρος και συνεχίζει με διάστημα, ή με πλήκτρο ποντικιού.\r\n\r\n\r\n\r\n4) ΕΙΣΑΓΩΓΗ ! μεταβλητη$, πλατος  [Μήκος=20]  εξ ορισμού το μέγιστο μήκος για τη μεταβλητή είναι το 50\r\n4.1) ΕΙΣΑΓΩΓΗ ! μεταβλητη, πλατος   \\\\ μόνο για αριθμό  - όχι για τύπου Long\r\n4.2) ΕΙΣΑΓΩΓΗ ! μεταβλητη%, πλατος   \\\\ μόνο για αριθμό  ακέραιο, όχι τύπου Long. Πέρνει μέχρι 16 ψηφία.\r\n  με Esc επιστρέφει η παλιά τιμή. Διαβάζει και στοιχεία πινάκων. Τι απλές μεταβλητές τις δημιουργεί αν δεν υπάρχουν\r\n  η μεταβλητή μόνο ανάγνωσης Πεδίο δίνει 99 για το Esc, -1 για το πάνω βελάκι και 1 για το κάτω και το enter.\r\n  με χρήση του Θέσε Διακόπτες \"+INP\" το Πεδίο γυρίζει 13 αν πατήσουμε το Enter (κανονικά γυρίζει 1)\r\n5) ΕΙΣΑΓΩΓΗ ! μεταβλητη$, πλατος, υψος  [, Τίτλος$]\r\n5.1) ΕΙΣΑΓΩΓΗ ! μεταβλητη$, πλατος, υψος , Τίτλος$, θέση δρομέα.\r\n Η θέση δρομέα όσο το μήκος συν ένα πάει το δρομέα στο τέλος.\r\n  Και οι δυο παραλλαγές μας δίνουν έναν τρόπο να εισάγουμε κείμενο σε μια μεταβλητή.\r\n  \r\n Επιπλέον από την έκδοση 3 έχει προστεθεί και η παρακάτω αντικατάσταση:\r\nΑ$={Πρώτη γραμμή κειμένου\r\nΔεύτερη γραμμή κειμένου\r\n...\r\n...sdsdsds\r\n}\r\nΜια ΤΥΠΩΣΕ Α$ δεν τυπώνει σωστά το κείμενο, διότι δεν λογαριάζει τις αλλαγές γραμμών που έχουν καταχωρηθεί στο Α$. Πρέπει να χρησιμοποιηθεί η ΕΠΙΓΡΑΦΗ !  ή η Αναφορά.\r\n\r\n
EN:INPUT$(\r\nΑ$=ΕΙΣΑΓΩΓΗ$(#ΑΡΧΕΙΟ, 20)\r\nΔιαβάζει είκοσι χαρακτήρες από το ανοιχτό αρχείο για εισαγωγή, στο τρέχοντα σημείο ανάγνωσης τους δρομεά του αρχείου. Μετά την ανάγνωση ο δρομέας προχωράει 20 θέσεις (χαρακτήρων, άρα 1 ή 2 bytes ανάλογα τον τύπο αρχείου, απλά εδώ στο διάβασμα μας ενδιαφέρει να πάρουμε συγκεκριμένους χαρακτήρες άρα πρέπε να έχουμε ανοίξει σωστά το αρχείο).\r\nΜπορούμε να μετακινήσουμε το δρομέα πριν διαβάσουμε, με την εντολή ΜΕΤΑΘΕΣΗ #ΑΡΧΕΙΟ, 100.  Η εντολή ΜΕΤΑΘΕΣΗ λογαριάζει θέσει σε Bytes πάντα. Μπορούμε να χρησιμοποιούμε την ΤΕΛΟΣ() για να γνωρίζουμε αν σημάνθηκε το τέλος στο διάβασμα του αρχείου (ο δρομέας πέρασε το τελευταίο χαρακτήρα, στους χαρακτήρες λογαριάζονται και οι αλλαγές γραμμών)\r\nΜπορούμε να διαβάσουμε UNICODE αν ορίσουμε ΓΙΑ ΕΥΡΙΑ ΕΙΣΑΓΩΓΗ στο ΑΝΟΙΞΕ\r\n\r\nΗ ΓΡΑΜΜΗ ΕΙΣΑΓΩΓΗΣ δεν φέρνει τις αλλαγές γραμμών αλλά σταματάει σε αυτές το διάβασμα και τοποθετή τον δρομέα στην επόμενη γραμμή, αφήνοντας την αλλαγή γραμμή (που μπορεί να είναι δυο χαρακτήρες)\r\n\r\n
EN:VERSION\r\nΕΚΔΟΣΗ\r\nΤυπώνει τον αριθμό έκδοσης της γλώσσας (υπάρχει και η μεταβλητή ΕΚΔΟΣΗ για έλεγχο μέσα από το πρόγραμμα.\r\n\r\n
EN:VERSION_as constant\r\nΤΥΠΩΣΕ ΕΚΔΟΣΗ\r\nτυπώνει τον αριθμό έκδοσης της γλώσσας, όπως η εντολή ΕΚΔΟΣΗ αλλά ως σταθερά\r\n\r\n\r\n
EN:EXECUTE\r\n1. Για βάσεις δεδομένων:\r\nΕΚΤΕΛΕΣΗ βαση, αλφαριθμητικόεκτέλεσης\r\nΕΚΤΕΛΕΣΗ βαση, αλφαριθμητικόεκτέλεσης, χρόνοςεξόδου\r\nεξ ορισμού χρόνοςεξόδου = 30 (ελάχιστο 10)\r\n\r\nΣε μια βάση δεδομένων μπορούμε να εκτελέσουμε εντολές όπως CREATE TABLE, INSERT INTO, SELECT\r\nΑυτό γίνεται με την ΕΚΤΕΛΕΣΗ.  Στη Select επιστρέφεται αντικείμενο Recordset, με αντίγραφο των στοιχείων που ζητάμε.\r\n\r\n\r\nΜπορούμε να φτιάξουμε ένα Αρχείο στη βάση με αυτή την εντολή (με χρήση της Create Table), ή περισσότερα με χρήση του ; μεταξύ των εντολών.\r\nΔες το παράδειγμα στα αγγλικά εδώ EXECUTE\r\n\r\n2. Για εκτέλεση κώδικα\r\nΕκτέλεση Κώδικα  ΔιάρθρωσηΑ, 0\r\nΕκτελεί το κώδικα σε Διάρθρωση που φτιάξαμε ως Διάρθρωση Κώδικα \r\nΠρέπει να υπάρχει το 0xC3 ως επιστροφή από τη κλήση αλλιώς υπάρχει πρόβλημα!\r\n\r\n\\\\ Φτιάχνουμε μια διάρθρωση μνήμης για δεδομένα\r\nΔιάρθρωση Δεδομένα ως Μακρύς*10\r\nΕπιστροφή Δεδομένα, 1:=500\r\nΔιάρθρωση Κώδικα Εκτελέσιμη ως ψηφίο*1024\r\n\\\\ δες εδώ https://defuse.ca/online-x86-assembler.htm\r\n\\\\ μετατρέπει την Assembly σε γλώσσα μηχανής\r\nΔιεύθυνση=0\r\n\\\\ x86 Γλώσσα Μηχανής\r\n\\\\ Το Δεδομένα(0) γυρνάει την διεύθυνση του πρώτου μακρύ (Long)\r\n\\\\ Το Δεδομένα(1) γυρνάει την διεύθυνση του δεύτερου μακρύ\r\nΚωδΜακρύς(0xb8, 5100)  ' mov eax,0xa     ' 10 στο eax\r\nΚωδΨηφΨηφ(0x83, 0xC0 ,5)  ' add  eax,0x5   ' πρόσθεσε 5 στο eax\r\nΚωδΨηφΜακρύς(0x3,0x5, Δεδομένα(1)) ' add eax, [Δεδομένα(1)]  ' πρόσθεσε στο eax το 500 από το δεύερο μακρύ στο Δεδομένα\r\nΚωδΜακρύς(0xa3, Δεδομένα(0))  ' mov [Δεδομένα(0)], eax\r\nΣημ : ΚωδΨηφ(0x31, 0xC0)  ' xor eax, eax 'σημαίνει eax=0  ' χωρίς αυτό θα πάρουμε το  5605 στο Μ\r\nΕπιστροφή() ' Επιστροφή\r\n\\\\ Τέλος Κώδικα\r\nΔες οκ {\r\n      Εκτέλεση Κώδικα Εκτελέσιμη, 0\r\n}\r\nΜ=Δυαδικό.Ακέραιο(Λάθος)\r\nΔεκαεξ Μ\r\nΤύπωσε Μ\r\nΤύπωσε Λάθος, οκ\r\nΤύπωσε Εκφρ(Δεδομένα, 0)  ' 5605\r\n\r\nΡουτίνα Επιστροφή()\r\n      Επιστροφή Εκτελέσιμη, Διεύθυνση:=0xC3  \r\n      Διεύθυνση++\r\nΤέλος Ρουτίνας\r\nΡουτίνα ΚωδΨηφΨηφ() \r\n      Επιστροφή Εκτελέσιμη, Διεύθυνση:=Αριθμός, Διεύθυνση+1:=Αριθμός, Διεύθυνση+2:=Αριθμός\r\n      Διεύθυνση+=3\r\nΤέλος Ρουτίνας\r\nΡουτίνα ΚωδΨηφ()\r\n      Επιστροφή Εκτελέσιμη, Διεύθυνση:=Αριθμός, Διεύθυνση+1:=Αριθμός\r\n      Διεύθυνση+=2\r\nΤέλος Ρουτίνας\r\nΡουτίνα ΚωδΜακρύς()\r\n      Επιστροφή Εκτελέσιμη, Διεύθυνση:=Αριθμός, Διεύθυνση+1:=Αριθμός ως Μακρύς\r\n      Διεύθυνση+=5\r\nΤέλος Ρουτίνας\r\nΡουτίνα ΚωδΨηφΜακρύς() \r\n      Επιστροφή Εκτελέσιμη, Διεύθυνση:=Αριθμός, Διεύθυνση+1:=Αριθμός, Διεύθυνση+2:=Αριθμός ως Μακρύς\r\n      Διεύθυνση+=6\r\nΤέλος Ρουτίνας\r\n\r\n\r\n\r\n
EN:PRINTINGS\r\nΕΚΤΥΠΩΣΕΙΣ\r\nΕΚΤΥΠΩΣΗ, ΕΚΤΥΠΩΤΗΣ, ΙΔΙΟΤΗΤΕΣ, ΣΕΛΙΔΑ\r\n
EN:PRINTING\r\nΕΚΤΥΠΩΣΗ ΝΑΙ\r\nΕΚΤΥΠΩΣΗ ΔΙΕΚΟΨΕ\r\nΣΕΛΙΔΑ\r\nΕΚΤΥΠΩΣΗ ΟΧΙ\r\n\r\nΜεταξύ των δυο αυτών εντολών μπορούμε να τυπώνουμε στον τρέχον εκτυπωτή.\r\nΔες ΣΕΛΙΔΑ\r\nΑυτή η εντολή υπάρχει λόγο συμβατότητας με προηγούμενες εκδόσεις.\r\nΔες ΕΚΤΥΠΩΤΗΣ\r\n\r\n
EN:PRINTER\r\n1) Στέλνουμε ένα τμήμα για εκτύπωση\r\n\r\nΕΚΤΥΠΩΤΗΣ {\r\n...\r\n}\r\n\r\n2) Όπως η 1 αλλά αλλάζουμε και το μέγεθος των γραμμάτων\r\nΕΚΤΥΠΩΤΗΣ 10 {\r\n...\r\n}\r\n3) Αλλαγή ιδιοτήτων εκτυπωτή\r\nΕΚΤΥΠΩΤΗΣ !\r\nΗ Μ2000 κρατάει για κάθε εκτυπωτή στοιχεία, τα οποία μπορεί να διαβάσει οποτεδήποτε. Αλλά μπορεί επίσης να τα αλλάξει ή ακόμα καλύτερα μπορεί να τα αποθηκεύσει χωριστά και να τα χρησιμοποιεί όποτε είναι αναγκαίο χωρίς να χρειάζεται ο χρήστης να ξαναρυθμίζει τον εκτυπωτή μέσω του διαλόγου των ιδιοτήτων. Δες το ΙΔΙΟΤΗΤΕΣ\r\n\r\n\r\n4) Αλλαγή εκτυπωτή τρόπος με επιλογή από λίστα\r\nΕΚΤΥΠΩΤΗΣ ?\r\nΟ αρχικός εκτυπωτής που δείχνει η λίστα είναι ο προεπιλεγμένος από τα Windows\r\nμπορούμε να διαβάσουμε το όνομα του εκτυπωτή από την εκτυπωτής$\r\nαφού ανοίξει μια φορά η λίστα θα γεμίσει ο πίνακας Επιλογή$()\r\nΗ μεταβλητή επιλογή θα είναι 0 αν δεν έχουμε κάνει επιλογή (πχ πατήσαμε το Esc)\r\n\r\n5) Αλλαγή εκτυπωτή τρόπος με απ' ευθείας επιλογή \r\nΕΚΤΥΠΩΤΗΣ 12, αλφαριθμητικό\r\nτο αλφαριθμητικό πρέπει να περιέχει το όνομα, διάστημα, παρένθεση, όνομα πόρτας, παρένθεση\r\nπαράδειγμα\r\nΕΚΤΥΠΩΤΗΣ?\r\nΤΥΠΩΣΕ ΕΠΙΛΟΓΗ$(ΕΠΙΛΟΓΗ)\r\nΤΥΠΩΣΕ \"-----------------------\"\r\nΕΚΤΥΠΩΤΗΣ 12, ΕΠΙΛΟΓΗ$(ΕΠΙΛΟΓΗ)\r\nΕΠΙΛΟΓΗ!\r\n\r\n6) Αναφορά επιλεγμένου εκτυπωτή\r\nΕΚΤΥΠΩΤΗΣ\r\nΤυπώνει τον επιλεγμένο εκτυπωτή και αλλάζει γραμμή\r\n? εκτυπωτής$  \\\\ δίνει το όνομα και τη θύρα του εκτυπωτή.\r\n\r\n\r\n
EN:PRINTERNAME$\r\n? ΕΚΤΥΠΩΤΗΣ$\r\nόνομα εκτυπωτή (και πόρτα)\r\n\r\n
EN:EVAL$(\r\nΕΚΦΡΑΣΗ$() ή ΕΚΦΡ$()\r\nείναι η αντίστοιχη ΕΚΦΡ$() για αλφαριθμητικά\r\n1) Χρήση της Εκφρ$() για άμεση χρήση δείκτη  (οι δείκτες σε μεταβλητές στη Μ2000 είναι αλφαριθμητικά)\r\nα$=\"οκ\"\r\nβ$=Ισχνή$(α$)\r\n\\\\ δείτε παρακάτω ότι η β$ έχει μια τελεία μετά το $\r\nβ$.=\"ναι\"   \\\\ η β$ περιέχει δείκτη στην α$, οπότε η τιμή \"ναι\" πάει στην α$\r\n\r\nΤύπωσε α$\r\nΤύπωσε Εκφρ$(β$.)  \\\\ \"ναι\"  \\\\  δες την τελεία μετά το $\r\nΤύπωσε Εκφρ$(β$)=β$ \\\\ δίνει το περιεχόμενο του β$, όχι αυτό που δείχνει αυτό!\r\n\r\n2) Χρήση της Εκφρ$() με αντικείμενο Κατάσταση\r\n\\\\ οι καταστάσεις έχουν κλειδιά και τιμές, ή αν δεν έχουν τιμή σε κλειδί, τότε γυρνάει ως τιμή το κλειδί\r\nΚατάσταση άλφα=1,\"200\",3:=500,4\r\nβ=Κάθε(άλφα)\r\nΕνώ β {\r\n      \\\\ δείτε το ! στο πρώτο Εκφρ(), λέει στο διερμηνευτή ότι θέλουμε το κλειδί\r\n      Τύπωσε Εκφρ$(β!), Εκφρ$(β)  ' Κλειδί, στοιχείο ως αλφαριθμητικό\r\n}\r\n\r\n3) Χρήση Εκφρ$() με αντικείμενο Διάρθρωση. Δείτε πως διαβάζουμε αλφαριθμητικό από θέση στη μνήμη:\r\nΔομή άλφα {\r\n     A as Μακρύς   \\\\ 32 δυαδικών ψηφίων\r\n     β ως Ακέραιος*40 \\\\ ο Ακέραιος εδώ είναι 16 δυαδικών ψηφίων\r\n}\r\nΤύπωσε Μήκος(άλφα)   \\\\ 4 byte + 2 byte * 40 = 84\r\nΔιάρθρωση Κενή β1 ως άλφα*20   \\\\ 84*20=1680 Bytes\r\nΤύπωσε Μήκος(β1)\r\nΤύπωσε Μήκος(\"Γεια χαρά!.........................1234567\")  ' 42\r\nΕπιστροφή β1, 3!β:=Πεδίο$(\"Γεια χαρά!.........................1234567\",40)\r\nΤύπωσε Εκφρ$(β1, 3!β, 40*2)\r\n\\\\ διαβάζουμε από τη θέση μνήμης β1+3*84+4, 40*2 = 80 bytes\r\n\\\\ ο αριθμός 3 δείχνει στην Εκφρ$() ότι μας ενδιαφέρει το τέταρτο άλφα, που έχει διεύθυνση από την αρχή, το β1, όσο 3 άλφα, άρα 3*84, και επιπλέον θέλουμε να διαβάσουμε από το β πεδίο της δομής άλφα, δηλαδή αμέσως μετά το πρώτο, που είναι 4 bytes. Ζητάμε 2*40 bytes.\r\n\\\\ εδώ γράφουμε χαρακτήρες ανά Byte\r\nΕπιστροφή β1, 10!β:=Γραφή$(\"Γεια\")\r\n\\\\ διαβάζουμε σαν να είχαμε δυο byte ανά χαρακτήρα, και μετά γίνεται μετατροπή με την Χαρ$()\r\n\\\\ εδώ θέλουμε μόνο 4 Bytes\r\nΤύπωσε Χαρ$(Εκφρ$(β1, 10!β, 2*2))\r\n\\\\ ενώ εδώ βάζουμε σε Unicode 16LE, και θέλουμε 8 bytes για να διαβάσουμε\r\nΕπιστροφή β1, 10!β:=\"Γεια\"\r\nΤύπωσε Εκφρ$(β1, 10!β, 8)\r\n\r\n\r\n
EN:EVAL(\r\nΧ=2\r\nΤΥΠΩΣΕ ΕΚΦΡ(\"Χ**2\")\r\nδίνει το 4\r\n\r\nΠροσοχή στην ΕΓΚΥΡΟ(\r\nη ΕΓΚΥΡΟ(\"Χ**2\") δίνει -1 όχι γιατί είναι ελεγμένη η έκφραση  Χ**2 αλλά γιατί ανάμεσα στις παρενθέσεις υπάρχει αλφαριθμητικό και αυτό είναι έγκυρο!\r\n\r\nΓια να πιάσουμε το λάθος πριν γίνει θα πρέπει να βάλουμε την ΕΚΦΡ(\"κατι\") σε μια δομή ΔΕΣ\r\n\r\nΔΕΣ ΚΚ {\r\nΤΥΠΩΣΕ ΕΚΦΡ(\"Χ**2\")\r\n}\r\nΑν Οχι ΚΚ Τοτε Τυπωσε\"Πρόβλημα με την έκφραση\"\r\n' δεν σταματάει η ροή του προγράμματος\r\n\r\nΑν δεν βάλουμε την ΔΕΣ τότε θα παραχθεί λάθος και αυτό θα βγει  παραέξω, μέχρι να το πιάσει κάποια άλλη ΔΕΣ παραπάνω η αν δεν υπάρχει να βγούμε στην γραμμή εντολών και να πάρουμε το μήνυμα ότι υπάρχει λάθος έκφραση το αλφαριθμητικό.\r\n\r\n
EN:ISWINE\r\nΤύπωσε ISWINE\r\nεπιστρέφει -1 αν ο διερμηνευτής τρέχει σε Linux με Wine\r\n\r\n
EN:OSBIT\r\nΤύπωσε OSBIT\r\nτυπώνει 32 ή 64 ανάλογα τι είναι τι είδους λειτουργικό σύστημα έχουμε\r\nΔες IsWine, ΛΣ$\r\n\r\n\r\n
EN:$(\r\nΗ $( ) είναι εσωτερική συνάρτηση της ΤΥΠΩΣΕ.\r\nΤΥΠΩΣΕ \r\n\r\n$(στοίχιση) \r\n$(στοίχιση, πλάτος στήλης)\r\n$(φόρμα$)\r\n$(φόρμα$ , πλάτος στήλης)\r\n\r\nστοίχιση αποτελέσματος αριθμητικών και λογικών  παραστάσεων: \r\n0 = δεξιά, 1 = αριστερά, 2 = κέντρο, 3 = δεξιά  - με σταθερά διαστήματα (όπως οι παλιές γραφομηχανές)\r\n4 = δεξιά, 5 = αριστερά, 6 = κέντρο, 7=δεξιά ,8 = δεξιά και αριστερά μαζί -   με αναλογικά διαστήματα (όπως στις εφημερίδες)\r\n\r\nστοίχιση αποτελέσματος αλφαριθμητικών παραστάσεων:\r\n0 = αριστερά, 1 = αριστερά, 2 = κέντρο, 3 = δεξιά   με σταθερά διαστήματα (όπως οι παλιές γραφομηχανές)  \r\n4 = αριστερά, 5 = αριστερά, 6 = κέντρο, 7 = δεξιά , 8 =  αριστερά  με αναλογικά διαστήματα (όπως στις εφημερίδες)\r\nστα 0 και 4 τα αλφαριθμητικά γεμίζουν όσες στήλες χρειαστούν. Σε όλα τα άλλα γίνεται αποκοπή.\r\n\r\n            Παράδειγμα - σε αυτό η αλλαγή γραμμής γίνεται με την ΔΡΟΜΕΑΣ ή CURSOR όπου δεν γίνεται ανανέωση στην οθόνη, οπότε εμφανίζεται σε κάθε πάτημα πλήκτρου όλη η αλλαγή των στοιχείων στην οθόνη.\r\nΓράφουμε edit a και κάνουμε επικόλληση το παρακάτω και μετά esc για να επιστρέψουμε στην γραμμή εντολών και δίνουμε a για να τρέξει το τμήμα\r\nFlush\r\nj=1\r\nForm 80,32\r\nRepeat {\r\n      j=j+1\r\n      Cls\r\n      Print \"Example for types of Print, Column:\";j;\" charcters\";\r\n      Cursor 0,Row+1\r\n      Data 0,1,2,3,4,5,6,7, 8\r\n      Repeat  {\r\n            Read i\r\n            Print $(I,j),145355,\"George Karras\", \"The Best\",\r\n            Cursor 0,Row+1\r\n      } Until Empty\r\n      Cursor 0,Row+1\r\n      Print $(0);\"press any key\"\r\n      a$=Key$\r\n} Until j=25\r\nPrint\r\n\r\n \r\nφόρμα$: αλφαριθμητικό δες παρακάτω.\r\nπλάτος στήλης (μπορούμε να δώσουμε μέχρι το μέγιστο που είναι το πλάτος οθόνης)\r\n\r\nΠαρατήρηση: Όταν ένας αριθμός έχει πλάτος μεγαλύτερο της στήλης και δεν έχουμε ορίσει φόρμα τότε αν η στοίχιση είναι δεξιά ή αριστερά, ο αριθμός θα καταλάβει όσες στήλες χρειασθεί.\r\n\r\nΟυσιαστικά αυτή η συνάρτηση είναι δυο! Μία για την στοίχιση και μία για το φορμάρισμα των εξαγομένων αριθμών ή και αλφαριθμητικών. Και οι δυο παραλλαγές ισχύουν μέχρι να ξαναδώσουμε μια ίδια εντολή αλλά με άλλες παραμέτρους. Η $(\"\") τερματίζει την χρήση φόρμας\r\n\r\n\r\nΔΕΣ \"ΦΟΡΜΑΡΙΣΜΑ ΑΛΦΑΡΙΘΜΗΤΙΚΩΝ\"\r\nΔΕΣ \"ΦΟΡΜΑΡΙΣΜΑ ΑΡΙΘΜΩΝ\"\r\nΔΕΣ \"ΦΟΡΜΑΡΙΣΜΑ ΗΜΕΡΟΜΗΝΙΩΝ ΚΑΙ ΩΡΑΣ\"\r\nΔΕΣ \"ΦΟΡΜΑΡΙΣΜΑ ΓΙΑ ΚΑΘΕ ΤΥΠΟ\"\r\n\r\n\r\n
EN:?\r\nΔες Τύπωσε\r\n\r\n
EN:@(\r\nΗ@( ) είναι εσωτερική συνάρτηση της ΤΥΠΩΣΕ.\r\nΤΥΠΩΣΕ @(10,10);\"ΓΕΙΑ ΧΑΡΑ\"\r\n\r\n@( Χ )\r\n@( ,Υ)\r\n@( Χ, Υ)\r\n@( Χ, Υ, Χ1 ,Υ1, ΧΡ)\r\n@( Χ, Υ, Χ1, Υ1, ΧΡ, ΠΕΡ)\r\n@( Χ, Υ, Χ1, Υ1, \"όνομα αρχείου γραφικών\")\r\n@( Χ, Υ, Χ1, Υ1, \"όνομα αρχείου γραφικών\", 1)\r\n\r\nΤα Χ, Υ μεταθέτουν σε απόλυτη θέση τον δρομέα. Υπάρχει και εντολή που το κάνει χωρίς να δώσουμε το π.χ. ΤΥΠΩΣΕ @(10,5); αλλά το ΔΡΟΜΕΑΣ 10,5\r\nτα Χ1 και Υ1 ορίζουν ένα σημείο πιο δεξιά και πιο κάτω από τα Χ και Υ όπου θα βάψουμε, ή και θα βάλουμε περίγραμμα τα χρώματα των οποίων θα είναι το ΧΡ και ΠΕΡ. \r\nΕπίσης αντί να βάψουμε μπορούμε να τοποθετήσουμε ένα γραφικό δίνοντας το όνομα του αρχείου μαζί με το μονοπάτι όπου βρίσκεται στον δίσκο (θα το δούμε αυτό αργότερα)\r\nΕπειδή ορίζουμε με τα Χ,Υ και Χ1,Υ1 δική μας αναλογία πλευρών Χ1-Χ προς Υ1-Υ μπορούμε να απλώσουμε ή όχι μια εικόνα. Αν την απλώσουμε θα καλύπτει όλο το τετράπλευρο, διαφορετικά αν δώσουμε την τελευταία παραλλαγή θα κρατήσει την αναλογία της εικόνας και θα επεκτείνει ή θα μικρύνει ανάλογα την Υ διάσταση.\r\nΆρα αν και δεν βάφει αυτόματα η Μ2000 πίσω από τους χαρακτήρες (στο φόντο), στην ΤΥΠΩΣΕ με την @( ) μπορεί να το κάνει.\r\nΚαι κάτι τελευταίο, οι εικόνες μπορεί να είναι jpg, bmp αλλά και σχέδια wmf ή emf. Ειδικά για τα σχέδια wmf και emf αυτά αναπαράγονται χωρίς να αλλάζουν τον φόντο (διάφανα).\r\n\r\n\r\n
EN:~(\r\nΤύπωσε ~(#12ff00), \"Άλφα\"\r\n
EN:MONITOR\r\nΕΛΕΓΧΟΣ   στη γραμμή εντολών \r\nή ΘΕΣΕ ΕΛΕΓΧΟΣ  σε πρόγραμμα\r\nΕμφανίζει πληροφορίες σχετικές με τον τρέχον διερμηνευτή\r\n\r\n\r\n
EN:MONITOR.STACK.SIZE\r\nΤύπωσε ΕΛΕΓΧΟΣ.ΜΕΓΕΘΟΣ.ΣΩΡΟΥ\r\nΤυπώνει το μέγεθος του σωρού επιστροφής, που μπορούμε να χρησιμοποιήσουμε.\r\nΤύπωσε ΕΛΕΓΧΟΣ.ΜΕΓΕΘΟΣ.ΣΩΡΟΥ-ΕΛΕΓΧΟΣ.ΣΩΡΟΥ\r\nΤυπώνει το μέγεθος του ελεύθερου υπόλοιπου του σωρού.\r\n\r\n\r\n
EN:MONITOR.STACK\r\nΤύπωσε ΕΛΕΓΧΟΣ.ΣΩΡΟΥ\r\nδίνει το μέγεθος του σωρού επιστροφής του διερμηνευτή σε χρήση\r\nΟι μεταβλητές/πίνακες  της Μ2000 δεν αυξάνουν τον σωρό.\r\nΟι κλήσεις των ρουτινών επίσεις δεν αυξάνουν τον σωρό. Δες Όριο.Αναδρομής\r\nΟι κλήσεις συναρτήσεων και τμημάτων αυξάνουν τον σωρό\r\nΟι παραστάσεις με τελεστές αυξάνουν τον σωρό\r\nΔες ΕΛΕΓΧΟΣ.ΜΕΓΕΘΟΣ.ΣΩΡΟΥ και ΕΛΕΓΧΟΣ\r\n
EN:GREEK\r\nΕΛΛΗΝΙΚΑ\r\nαλλάζει την κωδικοσελίδα αλλά και τη γλώσσα που εμφανίζονται τα μυνήματα λάθους \r\nΔΕΣ ΛΑΤΙΝΙΚΑ, ΧΑΡΑΚΤΗΡΕΣ\r\n\r\n\r\n
EN:GREEK_variable\r\nΤύπωσε ΕΛΛΗΝΙΚΑ\r\nγυρνάει αληθής αν έχουμε μηνύματα διαλόγων στα ελληνικά\r\nμε Θέσε Διακόπτες \"+GREEK\"  κάνουμε το ΕΛΛΗΝΙΚΑ αληθής\r\nμε Θέσε Διακόπτες \"+GREEK\"  κάνουμε το ΕΛΛΗΝΙΚΑ ψευδής\r\n\r\nΚαι η εντολή ΕΛΛΗΝΙΚΑ θέτει το ΕΛΛΗΝΙΚΑ αληθής αλλά θέτει και το Τοπικό στο 1032\r\nΤο ΛΑΤΙΝΙΚΑ κάνει το ανάποδο από το ΕΛΛΗΝΙΚΑ, οπότε θέτει την μεταβλητή ΕΛΛΗΝΙΚΑ ψευδής και το τοπικό στο 1033\r\n\r\n
EN:TEMPNAME$\r\nα$=εναονομα$\r\nδημιουργούμε ένα νέο όνομα αρχείου για προσωρινή χρήση με κατάληξη .tmp\r\nΜετά θα δημιουργήσουμε το αρχείο (θα είναι στο φάκελο των προσωρινών αρχείων). Μάλιστα αυτό το όνομα είναι μοναδικό, οπότε κανένα άλλο πρόγραμμα δεν θα τύχει να δημιουργήσει το ίδιο. (και αυτή είναι η σκοπιμότητα της μεταβλητής μόνο ανάγνωσης)\r\n\r\n
EN:INLINE\r\nα$=Παράθεση$(1,\"αλφαριθμητικό\",2,3)\r\nΈνθεση \"Σειρά \"+α$       'βάζει τη γραμμή Σειρά 1, \"αλφαριθμητικό\", 2, 3\r\n\r\nΗ ένθεση παρεμβάλει κώδικα που παίρνει από ένα αλφαριθμητικό και εκτελείται άμεσα.\r\nΜπορεί κανείς να βάλει σε έναν πίνακα εναλλακτικές ομάδες εντολών και να εκτελέσει κατά περίπτωση μια. Η θα μπορούσε ένα πρόγραμμα να λάβει από αυλό σειρά εντολών για να εκτελέσει.\r\n\r\nΧ=1\r\nΤμήμα Άλφα {\r\n      Χ++\r\n      Τύπωσε Χ\r\n}\r\nΈνθεση Κώδικα Άλφα, Άλφα\r\n\r\nΜπορούμε να ξέρουμε πότε υπάρχει ένα τμήμα ή μια συνάρτηση χωρίς να την καλέσουμε με χρήστη της συνάρτησης Τμήμα()\r\n\r\nΤύπωσε Τμήμα(Άλφα)   \\\\ δίνει ένα για τον προηγούμενο κώδικα\r\n\r\n
EN:INKEY$\r\nΕπιστρέφει έναν χαρακτήρα που έχουμε μόλις πληκτρολογήσει ή το κενό αλφαριθμητικό.\r\nΔεν περιμένει να πατηθεί κάποιο πλήκτρο (κομβίο), αλλά αν πατηθεί την στιγμή που τρέχει η εντολή τότε δίνει τον χαρακτήρα ως αλφαριθμητικό\r\n\r\n\r\n
EN:INKEY(\r\nέλεγχος πληκτρολογίου με καθυστέρηση για πάτημα πλήκτρου σε αυτό το διάστημα.\r\nΤύπωσε Ενκομ(1000)\r\n\r\nΑ=1\r\nΝήμα {\r\n      Α++\r\n} ως Μ κάθε 10\r\nΤύπωσε Ενκομ(2000)\r\nΤύπωσε Α\r\n\r\n\r\n
EN:VOLUME\r\nΜεταβάλουμε την ένταση του ήχου\r\nΕΝΤΑΣΗ 100 ' το μέγιστο\r\nΕΝΤΑΣΗ 0 ' το ελάχιστο\r\n\r\nΔιαβάζουμε την ένταση από την μεταβλητή ΕΝΤΑΣΗ\r\n\r\n
EN:VOLUME_as variable\r\nΔίνει την τρέχουσα ένταση. ΔΕΣ ΕΝΤΑΣΗ\r\n\r\n\r\n
EN:MOUSE COMMANDS\r\nΕΝΤΟΛΕΣ ΔΕΙΚΤΗ\r\nΔΕΙΚΤΗ.ΜΟΡΦΗ, ΛΑΒΗ\r\n
EN:BITMAP COMMANDS\r\nΕΝΤΟΛΕΣ ΕΙΚΟΝΩΝ\r\nΑΝΤΙΓΡΑΨΕ, ΔΙΑΦΑΝΟ, ΕΙΚΟΝΑ, ΠΑΙΚΤΗΣ\r\n
EN:BROWSER COMMANDS\r\nΕΝΤΟΛΕΣ ΙΣΤΟΥ\r\nΑΝΑΛΟΓΙΟ, ΚΕΙΜΕΝΟ\r\n
EN:CONSOLE COMMANDS\r\nΕΝΤΟΛΕΣ ΚΟΝΣΟΛΑΣ\r\nΑΝΑΝΕΩΣΗ, ΑΝΑΦΟΡΑ, ΑΝΑΨΕ, ΑΦΗΣΕ, ΓΡΑΜΜΑΤΟΣΕΙΡΑ, ΔΙΑΣΤΙΧΟ, ΔΙΠΛΑ, ΔΡΟΜΕΑΣ, ΕΙΚΟΝΙΔΙΟ, ΕΛΛΗΝΙΚΑ, ΕΠΙΓΡΑΦΗ, ΕΠΙΠΕΔΟ, ΕΠΙΦΑΝΕΙΑ, ΚΑΝΟΝΙΚΑ, ΚΙΝΗΣΗ, ΚΙΝΗΣΗ.Π, ΚΡΑΤΗΣΕ, ΚΥΛΙΣΗ, ΛΑΤΙΝΙΚΑ, ΟΘΟΝΗ, ΠΑΡΑΘΥΡΟ, ΠΕΔΙΟ, ΠΕΝΑ, ΠΕΡΙΘΩΡΙΟ, ΠΕΡΙΘΩΡΙΟ _, ΠΛΑΓΙΑ, ΠΛΑΙΣΙΟ, ΣΒΗΣΕ, ΣΗΜΑΔΙ, ΤΟΠΙΚΟ, ΤΥΠΟΣ, ΦΑΡΔΙΑ, ΦΟΝΤΟ, ΦΟΡΜΑ, ΧΑΡΑΚΤΗΡΕΣ\r\n
EN:STACK COMMANDS\r\nΕΝΤΟΛΕΣ ΣΩΡΟΥ\r\nΑΔΕΙΑΣΕ, ΑΝΑΘΕΣΕ, ΑΠΕΔΩΣΕ, ΒΑΛΕ, ΔΙΑΒΑΣΕ, ΠΑΝΩ, ΠΕΤΑ, ΣΕΙΡΑ, ΣΩΡΟΣ, ΦΕΡΕ, ΦΕΡΕΠΙΣΩ\r\n
EN:COMMAND$\r\nΤΥΠΩΣΕ ΕΝΤΟΛΗ$\r\nδίνει όλο το μονοπάτι μαζί με το όνομα αρχείου του τελευταίου φορτώματος\r\n\r\nΦΟΡΤΩΣΕ \"αλφα\"\r\nΣΩΣΕ \"αλφα\"\r\nή \r\nΣΩΣΕ ΕΝΤΟΛΗ$  \r\nαπλά το ΕΝΤΟΛΗ$ έχει το φάκελο (μονοπάτι), το όνομα και τον τύπο (GSB) του αρχείου\r\nΕπειδή φορτώσαμε έστω το αλφα και θέλουμε να το σώσουμε μας ρωτά το σύστημα αν θέλουμε να γράψουμε πάνω στο προηγούμενο.\r\n\r\nη εντολή αυτή ΣΩΣΕ ΕΝΤΟΛΗ$  δίνεται και με CTRL+A\r\n
EN:WHILE\r\nΕΝΩ συνθήκη {\r\nεντολές\r\n\r\n}\r\n\r\nΕνώ αντικείμενο_επαναλήπτης {\r\n      εντολε΄ς\r\n}\r\n\r\nΑυτή είναι μια ανακύκλωση που συμβαίνει αφού έστω και μια φορά ελεγχθεί η συνθήκη\r\n\r\nΣτην πρώτη περίπτωση μέσα στην ΕΝΩ θα πρέπει να υπάρχει ένας τρόπος που θα αλλάζει έτσι την συνθήκη ώστε να τερματίζει.\r\nΣτη δεύτερη θα τερματίσει στο πέρας της επανάληψης.\r\n\\\\Παράδειγμα πρώτης περίπτωσης\r\nΑ=10\r\nΕνώ Α>0 {\r\n      Τύπωσε Α\r\n      Α--  ' εδώ αλλάζει η Α άρα και η συνθήκη Α>0\r\n}\r\n\\\\ Παράδειγμα δεύτερης περίπτωσης\r\nΚ=(1,2,3,4,5)\r\nΚ1=Κάθε(Κ,1, 3)\r\nΤύπωσε \"Κ1\"\r\nΕνώ Κ1 {\r\n      ' θα γίνει τρεις φορές η επανάληψη\r\n      Τύπωσε Πίνακας(Κ1)\r\n}\r\nΚ1=Κάθε(Κ,1, 3)    ' από την αρχή στο 3\r\nΚ2=Κάθε(Κ,-1, 3)  ' από το τέλος στο 3\r\nΤύπωσε \"Κ1, Κ2\"\r\nΕνώ Κ1, Κ2 {\r\n      ' θα γίνει τρεις φορές η επανάληψη\r\n      Τύπωσε Πίνακας(Κ1)*Πίνακας(Κ2)\r\n}\r\nΚ1=Κάθε(Κ,1, 3)\r\nΚ2=Κάθε(Κ,-1, 3)\r\nΤύπωσε \"Κ1*Κ2\"\r\nΕνώ Κ1 {\r\n      Ενώ Κ2 {\r\n            ' θα γίνει 3Χ3 φορές η επανάληψη\r\n            Τύπωσε Πίνακας(Κ1)*Πίνακας(Κ2)\r\n      }\r\n}\r\n\r\nΥπάρχει και χωρίς μπλοκ\r\n\r\nΕνώ συνθήκη\r\n\r\nΤέλος Ενώ\r\n\r\n\r\n
EN:LINK\r\n\\\\ ενώνουμε μεταβλητές με άλλες μεταβλητές \r\n\r\nΈνωσε λίστα_μεταβλητών στο λίστα_μεταβλητών\r\nΈνωσε λίστα_μεταβλητών στη λίστα_μεταβλητών\r\n' νέο από 9.3 αν. 33 για δημιουργία νέας μεταβλητής ακόμα και αν υπάρχει ίδιο όνομα\r\nΈνωσε λίστα_μεταβλητών τοπικά στο λίστα_μεταβλητών\r\nΈνωσε λίστα_μεταβλητών τοπικά στη λίστα_μεταβλητών\r\n\r\n\\\\ απλό παράδειγμα\r\nΑ$=\"ένα\"\r\nΈνωσε Α$ στο Β$\r\nΤύπωσε Β$\r\n\r\n\\\\ απλό παράδειγμα χωρίς την ένωσε (κάνει εδώ ακριβώς το ίδιο)\r\nΑ$=\"ένα\"\r\nΒάλε &Α$  \\\\ βάζει την ισχνή αναφορά στο σωρό\r\n\\\\ δεν μπορούμε έτσι να συνδέσουμε υπάρχουσα Β$ θα βγει λάθος\r\nΔιάβασε &Β$  \\\\ διαβάζει την ισχνή αναφορά και συνδέει με την Β$\r\nΤύπωσε Β$\r\n\r\nΑ$=\"123345\"\r\nΈνωσε Α$ στο Β\r\nΤύπωσε Β\r\nΒ+=200\r\nΤύπωσε Α$\r\n\r\n\\\\ παράδειγμα με χρήση της ισχνής αναφοράς και της ένωσε\r\nα$=\"{=1000*αριθμός+αριθμός}\"\r\n\\\\ η α$ έχει ισχνή αναφορά συνάρτησης (έχει το μπλοκ εντολών {} )\r\nΈνωσε ισχνη α$ στο αα()\r\nΤύπωσε αα(10,-100)\r\nΜ=300\r\nβ$=ισχνή$(Μ)\r\n\\\\ η β$ είναι ισχνή αναφορά στην Μ\r\nΈνωσε ισχνη β$ στο Δ\r\nΤύπωσε Δ\r\nΔ+=5000\r\nΤύπωσε Μ, Μ=Δ, Εκφρ(β$)\r\n\\\\ μπορούμε με μια τελεία μετά το β$ να την χρησιμοποιούμε άμεσα\r\nβ$.+=500\r\nΤύπωσε Μ, Μ=Δ, Εκφρ(β$)\r\n\r\nΟμάδα Βήτα {\r\n      μετρητής=0\r\n      Συνάρτηση Α1 (χ, ψ) {\r\n            .μετρητής++\r\n            =χ**2+ψ\r\n      }\r\n}\r\nΤμήμα Δες_Αυτό (&φ()) {\r\n      Τύπωσε φ(11,3)\r\n}\r\nΈνωσε Βήτα.Α1() στη ζ()\r\nΤύπωσε ζ(10,2), Βήτα.μετρητής\r\nΔες_Αυτό &Βήτα.Α1()\r\nΔες_Αυτό Οκν$(Βήτα.Α1(αριθμός, 30))\r\nΔες_Αυτό Οκν$(Βήτα.Α1(20, 30))\r\nΤύπωσε ζ(12,4), Βήτα.μετρητής\r\n\r\n
EN:CONS(\r\nα=(1,2,3,4,5)\r\nβ=Ένωση(α, (6,7,8), α)\r\nΤύπωσε β\r\n\r\n\r\n
EN:UNION.DATA$(\r\nΤύπωσε Ένωση.Σειράς$(65, 66,\"C\", \"alfa\", 0x2102)=\"ABCalfaℂ\"\r\n
EN:EXIT\r\nεξοδος\r\nΆμεση έξοδος από τμήμα ή από δομή με αγκύλες\r\n\r\n\r\nΓια ι=1 εως 100\r\nΑν ι>5  Τοτε Έξοδος Για\r\nτυπωσε ι\r\nεπόμενο ι\r\n\r\nΗ ΕΞΟΔΟΣ από μπλοκ { } που έχουμε με εντολή ΚΥΡΙΟ.ΕΡΓΟ διαγράφει  όλα τα νήματα του τμήματος.\r\n\r\nΕξοδος Ρουτίνας\r\nΕξοδος Για\r\nΕξοδος Για ετικέτα\r\n\r\nΓια ι=1 εως 10\r\n      αν ι=5 τότε εξοδος για 10\r\nΕπόμενο ι\r\n5 Τυπωσε \"όχι αυτό\"\r\n10 Τύπωσε \"αυτό\"\r\n\r\n
EN:STRING$(\r\nΔέχεται δυο ορίσματα. Το πρώτο είναι ένα αλφαριθμητικό, το δεύτερο ένας αριθμός που δηλώνει πόσες φορές θα επαναλάβει το πρώτο σε ένα νέο που θα μας επιστρέψει\r\n1)Τύπωσε Επαν$(\"Α\", 3)\r\nΑΑΑ\r\n2) Τύπωσε Επαν$(α$)\r\n  επανεξάγει το αλφαριθμητικό με ορισμένες ακολουθίες escape (σε επιλεγμένους χαρακτήρες)\r\n3) Τύπωσε Επαν$(α$ ως json)\r\n  επανεξάγει το αλφαριθμητικό με ακολουθίες escape κατά json\r\nΠαράδειγμα:\r\nα$={alfa\r\n      \"beta\"\r\n      gamma\r\n}\r\nΤύπωσε επαν$(α$)\r\nΤύπωσε επαν$(α$ ως json)\r\nΑναφορά Μορφή$(επαν$(α$))\r\nΑναφορά Μορφή$(επαν$(α$ ως json))  \r\n4) Τύπωσε Επαν$(α$ ως Encode64) \r\n      εξ ορισμού βάζει αλλαγές γραμμών κάθε 60 χαρακτήρες\r\n    Τύπωσε Επαν$(α$ ως Encode64, 1)  ' δεν βάζει αλλαγές γραμμών\r\n    Τύπωσε Επαν$(α$ ως Encode64, 0, 6)  ' βάζει αλλαγές και βάζει και βάζει και 6 χαρακτήρες στην αρχή κάθε γραμμής\r\n5) Τύπωσε Επαν$(α$ ως Decode64)\r\n      αποκωδικοποίηση  BASE64\r\n6)  Τύπωσε Επαν$(α$ ως UTF8enc)    \r\n       Κωδικοποίηση σε UTF8\r\n7)  Τύπωσε Επαν$(α$ ως UTF8dec)\r\n       Αποκωδικοποίηση από UTF8\r\n8)  Tύπωσε Επαν$(α$ ως URLdec)\r\n      Tύπωσε Επαν$(α$ ως URLdec +)   ' αλλάζει τα + με διαστήματα\r\n9)  Τύπωσε Επαν$(α$ ως URLenc) \r\n      Υπάρχουν τρεις τρόποι κωδικοποίησης, ο απλός, ο HTML5 και ο RFC3986\r\n      α$=\"http://foo.bar.com/~user-name/_subdir/*~.html\"\r\n      Τύπωσε Επαν$(α$ ως URLencHTML5) \r\n      Τύπωσε Επαν$(Επαν$(α$ ως URLencHTML5) ως URLdec)\r\n      Τύπωσε Επαν$(α$ ως URLencHTML5 +)   ' διαστήματα με + και όχι %20\r\n      Τύπωσε Επαν$(α$ ως URLencRFC3986) \r\n      Τύπωσε Επαν$(α$ ως URLencRFC3986 +)   ' διαστήματα με + και όχι %20\r\n
EN:REPEAT\r\nΠροσθήκη από την 6.4\r\nContinue ή συνέχισε. \r\n\r\nΕΠΑΝΑΛΑΒΕ {\r\n      ΑΝ Β=3 ΤΟΤΕ ΕΞΟΔΟΣ\r\n      .............\r\n} ΜΕΧΡΙ Α=1\r\n\r\nΕΠΑΝΕΛΑΒΕ & ΕΠΑΝΑΛΑΒΕ\r\nΕΠΑΝΕΛΑΒΕ {\r\n\r\n} ΠΑΝΤΑ\r\n...δεν σταματάει ποτέ...εκτός από το ESC πλήκτρο ή με μια EXIT μέσα από την επανάληψη.\r\n\r\n\r\nΥπάρχει και χωρίς μπλοκ (σαρώνει για να βρει το Μεχρι ή το Πάντα οπότε είναι λίγο πιο αργή από την έκδοση με μπλοκ)\r\nΕΠΑΝΑΛΑΒΕ\r\n\r\nΜΕΧΡΙ  συνθήκη\r\n\r\nΕΠΑΝΑΛΑΒΕ\r\n\r\nΠΑΝΤΑ\r\n\r\n\r\nΑπό την έκδοση 6 μπήκε και η Repeat Until, μια δομή που θα μπορούσε να δουλέψει και με την Κυκλικά και ένα απλό {}\r\n\r\n{\r\nΚΥΚΛΙΚΑ ' αναγκάζει τον διερμηνευτή να ξανατρέξει το μπλοκ όταν όμως φθάσει στο  τέρμα του\r\n\r\n\r\nαν Α=1 τοτε εξοδος   ' μπορούμε όμως να βγούμε με την έξοδο, ή με διεκοψε (βγαίνουμε άμεσα και από τμήμα)\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
EN:DO\r\nΔΕΣ ΤΟ ΕΠΑΝΑΛΑΒΕ\r\n\r\n\r\n
EN:LEGEND\r\n1) Εγγραφή επιγραφών με οποιαδήποτε γραμματοσειρά \r\n  ΕΠΙΓΡΑΦΗ φραση$, γραμματοσειρα$, μεγεθος_γραμματων\r\n2) Όπως η (1) αλλά με γωνία\r\n  ΕΠΙΓΡΑΦΗ φραση$, γραμματοσειρα$, μεγεθος_γραμματων, γωνια_σε_ακτινια\r\n3)  Όπως η (2) αλλά με στοίχιση\r\nΕΠΙΓΡΑΦΗ φραση$, γραμματοσειρα$, μεγεθος_γραμματων, γωνια_σε_ακτινια, στοίχιση\r\nστοίχιση 1- δεξιά 2-κέντρο 3 αριστερά\r\nεδώ δεν έχουμε μεταφορά λέξης σε νέα γραμμή όπως στην Αναφορά (δεν υπάρχει ορισμός μέγιστου μήκους γραμμής)\r\n4) Όπως η (3) αλλά με επιλογή ποιότητας\r\nΕΠΙΓΡΑΦΗ φραση$, γραμματοσειρα$, μεγεθος_γραμματων, γωνια_σε_ακτινια, στοίχιση, ποιότητα\r\nΗ ποιότητα μπορεί να είναι 0 ή μη μηδέν (ό,τι άλλο από μηδέν)\r\nΗ διαφορά είναι ότι στη 0 ποιότητα τυπώνεται στο φόντο ακριβώς τα γράμματα με το χρώμα που έχουμε επιλέξει. Σε κάθε άλλη (μη μηδενική) το χρώμα διαφοροποιείται στις άκρες των γραμμάτων για να δείχνουν πιο καθαροί στο τύπωμα. \r\n5)  Όπως η 4 αλλα έχει επιπλέον τον αριθμό σε twips (θετικό η αρνητικό) που καθορίζει την πρόσθεση ή αφαίρεση χώρου μεταξύ των γραμμάτων\r\nΕΠΙΓΡΑΦΗ φραση$, γραμματοσειρα$, μεγεθος_γραμματων, γωνια_σε_ακτινια, στοίχιση, ποιότητα\r\n6) ΕΠΙΓΡΑΦΗ ! κειμενο$, πλατος_χαρακτήρων, υψος_χαρακτήρων\r\n  Δες ΕΙΣΑΓΩΓΗ !\r\n\r\n\r\n\r\nΠαράδειγμα:\r\nΔείτε παρακάτω πως μπορούμε να τυπώνουμε φράσεις με περίγραμμα σε κάθε γράμμα (outline text)\r\n\r\nΟΘΟΝΗ 3,0\r\nΘΕΣΗ 6100,3300\r\nΚΥΚΛΟΣ ΓΕΜΙΣΜΑ 1,2700\r\nΚΥΚΛΟΣ ΓΕΜΙΣΜΑ 3,2000,,3\r\nΚΥΚΛΟΣ ΓΕΜΙΣΜΑ 4,1500,,4\r\nΘΕΣΗ 2000,5000\r\nΠΕΝΑ 12\r\nΠΑΧΟΣ 3 {\r\nΧΡΩΜΑ 4 {\r\nΕΠΙΓΡΑΦΗ \"ΟΧΙ ΚΑΠΝΙΣΜΑ\",\"ARIAL\", 48 , ΠΙ/6\r\n}}\r\nΠΕΝΑ 11\r\n\r\nΣτην περίπτωση (5) η εκτύπωση γίνεται σε πλαίσιο όπου η αριστερή γωνία είναι η θέση του δρομέα χαρακτήρων και εμείς δίνουμε πλάτος και ύψος. Στις άλλες περιπτώσεις η εκτύπωση γίνεται με αρχή τον δρομέα γραφικών. Και στις δυο περιπτώσεις η γραφή είναι αναλογική.\r\nΠιο νέο παράδειγμα!\r\n\r\nπένα #7700ff\r\nποιότητα = αληθής  \r\nκέντρο = 2\r\nοθόνη #fccbb7, 0  \\\\ ακύρωση τυχόν διαχωρισμού οθόνης\r\nδιπλα : Αναφορά κέντρο, \"Παράδειγμα Επιγραφής\" : κανονικα\r\nοθόνη #efbbf7, 2   \\\\ διαχωρισμός οθόνης από τη τρίτη γραμμή (0 και 1 είναι οι δυο πρώτες)\r\nθέση 6000,6000\r\nπαλιά_τιμή_Φ = Φαρδιά\r\nπαλιά_τιμή_Π = Πλάγια\r\nΦαρδιά 1 : Πλάγια 1\r\nΠένα #224488 {       \\\\ χρώμα γύρω από τα γράμματα\r\n      Πάχος 3 {\r\n           Χρώμα #ff55aa {    \\\\ χρώμα μέσα στα γράμματα\r\n                        Επιγραφή  {Γειά σου\r\n                        Το όνομά μου είναι Γιώργος\r\n                        }, \"Arial Black\", 48, pi/6, κέντρο, ποιότητα, -90  \r\n                        \\\\  60 twips are 4 pixels in 15 dpi screens or 5 pixels in 12 dpi\r\n           }\r\n   }\r\n}\r\nΠλάγια παλιά_τιμή_Π : Φαρδιά παλιά_τιμή_Φ\r\nθέση 12000, 6000\r\nΕπιγραφή  {Γειά σου\r\nΤο όνομά μου είναι Γιώργος}, \"Arial Black\", 40, pi/6, κέντρο, ποιότητα\r\nα$=κομ$  \\\\ περιμένει ένα πλήκτρο να πατηθεί, πριν τελειώσει το πρόγραμμα\r\n\r\n\r\n\r\n
EN:SELECT\r\nΜπορείς να χρησιμοποιήσεις το Διεκοψε και το Συνεχισε. δες τις εντολές  αυτές.\r\nΜπορείς να χρησιμοποιήσεις την Προς για να βγεις από μπλοκ εντολών προς μια ετικέτα (αριθμό ή γράμματα)\r\nΣε κάθε Με μπορείς να γράψεις μια σειρά εντολών με διαχωριστικό :\r\nαλλιώς για πολλές γραμμές χρειάζεται ένα μπλοκ { }\r\nΤο ίδιο ισχύει στη Αλλιώς ή Αλλιώς Με  (αν χρησιμοποιούμε την Αν με Τέλος Αν τότε το Αλλιώς μόνο του θα το βρει η Αν και θα βγει λάθος)\r\n\r\nΕΠΙΛΕΞΕ ΜΕ αλφαριθμητικο$ ή αριθμητικό\r\nΜΕ >=τιμη, τιμη1 ΕΩΣ τιμη2, τιμη3\r\n{\r\nεντολές\r\n\r\n}\r\nΜΕ τιμη5, τιμη6, =τιμη7\r\nεντολή μιας γραμμής\r\nΜΕ ....\r\n...\r\nΑΛΛΙΩΣ ΜΕ\r\n{\r\n\r\n\r\n}\r\nΤΕΛΟΣ ΕΠΙΛΟΓΗΣ\r\n\r\n\r\n\r\n\r\n\r\n\r\n
EN:CHOOSE.FONT\r\nΕΠΙΛΕΞΕ.ΓΡΑΜΜΑΤΟΣΕΙΡΑ\r\n\r\nΤΜΗΜΑ Α {\r\n      ΤΜΗΜΑ ΛΕΓΕ {\r\n            ΔΙΑΒΑΣΕ Α\r\n            ΑΝ Α=0 ΤΟΤΕ { ? \"ΝΟ\"} ΑΛΛΙΩΣ ? \"YES\"\r\n      }\r\n      ΕΠΙΛΕΞΕ>ΓΡΑΜΜΑΤΟΣΕΙΡΑ\r\n      ΑΝ ΑΡΙΘΜΟΣ>0 ΤΟΤΕ {\r\n            ΔΙΑΒΑΣΕ ΓΡ$,ΜΕΓ,ΚΩΔ,ΠΛΑΓ,ΦΑΡΔ\r\n            ΤΥΠΩΣΕ \"ΓΡΑΜΜΑΤΟΣΕΙΡΑ:\"; ΓΡ$\r\n            ΤΥΠΩΣΕ \"ΜΕΓΕΘΟΣ:\"΄; ΜΕΓ\r\n            ΤΥΠΩΣΕ \"ΚΩΔΙΚΟΠΟΙΗΣΗ:\"; ΚΩΔ\r\n            ΤΥΠΩΣΕ \"ΠΛΑΓΙΑ\"΄; : ΛΕΓΕ ΠΛΑΓ\r\n            ΤΥΠΩΣΕ \"ΠΛΑΓΙΑ\"΄; : ΛΕΓΕ ΦΑΡΔ\r\n      } ΑΛΛΙΩΣ {\r\n            ΤΥΠΩΣΕ \"ΤΙΠΟΤΑ....\"\r\n      }\r\n      \r\n}      \r\n
EN:CHOOSE.ORGAN\r\nΕΠΙΛΕΞΕ.ΟΡΓΑΝΟ\r\nΑΝ ΕΠΙΛΟΓΗ>0 ΤΟΤΕ Α=ΕΠΙΛΟΓΗ\r\n\r\n
EN:CHOOSE.COLOR\r\n1) Βγάζει τον εξ ορισμού διάλογο για επιλογή χρώματος\r\nΕΠΙΛΕΞΕ.ΧΡΩΜΑ\r\n2) Όπως η ένα αλλά μας δείχνει και ένα συγκεκριμένο χρώμα που θέλουμε\r\nΕΠΙΛΕΞΕ.ΧΡΩΜΑ χρωμα\r\n\r\nμε βελάκια αριστερά και δεξιά περιστρέφουμε την πληροφορία χρώματος ώστε με τα άνω και κάτω να αλλάζουμε το πιο ακραίο δεξιά χρώψα κατά ένα.\r\nΜπορούμε ακόμα και να ολισθήσουμε την τιμή στο κάτω μέρος του διαλόγου, και αυτό ισοδυναμή με διπλό κλικ.\r\n\r\n\r\n
EN:MENUITEMS\r\nΜας δίνει τον αριθμό των επιλογών που έχουμε ορίσει. ΔΕΣ ΔΕΙΞΕ, ΕΠΙΛΟΓΗ\r\n\r\n\r\n\r\n
EN:MENU.VISIBLE\r\nΤΥΠΩΣΕ ΕΠΙΛΟΓΕΣ.ΦΑΝΕΡΕΣ\r\n\r\n' Παράδειγμα με χρήση νήματος\r\n\r\n Φ=1     \r\nΝΗΜΑ {\r\n      Φ++\r\n      ΑΝ ΕΠΙΛΟΓΕΣ.ΦΑΝΕΡΕΣ ΤΟΤΕ ΤΥΠΩΣΕ Φ, ΕΠΙΛΟΓΗ$(ΕΠΙΛΟΓΗ)\r\n} ΩΣ Ω\r\nΕΠΙΛΟΓΗ ΤΙΤΛΟΣ \"Ο ΤΙΤΛΟΣ ΜΟΥ\"\r\nΜΕΤΑ 100 {\r\n      ΝΗΜΑ Ω ΚΑΘΕ 100\r\n}\r\nΕΠΙΛΟΓΗ \"1η Γραμμή\", \"2η Γραμμή\"\r\nΤΥΠΩΣΕ ΕΠΙΛΟΓΗ\r\n\r\n
EN:MENU\r\n1) Σβήνει την λίστα επιλογών\r\nΕΠΙΛΟΓΗ\r\n2) Άμεση εμφάνιση λίστας επιλογών (εδώ θα έχει τα \"ΝΑΙ\" και \"ΟΧΙ\"\r\nΕΠΙΛΟΓΗ \"ΝΑΙ\",\"ΟΧΙ\"\r\n3) Εμφάνιση της κρατημένης λίστας επιλογών\r\nΕΠΙΛΟΓΗ !\r\n4) Πρόσθεση στοιχείου στην λίστα επιλογών (αλλά όχι εμφάνιση)\r\nΕΠΙΛΟΓΗ + \"ΔΕΝ ΑΠΑΝΤΩ\"\r\n\r\nΗ επιλογή θα εμφανιστεί στον δρομέα χαρακτήρων αν χωράει δεξιά και κάτω διαφορετικά αλλάζει το πάνω και αριστερό σημείο γι να χωρέσει η λίστα. Αν έχει πολλά στοιχεία (μάξιμουμ 2000) τότε εμφανίζει και μπάρα ολίσθησης,\r\n\r\nΜπορούμε να διαβάσουμε την επιλογή με τον αριθμό της από την μεταβλητή ΕΠΙΛΟΓΗ\r\nΜπορούμε να τυπώσουμε το στοιχείο που επιλέχθηκε με την\r\nΤΥΠΩΣΕ ΕΠΙΛΟΓΗ$(ΕΠΙΛΟΓΗ)\r\nΟ πίνακας ΕΠΙΛΟΓΗ$( ) περιλαμβάνει στοιχεία από το 1 έως το ΕΠΙΛΟΓΕΣ\r\nΟι μεταβλητές ΕΠΙΛΟΓΗ, ΕΠΙΛΟΓΕΣ και ο πίνακας ΕΠΙΛΟΓΕΣ$( )  αλλάζουν μετά από μια εμφάνιση της εντολής ΕΠΙΛΟΓΗ, ΑΡΧΕΙΑ, ΔΕΙΞΕ\r\n\r\n
EN:MENU$(\r\nΜπορούμε να διαβάσουμε αλλά όχι να μεταβάλουμε οποιαδήποτε καταχώρηση στον επιλογέα. Ο μέγιστος αριθμός στοιχείων μας επιστρέφεται από την αριθμητική συνάρτηση ΕΠΙΛΟΓΕΣ\r\nΔες ΕΠΙΛΟΓΗ\r\nΠαράδειγμα\r\nΣωρός Νέος {\r\n      Επιλογή   \\\\ καθαρίζει τον πίνακα\r\n      Σειρα \"alpha\",\"beta\",\"gama\",\"delta\"\r\n      Για ι =1 Έως 4 { Διάβασε α$ : Επιλογή + α$ }\r\n      Επιλογή !\r\n      Αν Επιλογή>0 Τότε Τύπωσε Επιλογή$(Επιλογή)\r\n}\r\n\r\n
EN:MENU_as variable\r\nΜας δίνει τον αριθμό της επιλογής μετά από μια ΔΕΙΞΕ ή ΕΠΙΛΟΓΗ.\r\nΜε 0 σημαίνει ότι δεν έγινε καμιά επιλογή.\r\n\r\n
EN:LAYER\r\nΕΠΙΠΕΔΟ 2 {\r\nεντολές που πάνε στον παικτη 2\r\n\r\n}\r\n\r\n\r\nΕκτός από την Φορμα που δεν λειτουργεί στο ΕΠΙΠΕΔΟ όλες οι άλλες εντολές της οθόνης μπορούν να χρησιμοποιηθούν. Π.χ. η Τυπος  για να αλλάξει το μέγεθος γραμμάτων αλλά και το μέγεθος του επιπέδου. Η εντολή Κινηση μετακινεί το Επιπεδο.\r\n\r\n            Επειδή τα επιπεδα δημιουργούνται με εικόνα...όταν καθαρίζουμε το επίπεδο με την εντολή Οθονη τότε επαναφέρουμε την αρχική εικόνα. Αν έχουμε επιλέξει διαφάνεια στο Παικτη (στη δημιουργία του Επιπέδου) τότε θα συνεχίσει το Επιπεδο να έχει διαφάνεια. Αυτό δεν σημαίνει ότι δεν θα τυπώνει εκεί που υπάρχει διαφάνεια, απλά δεν θα εμφανίζεται. Επίσης όταν με το ποντίκι κάνουμε κλικ πάνω σε διάφανο σημείο ενός επιπέδου τότε το κλικ δεν πάει στο επίπεδο αλλά σε εκείνο το αντικείμενο που έχει αδιάφανο σημείο ακριβώς από κάτω.\r\n\r\n\r\n
EN:RETURN\r\nΕΠΙΣΤΡΟΦΗ \"πρωτη\",\"SELECT * FROM ενα WHERE ΟΝΟΜΑ LIKE 'MAGELAN%'\" , ,\"EARTH THERE\",\"DATA2\",\"DATA3\"\r\nΠΡΟΣΟΧΗ στην LIKE σε ερωτήματα SQL δεν χρησιμοποιείται το * αλλά το % (λειτουργούσε παλιά λόγω του DAO, αλλά λόγω της χρήσης του αντικειμένου ADO θέλει αυτή την αλλαγή, διαφορετκά το * θα το βλέπει ως χαρακτήρα, οπότε δεν θα γυρνάει κάτι)\r\n\r\nΟ πίνακας ενα έχει τέσσερα πεδία και εμείς επιστρέφουμε σε μια εγγραφή τα τρία από τα τέσσερα πεδία. Το πρώτο πεδίο το αφήνουμε ως έχει (είναι το όνομα). Προσέξτε τα δυο συνεχόμενα κόμματα.\r\n\r\nΕΠΙΣΤΡΟΦΗ \"ΟΝΟΜΑΒΑΣΗΣ\", \"ΟΝΟΜΑΑΡΧΕΙΟΥ\" ΣΤΟ ΑΡΙΘΜΟΣΚΑΤΑΓΡΑΦΗΣ, ΠΕΔΙΟ1, ΠΕΔΙΟ2,....\r\nμπορούμε να παραλήψουμε ένα πεδίο με διπλό κόμμα.\r\nΑυτή την εντολή θα την χρησιμοποιήσουμε όταν το αρχείο χρησιμοποιείται ως πίνακας αναφοράς, οπότε η θέση της καταγραφής είναι σημαντική αφού καταχωρείται σε άλλα αρχεία στην βάση.\r\n\r\nΗ εντολή Επιστροφή χρησιμοποιείται και για άλλη λειτουργία.\r\n1) Για επιστροφή από απλές ρουτίνες\r\nΔιαμέσου αλφα\r\nΤέλος\r\nαλφα:\r\nΤύπωσε \"οκ\"\r\nΕπιστροφή\r\n2) Με αντικείμενα Κατάσταση, Πίνακας, Σωρός\r\nΚατάσταση Α=1:=\"Γεια\",\"αλλο\":=\"Ναι\"\r\n\\\\ οι καταστάσεις καταχωρούν βάσει κλειδιών\r\nΕπιστροφή Α, \"αλλο\":=\"Όχι\", 1:=\"Γειά σου\"\r\nΤύπωσε Α$(\"αλλο\"), Α$(1)\r\n\\\\ ο ΑΑ είναι επαναλήπτης\r\nΑΑ=Κάθε(Α)\r\nΤύπωσε \"Κλειδί\", \"Τιμή\"\r\nΕνώ ΑΑ { Τύπωσε εκφρ$(ΑΑ!), εκφρ$(ΑΑ)}\r\n\r\n\r\nΒ=(1,2,3,4,5)   \r\n\\\\ Η Πίνακας(Β) φέρνει το πρώτο στοιχείο\r\nΕπιστροφή Β,3:=400, 0:=Πίνακας(Β)+1,1:=Πίνακας(Β,1)**2  ' με βάση 0 , το 3 είναι το 4ο στοιχείο\r\nΤύπωσε Β\r\nΤύπωσε Πίνακας(Β,3)\r\n\\\\ Ο ΒΒ είναι επαναλήπτης\r\nΒΒ=Κάθε(Β)\r\nΕνώ ΒΒ { Τύπωσε γραφή$(Πίνακας(ΒΒ),\"00000\")}\r\n\r\n\\\\ Ο σωρός έχει κλειδιά θέσεις και μετακινεί εύκολα στοιχεία χωρίς αντιγραφές\r\nΜ=Σωρός:=1,2,3,4,5\r\nΕπιστροφή Μ, 4:=400,1:=ΤιμήΣωρού(Μ)+1, 2:=ΤιμήΣωρού(Μ,2)**2  ' Οι σωροί έχουν βάση 1\r\nΤύπωσε Μ\r\nΤύπωσε ΤιμήΣωρού(Μ,4)\r\n\\\\ Ο ΜΜ είναι επαναλήπτης\r\nΜΜ=Κάθε(Μ,-1,1)  \\\\ ή Κάθε(Μ Τέλος Έως Αρχή) ή Κάθε(Μ -1 Εως 1)\r\nΕνώ ΜΜ {Τύπωσε Γραφή$(ΤιμήΣωρού(ΜΜ))}\r\nΣωρός Μ {Φέρε 4 : ΦέρεΠίσω 5} \\\\ μετακίνηση του 4ου στοιχείου στην 5η θέση\r\nΤύπωσε Μ\r\n\r\n\r\n\r\n
EN:DESKTOP\r\nΕΠΙΦΑΝΕΙΑ\r\nΕμφανίζει τα περιεχόμενα της οθόνης πίσω από το περιθώριο μέσα σε αυτό\r\n\r\nΕΠΙΦΑΝΕΙΑ 100\r\nορίζει διαφάνεια όλης της εφαρμογής στο 100/255 *100%\r\nΜε ΕΠΙΦΑΝΕΙΑ 255 επαναφέρουμε την \"μη διαπερατότητα\" ή την αδιαφάνεια στην εφαρμογή.\r\n\r\nΕΠΙΦΑΝΕΙΑ 255,1 \r\nορίζουμε το χρώμα 1 (από τα 16 βασικά) αν είναι το διάφανο. Μπορούμε να φορτώσουμε μια εικόνα στο \"βαθύ\" φόντο. Υπάρχει δηλαδή ένα φόντο που χρησιμοποιείται όταν βάζουμε την διαφάνεια και καταλαμβάνει όλη την οθόνη. Σε αυτό το φόντο μπορούμε να βάλουμε μια εικόνα. Δες την παρακάτω εντολή:\r\n\r\nΕΠΙΦΑΝΕΙΑ ΕΙΚΟΝΑ Α$\r\nΤο Α$ μπορεί να είναι αρχείο εικόνας ή αλφαριθμητικό που περιέχει εικόνα.\r\nΗ εικόνα πάει  στο \"βαθύ\" φόντο, το οποίο ετοιμάζεται όταν επιλέξουμε διαφάνεια. Για την ακρίβεια αλλάζει το σύστημα που δουλεύει η βασική φόρμα της εφαραυτό επιβαρύνει το σύστημα.\r\n\r\nΕΠΙΦΑΝΕΙΑ ΚΡΥΨΕ\r\nΕξαφανίζει το βαθύ φόντο. Αυτό σημαίνει ότι η φόρμα μας αν έχει διαφάνεια τότε θα εκθέτει οτιδήποτε πίσω από αυτήν ώστε να μπορεί να επιλεχθεί.\r\n\r\nΕΠΙΦΑΝΕΙΑ ΚΑΘΑΡΗ\r\nΜαυρίζει το βαθύ φόντο και το κάνει αδιαπέραστο.\r\n\r\nΗ εντολή ΕΠΙΦΑΝΕΙΑ 255 επαναφέρει την αδιαφάνεια, αλλά δεν επαναφέρει το αρχικό σύστημα, άρα επιβαρύνει το σύστημα (στα XP       μόνο υπάρχει θέμα)\r\n\r\n
EN:CDR(\r\nα=((1,2), (3,4), (5, 6))\r\nb=Πρώτο(α)\r\nΤύπωσε Πρώτο(b)  ' 1\r\nΤύπωσε Πρώτο(Πρώτο(α))   ' 1\r\nΤύπωσε Επόμενα(Πρώτο(Επόμενα(Επόμενα(α))))  ' 6\r\n\r\n
EN:READY(\r\nΕπειδή σε ένα γεγονός σε φόρμα μπορεί να έχει ξεκινήσει μια φορά και να ξεκινήσει και δεύτερη (υπάρχει περίπτωση ότι αφήσουμε μια φόρμα για άλλη και πάλι την φέρουμε στο προσκήνιο),  όταν φορτώνουμε ένα έγγραφο με την Φόρτωσε.Έγγραφο μπορούμε να ξέρουμε αν η μεταβλητή που έχουμε δηλώσει ως έγγραφο είναι απασχολημένη ή όχι και ανάλογα να πράξουμε\r\nΑν Όχι Έτοιμο(εγγραφ$) Τότε Έξοδος\r\nΦόρτωσε.Έγγραφο εγγραφ$, όνομα_αρχείου$\r\n\r\nΑν η φόρμα έχει όνομα Φόρμα1, τότε η εντολή επίπεδο μπορεί να χρησιμοποιηθεί για να δώσει στη φόρτωσε.έγγραφο \"ανάδραση\", ώστε αν τερματίσει η φόρμα να στείλει μήνυμα για να τερματίσει και η φόρτωση.\r\n\r\nΑν Όχι Έτοιμο(εγγραφ$) Τότε Έξοδος\r\nΕπίπεδο Φόρμα1 {\r\n      Φόρτωσε.Έγγραφο εγγραφ$, όνομα_αρχείου$\r\n}\r\n\r\n\r\n
EN:FIND\r\nΕΥΡΕΣΗ μεταβλητή_τύπου_εγγράφου$,  αρχική θέση\r\n\r\nΈγγραφο Αλφα$={ΑΑΑΓΓΓ\r\n                        ΒΒΒ\r\n                        ΓΓΓ\r\n                        ΔΔΔ\r\n                        }\r\nΝ=1\r\nΕύρεση Αλφα$,\"ΓΓΓ\", Ν\r\nΔιάβασε Ν\r\nΕνώ Ν {\r\n      Διάβασε  παράγραφος, θέση_στη_παράγραφο\r\n      Τύπωσε μορφή$(\"Βρέθηκε στη θέση {0}, στη παράγραφο {1}\", θέση_στη_παράγραφο, παράγραφος)\r\n      Εύρεση Αλφα$,\"ΓΓΓ\", Ν+1\r\n      Διάβασε Ν\r\n}\r\n\r\n
EN:TAN(\r\nΕπιστρέφει την εφαπτομένη μιας γωνίας σε μοίρες\r\n\r\n
EN:FILE.APP$(\r\nΤύπωσε Εφαρμογή.Αρχείου$(\"txt\")\r\nΔίνει το πρόγραμμα που ανοίγει τα αρχεία txt\r\n\r\n\r\n
EN:APPDIR$\r\nμας δίνει τον κατάλογο της εφαρμογής, αν είναι όμως σωστά εγκατεστημένη αλλιώς είναι κενό\r\nΤΥΠΩΣΕ ΕΦΑΡΜΟΓΗ.ΚΑΤ$\r\n\r\n
EN:OR\r\nΤελεστής Η\r\n\r\nΤύπωσε  Αληθές Ή Ψευδές\r\n\r\n
EN:SIN(\r\nΕπιστρέφει το ημίτονο μιας γωνίας σε μοίρες\r\n\r\n\r\n
EN:DATE$(\r\nΔέχεται όρισμα μια αριθμητική παράσταση ημερομηνίας και δίνει την ημερομηνία ως αλφαριθμητικό.\r\nΑ=ΣΗΜΕΡΑ\r\nΤΥΠΩΣΕ ΗΜΕΡΑ$(Α)\r\nΤύπωσε ημέρα$(Σήμερα,1033,\"Long Date\")\r\nΤύπωσε ημέρα$(Σήμερα,1033,\"MMMMM d yyyy\")\r\nΤύπωσε ημέρα$(Σήμερα) ' χρήση σύντομης ελληνικής\r\nΤύπωσε ημέρα$(Σήμερα,)  'χρήση σύντομης όπως το ΤΟΠΙΚΟ\r\nΤύπωσε ημέρα$(Σήμερα,1033) ' χρήση σύντομης για το 1033\r\n
EN:DATE(\r\nΜετατροπή μέρας από αλφαριθμητικό σε αριθμητικό\r\nΑ=ημερα(\"2015-10-11\")\r\nΤυπωσε Γραφη$( Α ,\"LONG DATE\")\r\nΑ=ημέρα(\"March 7 2009\", 1033)\r\nΤυπωσε Γραφη$( Α ,\"LONG DATE\")\r\nΤύπωσε Ημερα$(Α, 1033, \"LONG DATE\")\r\n\r\n
EN:DATEFIELD\r\nχρησιμοποιείται στην εντολή ΑΡΧΕΙΟ\r\n\r\n
EN:SND$(\r\nΔίνουμε ένα όνομα αρχείου WAV χωρίς κατάληξη και εξάγει αν υπάρχει το αρχείο το πλήρες όνομά του (με τη διεύθυνσή του και την κατάληξη WAV)\r\n\r\n
EN:SOUNDS\r\nΗΧΟΙ\r\nΜας δίνει όλα τα αρχεία τύπου wav  στον τρέχον κατάλογο, ίδιο με το ΑΡΧΕΙΑ \"wav\"\r\n\r\nΚΑΤΑΛΟΓΟΣ \"C:\"\r\nΗΧΟΙ\r\nΑΡΧΕΙΑ \"wav\"\r\n\r\n\r\n
EN:SOUNDS AND MOVIES\r\nΗΧΟΙ ΚΑΙ ΤΑΙΝΙΕΣ\r\nΕΝΤΑΣΗ, ΕΠΙΛΕΞΕ.ΟΡΓΑΝΟ, ΗΧΟΣ, ΛΟΓΟΣ, ΜΕΛΩΔΙΑ, ΜΟΥΣΙΚΗ, ΜΠΙΠ, ΠΑΙΞΕ, ΤΑΙΝΙΑ, ΤΟΝΟΣ, ΦΩΝΗ\r\n
EN:SOUND\r\nΗΧΟΣ αρχείο_ήχου_wav\r\nΗΧΟΣ \"\" σταματάει το προηγούμενο ήχο\r\n\r\n\r\n
EN:SET\r\nΘεσε Α$=\"ΑΑΑΑΑΑΑΑ\"\r\nΣε ένα τμήμα έστω ΤΜΗΜΑ ΑΛΦΑ αν δώσουμε το παρακάτω:\r\nΑ$=\"ΒΒΒΒΒΒΒΒΒ\"\r\nΤότε θα έχει φτιαχτεί μια μεταβλητή ΑΛΦΑ.Α$ που μέσα στο τμήμα θα διαβάζεται σαν Α$. Μπορούμε όμως να διαβάζουμε και μεταβλητές που έχουμε φτιάξει με την ΘΕΣΕ.\r\nΜάλιστα η εντολή ΘΕΣΕ δεν ορίζει μόνο σφαιρικές μεταβλητές (καθολικές) αλλά κάνει και ενέργειες σαν να τις πληκτρολογούσαμε στον μεταφραστή γραμμής (από εκεί που καλούμε το πρώτο τμήμα)\r\n\r\nΔες το παρακάτω παράδειγμα (το γράφουμε σε ένα τμήμα)\r\n\r\nΘΕΣΕ Α$=\"111111\"\r\nΑ$=\"22222222\"\r\nΤΥΠΩΣΕ Α$\r\nΘΕΣΕ ΤΥΠΩΣΕ Α$\r\n\r\nΘα μας δώσει τα \r\n22222222\r\n1111111\r\n\r\nΔοκίμασε χωρίς το Α$=\"22222222\"\r\n1111111\r\n1111111\r\n\r\nΟι σφαιρικές μεταβλητές διαβάζονται από όλα τα τμήματα εφόσον το τμήμα όπου δημιουργήθηκαν δεν έχει τερματίσει (με τον τερματισμό ενός τμήματος πίνακες και μεταβλητές σβήνουν, δεν σβήνει όμως ο σωρός τιμών ΔΕΣ ΣΩΡΟΣ)\r\n\r\nΑν θέλουμε να αλλάξουμε τιμή σε μια σφαιρική μεταβλητή σε ένα τμήμα...δεν είναι τόσο εύκολο.\r\nΜε την ΘΕΣΕ μπορούμε να δώσουμε αρχική τιμή αλλά αν αυτή η τιμή βγαίνει από παράσταση τότε πρέπει να κάνουμε αυτό:\r\nΒΑΛΕ 12*Χ  ' βάζουμε στο σωρό την τιμή της παράστασης ενώ είμαστε στο τμήμα ΑΛΦΑ\r\nΘΕΣΕ ΣΦΑΙΡΙΚΗ=ΑΡΙΘΜΟΣ   ' Εδώ το τμήμα θα αλλάξει όνομα (θα είναι κενό) επειδή εδώ είναι σαν να είμαστε στο πρώτο επίπεδο, στον μεταφραστή γραμμής.\r\nΑν δεν βάλω την ΘΕΣΕ τότε θα φτιαχτεί τοπική μεταβλητή και από εκεί και πέρα θα διαβάζει την τοπική ο μεταφραστής,εκτός και αν πάλι την διαβάσουμε με την ΘΕΣΕ\r\n\r\n' Τα τμήματα μοιράζονται τον ίδιο σωρό\r\n' Εκτός από αυτά που ξεκίνησαν σε μια συνάρτηση δες παρακάτω\r\nΘΕΣΕ ΒΑΛΕ ΣΦΑΙΡΙΚΗ   ' η θεσε βάζει πάντα στην κορυφή του σωρού \r\nΔΙΑΒΑΣΕ ΠΑΛΙΑσφαιρικη\r\n\r\nΔες ένα παράδειγμα που δείχνει πως φαίνεται μια ΣΦΑΙΡΙΚΗ μεταβλητή\r\nΑυτό μπορείς να το αντιγράψεις σε ένα τμήμα έστω α\r\nΘεσε ΣΦΑΙΡΙΚΗ=5\r\nΤυπωσε ΣΦΑΙΡΙΚΗ              ' 5\r\nΧ=20\r\nΒαλε 20*Χ\r\nΘεσε ΣΦΑΙΡΙΚΗ=Αριθμος\r\nΤΥΠΩΣΕ ΣΦΑΙΡΙΚΗ              '400\r\n\r\nΣυναρτηση α { \r\nΤμημα ενα {\r\nΣειρα 3,2,1  ΄η Σειρα βάζει στο σωρό από το τέλος με πάτο το 1\r\n}\r\nενα\r\nδιαβασε α,β,γ ' τον οποίο διαβάζει εδώ\r\n=α+β+γ  ' εδώ επιστρέφει τιμή η συνάρτηση\r\n}\r\n\r\nτυπωσε α()                  '6\r\n' Μπορούμε να βάλουμε στη συνάρτηση τιμές\r\n' Θα μπουν όλες στο σωρό μπροστά από αυτές στο τμήμα ενα\r\nτυπωσε α(5,5,5), α(5,5), α(5) ' τυπώνει 15 13 10\r\n\r\nΣΦΑΙΡΙΚΗ=100\r\nΤυπωσε ΣΦΑΙΡΙΚΗ    '100 σκίαση της ΣΦΑΙΡΙΚΗΣ με τοπική με το ίδιο όνομα\r\n\r\nΣυναρτηση β {\r\n=ΣΦΑΙΡΙΚΗ             'Εδώ η β δεν βλέπει την τοπική παραπάνω αλλά την σφαιρική\r\n}\r\nτυπωσε β()               '400\r\n\r\n\r\n
EN:MOVE\r\nΘΕΣΗ 1000,1000\r\nΘΕΣΗ 3000\r\nΘΕΣΗ ,5000\r\nΜεταφορά του δρομέα γραφικών σε απόλυτη θέση.\r\nΜπορούμε να διαβάσουμε την τωρινή θέση από δυο μεταβλητές (μόνο για διάβασμα), τις ΘΕΣΗ.Χ και ΘΕΣΗ.Υ\r\nΕπίσης το 0,0 είναι πάνω αριστερά και το κάτω δεξιά σημείο είναι το ΚΛΙΜΑΞ.Χ, ΚΛΙΜΑΞ.Υ (συνώνυμα Χ.ΣΗΜΕΙΑ και Υ.ΣΗΜΕΙΑ)\r\nΑρνητικές τιμές μπορούμε να δώσουμε αλλά ο δρομέας θα πάει εκτός οθόνης, έτσι μια ΧΑΡΑΞΕ 3000,3000 θα χαράξει γραμμή μέσα στην οθόνη άλλα ένα τμήμα αυτής)\r\n\r\n\r\n\r\n\r\n\r\n
EN:INSTR(\r\nΔέχεται ως όρισμα δυο αλφαριθμητικά ή και μια αριθμητική τιμή. Δίνει τη θέση του δεύτερου αλφαριθμητικού στο πρώτο ή μηδέν αν δεν το βρει πουθενά. Αν δώσουμε και μια τιμή ψάχνει από την θέση που ορίζει αυτή η τιμή. Αν η θέση που δίνουμε είναι μεγαλύτερη από το μήκος του πρώτου αλφαριθμητικού δίνει μηδέν.\r\nΤΥΠΩΣΕ ΘΕΣΗ(\"12345\",\"2\")\r\nΤΥΠΩΣΕ ΘΕΣΗ(\"ΑΒΓΔΕΑΒΓΔ\",\"Α\",2)\r\n\r\nδίνει \r\n         2\r\n         6\r\n\\\\ δουλεύει και με ANSI αλφαριθμητικά (ένα ψηφίο (byte) ανά χαρακτήρα)\r\nΤοπικό 1033\r\nΑναζήτησε$ = Γραφή$(\"aetabetAbet\")\r\nτι$ = Γραφή$(\"bet\")\r\nΤύπωσε Θέση(Αναζήτησε$, τι$ ως ψηφίο)=5\r\nΤύπωσε Θέση(Αναζήτησε$, τι$, 6 ως ψηφίο)=9\r\nΤύπωσε Θέση(Αναζήτησε$, τι$, 1 ως ψηφίο)=5\r\nΑναζήτησε$ = \"aetabetAbet\"\r\nτι$ =\"bet\"\r\nΤύπωσε Θέση(Αναζήτησε$, τι$)=5\r\nΤύπωσε Θέση(Αναζήτησε$, τι$, 6)=9\r\nΤύπωσε Θέση(Αναζήτησε$, τι$, 1)=5\r\n\r\n
EN:POS.Y\r\nΘέση Υ του δρομέα γραφικών\r\n\r\n\r\n
EN:POS.X\r\nΘέση Χ του δρομέα γραφικών\r\n\r\n\r\n
EN:POS\r\nΔίνει την θέση Χ του δρομέα χαρακτήρων\r\n\r\nΤΥΠΩΣΕ \"ΑΒΓΔΕ\",ΘΕΣΗ\r\nΤΥΠΩΣΕ ΘΕΣΗ\r\n\r\n
EN:RINSTR(\r\nΑ$=\"12345612345612345\"\r\nΝ=ΘέσηΔεξιά(Α$,\"34\")\r\nΜ=μηκος(α$)+1\r\nΕνώ Ν>0 {\r\n      Τύπωσε Ν  ' χαρακτήρες από αριστερά που βρίσκεται αυτό που βρέθηκε ή το 0\r\n      Τύπωσε Μεσ$(Α$, Ν)  ' το Μεσ$ δουλεύει από αριστερά\r\n       Ν=ΘέσηΔεξιά(Α$,\"34\", Μ-Ν)  'χαρακτήρες από δεξιά\r\n}\r\n\r\nΝ=ΘέσηΔεξιά(Α$,\"34\")\r\nΕνώ Ν>0 {\r\n      Τύπωσε Ν  ' χαρακτήρες από αριστερά που βρίσκεται αυτό που βρέθηκε ή το 0\r\n      Τύπωσε Μεσ$(Α$, Ν) ' το Μεσ$ δουλεύει από αριστερά\r\n       Ν=ΘέσηΔεξιά(Α$,\"34\", -Ν)  'χαρακτήρες από αριστερά (με το -)\r\n}\r\n\r\n\\\\ Χρήση με αλφαριθμητικά του ενός ψηφίου (byte) ανά χαρακτήρα (τα φτιάχνει η Γραφή$())\r\nΤοπικό 1033\r\nΑναζήτησε$ = Γραφή$(\"aetabetAbet\")\r\nτι$ = Γραφή$(\"bet\")\r\nΤύπωσε ΘέσηΔεξιά(Αναζήτησε$, τι$ ως ψηφίο)=9\r\nΤύπωσε ΘέσηΔεξιά(Αναζήτησε$, τι$, 1 ως ψηφίο)=9\r\nΤύπωσε ΘέσηΔεξιά(Αναζήτησε$, τι$, 2 ως ψηφίο)=5\r\n\r\nΑναζήτησε$ = \"aetabetAbet\"\r\nτι$ =\"bet\"\r\nΤύπωσε ΘέσηΔεξιά(Αναζήτησε$, τι$,1 )=9\r\nΤύπωσε ΘέσηΔεξιά(Αναζήτησε$, τι$,2 )=5\r\n\r\n
EN:PROPERTY\r\n#1) Οι ιδιότητες είναι εσωτερικά ομάδες με κάποια Αξία, αν ορίσουμε ότι θα έχει μόνο Αξία τότε δεν θα αλλάζει τιμή απ' έξω\r\n Ομάδα Άλφα {\r\n      Χ=10\r\n      Ιδιότητα Όνομα$ {Αξία} =\"Γιάννης\"\r\n      Ιδιότητα Κάτι=100\r\n      Τμήμα ΘέσεΝέοΌνομα {\r\n            Διάβασε .[Όνομα]$\r\n      }\r\n}\r\nΤύπωσε Άλφα.Όνομα$\r\nΔες { Άλφα.Όνομα$=\"Ανδρέας\"}\r\n\\\\ δεν αλλάζει - δίνει λάθος - η Δες { } αφαιρεί το λάθος\r\nΤύπωσε Άλφα.Όνομα$\r\nΆλφα.ΘέσεΝέοΌνομα \"Ανδρέας\"\r\nΤύπωσε Άλφα.Όνομα$\r\n2) Η ιδιότητα Άλφα έχει δυο μέλη την Αξία και την Θέσε, η δεύτερη χρησιμοποιείται στο = (αντικατάσταση ή νέα τιμή). Για να δούμε από μια ιδιότητα κάτι στη γονική ομάδα πρέπει να το ενώσουμε με ένα όνομα που διαβάζεται στην ομάδα της ιδιότητας, και αυτό το κάνει η Ένωσε. Αυτό συμβαίνει γιατί οι ομάδες βλέπουν το δικό τους περιεχόμενο και όχι κάτι έξω από αυτό. Μια εσωτερική ομάδα δεν έχει πρόσβαση σε αυτήν που περιέχεται και αυτό το λύνει η Ένωσε. Έχει σημασία γιατί αν αντιγράψουμε την ομάδα (που χρησιμοποιούμε ως ιδιότητα) τότε η ένωση δεν θα πετύχει. Η τιμή της ιδιότητας δεν ανήκει στην ομάδα της ιδιότητας αλλά στη γονική ομάδα!\r\nΟμάδα Κάτι {\r\n      Γεγονός Γ {\r\n            Διάβασε Τι$\r\n            Συνάρτηση {\r\n                  Τύπωσε Τι$\r\n            }\r\n      }\r\n      Ιδιότητα Άλφα {\r\n            Αξία {\r\n                  Ένωσε Γονικό Γ στη Γ\r\n                  Αν Άλφα>300 Τότε Κάλεσε Γεγονός Γ, \"Υψηλή Τιμή\"\r\n                  \\\\ η μεταβλητή Αξία δίνει την επιστροφή, οπότε αν την αλλάξουμε εδώ δεν θα αλλάξουμε την  μεταβλητή πίσω από την ιδιότητα\r\n            }\r\n            Θέσε { \r\n                  Αν Αξία>400 Τότε Αξία=400\r\n            }\r\n      } = 10\r\n }\r\nΤύπωσε Κάτι.Άλφα\r\nΚάτι.Άλφα=500\r\nΜ=Κάτι.Άλφα  \\\\ Συμβαίνει το γεγονός Γ\r\nΤύπωσε Μ  \\\\ η Μ έχει πάρει τιμή την αξία της Κάτι.Άλφα\r\n3) Οι ιδιότητες μπορούν να έχουν και άλλες ιδιότητες. Στο όνομα της ιδιότητας υπάρχει μεταβλητή με [ ], όπως εδώ η Μετρητής είναι η [Μετρητής] και όταν θέλουμε να έχουμε πρόσβαση από μια συνάρτηση (και η αξία εσωτερικά συνάρτηση είναι), τότε βάζουμε την τελεία μπροστά.\r\n\r\nΟμάδα Κάτι {\r\n      Ιδιότητα Άλφα {\r\n            Αξία {\r\n                  .[Μετρητής]++\r\n            }\r\n            Θέσε\r\n      } = 10\r\n      Ομάδα Άλφα {\r\n           Ιδιότητα Μετρητής {Αξία}=0\r\n      }\r\n\r\n }\r\nΚάτι.Άλφα=500\r\nΓια ι=1 έως 100 : Ν=Κάτι.Άλφα : Επόμενο ι\r\nΤύπωσε Κάτι.Άλφα.μετρητής\r\n4) Σε περίπτωση που το όνομα της ιδιότητας είναι ανανγνωριστικό μόνο ανάγνωσης της Μ2000 πρέπει να φτιάξουμε την ιδιότητα απ ΄ευθείας ως ομάδα (η εντολή Ιδιότητα είναι μια μακροεντολή που βάζει τις σωστές εντολές)\r\nΟμάδα Κάτι {\r\n      Ιδιότητα ΜιαΤιμή {\r\n            Αξία\r\n            Θέσε {\r\n              .[Διπλός]<=Αξία*2\r\n            }\r\n      }\r\n      Ομάδα ΜιαΤιμή {\r\n      \\\\ Επειδή υπάρχει το αναγνωριστικό Διπλός στο λεξικό της Μ2000\r\n      \\\\ Η Μακροεντολή Ιδιότητα χρησιμοποιεί το =Διπλός και φέρνει λάθος το 7\r\n      \\\\ Μπορούμε όμως να φτιάξουμε την ιδιότητα απ΄ευθείας ως Ομάδα\r\n      Ιδιωτικό:\r\n            [Διπλός]\r\n      Δημόσιο:\r\n            Ομάδα Διπλός {\r\n                  Αξία { \r\n                        Ένωσε γονικό [Διπλός] στη Δπλ\r\n                        =Δπλ\r\n                  }\r\n            }\r\n            Τελεστής \"+=\" {\r\n                 Διάβασε Ν\r\n                 Ένωσε γονικό ΜιαΤιμή στο Α\r\n                 Α=Α+Ν\r\n            }\r\n            Συνάρτηση Ρίζα {\r\n                  Ένωσε γονικό ΜιαΤιμή στο Α\r\n                  =Ρίζα(Α)\r\n            }\r\n      }\r\n}\r\n\r\nΚάτι.ΜιαΤιμή=100\r\nΤύπωσε Κάτι.ΜιαΤιμή\r\nΤύπωσε Κάτι.ΜιαΤιμή.Διπλός\r\nΤύπωσε Κάτι.ΜιαΤιμή.Ρίζα()\r\nΚάτι.ΜιαΤιμή+=1000\r\nΤύπωσε Κάτι.ΜιαΤιμή.Διπλός\r\n5) Δείκτες σε ιδιότητες\r\nΚλάση  Δες_Ιδιότητα {\r\nΙδιωτικό:\r\n      Πίνακας Βάση 1, Α(3)\r\nΔημόσιο:\r\n      Ιδιότητα Όνομα$ {Αξία} = \"Δες_Ιδιότητα\"\r\n      Ομάδα Άλφα {\r\n            Ιδιότητα Όνομα$ {Αξία}= \"Άλφα(δείκτης) - Μόνο για ανάγνωση\"\r\n      }\r\n      Ιδιότητα Άλφα {\r\n            Αξία (δείκτης1)    {\r\n                  Ένωσε γονικό Α() στο Α()\r\n                  Δες οκ {\r\n                        Αξία=Α(δείκτης1)\r\n                  }\r\n                  Άδειασε Λάθος\r\n                  Αν όχι Οκ τότε Λάθος \"Δείκτης εκτός ορίων\"\r\n            }\r\n      }\r\nΚλάση:\r\n      Τμήμα Δες_Ιδιότητα {\r\n            .Α():=100,450,1890\r\n      }\r\n}\r\nΜ=Δες_Ιδιότητα()\r\nΤύπωσε Μ.Άλφα(1),Μ.Άλφα(2),Μ.Άλφα(3)\r\nΤύπωσε Μ.Άλφα.Όνομα$\r\nΔες Οκ {\r\n      Τύπωσε Μ.Άλφα(10)\r\n}\r\nΤύπωσε \"Το όνομά μου είναι:\";Μ.Όνομα$\r\nΑν όχι Οκ τότε Τύπωσε \"Λάθος\"+Λάθος$\r\n\r\n
EN:PROPERTY$(\r\nΗ συνάρτηση Ιδιότητα$() θέλει μια ιδιότητα που ορίσαμε με μεταβλητή με την Με αντικείμενο και επιστρέφει ένα αντικείμενο που μπορούμε να καταχωρήσουμε σε πίνακα ή σε κατάσταση\r\nΙσχύει το ίδιο για την Ιδιότητα(), με τη διαφορά ότι δέχεται αριθμητική μεταβλητή για ιδιότητα που γυρίζει ή και παίρνει αριθμό\r\n\r\nΙδιότητες που παίρνουν παράμετρο δεν χρησιμοποιούνται από τις Ιδιότητα() και Ιδιότητα$(). Εκεί χρησιμοποιούμε αντί για μεταβλητή, ένα όνομα πίνακα (χωρίς να ορίσουμε πίνακα). Ο πίνακας αυτός όταν χρησιμοποιείται χωρίς παράμετρο γυρίζει ότι και τα Ιδιότητα() και Ιδιότητα$()\r\n\r\n\r\nΤίτλος \"?\",0  ' ελαχιστοποίηση κονσόλας\r\nΌρισε Φόρμα1 Φόρμα\r\nΜε Φόρμα1, \"title\" ως τίτλος$\r\n\r\nΠίνακας α$(10)\r\nα$(1)=Ιδιότητα$(τίτλος$)\r\nΈνωσε τίτλος$ στο μ$\r\n\r\nΣυνάρτηση Φόρμα1.about {\r\n      \\\\ πάτα ctrl+F1\r\n      Περί \"Βοήθεια\",\"Μπλα Μπλα, ctrl+tab αλλάζει τα παράθυρα\"\r\n      μ$=\"Άνοιγμα Βοήθειας\"\r\n      Τίτλος μ$\r\n}\r\nΣυνάρτηση Φόρμα1.click {\r\n      \\\\ κάνε click στην φόρμα\r\n      α$(1)=\"Νέος Τίτλος\"\r\n      Τίτλος α$(1)\r\n}\r\nΜέθοδος Φόρμα1, \"show\",1\r\n\\\\ με το κλείσιμο της φόρμας, η φόρμα παραμένει ως αντικείμενο\r\nΤύπωσε τίτλος$, μ$, α$(1)  ' τυπώνει τρεις φορές τον τίτλο\r\n\\\\ η φόρμα \"Χαλάει\" όταν την αποδεσμεύσουμε με εντολή \r\n\\\\ ή στο πέρας εκτέλεσης αυτού του τμήματος\r\nΌρισε Φόρμα1 Τίποτα\r\nΤίτλος \"Πίσω ξανά\", 1\r\n\r\n
EN:PROPERTY(\r\nδες Ιδιότητα$()\r\n
EN:PROPERTIES\r\nΒ$=ΙΔΙΟΤΗΤΕΣ$\r\nΕΚΤΥΠΩΤΗΣ !\r\nΑ$=ΙΔΙΟΤΗΤΕΣ$\r\nΙΔΙΟΤΗΤΕΣ Β$\r\nΕΚΤΥΠΩΤΗΣ !\r\n\r\nβλέπουμε τις ιδιότητες που είχε ο εκτυπωτής όπως τις είδαμε την πρώτη φορά.\r\n\r\n
EN:PROPERTIES$\r\nΗ ΙΔΙΟΤΗΤΕΣ$ επιστρέφει ένα αλφαριθμητικό με τις τρέχουσες ιδιότητες του εκτυπωτή\r\n\r\nΕδώ είναι ένα παράδειγμα όπου αλλάζουμε μια φορά τις ιδιότητες και μετά ξαναγυρνάμε στις παλιές που είχε ο εκτυπωτής όπως τις είδαμε την πρώτη φορά.\r\n\r\nΒ$=ΙΔΙΟΤΗΤΕΣ$\r\nΕΚΤΥΠΩΤΗΣ!\r\nΑ$=ΙΔΙΟΤΗΤΕΣ$\r\nΙΔΙΟΤΗΤΕΣ Β$\r\nΕΚΤΥΠΩΤΗΣ!\r\n\r\n\r\n\r\n
EN:WEAK$(\r\nΗ ισχνή$() επιστρέφει ένα αλφαριθμητικό με ισχνή αναφορά σε αυτό που δίνουμε (πρέπει να υπάρχει το όνομα μιας μεταβλητής, ενός πίνακα (με δείκτες) ή μιας συνάρτησης)\r\n\\\\ παράδειγμα με χρήση της ισχνής αναφοράς και της ένωσε\r\nα$=\"{=1000*αριθμός+αριθμός}\"\r\n\\\\ η α$ έχει ισχνή αναφορά συνάρτησης (έχει το μπλοκ εντολών {} )\r\nΈνωσε ισχνη α$ στο αα()\r\nΤύπωσε αα(10,-100)\r\nΜ=300\r\nβ$=ισχνή$(Μ)\r\n\\\\ η β$ είναι ισχνή αναφορά στην Μ\r\nΈνωσε ισχνη β$ στο Δ\r\nΤύπωσε Δ\r\nΔ+=5000\r\nΤύπωσε Μ, Μ=Δ, Εκφρ(β$)\r\n\\\\ μπορούμε με μια τελεία μετά το β$ να την χρησιμοποιούμε άμεσα\r\nβ$.+=500\r\nΤύπωσε Μ, Μ=Δ, Εκφρ(β$)\r\n\r\n\\\\ Μπορούμε να έχουμε ισχνές αναφορές σε στοιχεία πίνακα\r\nΠίνακας α(20)=10\r\nΤύπωσε α()\r\nα(2)+=10\r\nΤύπωσε α(2)\r\n\\\\ η έκφραση χ-1 εκτελείτε πριν παραχθεί η ισχνή αναφορά\r\nχ=3\r\nα$=Ισχνή$(α(χ-1))\r\nΤύπωσε Έκφρ(α$)\r\nα$.+=20\r\nΤύπωσε Έκφρ(α$)\r\nΤύπωσε α(2), α(2)=Έκφρ(α$)\r\nΤύπωσε α$\r\nμ=100\r\nα$=Ισχνή$(μ)\r\nα$.+=20\r\nΤύπωσε Έκφρ(α$)\r\nΤύπωσε α$\r\n\r\n
EN:CLEAR\r\nΚΑΘΑΡΟ\r\nΚαθαρίζει όλες τις μεταβλητές αλλά όχι τα φορτωμένα τμήματα του προγράμματός μας.\r\nΜέσα σε τμήμα καθαρίζει τις στατικές από το τμήμα αυτό και σε κάθε άλλο που καλέστηκε από αυτό.\r\nδες παράδειγμα στα αγγλικά\r\n\r\nΠαράδειγμα που δείχνει πως εκκινούμε τη Διαγραφή σε ένα αντικειμενο\r\nκλάση Αλφα {\r\n\tΔιαγραφή {\r\n\t\tΤύπωσε \"οκ\"\r\n\t}\r\n}\r\nκ->Αλφα()\r\n\\\\ μπορούμε να εκκινήσουμε τη διαγραφή\r\n\\\\ αν δεν υπάρχει άλλος δείκτης στο αντικείμενο\r\nΚαθαρό κ\r\n\\\\ τώρα βάζουμε άλλο αντικείμενο\r\nκ->Αλφα()\r\n\\\\ Το τμήμα Διαγραφή θα εκκινηθεί αυτόματα\r\n\\\\ μόλις το κ διαγραφεί στο τέλος του τμήματος\r\n\\\\ αν δεν υπάρχει αλλος δείκτης να δείχνει στο\r\n\\\\ ίδιο αντικείμενο\r\n\r\n\r\n
EN:EVERY\r\nΚΑΘΕ 100 {\r\n      ................\r\n      ΑΝ Α=1 ΤΟΤΕ ΕΞΟΔΟΣ\r\n}\r\n\r\nEvery 100 {\r\n      ................\r\n      if a=1 then exit\r\n}\r\n\r\nΕκτέλεση εντολών ανά τακτά χρονικά διαστήματα (χιλιοστά του δευτερολέπτου) και το οποίο δεν τερματίζει εκτός και αν δώσουμε κάπου την εντολή Εξοδος.\r\nΕπειδή τα νήματα είναι μέρη τμημάτων που τρέχουν παράλληλα ανά τακτά χρονικά διαστήματα πρέπει να δώσουμε χρονο στο σύστημα για να τα τρέξει, διαφορετικά με το πέρας του τμήματος που τα δημιούργησε θα σβηστούν. Έτσι με αυτή την δομή αφήνουμε τα νήματα να λειτουργήσουν και ελέγχουμε κάποια συνθήκη για να δούμε πότε θα τερματίσουμε.\r\nΌμως από την έκδοση 6.2 μπήκε η νέα εκδοχή της η ΚΥΡΙΟ.ΕΡΓΟ που δημιουργεί ένα νήμα για να τρέξει το μπλοκ. Εδώ η εντολή ΕΞΟΔΟΣ διαγράφει όλα τα νήματα του τμήματος. Η διαφορά τους είναι σημαντική γιατί γίνεται διαφορετική κατανομή χρόνου επεξεργασίας. Στην περίπτωση της ΚΑΘΕ ένα μεγάλο τμήμα μπορεί να καθυστερήσει τόσο ώστε η ΚΑΘΕ να μην έχει χρόνο να τρέξει. Αν θέλουμε όμως με την ΚΥΡΙΟ.ΕΡΓΟ κάνουμε το μπλοκ της δομής να είναι ένα νήμα! Οπότε ο χρόνος των νημάτων μοιράζεται!**\r\n\r\nΤο αναγνωριστικό ΚΑΘΕ χρησιμοποιείται και στην εντολή ΝΗΜΑ \r\nΚαθε ή Interval\r\n\r\n\r\n**Εξήγηση. Τα νήματα τα διαχειρίζεται ένα σύστημα με ένα κεντρικό ρολόι, σε μια εσωτερική λειτουργία την οποία καλεί εξωτερικά το λειτουργικό. Ενώ τρέχει το περιβάλλον της Μ2000 όταν υπάρχουν νήματα ξεκινάει ο εξωτερικός σκανδαλισμός. Σε κάθε σκανδαλισμό η εσωτερική λειτουργία κοιτάει σε μια λίστα νημάτων να δει ποιο έχει σειρά να το καλέσει. Στη κλήση το νήμα κοιτάει αν είναι ο χρόνος του να τρέξει και αν είναι οκ τότε θα  τρέξει. Ο σκανδαλισμός όμως συνεχίζει να καλεί την εσωτερική ρουτίνα. Δεν γίνεται να καλέσουμε ένα νήμα δυο φορές γιατί σε κάθε περίπτωση το νήμα που πήρε το σκανδαλισμό βγαίνει εκτός λίστας και θα ξαναμπεί όταν τελειώσει ότι έχει να κάνει. Κάποια στιγμή η λίστα νημάτων θα αδειάσει. Όμως σε κάθε περίπτωση κρατάει το σύστημα μια λίστα με τα νήματα που τρέχουν. Έτσι το σύστημα δεν σταματάει τον σκανδαλισμό αν έχει νήματα που ήδη τρέχουν ενώ δεν έχει άλλα να τρέξει. Αν λοιπόν χρησιμοποιήσουμε την ΚΥΡΙΟ.ΕΡΓΟ τότε μόνο νήματα τρέχουν ενώ στην κύρια εφαρμογή υπάρχει ένας βρόχος που περιμένει πότε θα τερματίσει το κύριο έργο (το νήμα του). Ενώ η ΚΑΘΕ δεν ξεκινάει νήμα και απλά κοιτάει ένα εσωτερικό ρολόι πόσο χρόνο χρειάζεται μετά το πέρας των εντολών που έχει εκτελέσει για να συμπληρώσει μέχρι την επόμενη γύρα που θα ξανατρέξει τις εντολές του μπλοκ. Αν μάλιστα ο χρόνος περάσει τον προβλεπόμενο τότε απλά αμέσως έρχεται ο νέρος γύρος εκτέλεσης. Μοιάζει με το Νημα αλλά δεν είναι ίδιος ο μηχανισμός!\r\n\r\nδες το παράδειγμα στο EVERY\r\n\r\n\r\n\r\n\r\n
EN:EACH(\r\nΕπαναλήπτες\r\n1) δίνουμε όλα τα στοιχεία του Α στον επαναλήπτη Ν\r\n  Ν=ΚΑΘΕ(Α)\r\n2) δίνουμε τα στοιχεία 1,2,3 του Α στον επαναλήπτη Ν\r\n  Ν=ΚΑΘΕ(Α,1,3)\r\n3) δίνουμε αόριστα, από Αρχή έως Τέλος, το ίδιο όπως αυτό ΚΑΘΕ(Α,1,-1)\r\n  Ν=ΚΑΘΕ(Α ΑΡΧΗ ΕΩΣ ΤΕΛΟΣ)\r\n\r\n\\\\ για τα 1,2,3\r\nΕνω Ν {\r\n      Τύπωσε Ν^   \\\\ δίνει το νούμερο όπως αλλάζει\r\n}\r\n\r\nΓια βήμα μπορούμε μέσα στην επανάληψη να αλλάξουμε προγραμματισμό του επαναλήπτη, με μια νέα Κάθε.\r\nΤο Α μπορεί να είναι Πίνακας, Κατάσταση, Σωρός\r\nΚάθε επαναλήπτης έχει δικό του δρομέα και μπορούμε να βάλουμε φωλιασμένους επαναλήπτες για το ίδιο αντικείμενο\r\n
EN:AND\r\nΤελεστής Και\r\nΤύπωσε Αληθές Και Ψευδές\r\n\r\n
EN:CALL\r\nΜε την Κάλεσε καλούμε τμήματα και συναρτήσεις, δίνοντας τον τρέχον σωρό.\r\n\r\n\r\n1) Κάλεσε [Κενή] [Συνάρτηση] ΟΝΟΜΑ [ΠΑΡΑΜΕΤΡΟΙ)\r\nΜε το Κενή λέμε στην Κάλεσε να αγνοήσει τυχόν επιστροφή από τη συνάρτηση.\r\nΜπορούμε σε μια συνάρτηση να μην έχουμε επιστροφή ως εντολή αλλά πάντα γυρνάει το 0 ή το \"\" αν είναι αλφαριθμητική.\r\nΜε το Συνάρτηση απλά δεν δίνουμε τις παρενθέσεις, και παραθέτουμε τις παραμέτρους όπως στην Κάλεσε με τμήμα\r\n\r\n\r\nΚαθαρό \\\\ καθαρίζει και τις στατικές\r\nΑδειασε \\\\ αδειάζει το σωρό\r\nΣυνάρτηση Δικήμας {\r\n      Διάβασε Α,Β,Γ,Δ\r\n      Τύπωσε Β,Γ,Δ\r\n      Αν Α=1 Τότε {\r\n            =0\r\n      } Αλλιώς {\r\n            =1 \r\n      }\r\n}\r\n\\\\ με την λέξη Κενή αδιαφορεί για την επιστροφή\r\nΚάλεσε Κενή Συνάρτηση Δικήμας(0,2,3,4)\r\nΚάλεσε Κενή Συνάρτηση Δικήμας 0,2,3,4\r\nΚάλεσε Κενή Συνάρτηση Δικήμας, 0,2,3,4\r\nΔες οκ {\r\n      Κάλεσε Δικήμας(0,2,3,4)\r\n}\r\nΑν Όχι Οκ Τότε Τύπωσε Λάθος$\r\nΑ$=\"Δικήμας(\"\r\nΚάλεσε Α$, 1,2,3,4\r\nΚάλεσε Δικήμας(, 1,2,3,4\r\nΒάλε 4,3,2,1  ' το ένα θα γίνει κορυφή του σωρού\r\nΚάλεσε Δικήμας(\r\nΓενική Χ=10\r\nΤμήμα Αλφα {\r\n      Τύπωσε \"οκ\", Χ\r\n      \\\\ υπάρχει τρόπος για αναδρομή\r\n      Αν Χ>1 τότε Χ-- : Κάλεσε Αλφα\r\n}\r\nΑλφα\r\n\r\n\r\n2) Παράδειγμα με την Κάλεσε Τοπικά\r\nΧ=10\r\nΣυνάρτηση Αλφα {\r\n      Χ++\r\n      Τύπωσε Χ\r\n}\r\nΚάλεσε Τοπικά Αλφα()  \\\\ 11\r\nΚάλεσε Τοπικά \"Αλφα()\" \\\\ 12\r\nΣυνάρτηση Βήτα {\r\n      Τοπική Χ=1000\r\n      Κάλεσε Τοπικά Αλφα()\r\n}\r\nΚάλεσε Τοπικά Βήτα()  \\\\ 1001\r\nΚάλεσε Τοπικά Αλφα() \\\\13\r\nΤύπωσε Χ  \\\\ 13\r\nΣυνάρτηση Δέλτα {\r\n      Διάβασε Νέο &Χ\r\n      Κάλεσε Τοπικά Αλφα()\r\n}\r\nΜ=1233\r\nΚάλεσε Τοπικά Δέλτα(&Μ) \\\\ 1234\r\nΤύπωσε Μ \\\\ 1234\r\n\r\n\r\n3) Ειδική περίπτωση όταν το όνομα τμήματος είναι ίδιο με μια εντολή:\r\n3.1) Όταν το τμήμα είναι τοπικό\r\nΤμήμα Τύπωσε {      \r\n      Ενώ Όχι Κενό {\r\n            Διάβασε Α\r\n            Τύπωσε $(\"\\Α\\λ\\η\\θ\\έ\\ς;\\Α\\λ\\η\\θ\\έ\\ς;\\Ψ\\ε\\υ\\δ\\έ\\ς\"), Α,$(\"\")\r\n            Αν Πλάτος-Θέση<Στήλη Τότε @Τυπωσε\r\n            \\\\  το @ μπροστά από εντολή καλεί οπωσδήποτε την εντολή!          \r\n      }\r\n}\r\nΚάλεσε Τύπωσε -1,0,3\r\n.Τύπωσε -1,0,3\r\nΤύπωσε\r\nΤύπωσε -1,0,3\r\n3.2) Όταν το τμήμα είναι γενικό\r\nΤμήμα Γενικό Τύπωσε {      \r\n      Ενώ Όχι Κενό {\r\n            Διάβασε Α\r\n            @Τύπωσε $(\"\\Α\\λ\\η\\θ\\έ\\ς;\\Α\\λ\\η\\θ\\έ\\ς;\\Ψ\\ε\\υ\\δ\\έ\\ς\"), Α,$(\"\")\r\n            Αν Πλάτος-Θέση<Στήλη Τότε @Τυπωσε\r\n            \r\n      }\r\n}\r\nΤύπωσε -1,0,3\r\n@Τύπωσε -1,0,3\r\n\r\n4) Όταν καλούμε Γεγονός, δηλαδή να εκτελεστούν οι όποιες συναρτήσεις του, τότε χρησιμοποιούμε την Κάλεσε Γεγονός, δίνοντας το όνομα του γεγονότος και ακολουθούν οι όποιες παράμετροι που θα πάνε σε όλες τις συναρτήσεις (δέχεται και πέρασμα με αναφορά)\r\nΔείτε το παράδειγμα στην εντολή  Γεγονός όπου ορίζουμε ένα γεγονός.\r\n\r\n\r\n\r\n\r\n
EN:CURVE\r\nΗ εντολή ΚΑΜΠΥΛΗ μοιάζει με την πολύγωνο με την διαφορά ότι χρησιμοποιεί τρία σημεία για κάθε καμπύλη (πρώτο, δεύτερο, τρίτο) κατά το πρότυπο BEZIER.\r\nΗ τελική θέση της καμπύλης μπορεί να βρεθεί από το άθροισμα των χ και ψ χωριστά.\r\nΠ.Χ\r\nΚΑΜΠΥΛΗ 1000,1000,0,2000,500,1000\r\nσυνολικό Χ μετατόπιση= 1000+0+500 = 1500\r\nσυνολικό Ψ μετατόπιση= 1000+2000+1000= 4000\r\n\r\nΚΑΜΠΥΛΗ ΓΩΝΙΑ γωνία1, απόσταση1, γωνία2, απόσταση2, γωνία3, απόσταση3\r\nΚΑΜΠΥΛΗ ΓΩΝΙΑ γωνία1, απόσταση1, γωνία2, απόσταση2, γωνία3, απόσταση3, ..., ..., ..., γωνίαN, απόστασηN, γωνίαN, απόστασηN, γωνίαN, απόστασηN\r\n---------------------\r\n\r\nπαραδείγματα εδώ CURVE\r\n\r\n\r\n\r\n\r\n
EN:DEF\r\n1) Κάνε Αριθμό Α, Β, Γ\r\n   Κάνε Γράμμα Α$, Β$, Γ$\r\n   φτιάχνουμε μόνο τοπικές μεταβλητές και δεν πρέπει να υπάρχουν άλλες τοπικές με το ίδιο όνομα, αλλιώς βγάζει λάθος\r\n   (να αποφεύγουμε ορισμό σε ρουτίνες, εκτός αν έχουμε καλό σχεδιασμό)\r\n   γράμματα και αριθμοί (όλοι οι τύποι) μπορούν να έχουν το ίδιο όνομα (όχι όμως το ίδιο όνομα σε δυο αριθμητικούς τύπους)\r\n   Αριθμητικοί τύποι: Αριθμός, Διπλός, Απλός, Λογιστικό, Μακρύς, Λογικός, Ακέραιος\r\n   Δίνουμε τα ονόματα ως Αριθμό, Διπλό, Απλό, Λογιστικό, Μακρύ, Λογικό, Ακέραιο\r\n   Αντιστοιχούν στα Decimal, Double, Single, Currency, Long, Boolean, Integer\r\n   Όλες οι μεταβλητές αριθμητικών τύπων κάνουν αυτόματη προσαρμογή στο τύπο τους όταν τους δίνουμε τιμή. Μπορεί να βγεί λάθος αν δεν χωράει ο αριθμός κατά την προσαρμογή.\r\n  Κάνε Τοπικά Α, Β, Γ ' θα φτιάξει νέες τοπικές ακόμα και αν υπάρχουν (για ρουτίνες) \r\n  μπορούμε να δίνουμε τύπους και τιμές (χωρίς σύμβολο τύπου), ή μόνο τιμές (και με σύμβολο τύπου)\r\n  Κάνε Α=100~, Β ως Λογιστικό=12323.213, Γ ως Μακρύς=100\r\n\r\n\\\\ με την Κάνε Μακρύ φτιάχνουμε 32bit μεταβλητές\r\n\\\\ μπορούμε όμως ορισμένες να τις δηλώσουμε με την ως ή με τύπο στο νούμερο\r\n\\\\ με χρήση των & ~ @ # %\r\nΚάνε Μακρύ α=10, β=20, γ ως Διπλός=30, δ=40#\r\nΤύπωσε Τύπος$(α), Τύπος$(β), Τύπος$(γ), Τύπος$(δ)\r\n   \r\n2) ΚΑΝΕ Α(Χ)=Χ**2 : ΚΑΝΕ Α$(Χ$)=Χ$+Χ$\r\nΤΥΠΩΣΕ Α(100), Α$(\"00\")\r\nΜπορούμε να φτιάχνουμε συναρτήσεις σε μια εντολή\r\nΕδώ ουσιαστικα έχουμε δυο κανονικές συναρτήσεις όπως αυτές\r\nΣυνάρτηση Α {\r\n      Διάβασε Χ\r\n      =Χ**2\r\n}\r\nΣυνάρτηση Α$ {\r\n      Διάβασε Χ$\r\n      =Χ$+Χ$\r\n}\r\n
EN:NORMAL\r\nΚΑΝΟΝΙΚΑ\r\nΕπιλέγουμε κανονικά γράμματα\r\n(βάση του τύπου που έχουμε δώσει στην ΤΥΠΟΣ ή ΠΑΡΑΘΥΡΟ)\r\nΑντίθετη ΔΙΠΛΑ\r\n\r\n
EN:DIR$\r\nΤυπωσε Κατ$\r\nΕπιστρέφει τον τωρινό κατάλογο. Μπορεί να αλλαχτεί αυτός ο κατάλογος με την εντολή ΚΑΤΑΛΟΓΟΣ\r\n\r\nστο φάκελο χρήστη δίνει \".\" το οποίο μπορούμε να χρηιμοποιήουμε όσο είμαστε σε αυτόν τον  κατάλογο\r\nμπορούμε να μεταβούμε σε αυτόν με την εντολή (μπορούμε να βάλουμε και τόνους)\r\nκατάλογος χρήστη  \r\n\r\n
EN:DIR\r\nΚΑΤΑΛΟΓΟΣ \"C:\"\r\nΚΑΤΑΛΟΓΟΣ \"..\\αλφα\"  (ανεβαίνει ένα επίπεδο και κατεβαίνει στο αλφα - αν υπάρχει!)\r\nΤΥΠΩΣΕ KAT$\r\n\r\nDIR \"C:\\\"\r\nPRINT DIR$\r\n\r\nΚΑΤΑΛΟΓΟΣ ΧΡΗΣΤΗ  (κάνει τον κατάλογο του χρήστη  username\\M2000\\  τωρινό κατάλογο)\r\n\r\nΚΑΤΑΛΟΓΟΣ ?              (ανοίγει ένα διάλογο επιλογής φακέλου)\r\nΚΑΤΑΛΟΓΟΣ ? \"C:\\\"     (ανοίγει ένα διάλογο επιλογής φακέλου με κορυφή τον C:\\\")\r\nΚΑΤΑΛΟΓΟΣ ? \"C:\\\", \"ΓΡΑΨΕ ΚΑΤΙ\"\r\nΚΑΤΑΛΟΓΟΣ ? \"?\"  (βάζει και το ΝΕΟΣ ΦΑΚΕΛΟΣ)\r\nΚΑΤΑΛΟΓΟΣ ? \"C:\\?\"  (αρχικός φάκελος και επιλογή ΝΕΟΣ ΦΑΚΕΛΟΣ)\r\nΚΑΤΑΛΟΓΟΣ ? \"C:\\?\", \"ΓΡΑΨΕ ΚΑΤΙ, η βάλε και δυο τρεις γραμμές\"\r\n\r\nΚΑΤΑΛΟΓΟΣ {μια γραμμή\r\nμια άλλη\r\nκαι μια άλλη } ? \"C:\\?\"\r\n\r\nΑν ακυρώσουμε την εισαγωγή φακέλου τότε δεν αλλάζει ο τρέχον φάκελος.\r\nΑν προσθέσουμε το ΣΤΟ Κ$ τότε βάζουμε το μονοπάτι του φακέλου στο Κ$ και δεν αλλάζουμε τον τρέχον φάκελο\r\n\r\n' Δεν μπορούμε να ανοίξουμε δυο φορές τον επιλογέα φακέλου/αρχείου\r\n' Μπορούμε όμως να το ανοίξουμε ενώ έχουμε νήματα να τρέχουν μαζί.\r\n' η εντολή ΔΕΣ φτιάχνει την μεταβλητή ΕΝΤΑΞΕΙ και βάζει -1 αν δεν βγάλει λάθος το μπλοκ εντολών \r\n' η ΟΧΙ όπως και η ΔΕΝ αντιστρέφουν το ΑΛΗΘΕΣ με ΨΕΥΔΕΣ και το ΨΕΥΔΕΣ με ΑΛΗΘΕΣ\r\n' όπου ΑΛΗΘΕΣ = -1 και ΨΕΥΔΕΣ=0\r\n' Υπάρχουν και τα ΑΛΗΘΗΣ και ΨΕΥΔΗΣ επίσης\r\n\r\nΚΑΤΑΛΟΓΟΣ ΧΡΗΣΤΗ\r\nΜΕΤΑ 200 {\r\n      ΤΥΠΩΣΕ \"ΕΛΕΓΧΟΣ\"\r\n      ΔΕΣ ΕΝΤΑΞΕΙ {\r\n             ΚΑΤΑΛΟΓΟΣ ?\r\n       }\r\n       ΑΝ ΟΧΙ ΕΝΤΑΞΕΙ ΤΟΤΕ ΤΥΠΩΣΕ ΛΑΘΟΣ$\r\n }\r\n ΚΑΤΑΛΟΓΟΣ ?\r\n \r\n
EN:INVENTORY\r\n\\\\Λίστα ειδών\r\n\\\\εδώ μόνο με μοναδικά κλειδιά\r\nΚατάσταση Αλφα = 1,2,3,4,5\r\nνέα προσθήκη:   Αλφα=Λίστα:=1,2,3,4,5\r\n\\\\εδώ με όμοια κλειδιά  (στην τύπου ουρά δεν διαγράφουμε κλειδιά οπουδήποτε, παρά μόνο από το τέλος)\r\nΒήτα=Ουρά:=1,2,3,1,2,3\r\nΒήτα=(Ουρά:=1,2,3,1:=\"α\",2:=\"β\",3:=\"γ\")   ' βάζουμε παρενθέσεις αν μπει σε συνάρτηση λόγω του \":\" χαρακτήρα.\r\nΠέτα Βήτα 3   ' θα πετάξει 3 στοιχεία από το τέλος\r\nΤύπωσε Βήτα    ' 1 2 3\r\nΒήτα=Ουρά:=1,2,3,1,2,3\r\nΠέτα Βήτα  Εως 2   ' θα κρατήσει τα 2 πρώτα\r\nΤύπωσε Βήτα    ' 1 2 \r\nγια ι=0 έως μήκος(Βήτα)-1\r\n\\\\ τιμή ανά θέση  και κλειδί ανά θέση\r\nΤύπωσε Βήτα$(ι!), Εκφρ$(Βήτα, ι)\r\nΕπόμενο ι\r\n\\\\ Εύρεση κλειδιού, δίνει την τιμή και τη θέση\r\nΑν Υπάρχει(Βήτα, 2) Τότε Τύπωσε Εκφρ(Βήτα)=200, Εκφρ(Βήτα!)=1\r\nΕπιστροφή Βήτα, 2:=\"Αλφαριθμητικό\"\r\nΠροσθήκη Βήτα, \"κάτι\":=\"Αυτό\"\r\nΑν Υπάρχει(Βήτα, 2) Τότε Τύπωσε Εκφρ$(Βήτα)=\"Αλφαριθμητικό\", Εκφρ(Βήτα!)=1\r\nΤύπωσε Βήτα$(\"κάτι\")=\"Αυτό\"\r\n\r\n\r\n\r\n\r\nεπιστροφή Αλφα, 1:=\"οκ\", 2:=-500\r\n\\\\ η συνάρτηση Υπάρχει σε Ουρά θα δείξει στα όμοια κλειδιά το τελευταίο που μπήκε στην ουρά.\r\nΤύπωσε Υπάρχει(Αλφα, 1)\r\nΤύπωσε Αλφα$(1), Αλφα(2)\r\nΤύπωσε Μήκος(Αλφα)\r\nΠροσθήκη Αλφα, \"κάτι άλλο\":=\"αυτό\"\r\nΑφαίρεση Αλφα, 3,4,5\r\n\r\n\\\\ Παράδειγμα:\r\nΣυνάρτηση Πίνακας_2D { Πίνακας α(Αριθμός, Αριθμός) : =α()}\r\nΣυνάρτηση Πίνακας_1D {=0,1,2,3,4,5,6,7,8,9}\r\nΚατάσταση α=0:=Πίνακας_2D(5,5), 1:=Πίνακας_1D(),2,3:=100,4\r\nα(0)(2,2)=α(1)(5)*10\r\nΤύπωσε α(1)(5), α(0)(2,2)\r\nΠίνακας β(5)\r\nΓια ι=0 έως 1  { \r\n      β(ι)= α(ι)()\r\n}\r\nΓια ι=2 έως 4 {\r\n      β(ι)=α(ι)\r\n}\r\nβ(0)(2,2)=1000\r\nΤύπωσε β(0)(2,2), α(0)(2,2)\r\nΤύπωσε β(1)(3), β(2), β(3), β(4)\r\n\\\\ η επιστροφή στη κατάταξη γίνεται με ειδική εντολή\r\nΕπιστροφή α, 4:=400\r\n\\\\ όχι όμως για πίνακες σε αυτήν:\r\nα(1)(5)+=100\r\nΤύπωσε β(4), α(4), α(1)(5), β(1)(5)  ' 4, 400, 105, 5\r\n\\\\ τα νούμερα στη κατάταξη είναι κλειδιά\r\n\\\\ μπορεί να είναι αριθμοί ή αλφαριθμητικά\r\nΠροσθήκη α, \"2Χ2\":=Πίνακας_2D(2,2)\r\nα(\"2Χ2\")(0,0)=100\r\nΤύπωσε α(\"2Χ2\")(0,0)   ' 100\r\n\\\\ μπορούμε να αφαιρούμε στοιχεία\r\n\\\\ δεν αλλάζει η \"αρίθμηση\" γιατί στην ουσία είναι κλειδιά..μοναδικά!\r\n\\\\ η αφαίρεση δεν λειτουργεί για Ουρά\r\nΑφαίρεση α, 1,4\r\nΤύπωσε Μήκος(α) ' 4, δίνει το μήκος σε στοιχεία!\r\nΤύπωσε Υπάρχει(α, 0)  ' -1 ναι υπάρχει\r\nΤύπωσε Υπάρχει(α, 1)  ' 0 δεν υπάρχει\r\n\r\n\\\\ μπορούμε να δούμε τα κλειδιά\r\n\\\\ με χρήση ιδιοτήτων.\r\nΜε α, \"done\", αληθές, \"keytostring\" ως κλειδί$\r\nΓια ι=0 έως μήκος(α)-1\r\nΜε α, \"index\", ι\r\nΤύπωσε Κλειδί$\r\nΕπόμενο ι\r\n\r\n\\\\ ή με απλό τρόπο:\r\nΓια ι=0 έως μήκος(α)-1\r\nββ$=α$(ι!)  \\\\ απλά εξάγουμε μια τιμή αλφαριθμητική ή το \"\"\r\n\\\\ όμως πάμε το index στο ι και κάνουμε το done =true\r\n\\\\ το \"done\" είναι σημαία που λέει ότι το index είναι έγκυρο.\r\n\\\\ οπότε εδώ δεν δίνουμε καθόλου νούμερο, αλλά χρησιμοποιεί \r\n\\\\ η κατάταξη το τρέχον (είναι στην ιδιότητα index)\r\n\\\\ Η συνάρτηση Εκφρ$ με το ! έχει σκοπό να δώσει το κλειδί\r\nΤύπωσε Εκφρ$(α!)\r\nΕπόμενο ι\r\n\r\nΗ εκφρ$(α, 0) δίνει πάντα το κλειδί του στοιχείου 0 (το πρώτο στη κατάταξη)\r\n\r\n\\\\ Μπορούμε να βρούμε τη θέση (προσοχή γιατί οι θέσεις αλλάζουν αν ταξινομήσουμε, ή διαγράψουμε)\r\nΑν υπάρχει(α, \"2Χ2\") τότε κ=εκφρ(α!)\r\nΤύπωσε \"θέση=\";κ\r\n\r\nΤύπωσε α(κ!)(0,0) \r\nΤύπωσε Τύπος$(α(κ!))\r\nΠίνακας αα()\r\nαα()=α(κ!)\r\nΤύπωσε αα(0,0)\r\n\r\n\r\n\r\n
EN:MOVIE.STATUS$\r\nΚΑΤΑΣΤΑΣΗ.ΤΑΙΝΙΑΣ$\r\nμας δίνει την κατάσταση ταινίας!\r\n\r\n\r\n
EN:OVERWRITE\r\nΚΑΤΑΧΩΡΗΣΗ\r\n1)\\\\ για έγγραφο και για αλφαριθμητικό\r\n\\\\ δουλεύει ανάποδα από την Μέρος$(), εδώ καταχωρούμε σε θέση  μεταξύ των σημαδιών, εδώ το \".\"\r\nΑ$=\"ααα.βββ\"\r\nΚαταχώρηση Α$, \".\", 1:=\"Γεια\",5:=\"ένα ακόμα\"\r\nΤύπωσε Α$\r\nΤύπωσε Τύπος$(Α$)\r\nΠίνακας K$(5)\r\nK$(3)=\"ααα.βββ\"\r\nΚαταχώρηση K$(3), \".\", 1:=\"Γεια\",5:=\"ένα ακόμα\"\r\nΤύπωσε K$(3)\r\nΤύπωσε Τύπος$(K$(3))\r\nΈγγραφο Α$=\"ααα.βββ\"\r\nΚαταχώρηση Α$, \".\", 1:=\"Γεια\",5:=\"ένα ακόμα\"\r\nΤύπωσε Α$\r\nΤύπωσε Τύπος$(Α$)\r\nΠίνακας K$(5)\r\nΈγγραφο K$(3)=\"ααα.βββ\"\r\nΚαταχώρηση K$(3), \".\", 1:=\"Γεια\",5:=\"ένα ακόμα\"\r\nΤύπωσε K$(3)\r\nΤύπωσε Τύπος$(K$(3))\r\n\r\n2)\\\\ για έγγραφο\r\nέγγραφο α$, β$\r\nα$={aaaaaaaaaaa\r\n12345678901234567890\r\n}\r\nβ$=α$\r\n\\\\ ανοίγει χώρο και γράφει\r\nπαρεμβολή στο 2, 10 α$=\"γεια\"\r\nΑναφορά β$\r\nΑναφορά α$\r\nΚαθαρό α$\r\nΈγγραφο α$=β$\r\n\\\\ γράφει πάνω στο κείμενο\r\nπαρεμβολή στο 2, 10 α$=\"γεια\"\r\nΑναφορά β$\r\nΑναφορά α$\r\nΚαθαρό α$\r\nα$=β$\r\nκαταχώρηση 2,10 α$=\"γεια\"\r\nΑναφορά β$\r\nΑναφορά α$\r\nΚαθαρό α$\r\nα$=β$\r\nκαταχώρηση 2 α$=\"γεια\"   \\\\ αλλάζει την παράγραφο με την εισαγωγή του \"γεια\"\r\nΑναφορά β$\r\nΑναφορά α$\r\n\r\n
EN:LOWWORD(\r\nΑ=0xFFEE12C3\r\nΤύπωσε Δεκαεξ$(ΚΑΤΩΜΙΣΟ(Α),2)\r\nΤύπωσε Δεκαεξ$(ΠΑΝΩΜΙΣΟ(Α),2)\r\n\r\nΔεκαεξ ΚΑΤΩΜΙΣΟ(Α),  ΠΑΝΩΜΙΣΟ(Α)\r\n\r\n\r\n
EN:TEXT, HTML\r\nΤο κείμενο εδώ είναι με ένα Byte ανά χαρακτήρα  (όχι Unicode)\r\nΑυτή η εντολή είναι εδώ για δύο λόγους. Να δημιουργεί καταγραφές εύκολα (log file)\r\nκαι να δημιουγεί φόρμες για το ΑΝΑΛΟΓΙΟ\r\nΓια unicode μπορούμε να ανοίξουμε αρχεία στο ΠΡΟΣΩΡΙΝΟ$ και για να τα σβήσουμε μπορούμε να δώσουμε το όνομα με τον τύπο χωρίς το μονοπάτι στην εντολή ΚΕΙΜΕΝΟ χωρίς να προσθέσουμε μπλοκ με γραμμές. (δες 5)\r\n\r\nΠροσθήκη στην 7 έκδοση\r\n\r\nΚΕΙΜΕΝΟ utf-8 a$ {\r\n}\r\n\r\nΚΕΙΜΕΝΟ utf-16 a$ {  \r\n}\r\n\r\n1) Δημιουργία κειμένου σε προσωρινό φάκελο\r\nα$=\"αλφα\"\r\nΚΕΙΜΕΝΟ α$ {           \r\nμπλα μπλα μπλα \r\n}\r\nΚΕΙΜΕΝΟ αλφα {     ' εδώ το αλφα δεν είναι μεταβλητή αλλά όνομα\r\nμπλα μπλα μπλα \r\n}\r\n2) Προσθήκη κειμένου\r\nΚΕΙΜΕΝΟ αλφα + {\r\nάλλη γραμμή, μπλα μπλα\r\n}\r\n3) Δημιουργία Ιστοσελίδας και πέρασμα μεταβλητής\r\nalfa$=\"GEORGE\"\r\nΚΕΙΜΕΝΟ αλφα.html {<!doctype html public \"-//w3c//dtd html 3.5//en\">\r\n<html>\r\n<head>\r\n<title>(Type a title for your page here)</title>\r\n<meta name=\"GENERATOR\" content=\"M2000\">\r\n<meta name=\"FORMATTER\" content=\"M2000\">\r\n<meta content=\"this, other, that\" name=keywords>\r\n<meta content=All name=robots> \r\n<meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=windows-1253\">\r\n<meta NAME=\"Author\" CONTENT=\"GEORGE KARRAS\">\r\n</head>\r\n<body bgcolor=\"#ffffff\" text=\"#000000\" link=\"#0000ff\" vlink=\"#800080\" alink=\"#ff0000\">\r\nΓεια Χαρά ##alfa$##\r\n</body>\r\n</html>\r\n}\r\n\r\n4) Δημιουργία Ιστοσελίδας με φόρμα, πέρασμα τιμών και συλλογή τιμών σε μεταβλητές\r\nΤμημα α {\r\nΑΝΑΨΕ\r\nusername$ = \"Γιωργος\" \r\nκειμενο αλφα.html {<!doctype html public \"-//w3c//dtd html 3.2//en\">\r\n<html>\r\n<head>\r\n<title>(Type a title for your page here)</title>\r\n<meta name=\"GENERATOR\" content=\"M2000\">\r\n<meta name=\"FORMATTER\" content=\"M2000\">\r\n<meta content=\"this, other, that\" name=keywords>\r\n<meta content=All name=robots> \r\n<meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=windows-1253\">\r\n<meta NAME=\"Author\" CONTENT=\"GEORGE KARRAS\">\r\n</head>\r\n<body bgcolor=\"CYAN\" text=\"#000000\" link=\"#0000ff\" vlink=\"#800080\" alink=\"#ff0000\">\r\n<CENTER>Χειριστής</CENTER></H1><HR>\r\n<script> var m1;var p1;var total;function alfa() { total=\"?onoma=2000\";total=total+\"&username=\"+escape(m1);total=total+\"&password=\"+escape(p1);document.title=total;setTimeout (\"alfa()\",100);return true}</script>\r\n<FORM NAME=\"ValidForm\" action=\"about:blank\" >\r\n<INPUT NAME=\"onoma\" TYPE=\"HIDDEN\" MAXLENGTH=4 SIZE=\"4\" VALUE=\"1000\">\r\n<TABLE ALIGN=CENTER BORDER=0 RULES=NO COLS=\"2\">\r\n<TBODY>\r\n<TR VALIGN=TOP  >\r\n<TD  >Ονομα:</TD>\r\n<TD  ><INPUT NAME=\"username\" TYPE=\"TEXT\" id=\"uname\" MAXLENGTH=16 SIZE=\"16\" VALUE=\"##username$##\" ></TD>\r\n</TR>\r\n<TR VALIGN=TOP  >\r\n<TD  >Συνθηματικό:</TD>\r\n<TD  ><INPUT NAME=\"password\" ID=\"pass\" TYPE=\"PASSWORD\" MAXLENGTH=8 SIZE=\"8\"></TD>\r\n</TR>\r\n</TABLE>\r\n<CENTER><BR><HR>\r\n<input type=button value=\"Αποστολή\" onclick=\"m1=uname.value;p1=pass.value;alfa()\">\r\n</CENTER>\r\n</FORM>\r\n</body>\r\n</html>\r\n}\r\nonoma$=\"\"\r\nαναλογιο αλφα.html\r\nενω onoma$=\"\" {ανανεωση}    ' προσοχή εδώ ...η ανανέωση χρειάζεται για να πιάσουμε την αποστολή από την σελίδα.\r\nλιστα\r\nαναλογιο \"\"\r\nκειμενο αλφα.html  ' εδώ σβήνουμε το προσωρινό αρχείο\r\nΤυπωσε\"ΟΚ\":α$=κομ$\r\n}\r\nα\r\n\r\n5) ΚΕΙΜΕΝΟ ονομα.τυπος\r\nΚΕΙΜΕΝΟ \"ονομα.τυπος\"  ή  έκφραση αλφαριθμητική\r\nσβήνει το αρχείο προσωρινο$+\"ονομα.τυπος\"\r\n\r\n\r\nΔΕΣ ΓΕΝΙΚΑ ΓΙΑ ΙΣΤΟΣΕΛΙΔΕΣ\r\n\r\n\r\n
EN:TEXT_as constant\r\nχρησιμοποιείται στην εντολή ΑΡΧΕΙΟ\r\n\r\n
EN:EMPTY\r\nΤυπωσε ΚΕΝΟ\r\nΔίνει ΑΛΗΘΕΣ αν δεν υπάρχει στοιχείο στο ΣΩΡΟ\r\n\r\nΔες και την ΜΕΓΕΘΟΣ.ΣΩΡΟΥ\r\nΜΕΓΕΘΟΣ.ΣΩΡΟΥ=0 είναι ισοδύναμο με το ΚΕΝΟ\r\n\r\n
EN:UCASE$(\r\n1. Δέχεται σαν όρισμα ένα αλφαριθμητικό και δίνει το ίδιο αλλά με κεφαλαία γράμματα\r\n2. Δεύτερη παράμετρος προαιρετική το τοπικό. \r\nΔείτε το παράδειγμα. Το 1032 είναι για την Ελλάδα, ενώ το 1033 τα αγγλικά.\r\nΚανονικά η λέξη \"Γιώργος\" έχει 7 χαρακτήρες των 14 συνολικά bytes\r\nτοπικο 1032\r\nα$=γραφη$(\"Γιώργος\")\r\nΤύπωσε χαρ$(α$) ' μετατροπή βάσει του 1032\r\nΤύπωσε Μήκος(α$)=3.5  ' μονάδες word=2 bytes, άρα 3.5*2=7bytes\r\nτοπικό 1032\r\nΤύπωσε Κεφ$(χαρ$(α$), 0) ' δίνει λάθος\r\nτοπικό 1033\r\nΤύπωσε Κεφ$(χαρ$(α$), 1032) ' ΟΚ\r\nτοπικό 1033\r\nΤύπωσε Κεφ$(χαρ$(α$)) ' δίνει λάθος\r\nτοπικό 1032\r\nΤύπωσε Κεφ$(χαρ$(α$))  ' ΟΚ\r\n\r\n\r\n\r\n
EN:MOTION\r\nΜετακίνηση της οθόνης πάνω από το περιθώριο\r\nΚΙΝΗΣΗ ΚΕΝΤΡΟ\r\nΚΙΝΗΣΗ θεσηΧ, θεσηΥ\r\nΚΙΝΗΣΗ θεσηΧ\r\nΚΙΝΗΣΗ ,θεσηΥ\r\n\r\nΜπορούμε να διαβάσουμε την θέση της ΟΘΟΝΗΣ με τα ΚΙΝΗΣΗ.Χ και ΚΙΝΗΣΗ.Υ\r\n
EN:MOTION.W\r\nΜετακίνηση του περιθωρίου πάνω στην επιφάνεια εργασίας\r\nΚΙΝΗΣΗ.Π;\r\nΚΙΝΗΣΗ.Π θεσηΧ, θεσηΥ\r\nΚΙΝΗΣΗ.Π θεσηΧ\r\nΚΙΝΗΣΗ.Π ,θεσηΥ\r\n\r\nΠαρατήρηση: εδώ το ; δηλώνει κέντρο.\r\nΥπάρχουν οι μεταβλητές ΚΙΝΗΣΗ.ΠΧ και ΚΙΝΗΣΗ.ΠΥ που μας δείχνουν τα τωρινά Χ και Υ της άνω αριστερής γωνίας. Η εντολή ΕΠΙΦΑΝΕΙΑ αν είχε δοθεί πριν την μετακίνηση τότε δείχνει λάθος εικόνα, σε αυτήν την περίπτωση πρέπει να την ξανακαλέσουμε.\r\n\r\n
EN:MOTION.WY\r\nδίνει την θέση Υ του ΠΕΡΙΘΩΡΙΟΥ σε σχέση με την ΕΠΙΦΑΝΕΙΑ ΕΡΓΑΣΙΑΣ\r\nΚΙΝΗΣΗ.ΠΥ\r\nκαι ΚΙΝΗΣΗ.ΥΠ είναι το ίδιο\r\nΕίναι η ιδιότητα TOP της κεντρική φόρμας της Μ2000 (που αναλογεί στο περιθώριο).\r\n\r\n
EN:MOTION.WX\r\nδίνει την θέση Χ του ΠΕΡΙΘΩΡΙΟΥ σε σχέση με την ΕΠΙΦΑΝΕΙΑ ΕΡΓΑΣΙΑΣ\r\n\r\n
EN:MOTION.Y\r\nΔίνει την θέση Υ του άνω αριστερού σημείου της ΟΘΟΝΗΣ (η επιπέδου) σε σχέση με το ΠΕΡΙΘΩΡΙΟ\r\n\r\n\r\n\r\n
EN:MOTION.YW\r\nδίνει την θέση Υ του ΠΕΡΙΘΩΡΙΟΥ σε σχέση με την ΕΠΙΦΑΝΕΙΑ ΕΡΓΑΣΙΑΣ\r\n\r\n
EN:MOTION.X\r\nΔίνει την θέση Χ του άνω αριστερού σημείου της ΟΘΟΝΗΣ σε σχέση με το ΠΕΡΙΘΩΡΙΟ\r\n\r\nΧρησιμοποιείται και σε Επίπεδα σε σχέση με την Οθόνη\r\n\r\n
EN:MOTION.XW\r\nδίνει την θέση Χ του ΠΕΡΙΘΩΡΙΟΥ σε σχέση με την ΕΠΙΦΑΝΕΙΑ ΕΡΓΑΣΙΑΣ\r\n\r\n
EN:CLASS\r\nΗ κλάση μπορεί να έχει τρια διαφορετικά μέρη (όπως και η ομάδα) βάσει των Ιδιωτικό:, Δημόσιο: και Κλάση:. Μπορούμε να έχουμε πολλά τμήματα από το καθένα, δεν παίζει ρόλο η σειρά.\r\nΈνα τμήμα με ίδιο όνομα με τη κλάση είναι αυτό που θα κληθεί στη συνάρτηση Όνομα_Κλάσης()\r\nΟι κλάσεις είναι πάντα γενικές. Όμως μενουν ως έχουν μέχρι μια άλλη γενική με ίδιο όνομα τις αλλάξουν.\r\n1)\r\nΚλαση αλφα {\r\nΙδιωτικό:\r\n      ζ=10\r\n      Πίνακας αλφα(10)=5\r\nΔημόσιο:\r\n      χ, υ\r\n      τμημα αλφα {\r\n            διαβασε .Χ, .υ, .ζ\r\n            .χ/=.ζ\r\n      }\r\n      συνάρτηση γέμισε_πίνακα {\r\n            =.αλφα()\r\n      }\r\n}\r\n2)\r\nΟμαδα1=αλφα(10,20,5)\r\nγια Ομαδα1 { \r\n            τυπωσε .Χ, .Υ \r\n            Δες { τύπωσε .ζ}\r\n            Δες {τύπωσε .αλφα(5)}\r\n}\r\nΠίνακας κ()\r\nκ()=Ομάδα1.γέμισε_πίνακα()\r\nΤύπωσε κ(5)\r\n3)\r\nΚλάση Άλφα {\r\nΙδιωτικό:\r\n      Χ, Υ\r\nΔημόσιο:\r\n      Αξία {\r\n            = .Χ/ .Υ\r\n      }\r\nΚλάση:\r\n      Τμήμα Άλφα {\r\n            Διάβασε .Χ, .Υ\r\n      }\r\n}\r\nΝ=Άλφα(100,200)\r\nΤύπωσε Ν\r\nΜ=Ομάδα(Ν)  \\\\ γυρίζει το αντικείμενο μόνο, δεν υπάρχει το τμήμα ΆΛΦΑ.\r\n\r\n3) Ειδική συνάρτηση Διαγραφή {}\r\n\\\\ Η συνάρτηση αυτή θα κληθεί από την Καθαρό εφόσον δεν υπάρχει άλλος δείκτης να δείχενει την ομάδα που θέλουμε να διαγράφουμε. Μετρητής_Αλφα=0\r\nΚλάση Άλφα {\r\n      Ένας_Αριθμός\r\n      Διαγραφή {\r\n            Τύπωσε \"Διαγραφή\"\r\n            Μετρητής_Αλφα--\r\n      }      \r\n  Κλάση:\r\n      Τμήμα Άλφα (.Ένας_Αριθμός){\r\n            Μετρητής_Αλφα++\r\n      }\r\n\r\n}\r\nα=Αλφα(12345)\r\nΤύπωσε Μετρητής_Αλφα=1 \r\n\\\\ φτιάχνουμε έναν δείκτη στο α\r\nκ->α\r\nΤυπωσε κ=>Ένας_Αριθμός=12345\r\n\\\\ βάζουμε στο κ τη κενή ομάδα (θα το κάνει ο διερμηνευτής αυτό)\r\nκ->0&\r\n\\\\ Τώρα μειώθηκε ο αριθμός\r\n\\\\ Μόνο η Καθαρό καλεί  τη Διαγραφή\r\nΚαθαρό α  ' καλεί την διαγραφή αν είναι ο τελευταίος δείκτης στο αντικείμενο\r\nΤύπωσε Μετρητής_Αλφα=0\r\n\r\n\r\n
EN:FKEY\r\nκλειδιά από F1 =1 έως F12=12 και shift+F1 =13 έως shift+ F12=24\r\n1)\r\nΚΛΕΙΔΙ ΚΑΘΑΡΟ\r\n Σβήνουμε όλα τα κλειδιά\r\n2)\r\nΚΛΕΙΔΙ 1, εντολές_σε_αλφαριθμητικο$\r\nΚΛΕΙΔΙ 1 {εντολές που χρωματίζονται στον διορθωτή }\r\n3)\r\nΚΛΕΙΔΙ 1\r\n Μας δίνει την περιγραφή του\r\n4)\r\nΚΛΕΙΔΙ\r\n Μας δίνει όλες τις περιγραφές στα κλειδιά που έχουμε ενεργοποιήσει\r\n5) ΚΛΕΙΔΙ 1,\"\"\r\nΚλΕΙΔΙ 1 {}\r\nΔιαγράφουμε αυτό το κλειδί\r\n\r\nΤα κλειδιά διαβάζονται με την ΑΝΑΝΕΩΣΗ, σε περίπτωση που είμαστε στον μεταφραστή γραμμής (δεν τρέχουμε κάποιο τμήμα), στην ΣΑΡΩΣΗ όταν υπάρχει ένας τουλάχιστον  στόχος. Ο κώδικας του κλειδιού παρεμβάλλεται και εκτελείται\r\n\r\nΠροσοχή το κλειδί F1 έχει δυο λειτουργίες ανάλογα με το αν έχει πατηθεί το CTRL. Με το CTRL+F1 ανοίγουμε την άμεση βοήθεια.\r\n\r\n
EN:CLOSE\r\nΚΛΕΙΣΕ μεταβλητη_χειρισμου_αρχειου\r\nΚΛΕΙΣΕ μεταβλητη_χειρισμου_αρχειου1, ..., μεταβλητη_χειρισμου_αρχειουΝ\r\nΜπορούμε να βάζουμε # πριν την μεταβλητή χειρισμού (αν θέλουμε)\r\n\r\nη ΚΛΕΙΣΕ χωρίς μεταβλητή χειρισμού κλείνει όλα τα αρχεία και τις συνδέσεις με βάσεις δεδομένων\r\nΚΛΕΙΣΕ ΒΑΣΗ ονομα_βασης1$ [,ονομα_βασης2$]\r\nκλείνουμε επιλεκτικά τις συνδέσεις\r\n\r\n
EN:SCALE.Y\r\nΜέγιστα σημεία Υ στην ΟΘΟΝΗ ή στο ΠΕΡΙΘΩΡΙΟ (ΔΕΣ ΠΕΡΙΘΩΡΙΟ)\r\nσυνώνυμο με Υ.ΣΗΜΕΙΑ\r\n
EN:SCALE.X\r\nΜέγιστα σημεία Χ στην ΟΘΟΝΗ ή στο ΠΕΡΙΘΩΡΙΟ (ΔΕΣ ΠΕΡΙΘΩΡΙΟ)\r\nσυνώνυμο με Χ.ΣΗΜΕΙΑ\r\n\r\n
EN:COMMON DIALOGUES\r\nΚΟΙΝΕΣ ΦΟΡΜΕΣ\r\nΑΝΟΙΓΜΑ.ΑΡΧΕΙΟΥ, ΑΝΟΙΓΜΑ.ΕΙΚΟΝΑΣ, ΑΠΟΘΗΚΕΥΣΗ.ΩΣ, ΕΠΙΛΕΞΕ.ΓΡΑΜΜΑΤΟΣΕΙΡΑ, ΕΠΙΛΕΞΕ.ΧΡΩΜΑ, ΚΑΤΑΛΟΓΟΣ, ΡΥΘΜΙΣΕΙΣ, ΤΙΤΛΟΣ, ΥΠΟΚΑΤΑΛΟΓΟΣ\r\n
EN:KEY$\r\nα$=κομ$\r\nΟ μεταφραστής περιμένει να πατηθεί ένα πλήκτρο (κομβίο) και δίνει τον χαρακτήρα ως αλφαριθμητικό\r\nαυτή η εντολή βάζει σε αναναμονή τον μεταφραστή μέχρι να πατηθεί ένα πλήκτρο. \r\nαν το περιβάλλον είναι σε ελαχιστοποίηση τότε αυτόματα ανοίγει \r\n\r\n
EN:DOS\r\nΌταν έχουμε χρησιμοποιήσει την εντολή ΧΡΗΣΤΗΣ αυτή η εντολή επιστρέφει λάθος\r\n\r\n1) ΚΟΝΣΟΛΑ [, χιλιοστά δευτερολέπτου καθυστέρηση]\r\nΆνοιγμα παραθύρου DOS\r\n\r\n2) ΚΟΝΣΟΛΑ \"ΕΝΤΟΛΗ\" [, χιλιοστά δευτερολέπτου καθυστέρηση]\r\nΆνοιγμα παραθύρου DOS, εκτέλεση, κράτημα (περιμένει να γράψουμε exit)\r\n\r\n3) ΚΟΝΣΟΛΑ \"ΕΝΤΟΛΗ\" [, χιλιοστά δευτερολέπτου καθυστέρηση];\r\nΕκτέλεση εντολής χωρίς άνοιγμα παραθύρου.\r\n\r\n\r\n
EN:HOLD\r\nΚΡΑΤΗΣΕ\r\nΚρατάει προσωρινά τα περιεχόμενα της οθόνης σε εσωτερικό χώρο και τα αποδίδει με την ΑΦΗΣΕ\r\nΜπορούμε να φτιάξουμε γρήγορα ενα εφε όπου θα αναβοσβήνει κάτι! Ή μπορούμε να μετακινούμε έναν δείκτη ως ένα γραφικό και κάθε φορά πριν μια ΑΝΑΝΕΩΣΗ 0 να αφήνουμε με την ΑΦΗΣΕ την καθαρή εικόνα και να βάζουμε το δείκτη έτσι δεν θα βλέπουμε ποτέ να λείπει ο δείκτης αλλά να μετακινείται. Μπορούμε να χρησιμοποιήσουμε αντί για γραφικό δείκτη μια εικόνα με την εντολή ΔΙΑΦΑΝΟ\r\n\r\n\r\nHOLD και ΚΡΑΤΑ είναι αναγνωριστικά για το ΝΗΜΑ\r\n\r\n
EN:HIDE$(\r\nΜετατρέπει ένα αλφαριθμητικό σε ένα κρυπτογραφημένο αλφαριθμητικό (διπλάσιου μήκους). Δέχεται για όρισμα το προς κρυπτογράφηση αλφαριθμητικό, ένα αλφαριθμητικό για κωδικό καθώς και έναν αριθμό που επίσης διαφοροποιεί τον κωδικό.\r\nΤο σύστημα κρυπτογράφησης παράγει κάθε φορά διαφορετικό αποτέλεσμα αλλά όλα τα αποτελέσματα μπορούν να επαναφέρουν το αρχικό, αν γνωρίζουμε κωδικό και αριθμό. Ο αριθμός μπορεί να χρησιμοποιηθεί έτσι ώστε πολλαπλά αλφαριθμητικά να κρυπτογραφούνται με εξάρτηση του παρόντος από το προηγούμενο.\r\n\r\n
EN:LOOP\r\n1) Επανάληψη (LOOP) με έλεγχο στο τέλος\r\n{\r\nεντολές\r\n\r\nΑΝ συνθήκη ΤΟΤΕ ΕΞΟΔΟΣ\r\nΚΥΚΛΙΚΑ  ' Προκαλεί την επανεκτέλεση αυτού του τμήματος (μεταξύ των δυο αγκυλών)\r\n}\r\n\r\n2) Επανάληψη (LOOP) με έλεγχο στην αρχή (όπως η ΕΝΩ), εδώ όμως μπορούμε να έχουμε πολλαπλές εξόδους (και άλλα Αν με ΕΞΟΔΟ)\r\n\r\n{ \r\nΑΝ συνθήκη ΤΟΤΕ ΕΞΟΔΟΣ\r\nεντολές\r\nΚΥΚΛΙΚΑ \r\n}\r\n\r\n3) Και σε ένα τμήμα μπορούμε να δώσουμε την εντολή ΚΥΚΛΙΚΑ. Και ένα τμήμα έχει και αυτό αγκύλες (αν και από τον διορθωτή της Μ2000 (δες ΣΥΓΓΡΑΦΗ) δεν εμφανίζονται αυτές)\r\n\r\nΤΜΗΜΑ τάδε {\r\n....\r\nΚΥΚΛΙΚΑ\r\n....\r\n}\r\n\r\nΧρησιμοποιούμε την ΚΥΚΛΙΚΑ αντί για την ΓΙΑ όταν θέλουμε το βήμα να είναι μεταβλητό ή όταν θέλουμε έξοδο με συνθήκη. Ουσιαστικά και στις ΕΝΩ και ΕΠΑΝΑΛΑΒΕ μπορούμε να έχουμε έξοδο με συνθήκη κάπου μέσα, αλλά η ΚΥΚΛΙΚΑ δεν κάνει κάτι περισσότερο γιατί όπως και να έχει θα γίνει ο έλεγχος της συνθήκης  τόσο στην ΕΠΑΝΑΛΑΒΕ όσο και στην ΕΝΩ ενώ οι εντολές μετά την ΚΥΚΛΙΚΑ θα συνεχιστούν (απλή η ΚΥΚΛΙΚΑ δίνει ένα σύνθημα στο πέρας του τμήματος εντολών να επαναληφθεί, δεν λειτουργεί άμεσα)\r\n\r\nπ.χ.\r\nE\r\nΙ=0\r\nΕΠΑΝΑΛΑΒΕ {\r\nΞΑΝΑ:\r\nΙ=Ι+1\r\nΑ$=ΕΝΚΟΜ$\r\nΚΥΚΛΙΚΑ ' Σβήσε την εντολή αυτή δεν κάνει κάτι εδώ!\r\nΑΝ Α$=\"\" ΤΟΤΕ ΠΡΟΣ ΞΑΝΑ\r\nΑΝ Α$=\" \" ΤΟΤΕ ΕΞΟΔΟΣ\r\nΤΥΠΩΣΕ Ι\r\n} ΜΕΧΡΙ Ι=1000\r\n\r\n\r\n\r\n\r\n
EN:CIRCLE\r\nΚΥΚΛΟΣ ακτίνα, λόγος, χρωμα_περιφερειας, απο_ακτινια, εως_ακτινια\r\nΚΥΚΛΟΣ ΓΕΜΙΣΜΑ χρωμα1, ακτίνα, λόγος, χρωμα_περιφερειας, απο_ακτινια, εως_ακτινια\r\n\r\nΘΕΣΗ 1000,1000\r\nΚΥΚΛΟΣ 500\r\nΘΕΣΗ 5000,5000\r\nΠΑΧΟΣ 4 {\r\nΚΥΚΛΟΣ 3000,1/2,15, 0,ΠΙ/2\r\n}\r\n\r\nΔες ΠΟΛΥΓΩΝΟ, ΚΑΜΠΥΛΗ\r\n\r\n\r\n\r\n\r\n
EN:SCROLL\r\nΚΥΛΙΣΗ ΑΝΩ\r\nΚΥΛΙΣΗ ΚΑΤΩ\r\nΚΥΛΙΣΗ ΧΩΡΙΣΜΑ 5  ' δηλώνει την τελευταία ακίνητη σειρά του σταθερού άνω τμήματος\r\n\r\nΜε την εντολή ΟΘΟΝΗ , 5 πετυχαίνουμε το ίδιο αλλά καθαρίζουμε την οθόνη (το κάτω τμήμα)\r\n\r\nΗ εντολή ΑΝΑΦΟΡΑ που τυπώνει κείμενο σταματάει την ολίσθηση και περιμένει πάτημα πλήκτρου ή κλικ ποντικού στην οθόνη για να συνεχίσει. Το ίδιο κάνουν και άλλες εντολές που τυπώνουν πολλαπλές γραμμές, όπως η ΤΜΗΜΑΤΑ\r\n\r\nΜπορούμε να γράψουμε απευθείας κείμενο σε μια μεταβλητή\r\nΜεταβλητη$={Πρώτη γραμμή\r\n                  Δεύτερη γραμμή\r\n                  Τρίτη γραμμή\r\n                  }  ' η θέση της αγγύλης στο τέλος ορίζει το μέγεθος του κενού που δεν θα περιλαμβάνεται στη μετβλητή\r\n                  Αναφορα Μεταβλητη$\r\nΤυπώνει:\r\nΠρώτη γραμμή\r\nΔεύτερη γραμμή\r\nΤρίτη γραμμή\r\n
EN:MAIN.TASK\r\nΚΥΡΙΟ.ΕΡΓΟ 100 {\r\n\r\n}\r\n\r\nΕίναι εντολή όπως η ΚΑΘΕ αλλά με την διαφορά ότι αποτελεί νήμα, και έτσι διαχειρίζεται το χρόνο ισότιμα με τα νήματα που τρέχουν.  Μπορούμε να βγούμε με την εντολή ΕΞΟΔΟΣ ή με ESC.  Δεν μπορούμε να έχουμε φωλιασμένα κύρια έργα στο ίδιο τμήμα\r\n\r\n\r\n
EN:ASC(\r\nΕπιστρέφει τον κωδικό ASCII του πρώτου χαρακτήρα ενός αλφαριθμητικού που δίνουμε για όρισμα.\r\nΔες το ΧΑΡΚΩΔ() \r\n\r\n\r\n
EN:CODEPAGE\r\nΤύπωσε Κωδικοσελίδα\r\nγυρνάει την τρέχουσα κωδικοσελίδα\r\n\r\n
EN:JOYPAD\r\nΛΑΒΗ 0,1\r\nενεργοποιεί τις λαβές (παιχνιδιών) 0 και 1\r\nΧωρίς παράμετρο απενεργοποιεί τις Λαβές.\r\nΥπάρχουν τέσσερις συναρτήσεις για να χρησιμοποιήσουμε:\r\nΛΑΒΗ(0)\r\nΛΑΒΗ.ΚΑΤΕΥΘΥΝΣΗ(0)\r\nΛΑΒΗ.ΑΝΑΛΟΓΙΚΟ.Χ(0)\r\nΛΑΒΗ.ΑΝΑΛΟΓΙΚΟ.Υ(0)\r\nΚάθε φορά δίνουμε το νούμερο της λαβής. Στην πρώτη περίπτωση θα πάρουμε όλα τα πλήκτρα σαν ένα δυαδικό νούμερο.\r\nΣτη δεύτερη περίπτωση θα πάρουμε την κατεύθυσνη\r\n    Καμία = 0\r\n    Αριστερά = 1\r\n    Δεξιά = 2\r\n    Πάνω = 3\r\n    Κάτω = 4\r\n    Πάνω_Αριστερά = 5\r\n    Κάτω_Αριστερά = 6\r\n    Πάνω_Δεξιά = 7\r\n    Κάτω_Δεξιά= 8\r\n\r\n   Στη τρίτη και τέταρτη  περίπτωση θα έχουμε τις θέσεις του μοχλού (χωρίζεται ένας μοχλός πάνω στη Λαβή σε διακριτά βήματα ανάλογα τη γωνία του κατά Χ και κατά  Υ)\r\n\r\n\r\n\r\n
EN:JOYPAD(\r\nΤύπωσε ΛΑΒΗ(0)\r\nδίνει τη κατάσταση των κουμπιών πάνω στη λαβή 0 (καθε bit είναι και ένα πλήκτρο)\r\n\r\n
EN:JOYPAD.ANALOG.Y(\r\nΤΥΠΩΣΕ ΛΑΒΗ.ΑΝΑΛΟΓΙΚΟ.Υ(0)\r\nδίνει την διακριτή θέση της λαβής\r\nΚαλό είναι εδώ να υπάρχει ένα καλιμπράρισμα. Δηλαδή να ρωτάει η εφαρμογή \"είναι τώρα ο μοχλός τέρμα πάνω\"....και με το οκ να καταγράφει την τιμή.\r\nΧρειάζεται να ενεργοποιήσουμε τις λαβές. Π.χ. αν έχουμε 0 και 1 λαβή θα δώσουμε:\r\nΛΑΒΗ 0,1\r\nκαι θα απενεργοποιήσουμε στο πέρας της εφαρμογής\r\nΛΑΒΗ\r\n
EN:JOYPAD.ANALOG.X(\r\nΤΥΠΩΣΕ ΛΑΒΗ.ΑΝΑΛΟΓΙΚΟ.Χ(0)\r\nδίνει την διακριτή θέση της λαβής\r\nΚαλό είναι εδώ να υπάρχει ένα καλιμπράρισμα. Δηλαδή να ρωτάει η εφαρμογή \"είναι τώρα ο μοχλός τέρμα δεξιά\"....και με το οκ να καταγράφει την τιμή.\r\nΧρειάζεται να ενεργοποιήσουμε τις λαβές. Π.χ. αν έχουμε 0 και 1 λαβή θα δώσουμε:\r\nΛΑΒΗ 0,1\r\nκαι θα απενεργοποιήσουμε στο πέρας της εφαρμογής\r\nΛΑΒΗ\r\n\r\n
EN:JOYPAD.DIRECTION(\r\nΤΥΠΩΣΕ ΛΑΒΗ.ΚΑΤΕΥΘΥΝΣΗ(0)\r\n\r\n    Σταθερή DirectionNone = 0  ' ΚΑΜΙΑ ΚΑΤΕΥΘΥΝΣΗ\r\n    Σταθερή DirectionLeft = 1  ' ΑΡΙΣΤΕΡΑ\r\n    Σταθερή DirectionRight = 2  ' ΔΕΞΙΑ\r\n    Σταθερή DirectionUp = 3 ' ΠΑΝΩ\r\n    Σταθερή DirectionDown = 4 ' ΚΑΤΩ\r\n    Σταθερή DirectionLeftUp = 5 ΑΡΙΣΤΕΡΑ ΚΑΙ ΠΑΝΩ\r\n    Σταθερή DirectionLeftDown = 6 ' ΑΡΙΣΤΕΡΑ ΚΑΙ ΚΑΤΩ\r\n    Σταθερή DirectionRightUp = 7 ' ΔΕΞΙΑ ΚΑΙ ΠΑΝΩ\r\n    Σταθερή DirectionRightDown = 8 ' ΔΕΞΙΑ ΚΑΙ ΚΑΤΩ\r\n\r\nΠρέπει να έχουμε ενεργοποιήση την συγκεκριμένη λαβη\r\nΛΑΒΗ 0\r\nκαι όταν δεν την χρειαζόμαστε την απενεργοποιούμε (όλες μαζί, όχι ξεχωριστά)\r\nΛΑΒΗ\r\n\r\n
EN:ERROR\r\n1) ΑΜΕΣΗ ΔΙΑΚΟΠΗ ΠΡΟΓΡΑΜΜΑΤΟΣ ΚΑΙ ΜΕΤΑΦΡΑΣΤΗ\r\nΛΑΘΟΣ 0\r\n2) ΔΙΑΚΟΠΗ ΠΡΟΓΡΑΜΑΤΟΣ ΜΕ ΕΜΦΑΝΙΣΗ ΑΡΙΘΜΟΥ\r\nΛΑΘΟΣ 100\r\n3) ΔΙΑΚΟΠΗ ΜΕ ΕΜΦΑΝΙΣΗ ΦΡΑΣΗΣ ΚΑΘΩΣ ΚΑΙ ΕΜΦΑΝΙΣΗ ΘΕΣΗΣ ΚΛΗΣΕΩΝ ΤΜΗΜΑΤΩΝ\r\nΛΑΘΟΣ \" πρόβλημα με το ....\"\r\nΜπορούμε να μεταβούμε σε μια θέση με την ΣΥΓΓΡΑΦΗ ή απλά Σ ως εξής\r\nΣ ονομα_τμηματος, θεση\r\n\r\nΑΔΕΙΑΣΕ ΛΑΘΟΣ  ' το χρησιμοποιούμε πριν την ΛΑΘΟΣ αν θέλουμε να μην προστεθεί το μήνυμα σε υπάρχον μήνυμα\r\n\r\n
EN:ERROR$\r\nΤυπωσε Λαθος$\r\nτυπώνει την περιγραφή του λάθους μετά από μια ΔΕΣ\r\n
EN:MOVIE.ERROR$\r\n? ΛΑΘΟΣ.ΤΑΙΝΙΑΣ$\r\nμας δίνει το λάθος ταινίας!\r\n\r\n\r\n
EN:LAMBDA\r\nΑ=λάμδα ->100\r\nΤύπωσε Α()   \\\\ 100\r\nΒ=10\r\n\\\\ η Β συλλαμβάνεται από την λάμδα Α, ως αντίγραφο\r\nΑ=λάμδα Β -> {\r\n      =Β : Β--\r\n      }\r\nΜ=Α\r\nΤύπωσε Α(), Α(), Β, Μ()\r\nΑ=Μ    \\\\ ξαναπαίρνει τον ορισμό της Μ() με το Β σε 9\r\nΤύπωσε Α(), Α(), Β      \r\nΟι συναρτήσεις λάμδα είναι συναρτήσεις σε μεταβλητές. Μπορούμε να τις αλλάξουμε. Αλλάζουν όμως με αντικατάσταση.\r\nΜπορούν να πάρουν παραμέτρους και μπορούν να κληθούν με ή χωρίς επιστροφή τιμής. Μπορεί να επιστρέφει οτιδήποτε ακόμα και μια άλλη συνάρτηση λάμδα. Μπορούμε να τις περνάμε ως παραμέτρους.\r\nΑν μας ενδιαφέρει αποτέλεσμα αλφαριθμητικό τότε:\r\nΒ$=\"ΓΕΙΑ ΧΑΡΑ\"\r\nΘ$=\"!\"\r\nΑλφα$=λάμδα$ Β$, Θ$ ->Β$+\" \"+γράμμα$+Θ$\r\nΤύπωσε Αλφα$(\"ΓΙΩΡΓΟ\")\r\n\r\nΠίνακας Α$(10)\r\nΑ$(2)=Αλφα$\r\nΤύπωσε Α$(2)(\"ΑΝΔΡΕΑ\")\r\n\r\nΚατάσταση Μ = \"μια λάμδα\":=Αλφα$, 200:=\"ΓΕΙΑ\"\r\nΤύπωσε Μ$(\"μια λάμδα\")(\"ΠΕΤΡΟ\"), Μ$(200)\r\n\r\nΓια να έχουμε αναδρομή στη λάμδα και επειδή μπορεί να αλλάζει όνομα (ανάλογα με το ποιο όνομα την κρατάει), έχουμε τα Λάμδα() και Λάμδα$() που λειτουργούν εντός της λάμδα για να την ξανατρέξουν.\r\n\r\nΤύπωσε λάμδα (α)->{=α**2}(3)   ' δίνει 9\r\n\\\\ μπορεί να γραφτεί και έτσι\r\nΤύπωσε λάμδα (α)->{\r\n      =α**2\r\n}(3)   ' δίνει 9\r\n\r\n
EN:LATIN\r\nΛΑΤΙΝΙΚΑ\r\nαλλάζει την κωδικοσελίδα αλλά και τη γλώσσα που εμφανίζονται τα μυνήματα λάθους \r\nΔΕΣ ΛΑΤΙΝΙΚΑ, ΧΑΡΑΚΤΗΡΕΣ\r\n\r\n\r\n
EN:WORDS\r\nΛΕΞΕΙΣ έγγραφο$\r\nέχει δυο παραλλαγές ανάλογα με το ποια συνάρτηση έχουμε χρησιμοποιήσει πριν!\r\nτην Εγγράφου.Λέξεις() ή την Εγγράφου.Μοναδικές.Λέξεις()\r\nΣε κάθε περίπτωση έχουμε ταξινομημένη λίστα. Στην δεύτερη οι όμοιες λέξεις είναι ομαδοποιημένες και σε παρένθεση φαίνεται ο αριθμός τους στο κείμενο.\r\n\r\nΈγγραφο άλφα$ ={ ένα, δυο, τρία\r\n      και περισσότερες, όπως αυτή και η άλλη, ή ένα και δυο\r\n      } \r\nΤύπωσε Εγγράφου.Λέξεις(άλφα$)\r\nμ=Μέγεθος.Σωρού+1\r\nΛέξεις άλφα$\r\nΑν Μέγεθος.Σωρού >= μ Τότε {\r\nΤύπωσε Μέγεθος.Σωρού - μ\r\n      Για ι=Μέγεθος.Σωρού έως μ {\r\n            Τύπωσε Γράμμα$\r\n      }\r\n}\r\nΤύπωσε Εγγράφου.Μοναδικές.Λέξεις(άλφα$)\r\nμ=Μέγεθος.Σωρού+1\r\nΛέξεις άλφα$\r\nΑν Μέγεθος.Σωρού >= μ Τότε {\r\n      Για ι=Μέγεθος.Σωρού έως μ {\r\n            Τύπωσε Γράμμα$\r\n      }\r\n}\r\n\r\n
EN:LIST\r\n1) ΛΙΣΤΑ ΧΡΗΣΤΩΝ\r\nεμφανίζει λίστα χρηστών (δες ΧΡΗΣΤΗΣ)\r\n\r\n2) ΛΙΣΤΑ\r\nΕμφάνιση μεταβλητών και πινάκων. Οι μεταβλητές φαίνονται με τα περιεχόμενά τους ενώ οι πίνακες με τον αριθμό στοιχείων τους. Αν μια αλφαριθμητική μεταβλητή περιέχει εικόνα τότε φαίνεται  ως περιεχόμενο το cDIB.\r\nΤα ονόματα των μεταβλητών έχουν πρόθεμα το όνομα του τμήματος όπου δημιουργήθηκαν:\r\nΑ.Β=5 σημαίνει ότι η μεταβλητή Β έχει τιμή 5 και δημιουργήθηκε στο τμήμα Α\r\n\r\n3) ΛΙΣΤΑ !  \r\nδίνει το ίδιο αλλά με αναλογική γραφή\r\n\r\n4)ΛΙΣΤΑ k\r\nεξάγει στο κ αρχείο\r\n\r\nανοιξε κατ$+\"μεταβλητές.txt\" για εξαγωγη ως κ\r\nλίστα κ\r\nκλείσε κ\r\n\r\nεγγραφο κκκ$\r\nφορτωσε.εγγραφο κκκ$, κατ$+\"μεταβλητές.txt\",1\r\nδιορθωσε κκκ$\r\n\r\n5) Λιστα com\r\n6Λιστα com στο ΑλφαΤμήμα\r\nεξάγει από ένα αντικείμενο τους ορισμούς των αντικειμένων\r\nκαι αν δώσουμε το δεύτερο  θα πάρουμε την εξαγωγή σε τμήμα στην αρχή (με Όρισε εντολές)\r\nΥπάρχει η Επίλεξε.αντικείμενο η οποία απλά φέρνει στο μενού επιλογών όλα τα ονόματα. (πιθανόν να αλλαχθεί αυτή η εντολή)\r\n\r\n
EN:LOG(\r\nΕπιστρέφει τον δεκαδικό λογάριθμο ενός αριθμού\r\n\r\n
EN:BOOLEAN\r\nχρησιμοποιείται στην εντολή ΑΡΧΕΙΟ\r\n\r\n
EN:CURRENCY\r\nχρησιμοποιείται στην εντολή ΑΡΧΕΙΟ\r\n
EN:SPEECH\r\nΛογος \"Agglika\"\r\nΛογος \"Pediki phoni\" !\r\nΛογος \"Hena Hena Grama\" #\r\n\r\nΛογος \"Agglika\", φωνη\r\nΛογος \"Pediki phoni\" !. φωνη\r\nΛογος \"Hena Hena Grama\" #, φωνη\r\n\r\nΤΥΠΩΣΕ Λογος\r\nτυπωνει τον αριθμό φωνών\r\n\r\nΓια φωνη= 1 εως Λογος {\r\n      Τυπωσε Λογος$(φωνη)\r\n}\r\n\r\nΤυπώνει τα ονόματα των φωνών\r\n\r\n\r\n\r\n\r\n
EN:SPEECH as variable\r\nΤΥΠΩΣΕ Λογος\r\nτυπωνει τον αριθμό φωνών για λόγο\r\n\r\nΓια φωνη= 1 εως Λογος {\r\n      Τυπωσε Λογος$(φωνη)\r\n}\r\n\r\nΤυπώνει τα ονόματα των φωνών\r\n\r\n\r\n
EN:SPEECH$(\r\n? λογος$(1)\r\nτυπώνει το όνομα της φωνής 1 από το σύστημα ομιλίας\r\n\r\n\r\n
EN:OS$\r\n? ΛΣ$\r\nΜας δίνει το όνομα του λειτουργικού συστήματος\r\n\r\n
EN:LN(\r\nΕπιστρέφει τον φυσικό (νεπέριο) λογάριθμο ενός αριθμού\r\n\r\n
EN:LONG\r\nμακρυς α,β, γ=34.5\r\nα=4\r\n? τυπος$(β)\r\nΛΙΣΤΑ\r\n\r\nφτιάχνουμε ακέραιους των 4bytes\r\n\r\nΚανονικά μια μεταβλήτη  Α είναι διπλής ακρίβειας αριθμός\r\nΜε τον κατασκευαστή ΜΑΚΡΥΣ τον αλλάζεουμε (και τον μηδενίζουμε) σε ακέραιο.\r\nΠεριοχή για μακρύ  A -2,147,483,648 έως 2,147,483,647\r\nΠεριοχή για μεγάλους ακέραιους  A% -494,065,645,841,247 έως 494,065,645,841,247\r\nΜπορούμε να ορίσουμε πίνακες μεγάλων ακεραίων. Δεν μπορούμε να ορίσουμε πίνακες ακεραίων τύπου μακρύς.\r\n\r\n\r\n
EN:LONG_TYPE\r\nΜΑΚΡΥΣ\r\nΤύπος για την εντολή Αρχείο\r\n\r\nΥπάρχει και τύπος μεταβλητής\r\n\r\n\r\n
EN:CASE\r\nΔΕΣ ΕΠΙΛΕΞΕ ΜΕ\r\n\r\n\r\n\r\n\r\n\r\n
EN:WITH\r\nΠολύπλοκη εντολή για να αναλυθεί εδώ.\r\nΧρησιμοποιείται για να αλλάξουμε τιμές σε ιδιότητες αντικειμένων, να διαβάσουμε, και να αντιστοιχίσουμε μια μεταβλητή στην ιδιότητα. Η αντιστοίχιση μπορεί να γίνει και σε όνομα πίνακα, δηλαδή με παρενθέσεις, για να δίνουμε ορίσματα όταν διαβάζουμε ή όταν γράφουμε στην ιδιότητα.\r\nΈνα απλό παράδειγμα με δυο ιδιότητες, την ReadyState και την RensponseText\r\nη <έτοιμο> δεν είναι απλά μια μεταβλητή αλλά ένα αντικείμενο που συνδέεται με μια ιδιότητα ενός άλλου αντικειμένου. Η σύνδεση είναι έμμεση. Αν διαγραφεί το αντικείμενο και χρησιμοποιήσουμε την <έτοιμο> τότε θα βγει λάθος!\r\nΑντικείμενα που ορίζουμε με την Όρισε και τις ιδιότητες τους δεν μπορούμε να τις δώσουμε ως επιστροφή από το τμήμα που τα δημιουργούμε, γιατί το πραγματικό αντικείμενο θα διαγραφεί και αυτό που θα δώσουμε θα δείχνει το τίποτα!\r\nΜπορούμε να περνάμε αυτές τις  μεταβλητές με αναφορά όπως τις κανονικές μεταβλητές σε κλήσεις με τη χρήση του &.\r\n\r\n\r\nΌρισε Κείμενοhtml \"Microsoft.XMLHTTP\"\r\nΔοκιμήURL$ = \"http://httpbin.org/\"\r\nΜε Κείμενοhtml, \"readyState\" ως έτοιμο    \r\nΜέθοδος Κείμενοhtml \"open\",\"GET\", ΔοκιμήURL$, Αληθές\r\nΜέθοδος Κείμενοhtml \"send\"\r\nΕνώ έτοιμο<>4 {\r\n      Τύπωσε Πάνω έτοιμο\r\n      Αν Δείκτης Τότε Έξοδο\r\n      Αναμονή 1\r\n      Ανανέωση\r\n}\r\nΤύπωσε\r\nΈγγραφο ββ$\r\nΑν έτοιμο=4 Τότε {\r\n      Με  Κείμενοhtml, \"responseText\" ως έτοιμο$\r\n      ββ$=έτοιμο$\r\n}\r\nΑναφορά ββ$\r\nΣημ : Πρόχειρο ββ$\r\nΌρισε Κείμενοhtml Τίποτα\r\n\r\n\r\n\r\n
EN:MAX(\r\nΔουλεύει μόνο με μεταβλητές και στοιχεία πίνακα\r\nΑ=10\r\nΒ=3\r\nΤύπωσε ΜΕΓΑΛΟ(Α, Β)\r\n\r\nΠίνακας Α(10)=10\r\nΑ(3)+=10\r\nΤύπωσε ΜΕΓΑΛΟ(Α(3), Α(5))\r\n\r\nΔες ΜΙΚΡΟ()\r\n
EN:MAX.DATA$(\r\n? μεγαλο.σειρας$(\"αα\",\"ββ\")\r\nαα\r\n? μεγαλο.σειρας$(\"κλμν\",\"αα\",\"ββ\",\"βα\")\r\nκλμν\r\nΔες και το ΜΙΚΡΟ.ΣΕΙΡΑΣ$() και ΜΙΚΡΟ.ΣΕΙΡΑΣ() για αριθμούς\r\nυπάρχει και για αριθμούς ΜΕΓΑΛΟ.ΣΕΙΡΑΣ()\r\n\r\n\r\n\r\n
EN:MAX.DATA(\r\n\r\nΤύπωσε ΜΕΓΑΛΟ.ΣΕΙΡΑΣ(1, 30*5, 2)\r\n\r\n\r\nΔες ΜΙΚΡΟ.ΣΕΙΡΑΣ()\r\n
EN:STACK.SIZE\r\nΒΑΛΕ 100, \"123123\"\r\nΤΥΠΩΣΕ ΜΕΓΕΘΟΣ.ΣΩΡΟΥ\r\n\r\n\r\n
EN:SIZE.Y(\r\nΦόρμα 40,25\r\nκ$=\"Μ2000 Διερμηνευτής\"\r\nμ=πι/3\r\n\r\nΓια μεγ=16 έως 42 ανά 2 {\r\n      μ+=πι/9\r\n      b=Μέγεθος.Χ(κ$,\"ARIAL\",μεγ,μ)\r\n      d=-Μέγεθος.Υ(κ$,\"ARIAL\",μεγ,μ)\r\n      Θέση (χ.σημεία-b)/2,(υ.σημεία-d)/2\r\n      Πένα Τυχαίος(7,15) {\r\n            Επιγραφή κ$,\"ARIAL\",μεγ,μ,2\r\n      }\r\n}\r\n\r\n
EN:SIZE.X(\r\nΦόρμα 40,25\r\nκ$=\"Μ2000 Διερμηνευτής\"\r\nμ=πι/3\r\n\r\nΓια μεγ=16 έως 42 ανά 2 {\r\n      μ+=πι/9\r\n      b=Μέγεθος.Χ(κ$,\"ARIAL\",μεγ,μ)\r\n      d=-Μέγεθος.Υ(κ$,\"ARIAL\",μεγ,μ)\r\n      Θέση (χ.σημεία-b)/2,(υ.σημεία-d)/2\r\n      Πένα Τυχαίος(7,15) {\r\n            Επιγραφή κ$,\"ARIAL\",μεγ,μ,2\r\n      }\r\n}\r\n\r\n
EN:METHOD\r\nΚαλούμε μέθοδο  σε αντικείμενο τύπου Com (όπως και οι φόρμες χρήστη) τα οποία ορίζουμε με την εντολή Όρισε\r\nΟι μέθοδοι μπορεί να έχουν προαιρετικές παραμέτρους, οπότε η απουσία τους δεν θα δημιουργήσει πρόβλημα!\r\nΕπίσης μπορεί να γυρνούν τιμή ή όχι\r\nΑν γυρνούν τιμή αυτή μπορεί να είναι αντικείμενο. Μπορούμε να επιστρέφουμε τιμή σε μεταβλητή, ή σε νέα μεταβλητή (να σκιάζουμε υπάρχουσα). Επίσης μπορούμε να αν το δέχεται το αντικείμενο, να χρησιμοποιήσουμε τη ΜεΓεγονότα παραλλαγή, ώστε να πάρουμε γεγονότα κατά την διάρκεια ζωής του αντικειμένου\r\nΕιδικά για γεγονότα που δεν έχουν σχέση με τις φόρμες και τα στοιχεία της Μ2000, οι συναρτήσεις θα έχουν το όνομα της μεταβλητής μαζί με μια κάτω παύλα _ και μετά το όνομα του γεγονότος. Σε περίπτωση που κάποιες παράμετροι του γεγονότος είναι με πέρασμα με αναφορά τότε χρησιμοποιούμε στην συνάρτηση του γεγονότος μια Διάβασε Νέο &παρ1, &παρ2  ώστε στο τέλος της εκτέλεσης οι τιμές των παρ1 και παρ2 να αντιγραφούν πίσω στο αντικείμενο που παρήγαγε το γεγονός. Σε κάθε περίπτωση υπάρχουν δυο τελευταίοι παράμετροι στο σωρό της κλήσης (ο οποίος όπως και να έχει καταστρέφεται μετά τη κλήση), ένα αλφαριθμητικό με πληροφορίες (αν υπάρχουν αλλιώς κενό αλφαριθμητικό) και το αντικείμενο\r\n\r\nΣτο παράδειγμα φτιάχνουμε μια φόρμα\r\n\r\nΌρισε Φόρμα1 Φόρμα\r\nΜε Φόρμα1, \"Title\",\"η φόρμα μου\"\r\nΜέθοδος Φόρμα1,\"Show\", 1\r\nΌρισε Φόρμα1 Τίποτα\r\n\r\n\r\nΣτο παράδειγμα θα φτιάξουμε ένα αρχείο Xml και θα το διαβάσουμε μέσω του αντικειμένου Msxml2.DOMDocument.6.0 που υπάρχει στα Windows και μπορεί να φορτωθεί στη Μ2000\r\n\r\nΈγγραφο α$={<?xml version=\"1.0\"?>\r\n<Ονόματα>\r\n      <στοιχείο αα=\"69\">\r\n      <όνομακωδ>VB6</όνομακωδ>\r\n      <ποσότητα>2</ποσότητα>\r\n      </στοιχείο>\r\n      <στοιχείο αα=\"70\">\r\n      <όνομακωδ>C++</όνομακωδ>\r\n      <ποσότητα>3</ποσότητα>\r\n      </στοιχείο>\r\n      <στοιχείο αα=\"71\">\r\n      <όνομακωδ>Μ2000</όνομακωδ>\r\n      <ποσότητα>10</ποσότητα>\r\n      </στοιχείο>\r\n</Ονόματα>\r\n}\r\nΣώσε.Έγγραφο α$,\"άλφα.xml\",  -2    ' χωρίς BOM\r\nΑναμονή 100\r\nΌρισε ΑντικείμενοXml \"Msxml2.DOMDocument.6.0\"\r\nΜέθοδος ΑντικείμενοXml, \"Load\", κατ$+\"άλφα.xml\" ως οκ\r\nΑν οκ τότε {\r\n      Όρισε ΣτοιχείοXML με ΑντικείμενοXml, \"documentElement\"\r\n      Μέθοδος ΣτοιχείοXML, \"selectSingleNode\", \"στοιχείο[@αα=70]\" ως ΕπιλεγμένοΣτοιχείο\r\n      Μέθοδος ΕπιλεγμένοΣτοιχείο, \"selectSingleNode\", \"όνομακωδ\" ως ΕπιλεγμένοΠεδίο\r\n      Με ΕπιλεγμένοΠεδίο, \"text\" ως η_τιμή_μου$\r\n      Τύπωσε η_τιμή_μου$\r\n      η_τιμή_μου$=\"George\"\r\n      Μέθοδος ΑντικείμενοXml, \"Save\", κατ$+\"alfa.xml\" ως Οκ\r\n      Μέθοδος ΣτοιχείοXML, \"getElementsByTagName\", \"στοιχείο\" ως Αντικείμενο_NodeList \r\n      Με Αντικείμενο_NodeList , \"length\" ως Αντικείμενο_NodeList_μήκος\r\n      Τύπωσε Αντικείμενο_NodeList_μήκος \r\n      Για ι=0 έως Αντικείμενο_NodeList_μήκος-1 {\r\n            Μέθοδος Αντικείμενο_NodeList , \"item\", ι ως Αντικείμενο_NodeList_στοιχείο\r\n            Μέθοδος Αντικείμενο_NodeList_στοιχείο, \"getElementsByTagName\", \"όνομακωδ\" ως Αντικείμενο_NodeList2 \r\n            Μέθοδος Αντικείμενο_NodeList2 , \"item\", 0 ως Αντικείμενο_NodeList_στοιχείο2\r\n            Με  Αντικείμενο_NodeList_στοιχείο2 , \"text\" ως α12$\r\n            Πένα 12 {\r\n                 Τύπωσε α12$\r\n           }\r\n           Όρισε Αντικείμενο_NodeList_στοιχείο2 Τίποτα\r\n           Όρισε Αντικείμενο_NodeList2 Τίποτα\r\n           Όρισε Αντικείμενο_NodeList_στοιχείο Τίποτα\r\n     }\r\n      Όρισε Αντικείμενο_NodeList Τίποτα\r\n      Όρισε ΕπιλεγμένοΠεδίο Τίποτα\r\n      Όρισε ΕπιλεγμένοΣτοιχείο Τίποτα\r\n      Όρισε ΣτοιχείοXML Τίποτα\r\n}\r\nΌρισε ΑντικείμενοXml Τίποτα\r\nΕγγραφο ααα$\r\nΦόρτωσε.Έγγραφο ααα$, \"alfa.xml\"\r\nΑναφορά ααα$\r\n\r\n\r\n\r\n\r\nΚαι τα αντικείμενα Κατάσταση και Έγγραφο είναι Com αντικείμενα και μπορούμε να χρησιμοποιήσουμε μεθόδους\r\nΌπως στο παράδειγμα παρακάτω:\r\nΈγγραφο α$={péché\r\n            sin\r\n            peach\r\n            pêche\r\n            }\r\nΤύπωσε \"Με 1036 Γαλλικά\"\r\nΜέθοδος α$, \"SetLocaleCompare\", 1036\r\nΤαξινόμηση Αύξουσα α$, 1,4\r\nΑναφορά α$\r\nΤύπωσε \"Με 1033 Αγγλικά\"\r\nΜέθοδος α$, \"SetLocaleCompare\", 1033\r\nΤαξινόμηση Αύξουσα α$, 1,4\r\nΑναφορά α$\r\n\r\n\r\nΔες παράδειγμα στην συνάρτηση Ιδιότητα$()\r\n\r\n\r\n\r\n
EN:MEMBER$(\r\n? μελος$(αλφα, 3)\r\nτυπώνει το όνομα του 3ου μέλους της ομάδας αλφα\r\nδες ΟΜΑΔΑ\r\n\r\n\r\n
EN:MEMBER.TYPE$(\r\nΤυπωσε ΜΕΛΟΥΣ.ΤΥΠΟΣ$(αλφα, 2)\r\nτυπώνει το τύπο του 2ου μέλους από την ομάδα αλφα\r\nδες ΟΜΑΔΑ\r\n\r\n
EN:TUNE\r\nΜΕΛΩΔΙΑ 100, \"CAC\"\r\nΜΕΛΩΔΙΑ \"C3BC#\"\r\nδιάστημα μέσα στο αλφαριθμητικό είναι παύση, το νούμερο μας λεει τον αριθμό οκτάβας\r\nπαίζει νότες διαμορφώνοντας εσωτερικά μια σειρά από τόνους. Δες την ΤΟΝΟΣ\r\nπροσοχή σταματάει τα νήματα! \r\nΑνώτερο σύστημα που δουλεύει σε ξεχωριστά νήματα δημιουργείται με τις εντολές ΦΩΝΗ και ΠΑΙΞΕ όπου εκτός\r\n\r\nModule A {\r\n      Module AA {\r\n            For i=1 To 10 {\r\n                  Tone 50, 150\r\n                  Tone 25, 300\r\n            }\r\n      }\r\n      For i=1 To 5 {\r\n            AA\r\n            Wait 200\r\n            AA\r\n            Wait 800\r\n      }\r\n}\r\nModule B {\r\n      For i = 1 To 10 {\r\n            TUNE \"cac \"\r\n            Wait 200\r\n      }\r\n}\r\nModule C {\r\n      For i=100 To 8000 Step 20 {\r\n            Tone 2,i\r\n      }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n
EN:PART\r\nαν το Μ είναι Αληθές τότε το Μέρος {} Ως Μ δεν εκτελείται\r\nαν δεν υπάρχει Μ τότε το φτιάχνει και όταν τρέχει το μπλοκ το Μ γίνεται Αληθές.\r\nΘα αλλάξει ακριβώς στο τέλος της εκτέλεσης σε ψευδές\r\nΜερος {\r\n      Τύπωσε \"οκ\", Μ\r\n} Ως Μ\r\n\r\nχρησιμοποιείται όπου δεν θέλουμε κώδικας να εκτελεστεί ταυτόχρονα με άλλο κώδικα.\r\nμπορούμε να καλούμε ρουτίνες ή τμήματα από το μπλοκ κανονικά.\r\n\r\n
EN:PIECE$(\r\nΤύπωσε Μέρος$(\"αλφα.βήτα\",\".\", 2)  ' δίνει το βήτα\r\nΤύπωσε Μέρος$(\"αλφα.βήτα\",\".\")(1)  ' δίνει το βήτα\r\n' το Α παίρνει αντικείμενο από την Μέρος$() αν δεν δώσουμε αριθμό μέρους\r\n' ο πίνακας ξεκινάει από το 0\r\nΑ=Μέρος$(\"αλφα.βήτα\",\".\")   ' είναι ίδιο με αυτό: Μέρος$(\"αλφα.βήτα\",\".\")()\r\nΤύπωσε Πίνακας$(Α, 1) 'δίνει το βήτα\r\nΤύπωσε Α\r\nΠίνακας Β$()\r\n\\\\ διαφέρει αυτή η εκχώρηση από την Α=...\r\n\\\\ επειδή εδώ γίνεται αντιγραφή του πίνακα από το αριστερό μέρος στο δεξιό μερος\r\nΒ$()=Μέρος$(\"αλφα.βήτα\",\".\")\r\nΤύπωσε Β$()\r\n\r\n
EN:MID$(\r\nΔέχεται δυο ή τρία ορίσματα. \r\nΤο πρώτο είναι ένα αλφαριθμητικό, το δεύτερο μια τιμή που δηλώνει μια θέση μέσα στο πρώτο από όπου θα μας επιστρέψει ένα νέο αλφαριθμητικό. Το μέγεθος αυτού του νέου θα είναι ανάλογο με το πόσοι χαρακτήρες ακολουθούν από την θέση που ορίσαμε έως το τέλος ή αν δώσουμε ένα τρίτο όρισμα όσο αυτό. \r\nΣε περίπτωση που δεν υπάρχουν χαρακτήρες επειδή δώσαμε θέση μεγαλύτερη από το μέγεθος του αλφαριθμητικού τότε μας επιστρέφει το κενό αλφαριθμητικό. \r\nΣε περίπτωση που ζητήσουμε περισσότερους χαρακτήρες από όσους βρει στο αλφαριθμητικό μας επιστρέφει όσους βρει.\r\n\r\nδουλεύει και για αλφαριθμητικά με ένα ψηφίο ανά χαρακτήρα αρκεί να το δηλώσουμε:\r\n\r\nΤοπικο 1032\r\nΑ$=Γραφη$(\"Γιώργος\")  ' μετατροπή σε ANSI κατά  τοπικό1032 (ελληνικά)\r\nΤύπωσε Χαρ$(Μεσ$(Α$,2,2 ως Ψηφίο))=\"ιώ\"  ' το Χαρ$() μετατροπή σε UTF-16LE κατά 1032\r\n\r\n\r\n
EN:AFTER\r\n1) META 100  \r\nΌπως η ΑΝΑΜΟΝΗ 100\r\n2)ΜΕΤΑ 1000 {\r\nΕΝΤΟΛΕΣ\r\n....\r\n\r\n}\r\nΕδώ έχουμε ένα ΝΗΜΑ που θα εκτελεστεί μια φορά σε 1 δευτερόλεπτο. Αν τερματίσει το τμήμα που την κάλεσε και δεν έχει εκτελεστεί τότε δεν θα εκτελεστεί, όπως όλα τα ΝΗΜΑΤΑ έτσι και αυτό δεν θα υπάρχει με το πέρας του τμήματος που το δημιούργησε.\r\n\r\n\r\nΜικρό παράδειγμα:\r\nΑντέγραψε το παρακάτω σε ένα τμήμα:\r\nΚ=100\r\nμετα 1000 {\r\n      τυπωσε \"οκ\", Κ\r\n}\r\nτμημα ΑΛΛΟ {\r\n      μετα 500 {τυπωσε \"Είμαι στο  ΑΛΛΟ\"}\r\n      αναμονη 2000\r\n      τυπωσε \"Είμαι ακόμα στο ΑΛΛΟ\"\r\n}\r\nΑΛΛΟ\r\n\r\nΕδώ βλέπουμε ότι όταν τρέχει το τμήμα ΑΛΛΟ πρώτα έρχεται το σύντομο ΝΗΜΑ του ΑΛΛΟ και μετά κάπου στο χρόνο που δίνει η ΑΝΑΜΟΝΗ εμφανίζεται το ΝΗΜΑ του τμήματος που κάλεσε το ΑΛΛΟ και εμφανίζει και την μεταβλητή Κ. Γιατί τα νήματα διαβάζουν και φτιάχνουν αν θέλουμε μεταβλητές στο τμήμα που ανήκουν.\r\nΑκόμα και να χαθεί το ΝΗΜΑ, δεν χάνονται οι μεταβλητές που φτιάχνει, παρά μόνο αν χαθεί το ΤΜΗΜΑ (επειδή είναι μέρος του τμήματος και όχι άλλο τμήμα).\r\nΜπορούμε να ξέρουμε αν μια μεταβλητή υπάρχει πριν την χρησιμοποιήσουμε με την ΕΓΚΥΡΟ()\r\nΜπορούμε να δοκιμάζουμε κώδικα αν έχει λάθος με την ΔΕΣ μεταβλητή { ΕΝΤΟΛΕΣ } και μετά ελέγχουμε την μεταβλητή.\r\n\r\n\r\nΜεγαλύτερο παράδειγμα:\r\nΕδώ γίνεται χρήση του ΑΝΑΛΥΤΗ φόρτου. Φόρτος είναι χρόνος που κάνει να εκτελέσει μια ομάδα εντολών της Μ2000 ο υπολογιστής. Ο υπολογιστής δεν κουράζεται και η απόδοσή του μετριέται με το πόσο χρόνο κάνει να εκτελέσει συγκεκριμένη εργασία.\r\n\r\n\r\n\r\nΟΘΟΝΗ 0, 0 \\\\ το πρώτο 0 είναι το μαύρο χρώμα για φόντο, μετά ακυρώνουμε με το δεύτερο 0 την χωριστή οθόνη\r\nΠΕΝΑ 14  \\\\ είναι το κίτρινο. από 0 έως 15 είναι τα παλιά χρώματα της QBasic.\r\n\\\\ μπορεί να βάλει κανείς χρώμα όπως στην Html, απαιτεί 6 δεκαεξαδικά ψηφία και το # στην αρχή\r\n\\\\ ΠΕΝΑ #FF77FF \r\nΚ=ΨΕΥΔΕΣ\r\n' ΕΣΩΤΕΡΙΚΟ ΤΜΗΜΑ\r\nΤΜΗΜΑ ΑΣΤΕΡΙΑ {\r\n      ΟΘΟΝΗ\r\n      ΓΙΑ Ι=1 ΕΩΣ 200 {\r\n            Χ=ΤΥΧΑΙΟΣ(0,ΠΛΑΤΟΣ-1)\r\n            Υ=ΤΥΧΑΙΟΣ(0,ΥΨΟΣ-2)\r\n            ΤΥΠΩΣΕ @(Χ,Υ);\"*\";\r\n      }\r\n}\r\n      ' ΠΑΡΑΚΑΤΩ ΞΕΚΙΝΑΜΕ ΤΟΝ ΑΝΑΛΥΤΗ\r\n      ' Ο ΟΠΟΙΟΣ ΜΗΔΕΝΙΖΕΙ ΤΟΝ ΜΕΤΡΗΤΗ ΧΡΟΝΟΥ Ή ΦΟΡΤΟ\r\n      ' ΜΕΤΡΑΜΕ ΤΗ ΔΙΑΔΙΚΑΣΙΑ ΩΣ ΦΟΡΤΙΟ ΧΡΟΝΟΥ\r\n      ' ΘΕΛΟΥΜΕ ΤΟ ΤΜΗΜΑ ΚΑΙ ΤΗΝ ΕΝΤΟΛΗ ΕΞΟΔΟΥ\r\nΑΝΑΛΥΤΗΣ\r\nΑΣΤΕΡΙΑ\r\nΑΝ ΨΕΥΔΕΣ ΤΟΤΕ {}  \r\nΛ=ΦΟΡΤΟΣ+10\r\n      ' ΤΩΡΑ ΞΕΡΟΥΜΕ ΤΟ ΦΟΡΤΟ (ΒΑΖΟΥΜΕ ΚΑΙ ΛΙΓΟ ΠΑΡΑΠΑΝΩ)\r\n      ' ΚΑΙ ΣΤΕΛΝΟΥΜΕ ΕΝΑ ΜΕΡΟΣ ΤΜΗΜΑΤΟΣ ΝΑ ΤΡΕΞΕΙ\r\n      ' ΜΕΤΑ ΑΠΟ 10*Λ ΧΙΛΙΟΣΤΑ ΤΟΥ ΔΕΥΤΕΡΟΛΕΠΤΟΥ\r\nΜΕΤΑ 10*Λ {Κ=ΑΛΗΘΕΣ}\r\nΚΥΡΙΟ.ΕΡΓΟ Λ {\r\n      ΑΣΤΕΡΙΑ\r\n      ΑΝ Κ ΤΟΤΕ ΕΞΟΔΟΣ\r\n}\r\n      'ΤΙΣ ΠΕΡΙΣΣΟΤΕΡΕΣ ΦΟΡΕΣ ΘΑ ΔΟΥΜΕ ΔΕΚΑ ΔΙΑΦΟΡΕΤΙΚΕΣ\r\n      'ΣΥΣΤΑΔΕΣ ΑΣΤΕΡΙΩΝ ΚΑΙ ΑΥΤΟ ΓΙΑΤΙ ΚΑΜΙΑ ΦΟΡΑ\r\n      'Ο ΥΠΟΛΟΓΙΣΤΗΣ ΤΡΩΕΙ ΧΡΟΝΟ..ΑΠΟ ΤΗΝ ΔΙΑΔΙΑΚΑΣΙΑ\r\nΟΘΟΝΗ  7 \r\nΠΕΝΑ 1\r\n\r\n\r\n\r\n\r\n\r\n\r\n
EN:VARS READ ONLY\r\nΜΕΤΑΒΛΗΤΕΣ ΣΥΣΤΗΜΑΤΟΣ\r\nΑΝΑΛΟΓΙΟ$, ΑΥΤΟ, ΓΡΑΜΜΑ$, ΓΡΑΜΜΑΤΟΣΕΙΡΑ$, ΓΡΑΜΜΕΣΑΝΑΦΟΡΑΣ, ΓΡΑΜΜΗ, ΔΕΙΚΤΗΣ, ΔΕΙΚΤΗΣ.ΚΟΜ, ΔΕΙΚΤΗΣ.Υ, ΔΕΙΚΤΗΣ.Χ, ΔΕΙΚΤΗΣΑ.Υ, ΔΕΙΚΤΗΣΑ.Χ, ΔΙΑΔΙΚΤΥΟ, ΔΙΑΔΙΚΤΥΟ$, ΔΙΑΡΚΕΙΑ, ΔΙΑΦΑΝΕΙΑ$, ΔΙΚΤΥΟ$, ΕΙΝΑΡ, ΕΙΝΓΡ, ΕΚΤΥΠΩΤΗΣ$, ΕΛ OSBIT, ΕΛΕΓΧΟΣ.ΜΕΓΕΘΟΣ.ΣΩΡΟΥ, ΕΛΕΓΧΟΣ.ΣΩΡΟΥ, ΕΛΛΗΝΙΚΑ_μεταβλητή, ΕΝΑΟΝΟΜΑ$, ΕΝΚΟΜ$, ΕΝΤΑΣΗ_μεταβλητή, ΕΝΤΟΛΗ$, ΕΠΙΛΟΓΕΣ, ΕΠΙΛΟΓΕΣ.ΦΑΝΕΡΕΣ, ΕΠΙΛΟΓΗ_μεταβλητή, ΕΦΑΡΜΟΓΗ.ΚΑΤ$, ΘΕΣΗ.Υ, ΘΕΣΗ.Χ, ΘΕΣΗ_μεταβλητή, ΙΔΙΟΤΗΤΕΣ$, ΚΑΤ$, ΚΑΤΑΣΤΑΣΗ.ΤΑΙΝΙΑΣ$, ΚΕΝΟ, ΚΙΝΗΣΗ.ΠΥ, ΚΙΝΗΣΗ.ΠΧ, ΚΙΝΗΣΗ.Υ, ΚΙΝΗΣΗ.ΥΠ, ΚΙΝΗΣΗ.Χ, ΚΙΝΗΣΗ.ΧΠ, ΚΛΙΜΑΞ.Υ, ΚΛΙΜΑΞ.Χ, ΚΟΜ$, ΚΩΔΙΚΟΣΕΛΙΔΑ, ΛΑΘΟΣ$, ΛΑΘΟΣ.ΤΑΙΝΙΑΣ$, ΛΟΓΟΣ ως μεταβλητή, ΛΣ$, ΜΕΓΕΘΟΣ.ΣΩΡΟΥ, ΜΝΗΜΗ, ΜΟΥΣΙΚΗ.ΜΕΤΡΗΤΗΣ, ΝΗΜΑΤΑ$, ΟΝΟΜΑ.ΤΜΗΜΑΤΟΣ$, ΟΝΟΜΑ.ΧΡΗΣΤΗ$, ΠΑΙΖΕΙΦΩΝΗ, ΠΑΡΑΘΥΡΟ (HWND), ΠΑΡΑΜΕΤΡΟΙ$, ΠΑΡΕΚΑΡΕ$, ΠΕΔΙΟ_μεταβλητή, ΠΕΝΑ_μεταβλητή, ΠΕΡΙ$, ΠΛΑΤΟΣ, ΠΛΑΤΟΣ.ΣΗΜΕΙΟΥ, ΠΛΑΤΦΟΡΜΑ$, ΠΡΟΣΩΡΙΝΟ$, ΠΡΟΧΕΙΡΟ$, ΠΡΟΧΕΙΡΟ.ΕΙΚΟΝΑ$, ΣΗΜΕΙΟ, ΣΗΜΕΡΑ, ΣΤΗΛΗ, ΣΥΣΚΕΥΗ.ΠΡΟΒΟΛΗΣ$, ΤΑΙΝΙΑ.ΜΕΤΡΗΤΗΣ, ΤΑΙΝΙΑ_μεταβλητή, ΤΙΚ, ΤΙΜΗ, ΤΜΗΜΑ$, ΤΥΠΟΣ_μεταβλητή, ΤΥΧΑΙΟΣ, ΤΩΡΑ, Υ.ΣΗΜΕΙΑ, ΥΠΟΛΟΓΙΣΤΗΣ$, ΥΨΟΣ, ΥΨΟΣ.ΣΗΜΕΙΟΥ, ΦΟΡΜΑ$, ΦΟΡΤΟΣ, Χ.ΣΗΜΕΙΑ, ΧΡΩΜΑΤΑ\r\n
EN:SEEK\r\nΜΕΤΑΘΕΣΗ #L, 10\r\nσε ένα ανοιχτό αρχείο μεταθέτει τη θέση του δρομέα εγγραφής στο συγκεκριμένο Byte.\r\nελάχιστο 1  και μέγιστο όσο το μέγιστο ενός μακρυ ακεραίου (LONG)\r\nΑν το μέγεθος του αρχείου είναι μικρότερο τότε τοποθετεί τον δρομέα μετά το τέλος, έτσι  η εγγραφή θα μεγαλώσει το αρχείο\r\nμπορούμε να διαβάσουμε το με την SEEK(#L)\r\n\r\n
EN:SEEK(\r\n\\\\ η Μετάθεση() είναι πάντα σε bytes, και η πρώτη θέση στο αρχείο δίνει το 1\r\n\r\nΆδειασε\r\nM=Σωρός\r\nΣειρά \"allfa\", \"beta\",\"gama\",\"epsilon\", \"delta\"\r\nΆνοιξε \"a.dat\" Για Ευρεία Εξαγωγή Ως #κ\r\nΕνώ Όχι Κενό {\r\n      Τύπωσε #κ, Γράμμα$;\r\n      Σωρός M { Σειρά Μετάθεση(#κ)}  ' Σειρά comand push to end\r\n}\r\nΚλείσε #κ\r\nα=1\r\nβ=Κάθε(M)\r\nΆνοιξε \"a.dat\" Για Ευρεία Εισαγωγή Ως #κ\r\nΕνώ β {\r\n      Μετάθεση #κ, α\r\n      Τύπωσε Εισαγωγή$(#κ, (ΤιμήΣωρού(β)-α)/2)   ''χρήση του /2 για Ευρεία (UTF16LE)\r\n      α=ΤιμήΣωρού(β)\r\n}\r\nΚλείσε #κ\r\n\r\n
EN:UNTIL\r\nΜέρος της δομής\r\nΕπαναλαβε {\r\n\r\n\r\n} Μεχρι Α>2\r\n\r\n\r\n\r\n\r\n
EN:LEN(\r\nΕπιστρέφει το μήκος ενός αλφαριθμητικού σε χαρακτήρες.\r\nΣε πίνακες επιστρέφει τον αριθμό στοιχείων ανεξάρτητα από διαστάσεις\r\nΣε καταστάσεις και σωρούς (αντικείμενα) επιστρέφει τον αριθμό στοιχείων\r\n\r\n
EN:LEN.DISP(\r\n\\\\Δίνει το μήκος εμφάνισης\r\nΤύπωσε ΜΗΚΟΣ.ΕΜΦ(\"ãz̃\")  ' 2\r\nΤύπωσε Μήκος(\"ãz̃\")  ' 4\r\n\r\n
EN:MIN(\r\n? ΜΙΚΡΟ(Α,Β), ΜΙΚΡΟ(Α(3),Β)\r\n? ΜΙΚΡΟ(Α%,Β%(2))\r\nΔέχεται μόνο μεταβλητές ή στοιχεία πίνακα, και μόνο αριθμητικά, και ακριβώς δύο.\r\nΑν θέλουμε να εξάγουμε το μικρότερο από δυο ή περισσότερα και να περιλαμβάνονται και αριθμητικές παραστάσεις πρέπει να χρησιμοποιήσουμε την συνάρτηση ΜΙΚΡΟ.ΣΕΙΡΑΣ() η οποία δεν έχει όριο στον αριθμό των στοιχείων. Επειδή όμως περιμένει αριθμητικές παραστάσεις φτιάχνει πάντα αντίγραφα (το αποτέλεσμα της παράστασης)  οπότε  είναι πιο αργό από την ΜΙΚΡΟ() η οποία διαβάζει απευθείας τις τιμές από τις μεταβλητές χωρίς ενδιάμεσα αντίγραφα.\r\n\r\nΠαρακάτω είναι ένα πρόγραμμα σύγκρισης ταχύτητας. Έχουμ αυξήση τον αριθμό ανανέωσης οθόνης (της φόρμας που ονομάζουμε εδώ οθόνη, όχι του μόνιτορ), ώστε να κάνουμε το σύστημα πιο γρήγορο. \r\nΜε ΑΝΑΝΕΩΣΗ 400 περίπου πετυχαίνουμε  ότι  και η ΘΕΣΕ ΓΡΗΓΟΡΑ ! (με το θαυμαστικό). \r\nΗ μικρο() τρέχει στο μισό χρόνο περίπου.\r\nΕνώ αυτό γίνεται ΜΙΚΡΟ.ΣΕΙΡΑΣ(23, ΜΙΚΡΟ.ΣΕΙΡΑΣ(5,12/4, α+β*5)) στη ΜΙΚΡΟ() δεν μπορούμε να το κάνουμε, δεν διαβάζει παραστάσεις και θα δώσει λάθος.\r\n\r\n\\* δημιουργούμε τις μεταβλητές πριν εκκινήσουμε τον αναλυτή.\r\nΑΝΑΝΕΩΣΗ 400    ' με αυτό το τρόπο διπλασιάζουμε τη ταχύτητα\r\nΙ=1 : Α=10 : Β=4 : Δ=0\r\n\r\nΑΝΑΛΥΤΗΣ\r\nΓΙΑ Ι=1 ΕΩΣ 1000 {\r\n      Δ=ΜΙΚΡΟ.ΣΕΙΡΑΣ(Α,Β)\r\n} \r\nΤΥΠΩΣΕ ΦΟΡΤΟΣ\r\n\r\nΑΝΑΛΥΤΗΣ\r\nΓΙΑ Ι=1 ΕΩΣ 1000 {\r\n      Δ=ΜΙΚΡΟ(Α,Β)\r\n} \r\nΤΥΠΩΣΕ ΦΟΡΤΟΣ\r\nΑΝΑΝΕΩΣΗ 25\r\n
EN:MIN.DATA$(\r\n? μικρο.σειρας$(\"αα\",\"ββ\")\r\nαα\r\n? μικρο.σειρας$(\"κλμν\",\"αα\",\"ββ\",\"βα\")\r\nαα\r\nΔες και το ΜΕΓΑΛΟ.ΣΕΙΡΑΣ$() και ΜΕΓΑΛΟ.ΣΕΙΡΑΣ() για αριθμούς\r\nυπάρχει και για αριθμούς ΜΙΚΡΟ.ΣΕΙΡΑΣ()\r\n\r\n
EN:MIN.DATA(\r\n\r\nΤύπωσε ΜΙΚΡΟ.ΣΕΙΡΑΣ(1, 50*3,2)\r\n\r\nΔες ΜΕΓΑΛΟ.ΣΕΙΡΑΣ()\r\n\r\n
EN:SHORTDIR$(\r\n?   μικρος.καταλογος$(\"C:\\Documents and Settings\\All Users\\Documents\\\")\r\nC:\\DOCUME~1\\ALLUSE~1\\DOCUME~1\\\r\nδίνει το όνομα ενός αρχείου ή καταλόγου συμβατό με το DOS. \r\nαν δεν υπάρχει το αρχείο ή ο κατάλογος τότε επιστρέφει ένα κενό αλφαριθμητικό\r\n\r\n
EN:MEMORY\r\nΤΥΠΩΣΕ ΜΝΗΜΗ\r\n\r\nΟ αριθμός που μας δίνει είναι σε Mega Bytes (εκατομμύρια χαρακτήρες), και περιλαμβάνει όλη την φυσική μνήμη που είναι διαθέσιμη στο σύστημα.\r\n\r\nΠριν την έκτη έκδοση:\r\nΟ αριθμός που μας δίνει είναι σε Mega Bytes (εκατομμύρια χαρακτήρες), και περιλαμβάνει όλη την μνήμη που είναι διαθέσιμη (μαζί με την εικονική δηλαδή του χώρου του δίσκου μας που μπορούμε να χρησιμοποιήσουμε)\r\n\r\n
EN:FORMAT$(\r\n1)\r\nα$=μορφη$( αλφαριθμητικό$, λίστα παραμέτρων)\r\n\r\nτο αλφαριθμητικό μπορεί να περιέχει σημάνσεις όπως αυτή {0} που δηλώνει την πρώτη παράμετρο στη λίστα. Αν έχουμε παραπάνω σημάνσεις δεν θα αλλάξουν με τιμές. Αν λείπουν σημάνσεις τότε οι αντίστοιχες τιμές θα υπολογιστούν (αν είναι εκφράσεις) και δεν θα χρησιμοποιηθούν. Δεν μπορούμε στη λίστα παραμέτων να αφήσουμε κενή παράμετρο (δηλαδή συνεχόμενα κόμματα)\r\n\r\nτύπωσε μορφη$(\"γράμματα {1}\", 12323, 45) \r\n\r\nμπορούμε να βάλουμε {1:4} για να δηλώσουμε πόσα δεκαδικά θέλουμε σε αριθμούς (αν βάλουμε τη 2η παράμετρο λέξη τότε αυτή θα αναζητεί το {1} και δεν θα το βρει οπότε θα δούμε το {1:4} ως έχει. Δουλεύει και για την εκθετική μορφή π.χ. 1ε10\r\n\r\n\r\nΠροσθήκες, πεδίο τρίτο για το μέγεθος πεδίου, με αρνητικό νούμερο έχουμε κενό χώρο αριστερά, ενώ με θετικό νούμερο έχουμε χώρος δεξιά\r\nΤύπωσε μορφή$(\"{0:-20}{1:2:-6},{1:2:6}οκ\", \"όνομα δεξιά\",10.2)\r\n\r\n2) Μετατροπή αλφαριθμητικού με escape κώδικες τύπου json (και javascript)\r\n Αναφορά μορφή$(\"Πρώτο\\r\\nΔεύτερο\\r\\n\\Τρίτο\")\r\n Αναφορά μορφή$(μορφή$(\"Πρώτο\\r\\nΔεύτερο {0}\\r\\n\\Τρίτο\", 100))\r\n\r\n\r\n
EN:MUSIC\r\n1) ΜΟΥΣΙΚΗ ΚΑΤ$+\"ΒΗΤΑ.MID\", άλλο_κομμάτι$, ...\r\n\r\nΜπορούμε άμεσα να σταματήσουμε την μουσική με μια εντολή χωρίς όρισμα\r\nΜΟΥΣΙΚΗ\r\nΗ μεταβλητή ΜΟΥΣΙΚΗ δίνει ΑΛΗΘΕΣ αν η μουσική εκτελείτε ή ΨΕΥΔΕΣ αν έχει πάψει.\r\nπ.χ. ΕΝΩ ΜΟΥΣΙΚΗ { ΤΥΠΩΣΕ \"ΜΠΡΑΒΟ \";}\r\n\r\nΗ μεταβλητή ΔΙΑΡΚΕΙΑ: Δίνει την διάρκεια σε δευτερόλεπτα ενός πολυμέσου (δίνει μέχρι και τα χιλιοστά) κατά την εκτέλεση αυτού.\r\n2) ΜΟΥΣΙΚΗ ΚΑΤ$+\"ΒΗΤΑ.MID\";\r\n\r\nΟ μεταφραστής περιμένει να τελειώσει η μουσική και μετά συνεχίζει την ροή προγράμματος.\r\n\r\nΗ εντολή ΜΟΥΣΙΚΗ παίζει και MP3, wav κλπ.\r\n\r\nΔες το ΜΟΥΣΙΚΗ.ΜΕΤΡΗΤΗΣ\r\n\r\n3) ΜΟΥΣΙΚΗ -1\r\nσταματάει τη μουσική\r\n4) ΜΟΥΣΙΚΗ 1.2\r\nπροχωράει τη μουσική στο δευτερόλεπτο 1.2\r\n5) ΜΟΥΣΙΚΗ 0\r\nξεκινάει πάλι την μουσική\r\n\r\n\r\n
EN:MUSIC.COUNTER\r\nΔίνει -1 αν δεν υπάρχει μουσική!\r\nΔίνει το μετρητή (ανά χιλιοστό δευτερολέπτου)\r\nΓια όλη τη διάρκεια δες το ΔΙΑΡΚΕΙΑ\r\nΗ Μουσικη.Μετρητης είναι ακριβώς η ίδια εντολή με την Ταινια.Μετρητης\r\n\r\n
EN:BEEP\r\n1) εκτελεί τον ήχο ΜΠΙΠ\r\nΜΠΙΠ\r\n2) εκτελεί τον ήχο αριθμό 10 των windows\r\nΜΠΙΠ 32\r\n\r\n\r\n\r\n
EN:FORWARD(\r\nΕγγραφο α$={αααααααα\r\nββββββββββ\r\nγγγγγγγγγγ}\r\nμ=Παράγραφος(α$, 0) \r\nΑν Μπροστά(α$,μ) Τότε {\r\n      Ενώ μ {\r\n            Τύπωσε Παράγραφος$(α$,(μ))\r\n      }\r\n}\r\n\r\n\r\n
EN:NEW\r\nΝΕΟ\r\nΔιαγράφει όλα τα φορτωμένα τμήματα ώστε να φορτώσουμε ή να συγγράψουμε νέα τμήματα, νέο πρόγραμμα. Επίσης διαγράφει και τα ΚΛΕΙΔΙΑ αν έχουμε ορίσει τέτοια (Δες ΚΛΕΙΔΙ)\r\nΠαρατήρηση\r\nΔεν σβήνει τυχόν μεταβλητές που παράμεναν στην μνήμη (χρειάζεται η εντολή ΚΑΘΑΡΟ)\r\n\r\n
EN:THREAD\r\n\r\nΝήμα στη Μ2000 είναι κώδικας σε Τμήμα ή σε Συνάρτηση που χειριζόμαστε βάσει ενός αριθμού (χειριστής), και βλέπου ότι το πατρικό έχει, αλλά έχουν δικές τους στατικές μεταβλητές και δικό τους σωρό τιμών.\r\n\r\n\r\n1) δημιουργία\r\nΝΗΜΑ {\r\n      Στατική Κ=5\r\n.................\r\n} ΩΣ Κ   \\\\ εδώ μπορούμε να προσθέσουμε το Κάθε\r\n\r\n2) χειρισμός\r\nΝημα Κ Καθε 200\r\n      ορίζει και ξεκινάει το νήμα Κ να τρέχει κάθε 200 χιλιοστά του δευτερολέπτου (με ελάχιστο 10 χιλιοστά), αυτό λέγεται σκανδαλισμός\r\nΝημα Κ Κρατα\r\n      σταματάει ο σκανδαλισμός του νήματος\r\nΝημα Κ Ξεκινα \r\n      ξεκινάει ο σκανδαλισμός\r\nΝημα Κ Σβησε\r\n      διαγράφεται το νήμα, ο αριθμός χειρισμού δεν θα ξαναχρησιμοποιηθεί, δεν θα δοθεί το ίδιο νούμερο σε νέο νήμα\r\nΝήμα Κ Εκτέλεση Κ=10\r\n      Εκτελεί εντολή (οι εντολές) στο νήμα από άλλο νήμα\r\nΜπορούμε να χρησιμοποίουσε αυτές τις εντολές μέσα σε ένα νήμα και να απευθυνθούμε σε αυτό με την ΑΥΤΟ. Τα τμήματα και οι συναρτήσεις δεν έχουν ιδιότητες νήματος και αν απευθυνθούμε στο ΑΥΤΟ θα βγει λάθος.\r\nΝημα ΑΥΤΟ σβησε\r\n\r\n3) Αναφορά στην οθόνη για τα νήματα που  έχουν εγγραφεί στη λίστα του διαχειριστή νημάτων.\r\nΝηματα\r\n\r\n\r\n\r\n\r\n      Το  Νήμα είναι ένα τμήμα εντολών το οποιο χειριζόμαστε με έναν αριθμό χειρισμού σε μια μεταβλητή και μπορούμε να ξεκινάμε, να σταματάμε, να ορίζουμε κάθε πότε θα τρέχει, να το σβήσουμε, και όλα αυτά παράλληλα με τις εντολές του τμήματος που τρέχει στο προσκήνιο. Mπορούν να τρέχουν περισσότερα από ένα νήματα\r\n\r\n      Γενικά μέσα σε συναρτήσεις μπορούμε να βάζουμε τμήματα και νήματα, και το ίδιο συμβαίνει και στα τμήματα και στα νήματα. Οι συναρτήσεις έχουν όνομα όπως και τα τμήματα ενώ τα νήματα έχουν αριθμό χειρισμού (γράφεται σε μια μεταβλητή) και χρησιμοποιούν το όνομα του τμήματος που τα δημιούργησε. Αυτό σημαίνει ότι μπορούν να δουν και να αλλάξουν τις μεταβλητές του τμήματος που τα δημιούργησε.\r\n\r\n      Μέσα σε ένα νήμα δεν μπορούμε να χρησιμοποιήσουμε τον αριθμό χειρισμού του, γιατί απλά όταν τρέχει το νήμα έχει βγει από μια ομάδα νημάτων και ο αριθμός που θα αναζητείται εκεί  δεν θα βρεθεί, για να μην μπορεί να κληθεί δεύτερη φορά ενώ τρέχει ήδη. Για το λόγο αυτό αντί του αριθμού θα βάλουμε την λέξη Αυτο ή This\r\nΝημα Αυτο καθε 500 ' αλλάζουμε τον σκανδαλισμό του (το πότε θα ξαναπάρει εντολή να τρέξει)\r\nThread This Interval 500\r\n      ή \r\nΝημα Αυτό Κρατα ' Οπότε με το πέρας της εκτέλεσης του νήματος σταματάει και ο σκανδαλισμός του\r\n\r\nΕίδη νημάτων:\r\nΗ έκτη έκδοση εγκαινιάζει τα νήματα. Αρχικά φτιάχτηκαν τα νήματα για την μουσική, όπου κανείς μπορεί να δώσει Φωνες με σκοπό και τέμπο καθώς και να ορίσει όργανο ανα φωνή και να ακούσει στο περιθώριο μουσική. Μετά σχεδιάστηκε ένα σύστημα αυλών όπου με νήμα πάλι ελέγχεται η εισαγωγή τιμών στον αυλό (ο δημιουργός διαβάζει....είναι ο εξυπηρετητής, ενώ οι πελάτες του στέλνουν δεδομένα), και τέλος δημιουργήθηκαν και τα νήματα εντός τμημάτων και συναρτήσεων.\r\nΆρα έχουμε τρια είδη, τα νήματα μουσικής, αυλών και τμημάτων.\r\nΌταν αυτά τρέχουν φαίνονται με την εντολή Νηματα, ως αριθμοί χερισμού. Μπορούμε να δώσουμε την εντολή Νημα με τον ανάλογο αριθμό χειρισμού και να τα χειριστούμε.\r\nΤο ενδιαφέρον εδώ είναι το πότε αυτόματα παύει να τρέχει ενα νήμα!\r\nΚάθε νήμα λοιπόν τρέχει όσο το τρέχει και το τμήμα ή η συνάρτηση που το δημιούργησε. Οι αυλοί και η μουσική τρέχουν και πέρα από αυτά. Η μουσική τερματίζει στο προκαθορισμένο πέρας της (κάθε Φωνη παίζει το δικό της σκοπό και τερματίζει ανεξάρτητηα από το τι κάνει κάθε άλλη Φωνη). Οι αυλοί δέχονται τιμές εφόσον πάρουμε ότι έχουν ήδη στη μεταβλητή εισαγωγής, και παύουν να λειτουργούν αν σβήσουμε το νημα τους ή αν τερματίσει ο διερμηνευτής.\r\n\r\n\r\nΤΥΠΩΣΕ ΕΠΙΛΟΓΕΣ.ΦΑΝΕΡΕΣ\r\n Φ=1     \r\nΝΗΜΑ {\r\n      Φ++\r\n      ΑΝ ΕΠΙΛΟΓΕΣ.ΦΑΝΕΡΕΣ ΤΟΤΕ {\r\n       ΤΥΠΩΣΕ Φ, ΕΠΙΛΟΓΗ$(ΕΠΙΛΟΓΗ)\r\n\r\n      } ΑΛΛΙΩΣ {\r\n      ΤΥΠΩΣΕ  Φ\r\n      }\r\n      \r\n} ΩΣ Ω\r\nΕΠΙΛΟΓΗ ΤΙΤΛΟΣ \"Ο ΤΙΤΛΟΣ ΜΟΥ\"\r\n      ΝΗΜΑ Ω ΚΑΘΕ 100\r\nΑΝΟΙΓΜΑ.ΑΡΧΕΙΟΥ \r\nΝΗΜΑ Ω ΚΡΑΤΑ\r\nΜΕΤΑ 100 {\r\n     ΝΗΜΑ Ω ΞΕΚΙΝΑ\r\n}\r\n 'χρειάζεται η εκκίνηση μετά από λίγο γιατί χρησιμοποιούμε τίτλο και αυτός \"ανακατασκευάζει\" τη λίστα. Αν \"παρενοχλήσουμε\" την κατασκευή τότε δεν θα πετύχει. Εδώ βλέπουμε τη χρήση της ΚΡΑΤΑ και της ΞΕΚΙΝΑ\r\n\r\nΕΠΙΛΟΓΗ \"1η Γραμμή\", \"2η Γραμμή\"\r\nΤΥΠΩΣΕ ΕΠΙΛΟΓΗ\r\n\r\n\r\n
EN:THREADS\r\nΝΗΜΑΤΑ\r\nΔίνει τους αριθμούς των νημάτων που βρίσκονται στη λίστα νημάτων, ανεξάρτητα αν είναι κρατημένα ή όχι. Δεν συμπεριλαμβάνεται εκείνο το νήμα που την δεδομένη στιγμή τρέχει (αφού έχει βγει εκτός λίστας...δεν μπορεί δηλαδή να ξανατρέξει όσο εκτελείται)\r\nΝΗΜΑΤΑ ΣΒΗΣΕ\r\nΣβήνει όλα τα νήματα από τη λίστα νημάτων (και αυτών σε αναμονή και εκείνων που τρέχουν).\r\nΑυτό δεν σημαίνει ότι σταματούν όλα τα νήματα άμεσα, αλλά σίγουρα σύντομα γιατί δεν θα έχουν άλλη ευκαιρία να εκκινήσουν ξανά.\r\n\r\n
EN:THREADS$\r\n? ΝΗΜΑΤΑ$\r\nμας δίνει την λίστα νημάτων στο τρέχων τμήμα και σε όλα τα πατρικά προς τα πάνω.\r\n
EN:RESTART\r\nΣε μια ομάδα εντολών η ΞΕΚΙΝΑ κάνει επανάληψη από την αρχή χωρίς να ολοκληρώσει την ομάδα (όπως κάνει το Κυκλικα)\r\nΠαράδειγμα\r\n\r\nι=0\r\n{\r\nι++\r\nαν τυχαιος(10)>5 τοτε ξεκινα\r\nτυπωσε \"κανονικα\", ι\r\nαν ι<10 τοτε ξεκινα\r\nτυπωσε \"τελευταία εντολή\"\r\n}\r\n\r\nΑν αλλάξουμε το ξεκινα με το κυκλικα τότε θα έχουμε άλλη απόκριση, θα τυπωθούν όλα τα ι μέχρι και το 10 καθώς και το  \"τελευταία εντολή\" θα τυπωθεί δέκα φορές!\r\nΔες ΝΗΜΑ και ΤΑΙΝΙΑ όπου το αναγνωρισιτκό ΞΕΚΙΝΑ είναι διαφορετικό από αυτό εδώ.\r\n\r\n\r\n\r\n\r\n
EN:DRIVE$(\r\nΤυπωσε Οδηγος$(\"A:\\\")\r\nΔίνει περιφραστικά το τύπο οδηγού \r\n\r\n
EN:CLS\r\nΟΘΟΝΗ χρωμα, υψος_διαχωρισμού\r\nΟΘΟΝΗ ,υψος_διαχωρισμού\r\nΤο υψος_διαχωρισμού θα είναι κάποια γραμμή με 0 την πρώτη από πάνω.\r\nΑπό την έκδοση 3 μπορούμε να έχουμε και στο περιθώριο διαχωρισμό χωρίς να επηρεάζουμε αυτόν της οθόνης.\r\nΟ διαχωρισμός μας δείχνει το ύψος του  τμήματος της οθόνης που  θα ολισθαίνει προς τα πάνω. Ολισθαίνει πάντα το κάτω τμήμα. Με ΟΘΟΝΗ ,0 ακυρώνουμε τον διαχωρισμό - ολόκληρη η οθόνη μπορεί να ολισθαίνει.\r\n\r\nΌταν εκτυπώνουμε στον εκτυπωτή τότε η εντολή ΟΘΟΝΗ δεν κάνει τίποτα.\r\nΜπορούμε με την ΚΥΛΙΣΗ να αλλάξουμε το ύψος διαχωρισμού χωρίς να σβήσουμε την οθόνη, όπως επίσης να δώσουμε εντολή για ΚΥΛΙΣΗ ΑΝΩ ή ΚΥΛΙΣΗ ΚΑΤΩ.\r\n\r\nΔΕΣ ΕΝΤΟΛΕΣ ΚΟΝΣΟΛΑΣ\r\n\r\n\r\n
EN:SCREEN AND FILES\r\nΟΘΟΝΗ ΚΑΙ ΑΡΧΕΙΑ\r\nΔΕΚΑΕΞ, ΕΙΣΑΓΩΓΗ, ΕΛ?, ΤΥΠΩΣΕ\r\n
EN:LAZY$(\r\nΗ Οκν$()  φτιάχνει μια Ανώνυμη συνάρτηση σε αλφαριθμητικό την οποία συνδέουμε σε μια συνάρτηση και την εκτελούμε, ή την εκτελούμε ως όρισμα αλφαριθμητικό στην Συνάρτηση()\r\nχ=10\r\nζ=2\r\nΤύπωσε Συνάρτηση(Οκν$(χ**2+ζ)), Έκφρ(\"χ**2+ζ\")\r\n\r\n\r\n\\\\Παράδειγμα χρήσης με πέρασμα μέρους τμήματος σε άλλο τμήμα\r\n\r\nκαθαρό\r\nζ=100\r\nΤμήμα Τοπικό_Τμήμα {\r\n      Τύπωσε \"αυτό το τμήμα μπορεί να κληθεί μόνο από το πατρικό\"\r\n}\r\nΤοπικό_Τμήμα\r\nΤμήμα Γενικό Δοκιμή1 {\r\n      Στατική μ=10\r\n      μ++\r\n      Τύπωσε μ\r\n}\r\n\\\\ Αυτή δεν είναι μια οποιαδήποτε συνάρτηση!\r\n\\\\ αλλά αποτελεί μέρος του τμήματος.\r\n\\\\ τρέχει με το όνομα του τμήματος, και βλέπει ότι και το τμήμα!\r\n\\\\ εφόσον το καλέσουμε σωστά!\r\nΣυνάρτηση Ψεύτικη (&Ανάδραση) {\r\n      ζ++\r\n      Ανάδραση=ζ\r\n      Δοκιμή1\r\n      Τοπικό_Τμήμα\r\n}\r\n\r\nΤμήμα Δέλτα {     ' θα μπορούσε να γραφεί Τμήμα Δέλτα (&συναρ()) {}\r\n      Διάβασε &συναρ()\r\n      ν=0\r\n      Κάλεσε συναρ(&ν)\r\n      Τύπωσε ν\r\n      Κάλεσε συναρ(&ν)\r\n      Τύπωσε ν\r\n      Δοκιμή1\r\n      Δοκιμή1\r\n}\r\nΔοκιμή1\r\nΔοκιμή1\r\n\\\\ Περνάμε τη Ψεύτικη συνάρτηση με τη μετατροπή της συνάρτησης Οκν$()\r\nΔέλτα Οκν$(&Ψεύτικη())\r\nΔοκιμή1\r\n\r\n\r\n
EN:ALL\r\nΔΙΕΡΜΗΝΕΥΤΗΣ\r\nΑΡΓΑ, ΑΡΧΗ, ΒΟΗΘΕΙΑ, ΓΡΗΓΟΡΑ, ΔΙΑ, ΔΙΑ#, ΔΙΑΓΡΑΦΗ, ΔΙΑΚΟΠΤΕΣ, ΔΟΚΙΜΗ, ΕΙΝΑΙ, ΕΚΔΟΣΗ, ΕΛΕΓΧΟΣ, Η, ΚΑΘΑΡΟ, ΚΑΙ, ΚΛΕΙΔΙ, ΚΟΝΣΟΛΑ, ΛΙΣΤΑ, ΝΕΟ, ΟΡΙΟ.ΑΝΑΔΡΟΜΗΣ, ΠΕΡΙ, ΠΛΗΚΤΡΟΛΟΓΙΟ, ΠΡΟΧΕΙΡΟ, ΠΡΩΤΟΤΥΠΟ, ΣΕΝΑΡΙΟ, ΣΗΜ, ΣΥΓΓΡΑΦΕΑΣ, ΣΥΓΓΡΑΦΗ, ΣΥΣΤΗΜΑ, ΣΩΣΕ, ΤΑΞΙΝΟΜΗΣΗ, ΤΕΛΕΣΤΕΣ, ΤΕΛΟΣ, ΥΠΟΛ, ΥΠΟΛ#, ΦΟΡΤΩΣΕ\r\n\r\nΧΕΙΡΙΣΜΟΣ ΤΜΗΜΑΤΩΝ\r\nΑΛΤ, ΑΥΛΟΣ, ΔΙΑΚΟΠΗ, ΔΙΑΦΥΓΗ, ΕΝΘΕΣΗ, ΕΝΩΣΕ, ΛΑΘΟΣ, ΝΗΜΑ, ΝΗΜΑΤΑ, ΡΟΥΤΙΝΑ, ΣΥΝΑΡΤΗΣΗ, ΤΜΗΜΑ, ΤΜΗΜΑΤΑ, ΧΡΗΣΗ\r\n\r\nΡΟΗ ΠΡΟΓΡΑΜΜΑΤΟΣ\r\nΑΛΛΙΩΣ, ΑΛΛΙΩΣ.ΑΝ, ΑΝ, ΑΝΑΛΥΤΗΣ, ΑΝΑΜΟΝΗ, ΑΠΟ, ΓΙΑ, ΔΕΣ, ΔΙΑΜΕΣΟΥ, ΔΙΕΚΟΨΕ, ΕΝΩ, ΕΞΟΔΟΣ, ΕΠΑΝΑΛΑΒΕ, ΕΠΑΝΕΛΑΒΕ, ΕΠΙΛΕΞΕ, ΚΑΘΕ, ΚΑΛΕΣΕ, ΚΥΚΛΙΚΑ, ΚΥΡΙΟ.ΕΡΓΟ, ΜΕ, ΜΕΡΟΣ, ΜΕΤΑ, ΜΕΧΡΙ, ΞΕΚΙΝΑ, ΠΡΟΣ, ΣΥΝΕΧΙΣΕ, ΣΧΕΔΙΟ.ΝΗΜΑΤΩΝ, ΤΟΤΕ\r\n\r\nΕΝΤΟΛΕΣ ΣΩΡΟΥ\r\nΑΔΕΙΑΣΕ, ΑΝΑΘΕΣΕ, ΑΠΕΔΩΣΕ, ΒΑΛΕ, ΔΙΑΒΑΣΕ, ΠΑΝΩ, ΠΕΤΑ, ΣΕΙΡΑ, ΣΩΡΟΣ, ΦΕΡΕ, ΦΕΡΕΠΙΣΩ\r\n\r\nΟΡΙΣΜΟΙ\r\nΑΛΛΑΞΕ, ΑΠΑΡ, ΑΠΑΡΙΘΜΗΣΗ, ΑΥΤΟΜΑΤΟΙ_ΠΙΝΑΚΕΣ, ΓΕΓΟΝΟΣ, ΓΕΝΙΚΗ, ΔΙΑΡΘΡΩΣΗ, ΔΥΑΔΙΚΟ, ΕΓΓΡΑΦΟ, ΘΕΣΕ, ΙΔΙΟΤΗΤΑ, ΚΑΝΕ, ΚΑΤΑΣΤΑΣΗ, ΚΛΑΣΗ, ΛΑΜΔΑ, ΜΑΚΡΥΣ, ΜΕ_Αντικείμενο, ΜΕΘΟΔΟΣ, ΟΜΑΔΑ, ΟΡΙΣΕ, ΠΙΝΑΚΑΣ, ΣΤΑΘΕΡΗ, ΣΤΑΤΙΚΗ, ΣΤΗ, ΣΤΟΚ, ΤΟΠΙΚΗ, ΥΠΕΡΚΛΑΣΗ\r\n\r\nΕΓΓΡΑΦΑ\r\nΔΙΟΡΘΩΣΕ, ΕΥΡΕΣΗ, ΚΑΤΑΧΩΡΗΣΗ, ΛΕΞΕΙΣ, ΠΑΡΕΜΒΟΛΗ, ΠΡΟΣΘΕΣΕ.ΕΓΓΡΑΦΟ, ΣΥΓΧΩΝΕΥΣΕ.ΕΓΓΡΑΦΟ, ΣΩΣΕ.ΕΓΓΡΑΦΟ, ΤΑΞΙΝΟΜΗΣΗ(ΕΓΓΡΑΦΟΥ), ΦΟΡΤΩΣΕ.ΕΓΓΡΑΦΟ\r\n\r\nΧΕΙΡΙΣΜΟΣ ΑΡΧΕΙΩΝ\r\nΑΝΟΙΞΕ, ΑΡΧΕΙΑ, ΓΡΑΜΜΗ ΕΙΣΑΓΩΓΗΣ, ΓΡΑΨΕ, ΔΩΣΕ, ΕΙΚΟΝΕΣ, ΗΧΟΙ, ΚΛΕΙΣΕ, ΜΕΤΑΘΕΣΗ, ΟΝΟΜΑ, ΠΑΡΕ, ΣΧΕΔΙΑ, ΤΑΙΝΙΕΣ\r\n\r\nΕΝΤΟΛΕΣ ΚΟΝΣΟΛΑΣ\r\nΑΝΑΝΕΩΣΗ, ΑΝΑΦΟΡΑ, ΑΝΑΨΕ, ΑΦΗΣΕ, ΓΡΑΜΜΑΤΟΣΕΙΡΑ, ΔΙΑΣΤΙΧΟ, ΔΙΠΛΑ, ΔΡΟΜΕΑΣ, ΕΙΚΟΝΙΔΙΟ, ΕΛΛΗΝΙΚΑ, ΕΠΙΓΡΑΦΗ, ΕΠΙΠΕΔΟ, ΕΠΙΦΑΝΕΙΑ, ΚΑΝΟΝΙΚΑ, ΚΙΝΗΣΗ, ΚΙΝΗΣΗ.Π, ΚΡΑΤΗΣΕ, ΚΥΛΙΣΗ, ΛΑΤΙΝΙΚΑ, ΟΘΟΝΗ, ΠΑΡΑΘΥΡΟ, ΠΕΔΙΟ, ΠΕΝΑ, ΠΕΡΙΘΩΡΙΟ, ΠΕΡΙΘΩΡΙΟ _, ΠΛΑΓΙΑ, ΠΛΑΙΣΙΟ, ΣΒΗΣΕ, ΣΗΜΑΔΙ, ΤΟΠΙΚΟ, ΤΥΠΟΣ, ΦΑΡΔΙΑ, ΦΟΝΤΟ, ΦΟΡΜΑ, ΧΑΡΑΚΤΗΡΕΣ\r\n\r\nΟΘΟΝΗ ΚΑΙ ΑΡΧΕΙΑ\r\nΔΕΚΑΕΞ, ΕΙΣΑΓΩΓΗ, ΕΛ?, ΤΥΠΩΣΕ\r\n\r\nΧΕΙΡΙΣΤΕΣ ΤΗΣ ΤΥΠΩΣΕ\r\nΕΛ$, ΕΛ@, ΕΛ~\r\n\r\nΣΤΟΧΟΙ ΚΑΙ ΕΠΙΛΟΓΗ\r\nΑΛΛΑΓΗ, ΕΠΙΛΟΓΗ, ΣΑΡΩΣΕ, ΣΤΟΧΟΙ, ΣΤΟΧΟΣ\r\n\r\nΓΡΑΦΙΚΑ 2Δ\r\nΒΑΨΕ, ΒΗΜΑ, ΓΕΜΙΣΕ, ΘΕΣΗ, ΚΑΜΠΥΛΗ, ΚΥΚΛΟΣ, ΟΜΑΛΑ, ΠΑΧΟΣ, ΠΟΛΥΓΩΝΟ, ΧΑΡΑΞΕ, ΧΡΩΜΑ, ΧΡΩΜΑΤΙΣΕ\r\n\r\nΕΝΤΟΛΕΣ ΕΙΚΟΝΩΝ\r\nΑΝΤΙΓΡΑΨΕ, ΔΙΑΦΑΝΟ, ΕΙΚΟΝΑ, ΠΑΙΚΤΗΣ\r\n\r\nΒΑΣΕΙΣ ΔΕΔΟΜΕΝΩΝ\r\nΑΝΑΖΗΤΗΣΗ, ΑΝΑΚΤΗΣΗ, ΑΡΧΕΙΟ, ΑΦΑΙΡΕΣΗ, ΒΑΣΗ, ΒΑΣΗ.ΠΑΡΟΧΟΣ, ΒΑΣΗ.ΧΡΗΣΤΗΣ, ΔΕΙΞΕ, ΔΟΜΗ, ΕΚΤΕΛΕΣΗ, ΕΠΙΣΤΡΟΦΗ, ΠΡΟΣΘΗΚΗ, ΣΥΜΠΙΕΣΗ, ΤΑΞΗ\r\n\r\nΗΧΟΙ ΚΑΙ ΤΑΙΝΙΕΣ\r\nΕΝΤΑΣΗ, ΕΠΙΛΕΞΕ.ΟΡΓΑΝΟ, ΗΧΟΣ, ΛΟΓΟΣ, ΜΕΛΩΔΙΑ, ΜΟΥΣΙΚΗ, ΜΠΙΠ, ΠΑΙΞΕ, ΤΑΙΝΙΑ, ΤΟΝΟΣ, ΦΩΝΗ\r\n\r\nΕΝΤΟΛΕΣ ΔΕΙΚΤΗ\r\nΔΕΙΚΤΗ.ΜΟΡΦΗ, ΛΑΒΗ\r\n\r\nΕΝΤΟΛΕΣ ΙΣΤΟΥ\r\nΑΝΑΛΟΓΙΟ, ΚΕΙΜΕΝΟ\r\n\r\nΚΟΙΝΕΣ ΦΟΡΜΕΣ\r\nΑΝΟΙΓΜΑ.ΑΡΧΕΙΟΥ, ΑΝΟΙΓΜΑ.ΕΙΚΟΝΑΣ, ΑΠΟΘΗΚΕΥΣΗ.ΩΣ, ΕΠΙΛΕΞΕ.ΓΡΑΜΜΑΤΟΣΕΙΡΑ, ΕΠΙΛΕΞΕ.ΧΡΩΜΑ, ΚΑΤΑΛΟΓΟΣ, ΡΥΘΜΙΣΕΙΣ, ΤΙΤΛΟΣ, ΥΠΟΚΑΤΑΛΟΓΟΣ\r\n\r\nΑΡΙΘΜΗΤΙΚΑ\r\n#ΑΘΡ(, #ΑΝΑΠ(, #ΑΝΤ(, #ΕΚΦΡ(, #ΘΕΣΗ(, #ΜΕΓ(, #ΜΕΡΟΣ(, #ΜΙΚ(, #ΠΑΚ(, #ΤΑΞΙΝΟΜΗΣΗ(, #ΤΙΜΗ(, #ΦΙΛΤΡΟ(, ΑΚ(, ΑΚΕΡΑΙΟ.ΔΥΑΔΙΚΟ(, ΑΝ(, ΑΠΟΛ(, ΑΡΙΘΜΟΣ.ΠΑΡΑΓΡΑΦΟΥ(, ΑΡΧΕΙΟΥ.ΜΗΚΟΣ(, ΑΡΧΕΙΟΥ.ΣΤΑΜΠΑ(, ΒΑΣΗ(, ΔΑΠΕΔ(, ΔΕΙΚΤΗΣ(, ΔΕΚ(, ΔΕΝ, ΔΙΑΡΘΡΩΣΗ(, ΔΙΑΣΤΑΣΗ(, ΔΟΚΙΜΗ(, ΔΥΑΔΙΚΗ.ΠΕΡΙΣΤΡΟΦΗ(, ΔΥΑΔΙΚΟ(, ΔΥΑΔΙΚΟ.ΑΚΕΡΑΙΟ(, ΔΥΑΔΙΚΟ.ΑΝΤΙ(, ΔΥΑΔΙΚΟ.ΑΠΟ(, ΔΥΑΔΙΚΟ.Η(, ΔΥΑΔΙΚΟ.ΚΑΙ(, ΔΥΑΔΙΚΟ.ΟΛΙΣΘΗΣΗ(, ΔΥΑΔΙΚΟ.ΟΧΙ(, ΔΥΑΔΙΚΟ.ΠΡΟΣΘΕΣΗ(, ΔΥΟΜΙΣΑ(, ΕΓΓΡΑΦΕΣ(, ΕΓΓΡΑΦΟΥ.ΛΕΞΕΙΣ(, ΕΓΓΡΑΦΟΥ.ΜΗΚΟΣ(, ΕΓΓΡΑΦΟΥ.ΜΟΝΑΔΙΚΕΣ.ΛΕΞΕΙΣ(, ΕΓΓΡΑΦΟΥ.ΠΑΡ(, ΕΓΓΡΑΨΙΜΟ(, ΕΓΚΥΡΟ(, ΕΙΚΟΝΑ(, ΕΙΚΟΝΑ.Υ(, ΕΙΚΟΝΑ.Υ.ΣΗΜΕΙΑ(, ΕΙΚΟΝΑ.Χ(, ΕΙΚΟΝΑ.Χ.ΣΗΜΕΙΑ(, ΕΚΦΡ(, ΕΝΚΟΜ(, ΕΝΩΣΗ(, ΕΠΟΜΕΝΑ(, ΕΤΟΙΜΟ(, ΕΦΑΠ(, ΗΜ(, ΗΜΕΡΑ(, ΘΕΣΗ(, ΘΕΣΗΔΕΞΙΑ(, ΙΔΙΟΤΗΤΑ(, ΚΑΘΕ(, ΚΑΤΩΜΙΣΟ(, ΚΩΔ(, ΛΑΒΗ(, ΛΑΒΗ.ΑΝΑΛΟΓΙΚΟ.Υ(, ΛΑΒΗ.ΑΝΑΛΟΓΙΚΟ.Χ(, ΛΑΒΗ.ΚΑΤΕΥΘΥΝΣΗ(, ΛΟΓ(, ΛΦ(, ΜΕΓΑΛΟ(, ΜΕΓΑΛΟ.ΣΕΙΡΑΣ(, ΜΕΓΕΘΟΣ.Υ(, ΜΕΓΕΘΟΣ.Χ(, ΜΕΤΑΘΕΣΗ(, ΜΗΚΟΣ(, ΜΗΚΟΣ.ΕΜΦ(, ΜΙΚΡΟ(, ΜΙΚΡΟ.ΣΕΙΡΑΣ(, ΜΠΡΟΣΤΑ(, ΟΜΑΔΑ(, ΟΜΑΔΑ.ΣΥΝΟΛΟ(, ΟΡΟΦ(, ΟΧΙ, ΠΑΝΩΜΙΣΟ(, ΠΑΡΑΓΡΑΦΟΣ(, ΠΑΡΑΜ(, ΠΑΤΗΜΕΝΟ(, ΠΙΝΑΚΑΣ(, ΠΙΣΩ(, ΠΡΩΤΟ(, ΡΙΖΑ(, ΡΩΤΑ(, ΣΕΙΡΙΑΚΟΣ.ΔΙΣΚΟΥ(, ΣΗΜ(, ΣΗΜΕΙΟ(, ΣΤΗΛΗ(, ΣΤΡΟΓΓ(, ΣΥΓΚΡΙΝΕ(, ΣΥΓΚΡΟΥΣΗ(, ΣΥΝ(, ΣΥΝΑΡΤΗΣΗ(, ΣΥΧΝΟΤΗΤΑ(, ΣΩΡΟΣ(, ΤΑΞΗ(, ΤΑΥΤΙΣΗ(, ΤΕΛΟΣ(, ΤΙΜΗ(, ΤΙΜΗΣΩΡΟΥ(, ΤΜΗΜΑ(, ΤΟΞ.ΕΦ(, ΤΟΠΙΚΟ(, ΤΡΑΠ(, ΤΥΧΑΙΟΣ(, ΥΠΑΡΧΕΙ(, ΥΠΑΡΧΕΙ.ΚΑΤΑΛΟΓΟΣ(, ΥΠΜΕΡ(, ΥΠΩΡΑ(, ΧΑΡΚΩΔ(, ΧΚΦ(, ΧΡΟΝΟΣ(, ΧΡΩΜΑ(\r\n\r\nΑΛΦΑΡΙΘΜΗΤΙΚΑ\r\n#ΕΚΦΡ$(, #ΜΕΓ$(, #ΜΙΚ$(, #ΠΑΚ$(, #ΤΙΜΗ$(, ΑΛΛΑΓΗ$(, ΑΝ$(, ΑΝΑΠ$(, ΑΠΟΚ$(, ΑΠΟΚ.ΑΡ$(, ΑΠΟΚ.ΔΕ$(, ΑΡΙΣ$(, ΑΡΙΣΤΕΡΟΜΕΡΟΣ$(, ΑΡΧΕΙΟ$(, ΑΥΛΟΣ$(, ΒΑΛΕ.ΑΔΕΙΑ$(, ΓΡΑΦΗ$(, ΔΕΚΑΕΞ$(, ΔΕΞΙ$(, ΔΕΞΙΜΕΡΟΣ$(, ΕΙΚ$(, ΕΙΣΑΓΩΓΗ$(, ΕΚΦΡ$(, ΕΝΩΣΗ.ΣΕΙΡΑΣ$(, ΕΠΑΝ$(, ΕΠΙΛΟΓΗ$(, ΕΦΑΡΜΟΓΗ.ΑΡΧΕΙΟΥ$(, ΗΜΕΡΑ$(, ΗΧΟ$(, ΙΔΙΟΤΗΤΑ$(, ΙΣΧΝΗ$(, ΚΕΦ$(, ΚΡΥΦΟ$(, ΛΟΓΟΣ$(, ΜΕΓΑΛΟ.ΣΕΙΡΑΣ$(, ΜΕΛΟΣ$(, ΜΕΛΟΥΣ.ΤΥΠΟΣ$(, ΜΕΡΟΣ$(, ΜΕΣ$(, ΜΙΚΡΟ.ΣΕΙΡΑΣ$(, ΜΙΚΡΟΣ.ΚΑΤΑΛΟΓΟΣ$(, ΜΟΡΦΗ$(, ΟΔΗΓΟΣ$(, ΟΚΝ$(, ΟΜΑΔΑ$(, ΟΝΟΜΑ.ΑΡΧΕΙΟΥ$(, ΟΝΟΜΑ.ΑΡΧΕΙΟΥ.ΜΟΝΟ$(, ΠΑΡΑΓΡΑΦΟΣ$(, ΠΑΡΑΘΕΣΗ$(, ΠΑΡΑΜ$(, ΠΕΔΙΟ$(, ΠΕΖ$(, ΠΙΝΑΚΑΣ$(, ΡΩΤΑ$(, ΣΥΝΑΡΤΗΣΗ$(, ΣΧΔ$(, ΣΩΡΟΣ$(, ΣΩΡΟΥΤΥΠΟΣ$(, ΤΙΜΗΣΩΡΟΥ$(, ΤΙΤΛΟΣ$(, ΤΙΤΛΟΣ.ΑΡΧΕΙΟΥ$(, ΤΟΠΙΚΟ$(, ΤΟΠΟΣ$(, ΤΟΠΟΣ.ΑΡΧΕΙΟΥ$(, ΤΥΠΟΣ$(, ΤΥΠΟΣ.ΑΡΧΕΙΟΥ$(, ΦΑΚΕΛΟΣ$(, ΦΑΝΕΡΟ$(, ΦΙΛΤΡΟ$(, ΦΩΤΟ$(, ΧΑΡ$(, ΧΑΡΚΩΔ$(, ΧΡΟΝΟΣ$(\r\n\r\nΜΕΤΑΒΛΗΤΕΣ ΣΥΣΤΗΜΑΤΟΣ\r\nΑΝΑΛΟΓΙΟ$, ΑΥΤΟ, ΓΡΑΜΜΑ$, ΓΡΑΜΜΑΤΟΣΕΙΡΑ$, ΓΡΑΜΜΕΣΑΝΑΦΟΡΑΣ, ΓΡΑΜΜΗ, ΔΕΙΚΤΗΣ, ΔΕΙΚΤΗΣ.ΚΟΜ, ΔΕΙΚΤΗΣ.Υ, ΔΕΙΚΤΗΣ.Χ, ΔΕΙΚΤΗΣΑ.Υ, ΔΕΙΚΤΗΣΑ.Χ, ΔΙΑΔΙΚΤΥΟ, ΔΙΑΔΙΚΤΥΟ$, ΔΙΑΡΚΕΙΑ, ΔΙΑΦΑΝΕΙΑ$, ΔΙΚΤΥΟ$, ΕΙΝΑΡ, ΕΙΝΓΡ, ΕΚΤΥΠΩΤΗΣ$, ΕΛ OSBIT, ΕΛΕΓΧΟΣ.ΜΕΓΕΘΟΣ.ΣΩΡΟΥ, ΕΛΕΓΧΟΣ.ΣΩΡΟΥ, ΕΛΛΗΝΙΚΑ_μεταβλητή, ΕΝΑΟΝΟΜΑ$, ΕΝΚΟΜ$, ΕΝΤΑΣΗ_μεταβλητή, ΕΝΤΟΛΗ$, ΕΠΙΛΟΓΕΣ, ΕΠΙΛΟΓΕΣ.ΦΑΝΕΡΕΣ, ΕΠΙΛΟΓΗ_μεταβλητή, ΕΦΑΡΜΟΓΗ.ΚΑΤ$, ΘΕΣΗ.Υ, ΘΕΣΗ.Χ, ΘΕΣΗ_μεταβλητή, ΙΔΙΟΤΗΤΕΣ$, ΚΑΤ$, ΚΑΤΑΣΤΑΣΗ.ΤΑΙΝΙΑΣ$, ΚΕΝΟ, ΚΙΝΗΣΗ.ΠΥ, ΚΙΝΗΣΗ.ΠΧ, ΚΙΝΗΣΗ.Υ, ΚΙΝΗΣΗ.ΥΠ, ΚΙΝΗΣΗ.Χ, ΚΙΝΗΣΗ.ΧΠ, ΚΛΙΜΑΞ.Υ, ΚΛΙΜΑΞ.Χ, ΚΟΜ$, ΚΩΔΙΚΟΣΕΛΙΔΑ, ΛΑΘΟΣ$, ΛΑΘΟΣ.ΤΑΙΝΙΑΣ$, ΛΟΓΟΣ ως μεταβλητή, ΛΣ$, ΜΕΓΕΘΟΣ.ΣΩΡΟΥ, ΜΝΗΜΗ, ΜΟΥΣΙΚΗ.ΜΕΤΡΗΤΗΣ, ΝΗΜΑΤΑ$, ΟΝΟΜΑ.ΤΜΗΜΑΤΟΣ$, ΟΝΟΜΑ.ΧΡΗΣΤΗ$, ΠΑΙΖΕΙΦΩΝΗ, ΠΑΡΑΘΥΡΟ (HWND), ΠΑΡΑΜΕΤΡΟΙ$, ΠΑΡΕΚΑΡΕ$, ΠΕΔΙΟ_μεταβλητή, ΠΕΝΑ_μεταβλητή, ΠΕΡΙ$, ΠΛΑΤΟΣ, ΠΛΑΤΟΣ.ΣΗΜΕΙΟΥ, ΠΛΑΤΦΟΡΜΑ$, ΠΡΟΣΩΡΙΝΟ$, ΠΡΟΧΕΙΡΟ$, ΠΡΟΧΕΙΡΟ.ΕΙΚΟΝΑ$, ΣΗΜΕΙΟ, ΣΗΜΕΡΑ, ΣΤΗΛΗ, ΣΥΣΚΕΥΗ.ΠΡΟΒΟΛΗΣ$, ΤΑΙΝΙΑ.ΜΕΤΡΗΤΗΣ, ΤΑΙΝΙΑ_μεταβλητή, ΤΙΚ, ΤΙΜΗ, ΤΜΗΜΑ$, ΤΥΠΟΣ_μεταβλητή, ΤΥΧΑΙΟΣ, ΤΩΡΑ, Υ.ΣΗΜΕΙΑ, ΥΠΟΛΟΓΙΣΤΗΣ$, ΥΨΟΣ, ΥΨΟΣ.ΣΗΜΕΙΟΥ, ΦΟΡΜΑ$, ΦΟΡΤΟΣ, Χ.ΣΗΜΕΙΑ, ΧΡΩΜΑΤΑ\r\n\r\nΣΤΑΘΕΡΕΣ\r\nΑΚΕΡΑΙΟΣ, ΑΛΗΘΕΣ, ΑΛΗΘΗΣ, ΑΠΕΙΡΟ, ΑΠΛΟΣ, ΑΥΞΟΥΣΑ, ΔΙΠΛΟΣ, ΔΥΑΔΙΚΟ_σταθ, ΕΚΔΟΣΗ_σταθερά, ΕΛ ISWINE, ΗΜΕΡΟΜΗΝΙΑ, ΚΕΙΜΕΝΟ_σταθερά, ΛΟΓΙΚΟΣ, ΛΟΓΙΣΤΙΚΟ, ΜΑΚΡΥΣ_ΤΥΠΟΣ, ΠΙ, ΥΠΟΜΝΗΜΑ, ΦΘΙΝΟΥΣΑ, ΦΟΡΜΑΡΙΣΜΑ_ΑΛΦΑΡΙΘΜΗΤΙΚΩΝ, ΦΟΡΜΑΡΙΣΜΑ_ΑΡΙΘΜΩΝ, ΦΟΡΜΑΡΙΣΜΑ_ΓΙΑ ΚΑΘΕ ΤΥΠΟ, ΦΟΡΜΑΡΙΣΜΑ_ΗΜΕΡΟΜΗΝΙΩΝ ΚΑΙ ΩΡΑΣ, ΨΕΥΔΕΣ, ΨΕΥΔΗΣ, ΨΗΦΙΟ\r\n\r\nΕΚΤΥΠΩΣΕΙΣ\r\nΕΚΤΥΠΩΣΗ, ΕΚΤΥΠΩΤΗΣ, ΙΔΙΟΤΗΤΕΣ, ΣΕΛΙΔΑ\r\n\r\n\r\n
EN:GROUP\r\nΟΜΑΔΑ\r\n1)\r\nομαδα αλφα { α, β, Γ=5, δ$ }\r\nτύπωσε αλφα.γ\r\nομαδα βητα {\r\n      πινακας α(20)=20\r\n      α(1)=10\r\n      κ=0\r\n      συναρτηση ενα {\r\n            αυτο.κ++\r\n            =αυτο.α(αυτο.κ)\r\n      }\r\n}\r\nτύπωσε βητα.ενα()\r\nτμημα αλλο {\r\n      διαβασε &αλληομαδα\r\n      ? αλληομαδα.ενα()\r\n}\r\n\r\nαλλο &βητα\r\n2) Ιδιωτικό και δημόσιο μέρος στον ορισμό της ομάδας\r\nΟμάδα Άλφα {\r\nΙδιωτικό:\r\n      Χ, Υ=100, Ζ\r\nΔημόσιο:\r\n       Τμήμα Δείξε_μου {\r\n             Τύπωσε .Χ, .Υ, .Ζ\r\n       }\r\n}\r\nΆλφα.Δείξε_μου\r\nΤύπωσε Έγκυρο(Άλφα.Χ)   \\\\ 0 - δεν είναι έγκυρο\r\n3)Προσωρινό μέρος στον ορισμό ομάδας\r\nΟμάδα Άλφα {\r\nΙδιωτικό:\r\n      Χ, Υ=100, Ζ\r\nΔημόσιο:\r\n       Τμήμα Δείξε_μου {\r\n             Τύπωσε .Χ, .Υ, .Ζ\r\n       }\r\nΚλάση:\r\n      Τμήμα Πάρε_Τιμές {\r\n            Διάβασε .Χ, .Υ, .Ζ\r\n      }\r\n}\r\nΆλφα.Δείξε_μου\r\nΆλφα.Πάρε_Τιμές 1,2,100\r\nΆλφα.Δείξε_μου\r\nΜ=Άλφα\r\nΔες οκ {\r\n      Μ.Πάρε_Τιμές 1,2,100\r\n}\r\nΑν όχι οκ τότε Τύπωσε \"Λάθος:\"+Λάθος$\r\n' η Μ δεν έχει το τμήμα που φορτώνει τις μεταβλητές!\r\n3) Τελεστές - Δες το Τελεστής\r\n4) Ιδιότητες - Δες το Ιδιότητα\r\n5) Παλιός τρόπος δημιουργίας ομάδας με αλφαριθμητικό\r\nΑ$=\" Χ,Υ,Ζ\"\r\nΟμάδα Άλφα Τύπος Α$\r\nΆλφα.Χ+=100\r\nΤύπωσε Άλφα.Χ\r\n6) Εξαγωγή σειριακή σε μεταβλητές με αναφορά\r\nΟμάδα Άλφα {Χ, Υ, Ζ}\r\nΔιάβασε από Άλφα, Χ1, Υ1, Ζ1\r\nΧ1+=100\r\nΥ1=1\r\nΖ1=200\r\nΓια Άλφα {\r\n      Τύπωσε .Χ, .Υ, .Ζ\r\n}\r\n7)Μέλη ομάδας\r\nΟμάδα Άλφα {\r\n      Χ, Υ, Ζ\r\n      Πίνακας Α1()\r\n      Α=Λάμδα Χ=1 -> {=Χ : Χ++}\r\n}\r\nΣ=Ομάδα.Σύνολο(Άλφα)\r\nΓια Ι=1 έως Σ {\r\n      Τύπωσε Μέλος$(Άλφα, Ι), Μέλους.Τύπος$(Άλφα, Ι)\r\n}\r\nΤύπωσε Άλφα.Α(), Άλφα.Α()\r\n8)  Συγχώνευση Ομάδας\r\nΟμάδα Άλφα {Χ=10, Υ=20}\r\nΟμάδα Βήτα {Υ=30, Ζ=100}\r\nΆλφα=Βήτα\r\nΤύπωσε Άλφα.Ζ, Άλφα.Υ\r\n9) Ομάδα σε πίνακα ως κοινή ομάδα\r\nοι συναρτήσεις, τα τμήματα και οι τελεστές γράφονται μια φορά για όλα τα στοιχεία πίνακα\r\nΣτους πίνακες δεν γίνεται συγχώνευση αλλά αντικατάσταση\r\nΟμάδα Άλφα {\r\n      Χ=10,Υ=20\r\n      Συνάρτηση Γινόμενο {\r\n            =.Χ, .Υ\r\n      }\r\n}\r\nΠίνακας Βάση 1, Α(20)=Άλφα\r\nΑ(2).Χ+=10\r\nΤύπωσε Α(2).Γινόμενο()\r\n10)Ομάδα σε πίνακα χωρίς κοινή ομάδα (Ισχύει και για Κατάσταση)\r\nΜπορούμε να αλλάξουε μια συνάρτηση σε συγκεκριμένο αντικείμενο στο πίνακα. Ο πίνακας μπορεί να πάρει διαφορετικές ομάδες.\r\nΟμάδα Άλφα {\r\n      Χ=10,Υ=20\r\n      Συνάρτηση Γινόμενο {\r\n            =.Χ* .Υ\r\n      }\r\n}\r\nΠίνακας Βάση 1, Α(20)\r\nΑ(2)=Άλφα\r\nΑ(2).Χ+=10\r\nΤύπωσε Α(2).Γινόμενο()\r\nΓια Α(2) {\r\n      Ομάδα Προσωρινή {\r\n            Συνάρτηση Γινόμενο {\r\n                  =.Χ*.Υ*100\r\n            }     \r\n      }\r\n      \\\\ κάνουμε συγχώνευση\r\n      Αυτό=Προσωρινή\r\n}\r\nΤύπωσε Α(2).Γινόμενο()\r\nΚατάσταση Βήτα=\"Θέση Α\":=Άλφα\r\nΤύπωσε Βήτα(\"Θέση Α\").Γινόμενο()\r\nΒήτα(\"Θέση Α\").Χ+=20\r\nΤύπωσε Βήτα(\"Θέση Α\").Γινόμενο()\r\nΓια Βήτα(\"Θέση Α\") {\r\n      Ομάδα Προσωρινή {\r\n            Συνάρτηση Γινόμενο {\r\n                  =.Χ*.Υ*100\r\n            }     \r\n      }\r\n      \\\\ κάνουμε συγχώνευση\r\n      Αυτό=Προσωρινή\r\n}\r\nΤύπωσε Βήτα(\"Θέση Α\").Γινόμενο()\r\n11) Αλλαγή τιμής μεταβλητές ομάδας\r\nΟμάδα Άλφα {\r\n      Χ=10\r\n      Πίνακας Βάση 1, Μ(10)\r\n      Τμήμα ΠάρεΤιμές {\r\n            Διάβασε Κ, Λ\r\n            \\\\ εδώ θέλει <=\r\n            .Χ<=Κ*Λ\r\n            \\\\ οι πίνακες ως αντικείμενα δεν θέλουν <=\r\n            Αν Λ<>0 Τότε .Μ(2)=Κ/Λ\r\n      }\r\n}\r\n12) κατασκευής ομάδας με Κλάση - δες Κλάση\r\n\r\nΑλφα.ΠάρεΤιμές 100,50\r\nΤύπωσε Άλφα.Χ, Άλφα.Μ(2)\r\n
EN:GROUP$(\r\nΚλάση Άλφα$ {\r\nΙδιωτικό:\r\n      Όνομα$\r\nΔημόσιο:\r\n      Αξία {\r\n            =.Όνομα$\r\n      }\r\n      Ιδιότητα Μήκος {Αξία}=0\r\nΚλάση:\r\n      Τμήμα alfa {\r\n            Διάβασε .Όνομα$\r\n            .[Μήκος]<=Μήκος(.Όνομα$)\r\n      }\r\n}\r\n\r\nα$=Άλφα$(\"Hello\")\r\nΤύπωσε α.Μήκος, α$, Τύπος$(α$), Τύπος$(α)\r\nβ$=Ομάδα$(α$)\r\nΤύπωσε β.Μήκος, β$, Τύπος$(β$), Τύπος$(β)\r\nδ$=α$\r\nΤύπωσε Τύπος$(δ$), δ$\r\n\r\n
EN:GROUP(\r\nΟμάδα Άλφα {\r\nΙδιωτικό:\r\n      χ=0\r\nΔημόσιο:\r\n      Αξία {\r\n            =.χ\r\n            .χ++\r\n      }\r\n}\r\n\r\nΤύπωσε Άλφα, Άλφα, Άλφα\r\nΒήτα=Άλφα\r\nΤύπωσε Βήτα , Βήτα, Βήτα  ' 3   3   3  είναι τύπου double\r\nΤύπωσε Τύπος$(Βήτα)\r\nΔέλτα=Ομάδα(Άλφα)\r\nΤύπωσε Δέλτα, Δέλτα, Δέλτα ' 4, 5, 6\r\nΤύπωσε Άλφα, Άλφα, Άλφα' 4, 5, 6\r\n\r\n
EN:GROUP.COUNT(\r\nΔίνει τον αριθμό μελών μιας ομάδας\r\nΔείτε το παρακάτω παράδειγμα (προχωρημένο κάπως)\r\n\r\nΟμάδα Αλφα {\r\nΙδιωτικό:\r\n      χ=100\r\nΔημόσιο:\r\n      α=10\r\n      β=20\r\n      Πίνακας Κ(20)=50\r\n      Τμήμα βήτα {\r\n            Τύπωσε .α, .β, .α*.β, .χ, .Κ()\r\n      }\r\n}\r\nΑλφα.Βήτα\r\nΤύπωσε Ομάδα.Σύνολο(Αλφα)  \\\\ 3 only variables and arrays\r\nΆδειασε ' αδειάζουμε το Σωρό, για να τον γεμίσουμε με την Βάλε\r\nΓια ι=1 Έως Ομάδα.Σύνολο(Αλφα)\r\n      Τύπωσε \"Ισχνή Αναφορά: \"; Μέλος$(Αλφα, ι), Μέλους.Τύπος$(Αλφα, ι)\r\n      Βάλε Φίλτρο$(Μέλος$(Αλφα, ι),\"(\")  ' αφαιρούμε το ( - θα το δώσει ο πίνακας\r\nΕπόμενο ι\r\nΣωρός  ' Μας δείχνει τι έχει τώρα ο σωρός\r\n' τώρα διαβάζουμε από το σωρό\r\nΔιάβασε &κ1(), &β1, &α1\r\nΔες οκ {\r\n    Διάβασε &χ1  ' δεν θα πετύχει η αναφορά σε ιδιωτική μεταβλητή!\r\n}\r\nΑν όχι οκ Τότε Τύπωσε Λάθος$\r\nΤύπωσε κ1(3), β1, α1\r\nβ1+=100\r\nΤύπωσε Αλφα.β\r\n\r\n\\\\ ειδική εντολή διάβασε με το Από, διαβάζει μεταβλητές και πίνακες από ομάδα\r\n\\\\ εδώ μπορούμε να συνδέσουμε την ιδιωτική με μεταβλητή.\r\nΔιάβασε Από Αλφα, χ2, α2, β2, μ()\r\nΤύπωσε χ2, α2, β2, μ()\r\nα2+=1000\r\nχ2*=500\r\nΑλφα.Βήτα\r\n\r\n\r\n\r\n
EN:SMOOTH\r\nΟΜΑΛΑ ΝΑΙ\r\nΟΜΑΛΑ ΟΧΙ\r\nΒάζει το GDI+ για γραμμές, καμπύλες, πολύγωνα και κύκλους, ώστε να βγαίνουν οι γραμμές των σχημάτων ομαλά.\r\n\r\n
EN:NAME\r\nΟΝΟΜΑ αρχείο_ετσι ΩΣ αρχείο_αλλιως\r\nΑλλαγή ονόματος αρχείου που βρίσκεται στον τρέχον κατάλογο\r\n\r\n\r\n\r\n\r\n
EN:FILE.NAME$(\r\nΜας δίνει το όνομα ενός αρχείου διαγράφοντας το μονοπάτι (τον τόπο εγγραφής)\r\nπεριλαμβάνει και τον τύπο\r\nπ.χ. αλφα.gsb είναι όνομα με τύπο gsb\r\n\r\n
EN:FILE.NAME.ONLY$(\r\nΕπιλογή \\\\ καθαρίζει τη λίστα επιλογών\r\nΑρχεία + \"*\"  \\\\ γεμιζει τη λίστα με ονόματα και τύπο αρχείων από το τρέχον φάκελο\r\nΕπιλογή ! \\\\ ανοίγει τη λίστα για επιλογή\r\nΑν Επιλογή>0 Τότε Τύπωσε Επιλογή$(Επιλογή), Όνομα.Αρχείου.Μόνο$(Επιλογή$(Επιλογή))\r\nΤύπωσε Όνομα.Αρχείου.Μόνο$(\"c:\\alfa beta\\delta one.klm\")  \\\\ δεν ελέγχει αν υπάρχει το αρχείο, δουλεύει και με διαστήματα\r\n\\\\ αφήνει αυτόματα όποια παράμετρος ακολουθεί το όνομα\r\nΤύπωσε Όνομα.Αρχείου.Μόνο$(\"c:\\alfa beta.bin\\delta one.klm  -help fileother.txt\")\r\n\r\n
EN:MODULE.NAME$\r\nΤμήμα Βήτα {\r\n\tΤύπωσε Τμήμα$\r\n\t\\\\ το παραπάνω έχει κωδικούς\r\n\t\\\\ από αυτούς το παρακάτω βγάζει το κανονικό όνομα\r\n\tΤύπωσε όνομα.τμήματος$\r\n}\r\nΚάλεσε Βήτα\r\n\r\n
EN:USER.NAME$\r\n? ΟΝΟΜΑ.ΧΡΗΣΤΗ\r\nεπιστρέφει το όνομα χρήστη\r\nεπιλέγουμε ή και δημιουργούμε χρήστη με την παρακάτω εντολή\r\nΧΡΗΣΤΗΣ ονομα\r\n\r\nΟ επόπτης έχει το όνομα του χρήστη των Windows. Αν φτιάξουμε χρήστη με αυτό το όνομα δεν θα είναι ο επόπτης. Για να επιστρέψουμε στον επόπτη πρέπει να δώσουμε τη κατάλληλη εντολή (υπάρχει γραμμένη στην βοήθεια και θα τη βρει κανείς όταν την διαβάσει προσεκτικά)\r\nμπορούμε να επιλέξουμε τον κατάλογο χρήστη με την εντολή ΚΑΤΑΛΟΓΟΣ ΧΡΗΣΤΗ\r\nμε ενεργό ένα χρήστη εκτός τον επόπτη δεν δουλεύουν οι εντολές ΚΟΝΣΟΛΑ και ΣΥΣΤΗΜΑ\r\n\r\n
EN:RECURSION.LIMIT\r\nΟΡΙΟ.ΑΝΑΔΡΟΜΗΣ\r\n1000\r\nΧωρις παράμετρο δίνει το προηγούμενο νούμερο (δεν σημαίνει 1000 κλήσεις)\r\nμε παράμετρο 0 δεν υπάρχει πια όριο!\r\nμε κάθε άλλο υπάρχει περίπου ο αριθμός κλήσεων που βάζουμε.\r\n\r\nΑυτό το όριο  είναι για την κλήση ρουτίνας.\r\nεξ ορισμού οι ρουτίνες έχουν όριο 10000 κλήσεις (βάθος κλήσεων), αλλά μπορούμε να το αλλάξουμε πχ 50000 αρκεί να μην έχουμε μπλοκ { } μεταξύ των κλήσεων. Τα μπλοκ κάνουν χρήση του στοίβας του συστήματος.\r\nΟι συναρτήσες έχουν όριο τις 3375 κλήσεις (βάθος κλήσεων)\r\n\r\nπ.χ\r\n\r\nFUNCTION F {\r\n      READ FF\r\n      IF FF=0 THEN {\r\n            =1\r\n      } ELSE {\r\n            =F(FF-1)*FF\r\n      }\r\n}\r\n\r\nαν ξεχάσουμε το -1 στο = τότε θα γίνει η μια κλήση μετά την άλλη χωρίς τελειωμό.\r\nΛάθος  =F(FF)*FF \r\nΣωστό =F(FF-1)*FF\r\n\r\nΤα τμήματα δεν έχουν λειτουργία αναδρομής.\r\n\r\n\r\n
EN:DECLARE\r\nΟΡΙΣΕ Μηνυμα ΑΠΟ \"user32.MessageBoxW\" {Μακρυς Α, κειμενο$, κειμενο2$, Μακρυς τυπος}\r\nΤυπωσε Μηνυμα(Παραθυρο, \"Γεια χαρά\", \"Γιώργος\", 2)\r\nδες DECLARE\r\n\r\nmybuf$=επαν$(χαρ$(0), 1000)\r\n\\\\ Αν ορίσουμε συνάρτηση με το C πριν, τότε λέμε ότι είναι κλήση τύπου C\r\n\\\\  το σύμβολο ... δηλώνει λίστα παραμέτρων. Ισχύει μόνο για το τελευταίο στοιχείο.\r\n\\\\ μόνο Unicode κλήσεις για C.\r\n\\\\ Το Γενικό μπορούμε να το αφήσουμε αν θέλουμε την συνάρτηση τοπική.\r\nΌρισε Γενικό  MyPrint Από C \"msvcrt.swprintf\" { &sBuf$,  sFmt$, ... } \r\n\\\\ το σύμβολο ! πριν από μια αριθμητική έκφραση για παράμετρο...\r\n\\\\........λέει στον διερμηνευτή ότι θα καταχωρηθεί ως Μακρύς ή Long.\r\nΑ=MyPrint(&myBuf$, \"Γειά P1=%s, P2=%d, P3=%.4f, P4=%s\", \"ABC\", !123456, 1.23456, \"xyz\")\r\nΤύπωσε Αρισ$(myBuf$,Α)\r\n\r\n\r\nΗ όρισε κάνει αρκετά πράγματα, ένα επίσης από αυτά είναι ότι φτιάχνει πίνακες αντικειμένων, και αν ζητήσουμε με γεγονότα, τότε θα φτιάξει και τα ανάλογα αντικείμενα (είναι κρυφά) τα οποία ανακατευθύνουν τα γεγονότα σε συναρτήσεις στο τμήμα που δημιουργούμε τα αντικείμενα.\r\nΓια τα στοιχεία της διεπαφής δεν βάζουμε το ΜεΓεγονότα.\r\n \r\n Όρισε Α() πάνω   ' αυξάνει κατά ένα τα αντικείμενα και φτιάχνει και για το νέο αντικείμενο για γεγονότα\r\n Όρισε Α() τίποτα    ' διαγράφει τα αντικείμενα\r\n  \r\n  Χρησιμοποιούμε την Μέθοδος και την Με, με την πρώτη για να καλέσουμε μεθόδους, με ή χωρίς επιστροφή τιμής, και τη Με για να βάζουμε τιμές ή να βγάζουμε σε μεταβλητές. Οι μεταβλητές στην Με συνδέονται με τα αντικείμενα, ώστε μέσω αυτών να διαβάζουμε ή να γράφουμε άμεσα τιμές.\r\n Γενικά καλύτερα να δει κανείς παραδείγματα πάνω σε αυτά. \r\n  \r\n\r\n
EN:DEFINITIONS\r\nΟΡΙΣΜΟΙ\r\nΑΛΛΑΞΕ, ΑΠΑΡ, ΑΠΑΡΙΘΜΗΣΗ, ΑΥΤΟΜΑΤΟΙ_ΠΙΝΑΚΕΣ, ΓΕΓΟΝΟΣ, ΓΕΝΙΚΗ, ΔΙΑΡΘΡΩΣΗ, ΔΥΑΔΙΚΟ, ΕΓΓΡΑΦΟ, ΘΕΣΕ, ΙΔΙΟΤΗΤΑ, ΚΑΝΕ, ΚΑΤΑΣΤΑΣΗ, ΚΛΑΣΗ, ΛΑΜΔΑ, ΜΑΚΡΥΣ, ΜΕ_Αντικείμενο, ΜΕΘΟΔΟΣ, ΟΜΑΔΑ, ΟΡΙΣΕ, ΠΙΝΑΚΑΣ, ΣΤΑΘΕΡΗ, ΣΤΑΤΙΚΗ, ΣΤΗ, ΣΤΟΚ, ΤΟΠΙΚΗ, ΥΠΕΡΚΛΑΣΗ\r\n
EN:CEIL(\r\n\r\nστρογγυλοποιεί στην επόμενη ακέραια τιμή\r\n\r\n
EN:NOT\r\nΣυνάρτηση αναστροφής\r\nΤΥΠΩΣΕ ΟΧΙ ΑΛΗΘΕΣ\r\n\r\nΤΥΠΩΣΕ ΟΧΙ ( ΟΧΙ 2)\r\nδίνει 2\r\nΥπάρχει και η ΔΕΝ (ακριβώς ότι κάνει και η ΟΧΙ)\r\nΑυτήν την έφτιαξα για να την βάζουμε έτσι:\r\nΑΝ ΔΕΝ ΥΠΑΡΧΕΙ(αρχείο_ταδε$) ΤΟΤΕ {\r\n}\r\nτο οποίο είναι πιο ωραίο από το \r\nΑΝ ΟΧΙ ΥΠΑΡΧΕΙ(....\r\n\r\n
EN:PLAYSCORE\r\nΤύπωσε ΠΑΙΖΕΙΦΩΝΗ\r\n\r\nαν ένα οποιοδήποτε νήμα μουσικής εκτελείται τότε επιστρέφει αληθής\r\n\r\n
EN:PLAYER\r\nΠάνω από την οθόνη υπάρχουν 32 παίκτες ή επίπεδα. Είναι τα γνωστά sprites μόνο που σε αυτή την έκδοση μπορούν να λειτουργούν ως 32 νέες οθόνες προβάλοντας στοιχεία.\r\nΓια ιστορικούς λόγους έχει δοθεί το όνομα ΠΑΙΚΤΗΣ ή PLAYER...έτσι λέγονταν στα ATARI 8bit, υπολογιστές με παρόμοιες δυνατότητες τη δεκαετία του '80\r\n\r\n1) ΠΑΙΚΤΗΣ 0\r\nκαταργεί όλους τους παίκτες\r\n2) ΠΑΙΚΤΗΣ 1, 2000, 3000 ΜΕ ΑΑ$, χρωμαδιαφάνειας, ένταση  MΕΓΕΘΟΣ 1.4 \r\n2.1) ΠΑΙΚΤΗΣ 1, 2000, 3000 ΜΕ ΑΑ$, ΜΑΣΚΑΣ$, ένταση  MΕΓΕΘΟΣ 1.4 \r\n      player 1, 2000,3000 use AA$, 1, 0, γωνία size 1.4\r\nοι παίκτες έχουν αριθμό προτεραιότητας. Ο παίκτης 1 βρίσκεται πάντα πίσω από τον 2. Ο παίκτης 32 είναι πάνω απ΄όλους.\r\nη θέση 2000,3000 έχει να κάνει με το παράθυρο και όχι με την οθόνη.\r\nη εικόνα ΑΑ$ μπορεί να φορτωθεί με πολλούς τρόπους. Δεν υπάρχει περιορισμός στο μέγεθος, πέρα από τους περιορισμούς του συστήματος (περίπου διπλάσιο μέγεθος από την οθόνη είναι καλά). Μπορούμε να επιλέξουμε χρώμα διαφάνειας, θετικά νούμερα από το 0 ως το 15, τα βασικά χρώματα και αρνητικά νούμερα με την Χρωμα(0...255, 0...255, 0...255). Μπορούμε να δώσουμε μια ένταση που σημαίνει εδώ ότι όσο μεγαλύτερο νούμερο δώσουμε (1...255) τόσα περισσότερα χρώματα θα κάνουμε διάφανα, από το βασικό. Με -1 στην ένταση ακυρώνουμε την διαφάνεια.\r\nΗ γνωνία είναι σε μοίρες.\r\nΤέλος έχουμε το μέγεθος όπου 1 είναι το 100%.\r\n3) ΠΑΙΚΤΗΣ 1 ΔΕΙΞΕ\r\n      Player 1 show\r\n      Εμφανίζει το παίκτη. Η προηγούμενη εντολή δεν εμφανίζει τον παίκτη!\r\n4) ΠΑΙΚΤΗΣ 1 ΚΡΥΨΕ\r\n      Player 1 hide\r\n      Εξαφανίζει το παίκτη. Ο παίκτης δεν χάνεται απλά περιμένει εντολές!\r\n5) ΠΑΙΚΤΗΣ 1 ΑΛΛΑΞΕ 4\r\n      Player 1 swap 4\r\n      Αλλάζουμε προτεραιότητα στο παίκτη...Στην ουσία έχουμε μεταβλητές έστω Α και Β και κάνουμε αλλαγές στις προτεραιότητες και καταχωρούμε τις αλλαγές στα Α και Β και δουλεύουμε με τα Α και Β ως ξεχωριστές \"οντότητες\". Δες τη Συγκρουση(\r\n\r\n6) ΠΑΙΚΤΗΣ 1, 5000,6000\r\n      μετακινούμε τον παίκτη στο 5000,6000\r\n\r\nΜπορούμε να χειριστούμε τον κάθε Παικτη  ως οθονη με την εντολή Επιπεδο\r\n\r\nΔες το παράδειγμα εδώ Player\r\n\r\n\r\n
EN:PLAY\r\nΦωνη 1, 500, \"c@2dc @2ef\"\r\nΠαιξε 1,19\r\nScore 1, 500, \"c@2dc @2ef\"\r\nPlay 1, 19\r\n\r\nπαίζει την φωνή 1 με το όργανο 19\r\n\r\nΠαιξε 0 κλείνει όλες τις φωνές\r\nΔες Φωνη\r\nΔες Επιλεξε.Οργανο\r\nΜπορούμε να βάλουμε και τις 16 φωνές να παίξουν μαζί π.χ. Παιξε 1,19,2,19,3,20,4,20,...\r\nΚάθε φωνή έχει κάποιο χρόνο να τελειώσει. Αν ξαναδώσουμε την Play ενώ δεν έχουν τελειώσει η ακόμα οι φωνές το παίξιμό τους θα δημιουργηθεί ένα μπάχαλο γιατί το σύστημα φτιάχνει νήμα για κάθε κλήση φωνής-οργάνου και θα υπάρχουν πάνω από ένα νήμα για την ίδια φωνή. Το σύστημα δεν κολλάει αλλά στέλνει εντολές πιο γρήγορα με συνέπεια να ακούγονται οι νότες με μικρότερη διάρκεια.\r\n\r\nΗλεκτρική Κιθάρα:\r\nscore 1, 350, \"c@2dc @2ef\"\r\nplay 1, 29\r\n\r\nΚουδούνι!!!\r\nέχω βάλει το 2 μετά το C που σημαίνει 2η οκτάβα, πιο μπάσο δηλαδή από την 3η οκτάβα)\r\n\r\nτο @2 λέει να παίζει μισής χρονικής αξίας, και το διάστημα μετά τις dc λέει παύση μισής χρονικής αξίας, επειδή έχει το @2 μετά\r\nscore 1, 350, \"c2@2dc @2ef\"\r\nplay 1, 9\r\n\r\n\r\nαν δώσουμε τα παρακάτω θα παίξει η ταινία, η μουσική, και ο ήχος...μαζί (ο ήχος θα ξεκινήσει ένα δευτερόλεπτο πιο μετά)\r\nmovie \"second\"  \\\\ αν υπάρχει το second.avi\r\nwait 1000\r\nsound \"ringin\"  \\\\ αν υπάρχει το ringin.wav\r\n\r\n\r\n\r\n\\\\ Πρόγραμμα Πιάνο (με συγχορδίες)\r\n\r\nΠίνακας Νοτα1$(10,3), Νοτα2$(10,3)\r\nΓέμισεΠίνακα()\r\nΦόρμα 60,30\r\nΠένα 14\r\nΟθονη 5\r\nΔιπλά\r\nΑναφορά 2, \"Πιανάκι 005\"   \r\nΚανονικά\r\nΑναφορά 2,{Οδηγίες\r\n1-Έξοδος  3-Ξυλόφωνο 4-Πιάνο 5-Σαξόφωνο  8-Πλήκτρα/Νότες 9-Ρυθμός Ναι 0-Ρυθμός Όχι\r\n\r\nΔιάστημα - Δυναμώνει τις νότες\r\n-- Γιώργος Καρράς --\r\n\r\n}\r\nΣχέδιο.Νημάτων Διαδοχικό\r\nΠαίξε 0 \\\\ καθαρίζει το σύστημα\r\nΓενική πλ$=\" \", τέμπο=300, οργ=5, φ=0, εντ$=\"V90\", φων(18), χρη(17) ' 0 ..17,\r\nν=1\r\nΓια ι=1 έως 16 { χρη(ι)=Αληθές }\r\nχρη(10)= Ψευδές \\\\ για την drum machine\r\n\\\\ υπολογισμός θέσης του κλαβιέ!\r\nμμ=2*(χ.σημεια Δια 14)\r\nμμ2= μμ δια 2\r\nκκ=γραμμή/ύψος*υ.σημεια\r\nκκ1=υ.σημεια/ύψος*8\r\nγραμ=υ.σημεια/ύψος*1.5\r\nΟθόνη , Γραμμή+9\r\nΤμήμα Πλήκτρο {\r\n      Διάβασε α$, πατ, επιλ\r\n      αν πατ τοτε {\r\n      Αν Θέση(πλ$,α$+\"-\")>0 τότε έξοδος\r\n      Επομ()\r\n      φων(επιλ)=φ\r\n      Τύπωσε α$, φ\r\n      Φωνή φ, τεμπο, α$+εντ$ : πλ$<=πλ$+α$+\"-\": Παίξε φ, οργ\r\n      } αλλιως {\r\n            πλ$<=αλλαγή$(α$+\"-\",\"\", πλ$)\r\n            Αν φων(επιλ)>0 τότε {\r\n             Παίξε φων(επιλ), 0 \r\n             χρη(φων(επιλ))~\r\n             φων(επιλ)=0\r\n             }\r\n      }\r\n      Ρουτίνα Επομ()\r\n      τοπικη ι\r\n      για ι=1 έως 16 {\r\n            αν χρη(ι) τότε έξοδος\r\n      }\r\n      αν ι<17 τότε { φ<=ι : χρη(ι)~ } αλλιώς φ<=1: χρη(1)=αληθές : Τυπωσε \"!!!!!!!!\"\r\n      Τέλος Ρουτίνας\r\n}\r\n\\\\ κανάλι 10 είναι το drum machine\r\nΝήμα { Φωνή 10,400,\"CV90CC  ab Cd eCC\" : Παίξε 10,1 } ως Λ κάθε 60\r\nΝήμα {\r\n      πλήκτρο \"A#2\", πατημένο(κωδ(\"A\")), 1\r\n      πλήκτρο \"B2\", πατημένο(κωδ(\"Z\")), 2\r\n      πλήκτρο \"C3\", πατημένο(κωδ(\"X\")), 3\r\n      πλήκτρο \"C#3\", πατημένο(κωδ(\"D\")), 4\r\n      πλήκτρο \"D3\", πατημένο(κωδ(\"C\")), 5\r\n      πλήκτρο \"D#3\", πατημένο(κωδ(\"F\")), 6\r\n      πλήκτρο \"E3\", πατημένο(κωδ(\"V\")), 7\r\n      πλήκτρο \"F3\", πατημένο(κωδ(\"B\")), 8\r\n      πλήκτρο \"F#3\", πατημένο(κωδ(\"H\")), 9\r\n      πλήκτρο \"G3\", πατημένο(κωδ(\"N\")), 10\r\n      πλήκτρο \"G#3\", πατημένο(κωδ(\"J\")), 11\r\n      πλήκτρο \"A3\", πατημένο(κωδ(\"M\")), 12\r\n      πλήκτρο \"A#3\", πατημένο(κωδ(\"K\")), 13\r\n      \\\\ https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx\r\n      πλήκτρο \"B3\", πατημένο(0xBC), 14 \\\\ VK_OEM_COMMA\r\n      πλήκτρο \"C4\", πατημένο(0xBE), 15 \\\\ VK_OEM_PERIOD\r\n      πλήκτρο \"C#4\", πατημένο(0xBA), 16 \\\\ VK_OEM_1\r\n      πλήκτρο \"D4\", πατημένο(0xBF), 17 \\\\VK_OEM_2  \r\n} ως ΑΛ κάθε 50\r\nΤύπωσε \"οκ\"\r\nΝηματα\r\nΝήμα Λ Κάθε 6000\r\nΚύριο.Έργο 100 {\r\n      Εμφ_Κλαβιέ(μμ, κκ, μμ2, κκ1)\r\n      Ανανέωση 1000\r\n      αν πατημένο(κωδ(\"1\")) τότε έξοδος\r\n      αν πατημένο(κωδ(\"3\")) τότε οργ<=14 : τέμπο<=100 ' ξυλόφωνο\r\n      αν πατημένο(κωδ(\"4\")) τότε οργ<=5 : τέμπο<=300 ' Πιάνο\r\n      αν πατημένο(κωδ(\"5\")) τότε οργ<=65 : τέμπο<=5000 ' Σαξόφωνο\r\n      αν πατημένο(κωδ(\"8\")) τότε ν=1-ν\r\n      αν πατημένο(κωδ(\"9\")) τότε Νήμα Λ Ξεκίνα\r\n      αν πατημένο(κωδ(\"0\")) τότε Νήμα Λ Κράτα\r\n      αν πατημένο(32) τότε { εντ$ <= \"V127\"  } Αλλιώς εντ$ <= \"V90\"\r\n      Τύπωσε \"--------\"\r\n}\r\nΝήματα Σβήσε\r\nΤύπωσε \"Τέλος\"\r\nΡουτίνα Εμφ_Κλαβιέ(π0,υ0, π1, υ1)\r\n      Κλαβιέ(π0, υ0, π1, υ1, 0, &Νοτα1$())\r\n      Κλαβιέ(π0-π1/2,υ0,π1,υ1*2/3, -1, &Νοτα2$())\r\n      Ανανέωση 1000\r\nΤέλος Ρουτίνας\r\nΡουτινα Κλαβιέ(π0, υ0,π1, υ1, π3, &Ν$())\r\n      Ένωσε Ν$() στο Ν()\r\n      π3-!\r\n      Τοπικές κ=-1, ι\r\n      Για ι=π0 εως 9*π1+π0 ανά π1\r\n      κ++\r\n      Αν Ν$(κ,0)<>\"\" Τότε {\r\n            θέση ι+π3*π1/6, υ0\r\n            Αν π3 τότε {\r\n                  βαψε π1-π3*π1/3-15,υ1-15, 7* (1-(φων(Ν(κ,2))>0))+1, 0,1\r\n            } Αλλιώς {\r\n                  βαψε π1-15,υ1-15,15,7* (1-(φων(Ν(κ,2))=0))+1,1\r\n            }\r\n            θέση ι+π3*π1/6, υ0\r\n            βαψε @ π1-π3*π1/3,υ1,2,1\r\n            θέση ι+π3*π1/6, υ0+υ1-γραμ\r\n            πένα π3*15 { βαψε @ π1-π3*π1/3,γραμ,5,Ν$(κ,ν)}\r\n      }\r\n      Επόμενο ι\r\nΤέλος Ρουτίνας\r\nΡουτίνα ΓέμισεΠίνακα()\r\nΤοπικές ν,π, ν$, κ$, νο\r\nΣωρός Νέος {\r\n      Σειρά \"A#2\", \"A\", 1, 1, 2\r\n      Σειρά \"B2\", \"Z\", 2, 1, 1\r\n      Σειρά \"C3\", \"X\", 3, 2, 1\r\n      Σειρά \"C#3\", \"D\", 4, 3, 2\r\n      Σειρά \"D3\", \"C\", 5, 3, 1\r\n      Σειρά \"D#3\", \"F\", 6, 4, 2\r\n      Σειρά \"E3\", \"V\", 7, 4, 1\r\n      Σειρά \"F3\", \"B\", 8, 5, 1\r\n      Σειρά \"F#3\", \"H\", 9, 6, 2\r\n      Σειρά \"G3\", \"N\", 10, 6, 1\r\n      Σειρά \"G#3\", \"J\", 11, 7, 2\r\n      Σειρά \"A3\", \"M\", 12, 7, 1\r\n      Σειρά \"A#3\", \"K\", 13, 8, 2\r\n      Σειρά \"B3\", \",\", 14, 8, 1\r\n      Σειρά \"C4\", \".\", 15, 9, 1\r\n      Σειρά \"C#4\",\";\", 16 , 10, 2 \\\\ 10 μικρά - λείπουν μερικά\r\n      Σειρά \"D4\", \"/\", 17, 10, 1 \\\\ 10 μεγάλα πλήκτρα\r\n      Ενώ όχι κενό {\r\n      Διάβασε ν$, κ$, νο, ν, π\r\n            Αν π=1 τότε {\r\n                νοτα1$(ν-1,0):= ν$, κ$, νο\r\n            } Αλλιώς {\r\n                  νοτα2$(ν-1,0):= ν$, κ$, νο\r\n            }\r\n      }\r\n}\r\nΤέλος Ρουτίνας\r\n\r\n\r\n\r\n\r\n
EN:OVER\r\n1) ΠΑΝΩ 5\r\n2) ΠΑΝΩ\r\n3) ΠΑΝΩ 5,5\r\nαντιγράφει στη κορυφή του σωρού το στοιχείο στη 5η θέση\r\nη δευτερη περίπτωση αντιγράφει την κορυφή, οπότε έχουμε δυο στοιχεία ίδια στις δυο πρώτες θέσεις\r\nη τρίτη περίπτωση  βγάζει αντίγραφα στα πέντε πρώτα στοιχεία ( εκτελεί πέντε φορές το ΠΑΝΩ 5)\r\nΔες ΦΕΡΕ, ΠΑΝΩ, ΠΕΤΑ, ΤΙΜΗΣΩΡΟΥ(),ΤΙΜΗΣΩΡΟΥ$(),\r\n      ΑΡΙΘΜΟΣ, ΓΡΑΜΜΑ$, ΕΙΝΑΡ, ΕΙΝΓΡ, ΚΕΝΟ, ΑΔΕΙΑΣΕ, ΣΩΡΟΣ\r\n\r\n
EN:HIGHWORD(\r\n' η α δεν είναι ακέραιος, αλλά μπορεί να έχει ακέραιες τιμές.\r\nα=0xFFFF0000\r\nΤύπωσε ΠάνωΜισό(α)  ' 65535\r\n\r\nΚάτωΜισό(), ΔυοΜισά(), Δεκαεξ$()\r\nΔεκαεξ\r\n\r\n
EN:PARAGRAPH$(\r\nH παράγραφος$() δίνει μια παράγραφο και μπορεί ταυτόχρονα να την διαγράφει από το έγγραφο\r\n\r\nΕγγραφο Άλφα$={Πρώτη Παράγραφος\r\n                              Δεύτερη Παράγραφος\r\n                              Τρίτη Παράγραφος\r\n                              }\r\nΓια ι=3 έως 1 {\r\n      Αναφορά Παράγραφος$(Άλφα$, ι)\r\n}\r\nπαλία_παράγραφος$=Παράγραφος$(Άλφα$, 2, -1)\r\nΠαρεμβολή στο 2 Άλφα$=παλία_παράγραφος$+{\r\n      μια άλλη Παράγραφος\r\n      και ακόμη μια\r\n      }\r\nΚέντρο=2\r\nΑναφορά Κέντρο, Άλφα$\r\n\r\n                              \r\n\r\n\r\n\r\n\r\n
EN:PARAGRAPH(\r\nΚαθαρό\r\nΈγγραφο α$\r\nΓια ι=1 έως 9 {\r\n      α$=\"αααααααααααααααααααα\"+γραφη$(ι)+{\r\n      }\r\n}\r\nα$=\"αααααααααααααααααααα\"+γραφη$(ι)\r\nΓια ι=10  εως 1 ανα 2 {\r\n      \\\\ διαγραφή\r\n      δ$=Παράγραφος$(α$, ι, -1)\r\n}\r\n\r\nΜ=Παράγραφος(α$, 1-1) \r\nΔ=Μπροστά(α$, Μ)\r\nΕνώ Μ {\r\n      Τύπωσε Αριθμός.Παραγράφου(α$,Μ), Μ\r\n      Αναφορά Παράγραφος$(α$, (Μ))\r\n}\r\n\r\n
EN:QUOTE$(\r\nεδώ χρησιμοποιώ το ? για ΤΥΠΩΣΕ\r\n\r\n? ΠΑΡΑΘΕΣΗ$(\"ΑΛΦΑ\")\r\nΤυπώνει το \"ΑΛΦΑ\" \r\nδηλαδή βάζει εισαγωγικά\r\nτο παραθεση$(\"\") δίνει το \"\" το οποίο δεν είναι το κενό αλφαριθμητικό αλλά δυο χαρακτήρες εισαγωγικών.\r\n\r\nα$=ΠΑΡΑΘΕΣΗ$(1,2*100,3+Χ,4,\"κάτι\",5,\"κάτι άλλο\")\r\nβάζει στο αλφαριθμητικό τις τιμές από μια λίστα εκφράσεων, χωρίζοντάς τα με κόμμα και στα αλφαριθμητικά βάζει εισαγωγικά.\r\nΕΝΘΕΣΗ  \"ΣΕΙΡΑ \"+ΠΑΡΑΘΕΣΗ$(1,2*100,3+Χ,4,\"κάτι\",5,\"κάτι άλλο\")\r\nη οποία είναι ίδιο με την \r\nΣΕΙΡΑ 1,2*100,3+Χ,4,\"κάτι\",5,\"κάτι άλλο\"\r\nτην παράθεση μπορούμε να την υπολογίσουμε πριν φτάσουμε στο σημείο με την εντολή ΣΕΙΡΑ να φορτώσουμε τον σωρό.\r\nα$=ΠΑΡΑΘΕΣΗ$(1,2*100,3+Χ,4,\"κάτι\",5,\"κάτι άλλο\")\r\n...άλλες εντολές....\r\nΕΝΘΕΣΗ  \"ΣΕΙΡΑ \"+α$\r\n\r\n
EN:WINDOW\r\nΑλλάζουμε το περιθώριο και την οθόνη μαζί ώστε η οθόνη να καλύπτει όλο το περιθώριο\r\n1) Κεντράρουμε αυτόματα\r\nΠΑΡΑΘΥΡΟ τυπος_οθονης, πλατος, υψος;\r\n2)Το παράθυρο (πρώην περιθώριο) παραμένει στην πάνω αριστερή γωνία0\r\nΠΑΡΑΘΥΡΟ τυπος_οθονης, πλατος, υψος\r\n3)Το παράθυρο κεντράρεται και το ύψος δίνεται αυτόματα από τον μεταφραστή\r\nΠΑΡΑΘΥΡΟ τυπος_οθονης, πλατος\r\n4) Επαναφορά του παραθύρου στις διαστάσεις της επιφάνειας εργασίας.\r\nΠΑΡΑΘΥΡΟ τυπος_οθονης,0  ' επιλέγουμε την συσκευή οθόνης 1\r\nΠΑΡΑΘΥΡΟ τυπος_οθονης,1 ' επιλέγουμε την συσκευή οθόνης 2\r\nη μεταβλητή ΠΑΡΑΘΥΡΟ μας δίνει τον αριθμό της συσκευής οθόνης (από 0)\r\n\r\nΓια να γράψουμε στο παράθυρο, δηλαδή πίσω από την οθόνη, θα χρησιμοποιήσουμε την εντολή Περιθωριο όπου ανάμεσα σε δυο αγκύλες θα δώσουμε εντολές που θα κατεθύνουν την εκτύπωση εκεί.\r\nΜπορούμε να μετακινούμε το παραθυρο με την κινηση.π\r\nΜπορούμε να φτιάξουμε έναν στόχο και να μετακινούμε το παράθυρο με το ποντίκι\r\n\r\nΠαρακάτω έχουμε ένα παράδειγμα που μας δείχνει το πως φτιάχνουμε τρεις στόχους, το έναν στο περιθώριο, τον άλλο στο βασικό επίπεδο και ένα στο επίπεδο 1 (ή παίκτης 1). Ένα νήμα μετακινεί κάθε 4 δευτερόλεπτα τον παίκτη 1. Όλοι οι στόχοι κάνουν απλά ΜΠΙΠ όταν πατηθούν.\r\nΣτο τμήμα Β δημιουργούμε το Επίπεδο 1  το οποίο έχει αρχικό μέγεθος το μέγεθος του επιπέδου που το δημιούργησε!\r\n\r\nΤμημα Α {\r\nΠαραθυρο 12,10000, 8000;\r\nΕΣ=0\r\nΤυπος 12, Χ.Σημεια-2000, 2000\r\nΟθονη 1\r\nΚινηση 2000,4000\r\nΠεριθωριο  {\r\n      Οθονη 6\r\n      Δρομεας 13,4\r\n      Στοχος ΕΔ,\"ΤΕΛΟΣ\",12,1,13,5,5,\"ΤΕΛΟΣ\"\r\n}\r\nΕΔ1=0\r\nΔρομεας 13,3\r\nΣτοχος ΕΔ1,\"ΜΠΙΠ\",12,1,13,5,5,\"ΠΑΤΑ ΕΔΩ\"\r\nΒ\r\nΕπιπεδο 1 {\r\n      ΕΔ2=0\r\n      Δρομεας 13,3\r\n      Στοχος ΕΔ2,\"ΜΠΙΠ\",12,1,13,5,5,\"ΠΑΤΑ ΕΔΩ\"    \r\n}\r\nΝημα {\r\n      Παικτης 1, Τυχαιος(4000), Τυχαιος(4000)\r\n} Ως Λ\r\nΝημα Λ Καθε 3000\r\nΚαθε 100 {\r\n      Σαρωσε 0.3\r\n      Αν  Ενκομ$<>\"\" Τοτε Εξοδος\r\n}\r\nΝημα Λ Σβησε\r\nΠαικτης 0\r\nΣτοχοι Νεοι\r\n\r\n}\r\nΤμημα Β {\r\nΕπιπεδο 1 {\r\n            Παραθυρο 12, 7000,1500\r\n            Οθονη 2\r\n            Τυπωσε \"ΟΚ\"\r\n            }\r\nΠαικτης 1, 100,2000\r\nΠαικτης 1 Δειξε\r\n}\r\n\r\n
EN:HWND\r\nΤύπωσε ΠΑΡΑΘΥΡΟ\r\nγυρνάει τον αριθμό του παραθύρου (hWnd)\r\n\r\n
EN:PARAM$(\r\nΠαίρνςι μια λίστα σταθερών τιμών και την ενθέτει στο κώδικα. Πρέπει το πρώτο στοιχείο να είναι αλφαριθμητικό, αλλιώς χρησιμοποιούμε την Παραμ()\r\n\r\nα$={10,30,\"alfa\",40}\r\nα=(Παραμ(α$))\r\nΤύπωσε α\r\n' Το πρώτο στοιχείο πρέπει να είναι αλφαριθμητικό\r\nα$={\"hello\", 10,30,\"alfa\",40}\r\nα=(Παραμ$(α$))\r\nΤύπωσε α\r\nΤύπωσε Παραμ$(α$)\r\n\r\n
EN:PARAM(\r\n1) Ένθεση ορισμάτων στο κώδικα\r\n\\\\ υπολογίζουμε τα ορίσματα που θα δώσουμε στην Τύπωσε και στην ΔεςΕδώ\r\nΑ=10\r\nΒ=40\r\n\\\\ και τις καταχωρούμε σε ένα αλφαριθμητικό\r\nΣ$=Παράθεση$(Α*Β, Α/Β)\r\n\\\\ η Παραμ() με αλφαριθμητικό βάζει τα αποτελέσματα στο κώδικα\r\nΤύπωσε Παραμ(Σ$)\r\nΤμήμα ΔεςΕδώ (Χ,Υ) { Τύπωσε Χ, Υ }\r\nΔεςΕδώ Παραμ(Σ$)\r\nΔεςΕδώ Α*Β, Α/Β\r\n\r\n\r\n2) Υπάρχει τρόπος να δώσουμε διαβάσουμε τις ιδιότητες/μεθόδους ενός αντικειμένου που αναγνωρίζουν τα Windows.\r\n\\\\ Για να δουλέψει το παρακάτω πρέπει να έχουμε το Excel στον υπολογιστή μας!\r\n\\\\ Για να πάρουμε το GUID εκτελούμε στη γραμμή εντολών: ΛΙΣΤΑ COM ΣΤΟ Β\r\n\\\\ Θα μας βγάλει μια λίστα με αντικείμενα που αναγνωρίζει ο υπολογιστής\r\n\\\\ Θα επιλέξουμε ένα και σε ένα τμήμα (εδώ το Β) θα δώσει όλες τις γραμμές\r\n\\\\ όπως η ακόλουθη με τα αντικείμενα και τους αριθμούς GUID\r\n\\\\ οπότε με Σ Β ανοίγουμε το τμήμα Β και παίρνουμε ένα αντικείμενο\r\n\\\\ Όλα τα αντικείμενα δεν μπορούν να οριστούν παρόλο που βλέπουμε γεαμμές με Όρισε.\r\nΌρισε Worksheet \"{00020820-0000-0000-C000-000000000046}\"\r\n\\\\  Η εντολή Παραμ(αντικείμενο) εξάγει μια κατάσταση (λίστα)\r\n\\\\ Τα κλειδιά είναι τα ονόματα των ιδιοτήτων/συναρτήσεων\r\n\\\\ και τα στοιχεία είναι τα ονόματα με τα ορίσματά τους\r\n\\\\ Τα κλειδιά είναι σε κεφαλαία γράμματα\r\nΆλφα=Παραμ(Worksheet)\r\nΑναφορά Τύπος$(Worksheet) ' Workbook\r\nΑν  μήκος(Άλφα)>1 Τότε {\r\n\\\\ χρησιμοποιούμε την εντολή Αναφορά γιατί αφενός εμφανίζει κείμενο με παραγράφους, και αναδίπλωση λέξεων και αφετέρου σταματάει κάθε φορά που κάνει ολίσθηση στα 3/4 του ύψους της κονσόλας και περιμένει διάστημα ή κλικ με το ποντίκι.\r\n \\\\ τα 8 πρώτα είναι του διπλού Interface των com αντικειμένων, τα αφήνουμε!\r\n \\\\      Μ=Κάθε(Άλφα)\r\n      Μ=Κάθε(Άλφα, 9)\r\n      \\\\ το Μ^ είναι με βάση το 1 ο δρομέας του επαναλήπτη Μ\r\n      \\\\ εμείς θέλουμε με βάση το 0 για να δούμε τα κλειδιά στην πρώτη Εκφρ$()\r\n      \\\\ η δεύτερη έχει ήδη ρυθμιστεί διάβασε παρακάτω\r\n      Ενώ Μ { Αναφορά 3, Έκφρ$(Άλφα, Μ^-1)+\":\"+Έκφρ$(Άλφα)\r\n            \\\\ Δεν χρειάζεται αυτό:      Αναφορά 3, Άλφα$(Μ^-1!)\r\n            \\\\ γιατί η Άλφα έχει μια ιδιότητα index και αυτή ρυθμίζεται είτε από το Μ, είτε από τη προηγούμενη χρήση\r\n            \\\\ οπότε η Έκφρ$(Άλφα) χρησιμοποιεί την ιδιότητα index\r\n      }\r\n}\r\n\\\\ και το Άλφα είναι αντικείμενο, αλλά δεν μπορούμε να το διαβάσουμε με την Παραμ()\r\n\\\\ Με την Παραμ() διαβάζουμε ότι είναι \"δημόσιο\" στο Registry των Windows, και μπορούμε να το δημιουργήσουμε\r\n\\\\ με την Όρισε.\r\nΜε Άλφα, \"index\" ως index\r\nΑν Υπάρχει(Άλφα, \"APPLICATION\") Τότε {\r\n\\\\ επειδή το Index έχει βάση το 0, βάζουμε +1 για να πάρουμε το νούμερο του Application στo WorkSheet\r\n      Τύπωσε Index+1, Εκφρ$(Άλφα, Index), Εκφρ$(Άλφα)\r\n}\r\n\r\n\r\n
EN:PARAMETERS$\r\nΔιαβάζει παράμετρους που μπήκαν κατά τη κλήση ενός προγράμματος με κατάλληξη gsb.\r\nΜπορούμε να βάζουμε εντολές ή παραμέτρους με - ή + (αυτές γυρίζει η μεταβλητή)\r\nαν έχουμε γνωστές παραμέτρους πχ +DEC (δες Διακόπτες) στην αρχή του αλφαριθμητικού τότε διαβάζονται και αφαιρούνται από το αλφαριθμητικό. (αν βρει ο διερμηνευτής κάτι που δεν γνωρίζει ως διακόπτη σταματάει την ανάγνωση και επιστρέφει το υπόλοιπο - το πρώτο μη γνωστό αναγνωριστικό το έχει μετατρέψει σε κεφαλαία όταν το βάλει πάλι πίσω)\r\nΔες στην αγγλική έκδοση πρόγραμμα χρήσης.\r\n\r\n
EN:GET\r\nΤο αντίστροφο της ΔΩΣΕ\r\nΠΑΡΕ μεταβλητη_χειρισμου_αρχειου,  αλφαριθμητική_μεταβλητή$, θεση_στο_αρχειο\r\nΠΑΡΕ μεταβλητη_χειρισμου_αρχειου,  αλφαριθμητική_μεταβλητή$(δείκτης), θεση_στο_αρχειο\r\n\r\nπ.χ. Λαμβάνουμε την τελευταία εγγραφή στην μεταβλητή α$\r\nοι εγραφές είναι τμήματα στο αρχείο σειρών από bytes, με συγκεκριμένο μήκος,\r\nτο οποίο δηλώνουμε στο άνοιγμα. Δες ΑΝΟΙΞΕ, ΚΛΕΙΣΕ, ΔΩΣΕ\r\nεδω=ΕΓΓΡΑΦΕΣ(αλφα)\r\nΠΑΡΕ αλφα, α$, εδω\r\n\r\n\r\n\r\n\r\n\r\n
EN:GRABFRAME$\r\nΑ$=ΠΑΡΕΚΑΡΕ$\r\nΜπορούμε να ανοίξουμε ένα βίντεο και να το μετακινήσουμε στο καρέ που θέλουμε και να πάρουμε ένα καρέ, στην ΠΑΡΕΚΑΡΕ$\r\nτο καρέ πρέπει να το γράψουμε  σε μια άλλη μεταβλητή...γιατί την επόμενη φορά που θα διαβάσουμε μπορεί το βίντεο να έχει μετακινηθεί σε άλλο καρέ ή να έχει κλείσει.\r\n\r\n
EN:INSERT\r\nΠΑΡΕΜΒΟΛΗ\r\n\\\\ για αλφαριθμητικά\r\nα$=\"12345678901234567890\"\r\nβ$=α$\r\n\\\\ ανοίγει χώρο και γράφει\r\nπαρεμβολή 10 α$=\"γεια\"\r\nΤύπωσε β$\r\nΤύπωσε α$\r\nα$=\"12345678901234567890\"\r\n\\\\ γράφει πάνω στο κείμενο\r\nπαρεμβολή 10,2 α$=\"γεια\"\r\nΤύπωσε β$\r\nΤύπωσε α$\r\n\r\n\\\\ για έγγραφο\r\nέγγραφο α$, β$\r\nα$={aaaaaaaaaaa\r\n12345678901234567890\r\n}\r\nβ$=α$\r\n\\\\ ανοίγει χώρο και γράφει,  το πρώτο νούμερο είναι θ θέση χαρακτήρα (όχι η γραμμή)\r\nπαρεμβολή στο 2, 10 α$=\"γεια\"\r\nΑναφορά β$\r\nΑναφορά α$\r\nΚαθαρό α$\r\nΈγγραφο α$=β$\r\n\\\\ γράφει  στο κείμενο στη 2η γραμμή (υπάρχει και δυνατότητα τρίτης παραμέτρου για να ορίσουμε τι θα διαγραφεί πρώτα)\r\nπαρεμβολή στο 2, 10 α$=\"γεια\"\r\nΑναφορά β$\r\nΑναφορά α$\r\nΚαθαρό α$\r\nα$=β$\r\nκαταχώρηση 2,10 α$=\"γεια\"\r\nΑναφορά β$\r\nΑναφορά α$\r\nΚαθαρό α$\r\nα$=β$\r\nκαταχώρηση 2 α$=\"γεια\"   \\\\ αλλάζει την παράγραφο με την εισαφωγή του \"γεια\"\r\nΑναφορά β$\r\nΑναφορά α$\r\n\r\n
EN:KEYPRESS(\r\nΗ συνάρτηση Πατημένο(αριθμός) παίρνει τον αριθμό πλήκτρου (σε πληκτρολόγιο και ποντίκι) και ελέγχει αν είναι πατημένο, μόνο όταν το παράθυρο του περιβάλλοντος της Μ2000 είναι στο προσκήνιο (δηλαδή όταν δουλεύουμε σε αυτό).\r\n\r\nΑ=1\r\nΕπανέλαβε {\r\n      Τύπωσε Α\r\n      Α++\r\n} Μέχρι Πατημένο(1)  \\\\ 1 είναι το αριστερό πλήκτρο του ποντικιού\r\n\r\nΔεν υπάρχει εδώ ενδιάμεση μνήμη να κρατάει τα πατήματα στη σειρά που πατήθηξαν, αλλά άμεσος έλεγχος.\r\nΕδώ υπάρχουν οι αριθμοί των πλήκτρων (λέγονται virtual keys)\r\nhttps://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx\r\n\r\n\r\n
EN:WIDTH\r\nΠΑΧΟΣ παχος [, επιλογή τύπου γραμμής] {\r\nεντολές\r\n}\r\n\r\nΌταν έχουμε GDI+ τότε οι τύποι γραμμής από 2 έως 5 λειτουργούν για κάθε πάχος. Στο GDI λειτουργούν μόνο με πάχος 1 pixel\r\nΜέσα στις αγκύλες οι εντολές γραφικών χρησιμοποιούν το επιλεγμένο πάχος γραμμής σε pixels.\r\nΔείτε στο παρακάτω παράδειγμα φωλιασμένες εντολές τύπου ΠΑΧΟΣ\r\n\r\nτμημα πα {\r\nπαχος 2 {\r\nθεση 1000,1000\r\nχαραξε 1000,1000\r\nπαχος 5 {\r\nθεση 3000,3000\r\nχαραξε 0,1000\r\n}\r\nθεση 3000,1000\r\nχαραξε 1000,-1000\r\n}\r\nθεση 4000,4000\r\nχαραξε 0,1000\r\n}\r\n\r\n\r\n\r\n\r\n
EN:FIELD\r\nΑ$=\"ΓΙΩΡΓΟΣ\"\r\nΠΕΔΙΟ 10,10,20 ΩΣ Α$\r\nΤΥΠΩΣΕ ΠΕΔΙΟ, Α$\r\n\r\nΣημειώστε ότι το πλήκτρο Insert αλλάζει τον τρόπο παρεμβολής, τον κάνει να \"πατάει\" ή όχι τα γράμματα προς τα δεξιά. Επίσης με τα άνω και κάτω βελάκια μπορούμε να τερματίσουμε την εισαγωγή. Το αποτέλεσμα του τερματισμού, εκτός από την καταγραφή στην μεταβλητή που δίνουμε είναι και η καταγραφή της αιτίας τερματισμού στην εσωτερική μεταβλητή ΠΕΔΙΟ.\r\nΑν μας δώσει -1 σημαίνει έξοδος με το άνω βελάκι, 1 έξοδος με το κάτω βελάκι ή το Enter, 99 έξοδος με το Esc.\r\nΑν θέλουμε δίνουμε την εντολή ΠΕΔΙΟ ΝΕΟ και σβήνουμε το αποτέλεσμα της μεταβλητής ΠΕΔΙΟ. Μεταξύ της εντολής και του ελέγχου της μεταβλητής μπορούμε να κάνουμε έλεγχο του όποιου αποτελέσματος και να αλλάξουμε την κατάσταση.\r\nΈτσι ενώ κανονικά δίνει -1 (πάνω), 1 (κάτω) και 99 το  Esc (άκυρο από απόφαση του χρήστη) με την ΠΕΔΙΟ ΝΕΟ δίνουμε τιμή στην ΠΕΔΙΟ το  0 που σημαίνει \"άκυρο από έλεγχο\"\r\n\r\nΠΕΔΙΟ ΣΥΝΘΗΜΑ 1,1, 10 ΩΣ ΣΥΝΘΗΜΑΤΙΚΟ$\r\n\r\n\r\nΑν ζητήσουμε πεδίο από τμήμα έξω από την οθόνη, ή δεν φθάνει ο χώρος για να πάρει η γλώσσα ένα πεδίο, τότε ανοίγει παράθυρο για εισαγωγή τιμής όπως το παράδειγμα παρακάτω:\r\n(τότε δεν δουλεύει το PASSWORD, για τα PASSWORD καλύτερα να ετοιμάζουμε ΦΟΡΜΑ)\r\nΑ$=Πεδιο$(\"1213\", 10)\r\nΠεδιο Πλατος+10, 1,10 Ως Α$\r\nΤυπωσε @(0,11); Α$\r\n\r\n\r\nΝέοι αριθμοί για έξοδο:\r\n-20 Home\r\n20 End\r\n-10 pageup\r\n10 pagedown\r\n1 Tab\r\n-1 Shift Tab\r\n\r\n
EN:FIELD$(\r\n\r\nα$=Πεδιο$(\"Περιεχόμενο κείμενο\", 40)\r\nΔέχεται δυο ορίσματα ένα αλφαριθμητικό και έναν αριθμό. Εξάγει πάντα ένα αλφαριθμητικό με μήκος όσο ο αριθμός που δώσαμε. Αν το αλφαριθμητικό έχει μήκος μικρότερο από αυτόν τον αριθμό προσθέτονται διαστήματα δεξιά. Αν έχει μεγαλύτερο τότε αποκόπτονται οι πλεονάζοντες χαρακτήρες.\r\n\r\n\r\n
EN:FIELD_as variable\r\nΔες εντολή ΠΕΔΙΟ\r\n\r\nΗ μεταβλητή μόνο ανάγνωσης ΠΕΔΙΟ γυρνάει την κατάσταση μιας εισαγωγής πεδίου.\r\nΈτσι μπορούμε να ξέρουμε αν ο χρήστης έχει πατήσει ESC ή βελάκια για να πάει στο επόμενο πεδίο\r\n1 προηγούμενο (άνω βέλος)\r\n-1 επόμενο (κάτω βέλος, πλήκτρο enter, πλήκτρο TAB)\r\n99 ακύρωση (ESC)\r\n-20 Home\r\n20 End\r\n-10 pageup\r\n10 pagedown\r\n1 Tab\r\n-1 Shift Tab\r\n
EN:LCASE$(\r\n1. Δέχεται σαν όρισμα ένα αλφαριθμητικό και δίνει το ίδιο αλλά με πεζά γράμματα\r\n2. Δεύτερη παράμετρος προαιρετική το τοπικό. \r\nΔείτε το παράδειγμα. Το 1032 είναι για την Ελλάδα, ενώ το 1033 τα αγγλικά.\r\nΚανονικά η λέξη \"Γιώργος\" έχει 7 χαρακτήρες των 14 συνολικά bytes\r\nτοπικο 1032\r\nα$=γραφη$(\"Γιώργος\")\r\nΤύπωσε χαρ$(α$) ' μετατροπή βάσει του 1032\r\nΤύπωσε Μήκος(α$)=3.5  ' μονάδες word=2 bytes, άρα 3.5*2=7bytes\r\nτοπικό 1032\r\nΤύπωσε Πεζ$(χαρ$(α$), 0) ' δίνει λάθος\r\nτοπικό 1033\r\nΤύπωσε Πεζ$(χαρ$(α$), 1032) ' ΟΚ\r\nτοπικό 1033\r\nΤύπωσε Πεζ$(χαρ$(α$)) ' δίνει λάθος\r\nτοπικό 1032\r\nΤύπωσε Πεζ$(χαρ$(α$))  ' ΟΚ\r\n\r\n\r\n\r\n
EN:PEN\r\nΠΕΝΑ χρωμα\r\nΔίνει το χρώμα των γραμμάτων και των γραμμών\r\nΤΥΠΩΣΕ ΠΕΝΑ \r\nμας δίνει ή ενα αρνητικό νούμερο ή αν υπάρχει αντιστοιχεία ένα θετικό από 0 ως 15.\r\nΜπορούμε να δώσουμε 0,1,2 ... 15 για τα βασικά χρώματα των Windows, όπως και αρνητικές τιμές για τα 16 εκατομμύρια χρώματα που μπορούν να απεικονισθούν (24 bit).\r\nΤΥΠΩΣΕ ΧΡΩΜΑΤΑ\r\nμας δίνει τον αριθμό χρωμάτων της οθόνης.\r\nΤΥΠΩΣΕ ΧΡΩΜΑ(128,0,255)\r\nμας δίνει το χρώμα με κόκκινο 128, πράσινο 0 και μπλε 255\r\nΠΕΝΑ ΧΡΩΜΑ(128,0,255)\r\n\r\nΘΕΣΗ 3000,3000 : ΤΥΠΩΣΕ ΣΗΜΕΙΟ\r\nΜας τυπώνει το χρώμα στην θέση 3000,3000 σε αρνητική τιμή. \r\nτυπωσε -σημειο  ' σε δεδκαδικό σύστημα\r\nτυπωσε β16$(-σημειο,3)  ' σε δεκαεξαδικό με 6 ψηφία, 2 για κάθε byte)\r\n\r\nΔες την εντολή ΕΠΕΛΕΞΕ.ΧΡΩΜΑ η οποία σου δίνει το στάνταρ τρόπο επιλογής χρωμάτων.\r\n\r\n\r\n
EN:PEN_variable\r\nΤυπωσε ΠΕΝΑ\r\nδίνει το χρώμα σε αριθμό. Ο αριθμός είναι αρνητικός αν είναι RGB (δηλαδή γινόμενο των τριών χρωμάτων) ή αν είναι ένα από τα δεσμευμένα από το 1 έως το 15 (το 0 είναι το μαύρο και στις δυο περιπτώσεις)\r\n\r\nΠενα 1\r\nΤυπωσε Πενα\r\n                  1\r\nΠενα χρωμα(255,250,255)\r\nΤυπωσε Πενα\r\n -16775935    \r\n\r\n
EN:ABOUT\r\n1) Παράθυρο βοήθειας\r\nΠΕΡΙ τιτλος$, περιγραφη$\r\n2)\r\nΠΕΡΙ τιτλος, πλατος_σε_twips, περιγραφη$\r\n3)\r\nΠΕΡΙ τιτλος, πλατος_σε_twips, υψος_σε_twips, περιγραφη$\r\n4)\r\n ΠΕΡΙ\r\n Κλείνει το παράθυρο (το οποίο κλείνει και με δεξί κλικ στο ποντίκι)\r\nΜπορούμε να μετακινήσουμε το παράθυρο με το αριστερό πλήκτρο του ποντικιού πατημένο.\r\n\r\nΑυτή η εντολή χρησιμοποιείται για να προκαλέσουμε την προσοχή του χρήστη σε ένα ιδιαίτερο μήνυμα που περιγράφει κάποιον χειρισμό.\r\n\r\nΜπορούμε να έχουμε βοήθεια και με το control F1\r\n{}\r\n5)\r\nΠΕΡΙ ! τιτλος, πλατος_σε_twips, υψος_σε_twips, περιγραφη$\r\n  Δεν θα ανοίξει αμέσως η φόρμα αλλά όταν πατήσουμε control+F1\r\n6)\r\nΠΕΡΙ ! \"\"\r\n Σβήνουμε την βοήθεια\r\n7) ΠΕΡΙ ΔΕΙΞΕ \"κάτι\"  ή Περί Δείξε αν έχει προετοιμαστεί η φόρμα βοήθειας.\r\nΜε την συνάρτηση Περί Κάλεσε {} φτιάχνουμε μια Επίλεξε Με Περί$ ....Τέλος Επιλογής, όπου σε κάθε Με \"θέμα\" ακολουθεί μια Περί με τίτλο και Περιγραφή, όπου στο θέμα υπάρχουν [ ] με θέματα με πολλές λέξεις ή μία, κσι αυτά με κλικ οδηγούνται μέσω πάλι της Περί$ στην συνάρτησης Περί Κάλεσε { } και έτσι έχουμε μια δομή υπερκειμένου με πολλές σελίδες!\r\nΑν το χρησιμοποιήσουμε στη κονσόλα, με εντολές εκτός στοιχείων ελέγχων πχ στην Εισαγωγή, θα προετοιμάσουμε τη σελίδα που θέλουμε με την Περί ! ....\r\nΑν το χρησιμοποιήσουμε σε φόρμα (και η φόρμα και τα στοιχεία ελέγχου έχουν το γεγονός About),  μόλις δώσουμε το Ctrl+F1 θα κληθεί το γεγονός About και αν θέλουμε βάζουμε μια Περί όπως τα 1 έως 4, ή έχουμε δώσει πιο πριν την Περί Κάλεσε { } και απλά επιλέγουμε ένα από τα θέματα με την Περί Δείξε \"θέμα\". Ο κώδικας της Περί Κάλεσε αποθηκεύεται ξεχωριστά και ισχύει μέχρι την επόμενη αλλαγή, με νέα Περί Κάλεσε, ή με την καθαρίζουμε με την Περί ! \"\". Αν είμαστε στην κονσόλα, δηλαδή δεν τρέχει κάποιο τμήμα, με την εντολή Βοήθεια, βγάζουμε εκτός την συνάρτηση αυτή και βλέπουμε τη βοήθεια της Μ2000. Το ίδιο συμβαίνει αν ανοίξουμε το διορθωτή για τμήμα, θα γυρίσει η βοήθεια σε αυτήν του διερμηνευτή για τις εντολές του, και γενικότερα τα αναγνωριστικά του.\r\n\r\n\r\n\r\n
EN:ABOUT$\r\nΑ$=ΠΕΡΙ$\r\nδιαβάζουμε την επιλογή από την φόρμα βοήθειας που ανήγει η εφαρμογή μας με την εντολή ΠΕΡΙ\r\nΣτην βοήθεια για την εφαρμογή μας που φτιάχνουμε με την ΠΕΡΙ μπορούμε να βάλουμε λέξεις σε τετράγωνε αγκύλες [ ]\r\nΑυτές οι λέξεις οδηγούνται σε μια ρουτίνα που έχουμε φορτώσει στο σύστημα με την ΠΕΡΙ ΚΑΛΕΣΕ\r\n\r\nΠΕΡΙ ! \"ΤΙΤΛΟΣ: ΕΚΕΙΝΟ\", 8000,6000, {Βοήθεια προγράμματος....\r\n                  ....[ΑΥΤΟ], [ΕΚΕΙΝΟ], [γράψε εδώ]\r\n                  }\r\nΠΕΡΙ ΚΑΛΕΣΕ {\r\nΕΠΙΛΕΞΕ ΜΕ ΠΕΡΙ$ \r\nΜΕ \"ΑΥΤΟ\"\r\n      ΠΕΡΙ \"ΤΙΤΛΟΣ: ΑΥΤΟ\", 8000,6000, \"ΔΕΣ [ΑΥΤΟ] ΚΑΙ [ΕΚΕΙΝΟ]\"\r\nΜΕ \"ΕΚΕΙΝΟ\"\r\n      {\r\n            ΠΕΡΙ \"ΤΙΤΛΟΣ: ΕΚΕΙΝΟ\", 8000,6000, {Κείμενο....\r\n                                          .....άλλη γραμμή......................\r\n                                          ....και άλλη.....\r\n                                          γύρνα σε [ΑΥΤΟ] η τράβα στο [ΑΛΛΟ]\r\n                                          }\r\n      }\r\nΑΛΛΙΩΣ\r\n      ΠΕΡΙ \"ΤΙΤΛΟΣ: ΑΛΛΟ\", 8000,6000, \"ΔΕΣ [ΑΥΤΟ] ΚΑΙ [ΕΚΕΙΝΟ]\"\r\nΤΕΛΟΣ ΕΠΙΛΟΓΗΣ\r\n}\r\n\\* ενώ η εισαγωγή περιμένει να γράψεις πάτα CTRL+F1\r\n\\* θα ανοίξει η βοήθεια και μπορείς να πλογηθείς σε αυτήν\r\nΕΙΣΑΓΩΓΗ \"Ονομα:\", ν$\r\n\\*  μπορούμε με μια σκέτη ΠΕΡΙ να απενεργοποιήσουμε τη βοήθεια\r\n\r\n
EN:BACKGROUND\r\nΜπορούμε να γράψουμε και να σχεδιάσουμε στο περιθώριο (πλαίσιο πίσω από την ΟΘΟΝΗ).\r\nΤο περιθώριο είναι η φόρμα που κρατάει όλα τα άλλα επίπεδα  και λειτουργεί και αυτό ως επίπεδο, δηλαδή με την εντολή ΠΑΡΑΘΥΡΟ μπορεί να πάρει συγκεκριμένο πλάτος και ύψος και μέγεθος γραμμάτων, ενώ μπορούμε να χρησιμοποιήσουμε και την ΦΟΡΜΑ για να ορίσουμε ανάλυση οθόνης σε χαρακτήρες ώστε να υπολογιστούν αυτόματα το μέγεθος και οι διαστάσεις του περιθωρίου.\r\nΤο περιθώριο μπορεί να κοπεί από τη ΦΟΡΜΑ ή μπορεί να ξαναμεγαλώσει με αυτήν.  Επίσης μπορεί να έχει αντίγρφο της εικόνας της επιφάνειας εργασίας με την εντολή ΕΠΙΦΑΝΕΙΑ \r\nΜπορούμε να γράψουμε και να σχεδιάσουμε στο περιθώριο (πλαίσιο πίσω από την ΟΘΟΝΗ).\r\n1)\r\nΠΕΡΙΘΩΡΙΟ {\r\n      φοντο 1,5\r\n}\r\n\r\n2) Μπορούμε να ορίσουμε το μέγεθος γραμμάτων εδώ 20\r\nΠΕΡΙΘΩΡΙΟ 20 {\r\n      φοντο 1,5\r\n}\r\n\r\n
EN:BACK\r\nΜπορούμε να γράψουμε και να σχεδιάσουμε στο περιθώριο (πλαίσιο πίσω από την ΟΘΟΝΗ).\r\nΤο περιθώριο είναι η φόρμα που κρατάει όλα τα άλλα επίπεδα  και λειτουργεί και αυτό ως επίπεδο, δηλαδή με την εντολή ΠΑΡΑΘΥΡΟ μπορεί να πάρει συγκεκριμένο πλάτος και ύψος και μέγεθος γραμμάτων, ενώ μπορούμε να χρησιμοποιήσουμε και την ΦΟΡΜΑ για να ορίσουμε ανάλυση οθόνης σε χαρακτήρες ώστε να υπολογιστούν αυτόματα το μέγεθος και οι διαστάσεις του περιθωρίου.\r\nΤο περιθώριο μπορεί να κοπεί από τη ΦΟΡΜΑ ή μπορεί να ξαναμεγαλώσει με αυτήν.  Επίσης μπορεί να έχει αντίγρφο της εικόνας της επιφάνειας εργασίας με την εντολή ΕΠΙΦΑΝΕΙΑ \r\n1)\r\nΠΕΡΙΘΩΡΙΟ {\r\n      φοντο 1,5\r\n}\r\n\r\n2) Μπορούμε να ορίσουμε το μέγεθος γραμμάτων εδώ 20\r\nΠΕΡΙΘΩΡΙΟ 20 {\r\n      φοντο 1,5\r\n}\r\n\r\n\r\n
EN:DROP\r\nΠΕΤΑ 4\r\nαν υπάρχουν 4 στοιχεία στο σωρό τα πετάει αλλιώς βγαίνει λάθος\r\nΔες ΜΕΓΕΘΟΣ.ΣΩΡΟΥ (μεταβλητή που δίνει τον αριθμό των στοιχείων στο σωρό)\r\n\r\nΠΕΤΑ 0 \r\nδεν βγαίνει λάθος, και δεν κάνει τίποτα.\r\nΑν δώσουμε μικρότερο από το  0 τότε βγαίνει λάθος\r\n\r\nΜπορούμε με την ΠΕΤΑ, το ΜΕΓΕΘΟΣ.ΣΩΡΟΥ και τα ΤΙΜΗΣΩΡΟΥ() και ΤΙΜΗΣΩΡΟΥ$() να φτιάξουμε πλαίσια παραμέτρων στο σωρό. Έτσι με αυτόν τον τρόπο κρατάμε τιμές που δεν αποδίδουμε σε μεταβλητές και καλούμε τμήματα χωρίς να πειράζουμε το σωρό. Απλά χρησιμοποιούμε μια μεταβλητή Σ για να μαρκάρουμε το μέγεθος του σωρού στην είσοδο ενός τμήματος και στο τέλος του να βάλουμε μια ΠΕΤΑ ΜΕΓΕΘΟΣ.ΣΩΡΟΥ-Σ, για να διορθώσουμε το σωρό σε αυτόν που ήταν όταν μπήκαμε στο τμήμα!\r\n\r\n\r\n
EN:PI\r\n? πι\r\n            3.1415926535897932384626433832\r\n            Γενική πι=3.14159~   ' αναπρογραμματισμός\r\n\r\n
EN:DIM\r\nΕντολή που ορίζει πίνακες με εώς 10 διαστάσεις, αριθμητικούς και αλφαριθμητικούς.\r\n\r\nΝέες προσθήκες από την έκδοση 8\r\nΕπιστροφή πίνακα από συνάρτηση:\r\n\r\nΣυναρτηση ΕναςΠινακας {\r\n      Διαβασε τοσα\r\n      Πινακας α(τοσα) : για ι=0 εως τοσα-1 {α(ι)=ι+1}\r\n      =α()\r\n}\r\nΠινακας κ()\r\nκ()=ΕναςΠινακας(10)\r\nΓια ι=0 εως 9 {τυπωσε κ(ι)}\r\n\r\nΟλοι οι πίνακες σε κάθε διάσταση  με όρισμα Ν ξεκινούν από το 0 και έχουν Ν στοιχεία ή άνω όριο Ν-1\r\n1) Τοπικοί πίνακες\r\n      ΠΙΝΑΚΑΣ Α(20)=5, Α$(1000) , Α%(20000)=1      \r\n      Πινακας Α() ' χωρίς στοιχεία\r\n      Πίνακας Βάση 1, Α(),Β(10)  ' με βάση το 1  (παίρνει τιμές 1 ή 0)  \r\n      \\\\ ο Β() έχει στοιχεία από το 1 έως το 10\r\n      Τύπωσε διάσταση(Β(),0)  ' μας δίνει την βάση\r\n      \\\\ εδώ αλλάζουμε βάση\r\n      Πίνακας Βάση 0 στο Α(), Β()  ' αλλαγή βάσης στο Α()\r\n2) Σφαιρικός - Καθολικός πίνακας  (αλλαγή από έκδοση 8)\r\n      ΓΕΝΙΚΟ Κ(300)=20\r\n3) Τοπικο Κ(20) - τοπικός πίνακας (όλοι τοπικοί είναι εξ ορισμού) αλλά δες την ΓΙΑ ΑΥΤΟ { } \r\n4) Διαγραφή στοιχείων πίνακα (το όνομα παραμένει, αλλά όλα τα στοιχεία σβήνουν, και τυχόν αντικείμενα τύπου ΕΓΓΡΑΦΟ)\r\n      ΠΙΝΑΚΑΣ Α(0) \r\n5) Αλλλαγή διαστάσεων με λιγότερα, ίδια ή περισσότερα στοιχεία, χωρίς να αλλαχθούν όσα απομείνουν.\r\n      ΠΙΝΑΚΑΣ Α(2,2)=5        ' 2Χ2= 4 στοιχεία  και βάζουμε αρχική τιμή το 5\r\n      ΠΙΝΑΚΑΣ Α(2)               ' διαγράφουμε τα τελευταία 2\r\n      ΤΥΠΩΣΕ Α(1)                ' 5\r\n      ΠΙΝΑΚΑΣ Α(2,2)            ' προσθέτουμε  2 στοιχεία με 0 τιμή\r\n      ΤΥΠΩΣΕ Α(0,1)            '5\r\n      ΤΥΠΩΣΕ Α(1,0)            '0      \r\n      Α(1,0)=5,6                     ' βάζουμε στο Α(1,0) το 5 και στο επόμενο στη μνήμη που είναι εδώ το Α(0,1) το 6 \r\n      ΤΥΠΩΣΕ Α(1,1)            '5\r\n      ΠΙΝΑΚΑΣ Α(4)              ' Τώρα έχουμε μονοδιάστατο πίνακα με τα ίδια στοιχεία\r\n      ΤΥΠΩΣΕ Α(3)               ' 6  \r\n      Παρατηρήσεις: Μπορούμε να προσθέτουμε στοιχεία αυξάνοντας μόνο την πρώτη διάσταση αν δεν θέλουμε να μετακινηθούν τα υπάρχοντα στοιχεία σε άλλες θέσεις.\r\n      \r\n 6) Μόνο για αλφαριθμητικούς πίνακες απόδοση αριθμητικών τιμών (στην έκδοση 8 υπάρχει και το ΣΤΟΚ)\r\n      ΓΡ=1\r\n      ΠΙΝΑΚΑΣ Α$(ΓΡ,5)   ' 1 γραμμή με 5 πεδία\r\n      Α$(ΓΡ-1,0) := \"ΓΙΩΡΓΟΣ\", 100, 20, \"ΗΠΕΙΡΟΣ\", 12.5\r\n      ΓΡ++\r\n      ΠΙΝΑΚΑΣ Α$(ΓΡ,5)   ' δίνουμε μια γραμμή ακόμα\r\n      Α$(ΓΡ-1,0) := \"ΑΛΕΞΑΝΔΡΟΣ\", 101, 120, \"ΜΑΚΕΔΟΝΙΑ\", 14.5\r\n      ΒΑΛΕ &Α$()  :  ΔΙΑΒΑΣΕ &Α()   ' φτιάχνουμε μια αναφορά πίνακα που δίνει όμως αριθμητικό αποτέλεσμα\r\n      Χ=0  ' επιλέγουμε τη πρώτη γραμμή\r\n      ΤΥΠΩΣΕ Α$(Χ,0),Α(Χ,1),Α(Χ,2),Α$(Χ,3),Α(Χ,4)\r\n      Παρατηρήσεις: Μια αριθμητική τιμή θα διαβαστεί και σαν αλφαριθμητική. Το ίδιο και μια αλφαριθμητική θα διαβαστεί ως αριθμητική στον αριθμητικό πίνακα που έχει αναφορά στον αλφαριθμητικό.\r\n  7)  Μετατροπή ενός στοιχείου αλφαριθμητικού πίνακα σε ΕΓΓΡΑΦΟ\r\n       ΠΙΝΑΚΑΣ Α$(10)\r\n       ΕΓΓΡΑΦΟ Α$(4)  = {Πρώτη γραμμή\r\n                                          Δεύτερη με αλλαγή γραμμής\r\n                                          }\r\n      ΑΝΑΦΟΡΑ Α$(4)   \r\n      τα έγγραφα μπορούν να χρησιμοποιηθούν όπως και τα αλφαριθμητικά αλλά βρίσκονται στη μνήμη χωρισμένα σε παραγράγους. Μπορούν να χρησιμοποιηθούν ως δυναμικά αναπτυσσόμενες λίστες.\r\n    8) Σκίαση πίνακα\r\n      Πίνακας Νέο Α(10) \r\n        Εδώ θα σκιάσουμε τον Α() αν υπάρχει - αυτό σε μια Ρουτίνα ή σε Για  { } όπου όλα τα νέα (μεταβλητές και τμήματα και συναρτήσεις) είναι προσωρινά.                                      \r\n                                                                                                                \r\nΗ εντολή ΠΙΝΑΚΑΣ φτιάχνει πίνακες αριθμητικούς, αλφαριθμητικούς και ακέραιους ενώ μπορεί και να τους γεμίσει με μια τιμή.\r\nΜε το πέρας του τμήματος που δημιούργησε τους πίνακες, παύουν οι πίνακες να υπάρχουν.\r\nΑπό την έκδοση 6.1 οι πίνακες μπορούν να ξαναοριστούν χωρίς να σβήσουν τα περιεχόμενα τους (αν θέλουμε τα σβήνουμε με το =0 ή =\"\"). Μπορούμε να μεγαλώσουμε ή να μικρύνουμε τον πίνακα ή να αλλάξουμε διάσταση!\r\nΔηλαδή μπορούμε τον Α(2,2)  με τιμές από (0..1, 0..1) να τον κάνουμε Α(4)  (0..3)\r\n\r\n\r\nMπορούμε να περνάμε με αναφορά τιμής πίνακες σε συναρτήσεις και τμήματα όπου εκεί μπορούν να μεταβληθούν οι τιμές των στοιχείων τους και στην επιστροφή να φανεί άμεσα! Δείτε την ΒΑΛΕ\r\nΠΙΝΑΚΑΣ Α(100)\r\nΑ(24)=1,2,3\r\nΤο στοιχείο 26 θα έχει τιμή 3\r\nΕιδικά για τους πίνακες αλφαριθμητικών υπάρχει το \":=\" ως χειριστής όπου διαβάζει νούμερα και αλφαριθμητικά ταυτόχρονα.\r\nΠΙΝΑΚΑΣ Α$(100)\r\nΑ$(10):=\"\",34>Α, Β, ΜΗΚΟΣ(\"ΑΛΦΑ\")\r\nτα στοιχεία 11 και 12 θα πάρουν αριθμητικές τιμές ως αλφαριθμητικά.\r\nΕπίσης μπορούμε να βάλουμε αλφαριθμητικά με αγκύλες..(αλλά δεν μπορούμε να τις βάλουμε σε συνθήκες)\r\nπ.χ. μια διατύπωση συνθήκης είναι αυτή \"ΑΛΦΑ\">Β$ ΚΑΙ Κ<3*Λ  η οποία επιστρέφει τιμή 0 ή -1\r\n\r\n\r\nγια ταξινόμηση μπορεί να χρησιμοποιηθεί μια \"άμεση\" βάση δεδομένων!\r\nΕδώ η ιδιομορφία δεν είναι στη χρήση της βάσης αλλά στο ότι έχουμε καθορισμένο μέγεθος πεδίου.\r\nπ.χ.\r\n      βαλε \"αααααα\", \"λλλλλλ\", \"βββββββ\"\r\n      βαση \"τεστ\"  'σβήνει αν υπάρχει και δημιουργεί νέα βάση\r\n      αρχειο \"τεστ\",\"π1\",\"ονομα\",κειμενο, 20\r\n      ταξη \"τεστ\", \"π1\",\"ονομα\", αυξουσα\r\n      για ι=1 εως 3 {\r\n            προσθηκη \"τεστ\",\"π1\", γραμμα$\r\n      }\r\n      για ι=1 εως 3 {\r\n            ανακτηση \"τεστ\",\"π1\",ι,\"\",\"\"\r\n            διαβασε ποσα, ονομα$\r\n            τυπωσε ονομα$\r\n      }\r\n      αφαιρεση \"τεστ\"\r\n      \r\nΠροσθήκη 8.2 αναθεώρηση 16\r\nΠίνακας Βάση 1, Α(10)\r\nφτιάχνει άμεσα ένα πίνακα από 1 έως 10, και δεν αλλάζει την τρέχουσα βάση (από πιο νούμερο δηλαδή ξεκινάει ο πίνακας), μπορεί να είναι 0 ή 1.\r\nΜετά τη λέξη βάση μπορούμε να βάλουμε το 1 ή το 0 αλλά όχι αριθμητική έκφραση π.χ. 3-2\r\nΔες την εντολή Βάση (κάνει και άλλες δουλειές, με τις βάσεις δεδομένων)\r\nΌταν αντιγράφουμε έναν πίνακα σε έναν άλλο, πχ Α()=Β()  πρέπει  να έχουμε ορίσει τον Α() ακόμα και χωρίς στοιχεία. Η βάση του Α() χάνεται και παίρνει αυτή που έχει ο Β().\r\nΜπορούμε να βάλουμε πίνακα σε θέση πίνακα\r\n\\\\ Παράδειγμα:\r\nΠίνακας Α(3), Β(10)=3\r\nΑ(0)=Β()\r\nΑ(0)(9)=100\r\nΤύπωσε Α(0)(9)/5\r\nΓια Αυτό {\r\n      Πίνακας Ν()\r\n      Ν()=Α(0)\r\n      Πίνακας Ν(2,5)\r\n      Α(0)=Ν()\r\n}\r\nΤύπωσε Α(0)(0,4), Α(0)(1,4)\r\n\r\n\r\nΓέμισμα στοιχείων πίνακα με παραγωγή τιμών από Λάμδα συνάρτηση:\r\nΚ=Λάμδα Ν=1 -> {=Ν:Ν++}\r\nΠίνακας Μ(3,4)<<Κ()\r\nΤύπωσε Μ()\r\n \r\n 
EN:ARRAY$(\r\nΠίνακας Α$(2,5,2)=\"γεια\"\r\nΤύπωσε ΠΙΝΑΚΑΣ$(\"Α$\",1,4,1)\r\nΤύπωσε Α$(1,4,1)\r\n\r\nα=(1,2,3,\"΄λέξη\")\r\nα+=20\r\nΤύπωσε α\r\nΤύπωσε Πίνακας$(α, 3)\r\n\r\n
EN:ARRAY(\r\nΤυπωσε Πινακας(\"α\",1,3)\r\nείναι ισοδύναμο με \r\nΤυπωσε α(1,3)\r\n\r\nΥπάρχει αντίστοιχη ΠΙΝΑΚΑΣ$(\"α$\",1,2)\r\nγια αλφαριθμητικά\r\n\r\nπινακας α(10)\r\nσυναρτηση α {\r\nδιαβασε α\r\n=α*2\r\n}\r\nα(5)=3\r\nτυπωσε α(5), πινακας(\"α\",5)\r\n\r\n\\\\Θα τυπώσει 3 3  γιατί οι πίνακες προηγούνται.\r\nΤύπωσε α(* 5)  \\\\ θα τυπώσει 10 γιατί το * λέει ότι είναι  συνάρτηση \r\n\r\nΧρησιμοποιείται και με δείκτη σε πίνακα\r\nΑ=(1,2,3,\"Κείμενο\",5)\r\nΤύπωσε Πίνακας(Α, 0)  ' θα δώσει το 1\r\nΕπιστροφή Α, 0:=1000, 4:=\"Κείμενο Β\"\r\nΤύπωσε Α, Πίνακας(Α,0), Πίνακας$(Α,4)\r\nΠροσθήκη Α, (6,7,8,9)\r\nΤύπωσε Πίνακας(Α, 8)\r\nΤύπωσε Μήκος(Α)\r\nΈνωσε Α στο Α$()\r\nΤύπωσε Α$(4)\r\nΤύπωσε Πίνακας(Α$(), 1)\r\n\r\n
EN:BACKWARD(\r\nΕγγραφο α$={αααααααα\r\nββββββββββ\r\nγγγγγγγγγγ\r\n}\r\nμ=Παράγραφος(α$, Εγγράφου.παρ(α$)) \r\nΑν Πίσω(α$,μ) Τότε {\r\n      Ενώ μ {\r\n            Τύπωσε Παράγραφος$(α$,(μ))\r\n      }\r\n}\r\n\r\n\r\n
EN:ITALIC\r\nΠΛΑΓΙΑ : ΤΥΠΩΣΕ \"ΑΥΤΑ ΕΙΝΑΙ ΓΡΑΜΜΑΤΑ\": ΠΛΑΓΙΑ\r\nκάθε φορά που χρησιμοποιούμε την εντολή ΠΛΑΓΙΑ αυτή αλλάζει τα γράμματα από όρθια σε πλάγια και πάει λέγοντας...\r\nΑΛΛΟΣ ΤΡΟΠΟΣ\r\nΠΛΑΓΙΑ 1  - κάνει τα γράμματα πλάγια\r\nΠΛΑΓΙΑ 0 - κάνει τα γράμματα ορθά\r\n\r\n
EN:FRAME\r\nΗ εντολή αυτή μας δίνει έναν τρόπο για να σχεδιάσουμε πλαίσια με συντεταγμένες χαρακτήρων.\r\nΗ πάνω αριστερή γωνία του πλαισίου θα είναι αυτή του δρομέα πριν την εκτέλεση της εντολής. \r\n1) Πλαίσια με γραμμή περιγράμματος και φόντο\r\nΠΛΑΙΣΙΟ πλάτος, ύψος, χρωμα_φοντου, χρωμα_πλαισιου.\r\n  Το πλάτος και το ύψος σε χαρακτήρες.\r\n  Ο δρομέας παραμένει στην θέση του.\r\n  Αν δεν δώσουμε χρώμα πλαισίου τότε αυτό θα είναι το χρώμα πένας.\r\n2) Πλαίσια σε στυλ εντολής ΒΑΨΕ@  με απόλυτες συντεταγμένες\r\nΠΛΑΙΣΙΟ @  απόλυτηθεσηΧ, απόλυτηθεσηΥ, τυπος, παραμετρος1, παραμετρος2\r\n3) Πλαίσια σε στυλ εντολής ΒΑΨΕ@  με σχετικές συντεταγμένες\r\nΠΛΑΙΣΙΟ @  (πλάτος), (ύψος), τυπος, παραμετρος1, παραμετρος2\r\n  Τα τρία τελευταία στοιχεία είναι ίδια με αυτά της ΒΑΨΕ @ (η διαφορά των δύο εντολών είναι ότι η ΒΑΨΕ@ λογαριάζει τις διαστάσεις σε twips και κάνει χρήση του δρομέα γραφικών)\r\n  \r\n
EN:WIDTH_as variable\r\nΜας δίνει το πλάτος σε χαρακτήρες (ανάλογα της ΟΘΟΝΗΣ, του ΠΕΡΙΘΩΡΙΟΥ, της σελίδας του ΕΚΤΥΠΩΤΗ)\r\n
EN:TWIPSX\r\nΑν δώσει 15 (συνήθως αυτό είναι) σημαίνει ότι 15 twips είναι ένα εικονοστοιχείο,  άρα στα 1440 twips (μια ιντσα) έχουμε 1440/15 εικονοστοιχεία, που ισούται με 96 dpi.\r\nΠου μας βοηθάει αυτή η γνώση; Όταν τυπώνουμε γραφικά, για να διευκολύνουμε το πρόγραμμα, να μην χρονοτριβεί, τυπώνουμε σε θέσεις σημείων, δίνοντας πολλαπλάσια του πλάτους σημείου σε κάθε περίπτωση που αναφερόμαστε σε συντεταγμένες πάνω στην οθόνη.\r\nΠροσοχή: Πάντα γυρίζει τo πλάτος σημείου της οθόνης και όχι του εκτυπωτή, ακόμα και αν συμπεριλάβουμε την εντολή σε δομή ΕΚΤΥΠΩΣΕ  { }\r\nΣτους εκτυπωτές τα dpi κατά Χ και κατά Υ μπορεί να διαφέρουν, που σημαίνει με απλά λόγια ότι οι εκτυπωτές κατά κανόνα δεν έχουν τετράγωνα εικονοστοιχεία αλλά παραλληλόγραμμα. Εκεί επειδή χρησιμοποιούμε twips..και επειδή το πλάτος εικονοστοιχείου είναι μικρό, πλησιάζει το 1...δεν μας ενοχλεί  η απόκριση ως προς τον χρόνο ενός προγράμματος (στο φινάλε και ο εκτυπωτής θα αργήσει να δώσει το ζητούμενο, την εκτύπωση, πράγμα που δεν συμβαίνει αυτό στην οθόνη).\r\n\r\nΔείτε και ΥΨΟΣ.ΣΗΜΕΙΟΥ ή TWIPSY\r\n\r\n
EN:PLATFORM$\r\n? πλατφορμα$\r\nεπιστρέφει την περιγραφή της πλατφόρμας (π.χ. WINDOWS NT)\r\n\r\n
EN:KEYBOARD\r\nΠληκτρολογιο !\r\nανοίγει ένα πληκτρολόγιο οθόνης\r\nΠληκτρολόγιο \"αδσδασδα\" \r\nστέλνει τους χαρακτήρες στο πληκτρολόγιο\r\nΠληκτρολόγιο  65, 66, 67, \"φ\", 255\r\nμπορεί να στέλνει ASCII κώδικα ή χαρακτήρες\r\n\r\nΑυτά που στέλνει τα διαβάζει η ίδια εφαρμογή όταν έρθει η σειρά για ΕΙΣΑΓΩΓΗ ή για ΠΕΔΙΟ\r\nΣτο ΠΕΔΙΟ βάζουμε τιμή πριν την καλέσουμε, οπότε η χρησιμότητα εδώ είναι στην εισαγωγή!\r\n\r\nπληκτρολογιο \"1212\"\r\nεισαγωγη \"Τιμή Χ=\",Χ\r\nτυπωσε \"Χ=\";Χ\r\n\r\n
EN:POLYGON\r\nΗ εντολή πολύγωνο όπως και η καμπύλη έχουν σημεία (θέσεις του δρομέα γραφικών) σχετικές με την ακριβώς προηγούμενη.\r\nΠαράδειγμα\r\nα) ΠΟΛΥΓΩΝΟ 4, 1000,0,0,1000,-1000,0,0,-1000\r\nβ) ΠΟΛΥΓΩΝΟ 4, 1000,0,0,1000,-1000,0,1000,-1000\r\nΟι α και β είναι σχεδόν ίδιες. Η διαφορά θα φανεί αν δώσουμε δυο ή περισσότερες φορές την ίδια εντολή. Στην περίπτωση α όλα τα τετράγωνα γράφονται το ένα πάνω στο άλλο. Στην περίπτωση β το κάθε νέο τετράγωνο γράφεται δίπλα δεξιά.\r\nΔηλαδή το τελευταίο σημείο δηλώνει την θέση που θα μετακινηθεί ο δρομέας, ενώ το σχήμα πάντα κλείνει στην θέση του πρώτου σημείου.\r\n\r\nΥπάρχει και η παραλλαγή με την ΓΩΝΙΑ\r\nΘΕΣΗ 5000,2000\r\nΠΟΛΥΓΩΝΟ 4, ΓΩΝΙΑ ΠΙ/4,3000,-ΠΙ/4,3000,ΠΙ/4,-3000,-ΠΙ/4,-3000\r\n\r\nΠροσέξτε μια διαφορά με την Καμπύλη. Η εντολή ΠΟΛΥΓΩΝΟ θέλει το χρώμα γεμίσματος.\r\nΑν δεν θέλουμε γέμισμα:\r\nΘΕΣΗ 5000,3000\r\nΧΡΩΜΑ { ΠΟΛΥΓΩΝΟ 4, ΓΩΝΙΑ ΠΙ/4,3000,-ΠΙ/4,3000,ΠΙ/4,-3000,-ΠΙ/4,-3000 }\r\n\r\n
EN:GOTO\r\nΑλλαγή ροής (άλμα) προς οποιαδήποτε διεύθυνση, σε ένα αυτοτελές τμήμα (να έχει αγκύλες)\r\n\r\nΠΡΟΣ ετικετα\r\n\r\nκάπου μέσα στο τμήμα και πάντα σε αρχή γραμμής θα μπει η ετικέτα\r\n\r\nετικετα:\r\nή ένας αριθμός (μέχρι πέντε ψηφία και όχι 0 μπροστά)\r\n\r\nπροσέξτε την άνω και κάτω τελεία, μετά από αυτή πρέπει να ακολουθεί αλλαγή γραμμής. Κάθε ετικέτα πρέπει να έχει το πρώτο γράμμα ως γράμμα και όχι αριθμό, όπως οι μεταβλητές.\r\n\r\nΣτο παρακάτω πρόγραμμα χρησιμοποιούμε την ΠΡΟΣ για να επαναλάβουμε ένα τμήμα σε ένα τμήμα!\r\n\r\nΙ=0\r\nΕΠΑΝΑΛΑΒΕ {\r\nΞΑΝΑ:\r\n      Ι=Ι+1\r\n      Α$=ΕΝΚΟΜ$\r\n      ΑΝ Α$=\"\" ΤΟΤΕ ΠΡΟΣ ΞΑΝΑ\r\n      ΑΝ Α$=\" \" ΤΟΤΕ ΕΞΟΔΟΣ\r\n      ΤΥΠΩΣΕ Ι\r\n} ΜΕΧΡΙ Ι=1000\r\n\r\nΜπορούμε να καλέσουμε εδώ την Συνεχεια (στη θεση της ΠΡΟΣ ΞΑΝΑ) και είναι το ίδιο. Αλλά μπορεί να θέλουμε διαφορετικό σημείο εισόδου και εκεί είναι χρήσιμη η ΠΡΟΣ\r\n\r\n\r\nΔες την ΑΠΟ  Μεταβλητη ΠΡΟΣ Ετικετα1, Ετικετα2...\r\n\r\n \r\n\r\n
EN:APPEND.DOC\r\nΠΡΟΣΘΕΣΕ.ΕΓΓΡΑΦΟ ονομα$, τυπος_αρχείου\r\nτύπος αρχείου:\r\n0 για UTF-16LE\r\n1 για UTF-16BE\r\n2 UTF-8 \r\n3 ANSI\r\n\r\nεξ ορισμού είναι Utf-8\r\n\\\\ εδω αν υπάρχει αρχείο name1.txt θα \"πατηθεί\" από νέο αρχείο\r\n\\\\ με ίδιο όνομα αλλά με κενό περιεχόμενο\r\nΈγγραφο αλφα$={Μια μόνο παράγραφος\r\n}\r\nΣώσε.Έγγραφο αλφα$,\"name1.txt\"\r\n\\\\ έστω μια άλλη φορά ή σε άλλο πρόγραμμα:\r\n\\\\ θέλουμε να προσθέσουμε\r\nΈγγραφο βήτα$={Μια άλλη παράγραφος\r\n}\r\nΑν Υπάρχει(\"name1.txt\") τότε {\r\nΠρόσθεσε.Έγγραφο βήτα$,\"name1.txt\"\r\n} αλλιώς {\r\nΣώσε.Έγγραφο βήτα$,\"name1.txt\"\r\n}\r\n\\\\ τώρα διαβάζουμε όλο μαζί\r\nΈγγραφο καππα$\r\nΦόρτωσε.Έγγραφο καππα$, \"name1.txt\"\r\nΑναφορά καππα$\r\n\r\n\r\n\r\n
EN:APPEND\r\n1) Για πίνακες σε βάσεις δεδομένων\r\nΠΡΟΣΘΗΚΗ ονομα_βασης$, ονομα_πινακα$, πεδιο1, πεδιο2$, πεδιο3$,πεδιο4,....\r\n\r\nΠαραδείγματα\r\nΠΡΟΣΘΗΚΗ ΒΑΣ$,\"ΕΓΓΡΑΦΗ\", ΠΡΑΞΕΙΣ, ΓΡΑΦΗ$(ΣΗΜΕΡΑ,\"SHORT DATE\") ,ΚΩΔΙΚΟΣ, ΠΟΣΟ\r\nΠΡΟΣΘΗΚΗ ΒΑΣ$,\"ΟΦΕΙΛΕΤΕΣ\",ΚΩΔ.ΠΕΛ,ΠΡΑΞΕΙΣ,ΤΙΜΗ(ΑΠΟΚ$(ΠΟΣΟ$))\r\n2) Για Καταστάσεις και δείκτες σε πίνακες\r\nα=(1,2,3,4)\r\nΠροσθήκη α, (5,6,7,8), (9,10,11,12)    \\\\ , ....\r\nΚατάσταση β=1,2,3,4:=300,5\r\nΠροσθήκη β, 100:=500, \"Γεια\":=1000, \"οκ\":=\"εντάξει\"\r\nΤύπωσε β$(\"ok\"), β(4)\r\nΤύπωσε β\r\n\r\n
EN:TEMPORARY$\r\nΤΥΠΩΣΕ ΠΡΟΣΩΡΙΝΟ$\r\nC:\\WINDOWS\\TEMP\\\r\n\r\nΜας δίνει τον κατάλογο για προσωρινή αποθήκευση (δεν είναι απαραίτητα αυτός που εμφανίζεται στο παράδειγμα εδώ)\r\nΔες το ΕΝΑΟΝΟΜΑ$\r\n\r\n
EN:CLIPBOARD\r\nΠΡΟΧΕΙΡΟ \"ΑΑΑΑΑΑΑΑ\"\r\nΤΥΠΩΣΕ ΠΡΟΧΕΙΡΟ$\r\n\r\nΗ πρώτη εντολή βάζει στο πρόχειρο το αλφαριθμητικό και η δεύτερη το παίρνει. Θα μπορούσε κανείς να βάλει εδώ ένα αλφαριθμητικό με δομή σωρού. Δες Σωρος\r\nΕπίσης αν βάλουμε αλφαριθμητικό με εικόνα τότε η εντολή στέλνει την εικόνα στο πρόχειρο\r\n\r\nΗ προχειρο$ δεν παίρνει εικόνα\r\nδες την προχειρο.εικονα$\r\n\r\n
EN:CLIPBOARD$\r\nτυπωσε Προχειρο$\r\nδιαβάζουμε από το πρόχειρο ένα αλφαριθμητικό\r\nΜπορούμε να βάλουμε στο πρόχειρο ένα αλφαριθμητικό με την εντολή Προχειρο\r\nΧρησιμοποίησε το Πρόχειρο.Εικόνα$ για να πάρεις εικόνα από το πρόχειρο\r\n\r\n\r\n
EN:CLIPBOARD.IMAGE$\r\nα$=προχειρο.εικονα$\r\nαντιγράφουμε στο αλφαριθμητικό την είκονα από το πρόχειρο, αν υπάρχει.\r\n\r\n\r\n
EN:CAR(\r\nα=((1,2), (3,4), (5, 6))\r\nb=Πρώτο(α)\r\nΤύπωσε Πρώτο(b)  ' 1\r\nΤύπωσε Πρώτο(Πρώτο(α))   ' 1\r\nΤύπωσε Επόμενα(Πρώτο(Επόμενα(Επόμενα(α))))  ' 6\r\n\r\n
EN:PROTOTYPE\r\nΠρωτότυπο {\r\n      Τύπωσε \"ok\"\r\n}  ως Αλφα$\r\nΤύπωσε Μήκος(Αλφα$)\r\nΈνθεση Αλφα$\r\n\r\n
EN:SQRT(\r\nΕπιστρέφει την τετραγωνική ρίζα ενός θετικού αριθμού.\r\n
EN:FLOW CONTROL\r\nΡΟΗ ΠΡΟΓΡΑΜΜΑΤΟΣ\r\nΑΛΛΙΩΣ, ΑΛΛΙΩΣ.ΑΝ, ΑΝ, ΑΝΑΛΥΤΗΣ, ΑΝΑΜΟΝΗ, ΑΠΟ, ΓΙΑ, ΔΕΣ, ΔΙΑΜΕΣΟΥ, ΔΙΕΚΟΨΕ, ΕΝΩ, ΕΞΟΔΟΣ, ΕΠΑΝΑΛΑΒΕ, ΕΠΑΝΕΛΑΒΕ, ΕΠΙΛΕΞΕ, ΚΑΘΕ, ΚΑΛΕΣΕ, ΚΥΚΛΙΚΑ, ΚΥΡΙΟ.ΕΡΓΟ, ΜΕ, ΜΕΡΟΣ, ΜΕΤΑ, ΜΕΧΡΙ, ΞΕΚΙΝΑ, ΠΡΟΣ, ΣΥΝΕΧΙΣΕ, ΣΧΕΔΙΟ.ΝΗΜΑΤΩΝ, ΤΟΤΕ\r\n
EN:SUB\r\nΡΟΥΤΙΝΑ ΑΛΦΑ(Χ)\r\n\\\\ ΕΝΤΟΛΕΣ\r\nΤΕΛΟΣ ΡΟΥΤΙΝΑΣ\r\n\r\nΟι ρουτίνες γράφονται στο τέλος των τμημάτων ή συναρτήσεων. Καλούμε τις ρουτίνες με την ΔΙΑΜΕΣΟΥ. Οι ρουτίνες έχουν καθορισμένες παραμέτρους. Κάθε νέα μεταβλητή εντός της ρουτίνας θα σβηστεί με το πέρας αυτής. Μπορούμε να φύγουμε με την Έξοδος Ρουτίνας. Η Μ2000 χρησιμοποιεί τόνους στα Ελληνικά αλλά στον ορισμό της ρουτίνας η λέξη Ρουτινα δεν πρέπει να έχει τόνο (για λόγους ταχύτητας). Η γλώσσα αναζητεί πάντα από το τέλος τις ρουτίνες. Αν θέλουμε να έχουμε τοπική μεταβλητή μπορούμε με την εντολή Τοπική. Μπορεί μια ρουτίνα να καλέσει τον εαυτό της, μέχρι το ΟΡΙΟ.ΑΝΑΔΡΟΜΗΣ που αρχικά είναι 1000\r\nΌταν βρει την εντολή ΡΟΥΤΙΝΑ ο μεταφραστής καθώς εκτελεί εντολές τότε κάνει έξοδο (δεν συνεχίζει)\r\n\r\nΥ=100\r\nΚ=30    \\\\ θα διαβαστεί στην ρουτίνα γιατί δεν είναι τοπική\r\nΔΙΑΜΕΣΟΥ ΑΛΦΑ(3)\r\nΔΙΑΜΕΣΟΥ ΑΛΦΑ(13)\r\nΔΙΑΜΕΣΟΥ ΑΛΦΑ(5)\r\nΤΥΠΩΣΕ Υ\r\n\r\nΡΟΥΤΙΝΑ ΑΛΦΑ(Χ)\r\n      ΤΟΠΙΚΗ Υ=10\r\n      ΑΝ Χ>10 ΤΟΤΕ ΕΞΟΔΟΣ ΡΟΥΤΙΝΑΣ\r\n      ΤΥΠΩΣΕ Χ*Υ, Κ\r\nΤΕΛΟΣ ΡΟΥΤΙΝΑΣ\r\n\r\n
EN:SETTINGS\r\nΡΥΘΜΙΣΕΙΣ\r\nΑνοίγει μια φόρμα ρυθμίσεων οι οποίες θα λειτουργήσουν άμεσα (αλλά θα σβήσει η οθόνη και θα τυπωθεί το αρχικό μήνυμα - τρεις γραμμές πάνω αριστερά) και θα φτιαχτεί και χωριστή οθόνη ολίσθησης\r\n\r\n\r\n
EN:ASK$(\r\nΤΥΠΩΣΕ ΡΩΤΑ$(\"ΟΛΑ ΚΑΛΑ\")\r\nΑνοίγει ένα παράθυρο μηνυμάτων και περιμένει ένα ΟΚ ή ένα Άκυρο.\r\nΣτο ΟΚ δίνει τη λεζάντα που έχουμε ορίσει για ΟΚ δες παρακάτω, ή την εξορισμού \"ΕΝΤΑΞΕΙ\"\r\nΥπάρχει και ως ΡΩΤΑ()\r\nΕπιπλέον δέχεται προαιρετικούς παραμέτρους  με τη σειρά:\r\nΤίτλος\r\nΛεζάντα για ΟΚ  (με * στην αρχή είναι το επιλεγμένο, με σκέτο * είναι η προεπιλεγμένη λεζάντα και επιλεγμένο)\r\nΛεζάντα για ΑΚΥΡΟ (με * στην αρχή είναι το επιλεγμένο, με σκέτο * είναι η προεπιλεγμένη λεζάντα και επιλεγμένο, με κενή λεζάντα , δηλαδή με \"\" δεν εμφανίζεται)\r\nΑλφαριθμητικό για εικόνα, ή μονοπάτι όπου βρίσκεται στο δίσκο μια εικόνα\r\nΑλφαριθμητικό που μετατρέπει το παράθυρο μυνημάτων σε παραθυρο εισαγωγής (δέχεται μέχρι 100 χαρακτήρες)\r\nΣε περίπτωση που έχουμε εισαγωγή και δώσουμε ΟΚ τότε στον σωρό θα υπάρχει το αλφαριθμητικό\r\n\r\n\r\n
EN:ASK(\r\nΤΥΠΩΣΕ ΡΩΤΑ(\"ΟΛΑ ΚΑΛΑ\")\r\nΑνοίγει ένα παράθυρο μηνυμάτων και περιμένει ένα ΟΚ ή ένα Άκυρο.\r\nΣτο ΟΚ δίνει 1\r\nΥπάρχει και ως ΡΩΤΑ$()\r\nΕπιπλέον δέχεται προαιρετικούς παραμέτρους  με τη σειρά:\r\nΤίτλος\r\nΛεζάντα για ΟΚ  (με * στην αρχή είναι το επιλεγμένο, με σκέτο * είναι η προεπιλεγμένη λεζάντα και επιλεγμένο)\r\nΛεζάντα για ΑΚΥΡΟ (με * στην αρχή είναι το επιλεγμένο, με σκέτο * είναι η προεπιλεγμένη λεζάντα και επιλεγμένο, με κενή λεζάντα , δηλαδή με \"\" δεν εμφανίζεται)\r\nΑλφαριθμητικό για εικόνα, ή μονοπάτι όπου βρίσκεται στο δίσκο μια εικόνα\r\nΑλφαριθμητικό που μετατρέπει το παράθυρο μυνημάτων σε παραθυρο εισαγωγής (δέχεται μέχρι 100 χαρακτήρες)\r\nΣε περίπτωση που έχουμε εισαγωγή και δώσουμε ΟΚ τότε στον σωρό θα υπάρχει το αλφαριθμητικό\r\n\r\n\r\n
EN:SCAN\r\n1) Με αναμονή ενεργοποίησης στόχου\r\nΣΑΡΩΣΕ\r\n2) Με περιορισμένη αναμονή ενεργοποίησης στόχου\r\nΣΑΡΩΣΕ 0.5\r\n\r\n
EN:HIDE\r\nΣΒΗΣΕ\r\nΚρύβει την ΟΘΟΝΗ (αλλά όχι το περιθώριο ή την επιφάνεια εργασίας)\r\nΘα ανοίξει αυτόματα αν κάπου στο πρόγραμμά μας ζητάμε εισαγωγή από πληκτρολόγιο με παράλληλη εμφάνιση στην οθόνη.\r\n\r\nΜε τις ΑΝΑΨΕ & ΣΒΗΣΕ μπορούμε να δείχνουμε κάτι στο περιθώριο ενώ φτιάχνουμε την οθόνη μας κρυφά!\r\nΣε συνδυασμό με την ΚΙΝΗΣΗ μπορούμε να δημιουργήσουμε ωραία εφέ παρουσιάσεων (π.χ. ολίσθηση από δεξιά ή από πάνω προς τα κάτω)\r\n\r\n
EN:DATA\r\nΌπως το ΒΑΛΕ αλλά \r\nΤο πρώτο θα βγει πρώτο: Ουρά τύπου  FIFO\r\n(πριν από τις αλλαγές χρήσεως καλό είναι να αδειάζει ο σωρός)\r\n\r\nΑΔΕΙΑΣΕ\r\nΠΙΝΑΚΑΣ Α(Ι)\r\nΣΕΙΡΑ 1,2,3,4,5,6,7,8,9,10\r\nΓΙΑ Ι=0 ΕΩΣ 9 { ΔΙΑΒΑΣΕ Α(Ι) }\r\n\r\nΒλέπουμε τα περιεχόμενα του σωρού με την ΣΩΡΟΣ\r\nεπίσης με την ΔΟΚΙΜΗ ανοιγει ένα πλαίσιο διαλόγου όπου φαίνεται άμεσα ο σωρός\r\n\r\n
EN:DRIVE.SERIAL(\r\nΓυρίζει το αριθμό του δίσκου (ως ακέραια τιμή, μπορεί να είναι και αρνητικός)\r\n' Μπορούμε να τον μετατρέψουμε σε ισοδύναμο ακέραιο χωρίς πρόσημο (με ίδια δυαδικά ψηφία)\r\n' Δείτε το παράδειγμα (το πρώτο είναι σε μια γραμμή αλλά φαίνεται σε δυο)\r\n\r\nΤύπωσε Δεκαεξ$(ΠάνωΜισό(Δυαδικό.Ακέραιο(Σειριακός.Δίσκου(\"c:\\\"))),2) + \"-\" + Δεκαεξ$(ΚάτωΜισό(Δυαδικό.Ακέραιο(Σειριακός.Δίσκου(\"c:\\\"))),2)\r\n\r\nΔεκαεξ Δυαδικό.Ακέραιο(Σειριακός.Δίσκου(\"c:\\\"))\r\n\r\n\r\n
EN:PAGE\r\nΣΕΛΙΔΑ\r\nΜε αυτήν την εντολή λέμε στον εκτυπωτή ό,τι έχουμε στείλει σ' αυτόν να το γράψει σε μια σελίδα. Μετά ότι θα γράψουμε θα εμφανισθεί στην επόμενη ΣΕΛΙΔΑ.\r\n\r\nΣΕΛΙΔΑ 1    ' Ζητάμε μια σελίδα portrait (το μήκος μεγαλύτερο από το πλάτος)\r\nΣΕΛΙΔΑ 0 ' Ζητάμε μια σελίδα landscape (το μήκος μικρότερο από το πλάτος)\r\n\r\n
EN:SCRIPT\r\nμόνο από τον μεταφραστή γραμμής εντολών \r\nΣενάριο αλφαριθμητική_παράσταση ' τρέχει τις εντολές στη παράσταση στον μεταφραστή γραμμής εντολών\r\n(ο μεταφραστής δεν υποστηρίζει επαναλήψεις)\r\nΣενάριο όνομα_τμήματος         ' πρέπει να είναι γενικό το τμήμα\r\nΤο τμήμα ότι φτιάχνει παραμένει!\r\nΜέσα από το μεταφραστή προγράμματος μπορούμε να καλέσουμε ένα σενάριο με την Θέσε\r\nΘέσε Σενάριο όνομα_τμήματος\r\n\r\n\\\\ Παράδειγμα\r\n\\\\ Τοπικά φτιαγμένα σενάρια, ως γενικά!\r\n\\\\ οι μεταβλητές/συναρτήσεις/τμήματα\r\n\\\\ παραμένουν μετά τη κλήση (δεν γίνεται αυτό στα κανονικά τμήματα)\r\nΤμήμα Γενικό [001] {\r\n      Σταθερές Ν=5, Ζ=50\r\n      Συνάρτηση Γεια$ {\r\n            =\"Γεια χαρά\"\r\n      }\r\n}\r\nΤμήμα Γενικό [002] {\r\n      \\\\ ότι φτιάχνουμε θα είναι γενικό\r\n      \\\\ και προσωρινό για το τμήμα που κάλεσε το σενάριο\r\n      Σταθερές Ν=55, Ζ=550\r\n      Συνάρτηση Γεια$ {\r\n            =\"Καλημέρα\"\r\n      }\r\n}\r\nΘέσε σενάριο [001]\r\nΑρχη()\r\nΚαθαρό\r\nΒάλε \"[002]\"\r\n\\\\ διαβάζουμε με την γράμμα$ γιατί στη υπόλοιπη γραμμή της  θέσε...\r\n\\\\ δεν διαβάζονται οι μεταβλητές του τμήματος, μόνο ο σωρός είναι κοινός.\r\nΘέσε σενάριο \"σενάριο \"+γράμμα$\r\nΑρχη()\r\n\r\n\r\nΡουτίνα Αρχη()\r\n      Τύπωσε Ν, Ζ, Γεια$()\r\nΤέλος Ρουτίνας\r\n\r\n\r\n\r\n
EN:REM\r\nΣΗΜ : ΤΥΠΩΣΕ \"ΑΥΤΗ Η ΓΡΑΜΜΗ ΔΕΝ ΘΑ ΕΚΕΛΕΣΤΕΙ ΑΛΛΑ ΘΑ ΕΧΕΙ ΧΡΩΜΑ\"\r\n\r\nΣΗΜ {\r\n\tΤΥΠΩΣΕ \"ΑΥΤΟ ΤΟ ΜΠΛΟΚ ΔΕΝ ΘΑ ΕΚΤΕΛΕΣΤΕΙ, ΚΑΙ ΔΕΝ ΕΧΕΙ ΧΡΩΜΑ\"\r\n\t\\\\ ΕΙΝΑΙ ΜΙΑ ΣΗΜΕΙΩΣΗ ΠΟΛΛΩΝ ΓΡΑΜΜΩΝ\r\n}\r\n\r\n\r\n\r\n
EN:SGN(\r\nΤύπωσε Σημ(10),Σημ(0),Σημ(-5)\r\n Δίνει:     1      0      -1\r\nΑ=-5\r\nΤύπωσε Σημ(Α)\r\n      -1\r\n\r\n
EN:MARK\r\nΣΗΜΑΔΙ πλατος_σε_χαρακτηρες, υψος_σε_χαρακτηρες, χρώμα, ελλειψη_η_κυκλος\r\n\r\nελλειψη_η_κυκλος = 1 ή 0 (Η έλλειψη θα φανεί όταν δώσουμε πλάτος διάφορο από το ύψος)\r\nΟ δρομέας χαρακτήρων δεν αλλάζει και έτσι μπορούμε να γράψουμε πάνω από το σημάδι γράμματα.\r\n\r\nΠαράδειγμα\r\nΤΥΠΩΣΕ \" \";\r\nΣΗΜΑΔΙ 1,1,14\r\nΤΥΠΩΣΕ \"  \";\r\nΣΗΜΑΔΙ 8,1,5,1\r\nΤΥΠΩΣΕ \" ΣΗΜΑΔΙ\"\r\n\r\n\r\n
EN:POINT\r\nΔίνει το χρώμα του σημείου που δείχνει ο δρομέας γραφικών (της ΟΘΟΝΗΣ ή του ΠΕΡΙΘΩΡΙΟΥ - ΔΕΣ ΠΕΡΙΘΩΡΙΟ)\r\nΜπορούμε με την Επίπεδο {} να αλλάξουμε τρέχον επίπεδο και να διαβάσουμε το χρώμα από Φόρμα ή Επίπεδο πάνω στην Οθόνη.\r\n\r\n
EN:POINT(\r\nΤΥΠΩΣΕ ΣΗΜΕΙΟ(Α$,10,10)\r\nΤυπώνει το χρώμα της εικόνας που υπάρχει στο Α$ (αν δεν υπάρχει τότε βγαίνει λάθος) στο σημείο 10,10 (σε σημεία - pixels)\r\n\r\nΠαλιό=ΣΗΜΕΙΟ(Α$,10,10, Χρώμα(255, 0, 128))\r\nΜας δίνει το παλιό χρώμα και βάζουμε νέο στο σημείο που θέλουμε (σε pixels, από το 0 πάνω αριστερά)\r\n\r\n\r\nΓια περισσότερους χειρισμούς πρέπει να το βάλουμε σε ένα επίπεδο, να εφαρμόσουμε εντολές σχεδίων και εικόνων, και μετά να το ξανασώσουμε στο αλφαριθμητικό.\r\n\r\n
EN:TODAY\r\nΔίνει έναν αριθμό που αντιπροσωπεύει την σημερινή μέρα.\r\nΤΥΠΩΣΕ ΗΜΕΡΑ$(ΣΗΜΕΡΑ)\r\nΤΥΠΩΣΕ ΓΡΑΦΗ$(ΣΗΜΕΡΑ, \"LONG DATE\")\r\n
EN:CONSTANTS\r\nΣΤΑΘΕΡΕΣ\r\nΑΚΕΡΑΙΟΣ, ΑΛΗΘΕΣ, ΑΛΗΘΗΣ, ΑΠΕΙΡΟ, ΑΠΛΟΣ, ΑΥΞΟΥΣΑ, ΔΙΠΛΟΣ, ΔΥΑΔΙΚΟ_σταθ, ΕΚΔΟΣΗ_σταθερά, ΕΛ ISWINE, ΗΜΕΡΟΜΗΝΙΑ, ΚΕΙΜΕΝΟ_σταθερά, ΛΟΓΙΚΟΣ, ΛΟΓΙΣΤΙΚΟ, ΜΑΚΡΥΣ_ΤΥΠΟΣ, ΠΙ, ΥΠΟΜΝΗΜΑ, ΦΘΙΝΟΥΣΑ, ΦΟΡΜΑΡΙΣΜΑ_ΑΛΦΑΡΙΘΜΗΤΙΚΩΝ, ΦΟΡΜΑΡΙΣΜΑ_ΑΡΙΘΜΩΝ, ΦΟΡΜΑΡΙΣΜΑ_ΓΙΑ ΚΑΘΕ ΤΥΠΟ, ΦΟΡΜΑΡΙΣΜΑ_ΗΜΕΡΟΜΗΝΙΩΝ ΚΑΙ ΩΡΑΣ, ΨΕΥΔΕΣ, ΨΕΥΔΗΣ, ΨΗΦΙΟ\r\n
EN:CONST\r\nΔημιουργία μεταβλητών μόνο για ανάγνωση.\r\n1)\r\nΣΤΑΘΕΡΗ α=10, β$=\"αλφα\"\r\n2)\r\nΣΤΑΘΕΡΕΣ  α=10, β$=\"αλφα\", γ%=12121\r\n3)\r\nΓΕΝΙΚΗ ΣΤΑΘΕΡΗ α=10\r\n4)\r\nΜέσα σε τμήμα αν θέλουμε να πάρουμε την τιμή γενικής σταθερής σε σταθερή\r\nΣΤΑΘΕΡΗ Α\r\n5)\r\nΓΕΝΙΚΗ ΣΤΑΘΕΡΗ Α\r\nΜέσα σε τμήμα αν θέλουμε να πάρουμε την τιμή γενικής σταθερής ως γενική Σταθερή\r\n\r\n\r\nΜια τοπική Α σκιάζει μια γενική σταθερή, και δεν είναι σταθερή, δηλαδή μπορούμε να αλλάξουμε την τιμή της.\r\nΜε την εντολή λίστα βλέπουμε τις σταθερές με τιμές σε [ ]\r\n\r\n\r\n
EN:STATIC\r\nΣτατική ή Στατικές\r\nΣΤΑΤΙΚΕΣ Α=0, Β=10\r\n\r\n\r\nΤο παρακάτω παράδειγμα γράψτε το σε αρχείο με Σ \"στ.gsb\"  ανοίγει ο διορθωτής για το αρχείο, αντιγράφουμε, πατάμε το Esc, και το φορτώνουμε και τρέχει άμεσα με το Φόρτωσε στ\r\nΜε την εντολή Καθαρό καθαρίζουμε τις στατικές\r\n\r\nΤμήμα άλφα {\r\n      Αν Ταύτιση(\"Α\") Τότε Πέτα : Καθαρό\r\n      \\\\ γενικό μόνο στο Τμήμα άλφα και σε ότι καλεί.\r\n      Τμήμα Γενικό Μ {\r\n            Στατικές α=0, β$=\"όνομα\", ζ=(1,2,3,4,5)\r\n            ζ+=20\r\n            Τύπωσε ζ\r\n      }\r\n      Τμήμα Δοκιμή1 {\r\n            Μ\r\n            Μ\r\n            Μ\r\n      }\r\n      Τύπωσε \"3 φορές καλούμε το Μ από το Δοκιμή1\"\r\n      Δοκιμή1\r\n      Τύπωσε \"2 φορές καλούμε το Μ από Τμήμα αυτό\"; Τμήμα$\r\n      Μ\r\n      Μ\r\n      Τύπωσε \"3 φορές καλούμε ξανά το Μ από το Δοκιμή1\"\r\n      Δοκιμή1\r\n}\r\nΤμήμα βήτα {\r\n      κ=100\r\n      άλφα 1  ' το βήτα έχει δικό του αντικείμενο εκτέλεσης, και κρατάει δικές του στατικές για ότι καλεί.\r\n      Τύπωσε κ\r\n}\r\nάλφα\r\nβήτα\r\n\r\nΔεν μπορούμε να έχουμε στατική με ίδιο όνομα με τοπική στο τμήμα.\r\nΔεν μπορούμε να έχουμε στατικές ως πίνακες με παρενθέσεις (μπορούμε να έχουμε δείκτες σε πίνακες)\r\nΟι στατικές δεν μπορούν να περαστούν με αναφορά.\r\nΟι στατικές σβήνουν με την Καθαρό μαζί με τις μεταβλητές του τμήματος ή της συνάρτησης που δίνουμε την εντολή Καθαρό\r\nΠάντα το πατρικό αντικείμενο εκτέλεσης κρατάει τις στατικές των τμημάτων που καλεί.\r\n\r\n
EN:LET\r\nΣΤΗ Χ=10,Υ=30, Κ%=15, Κ$=\"όλα καλά\"\r\nΔημιουργούμε ή και βάζουμε τιμές σε μεταβλητές. Δεν χρειάζεται εξ ορισμού αλλά. Η ΣΤΗ έχει το γνώρισμα ότι εκτελεί πρώτα το δεξιό μέρος και μετά το αριστερό έτσι στην εντολή ΣΤΗ Α(Χ+Υ(3))=Κ(10)  πρώτα θα εκτελεστεί  το δεξιό μέρος Κ(10) και μετά το αριστερό Χ+Υ(3). Επίσης η ΣΤΗ δεν σκεπάζει ποτέ μια γενική μεταβλητή δημιουργόντας μια τοπική. Αν υπάρχει η γενική Λ τότε η Στη Λ=5 βάζει τιμή 5 στη γενική μεταβλητή Λ. Χωρίς την ΣΤΗ πρέπει να κάνουμε αυτό Λ<=5 διαφορετικά η Λ=5 θα φτιάξει μια νέα Λ και θα προηγείται της γενικής.\r\n\r\n
EN:TAB\r\nΔίνει  το πλάτος των νοητών στηλών της οθόνης. ΔΕΣ ΤΥΠΩΣΕ\r\nΤύπωσε @(στήλη*3), \"οκ\"\r\nΤύπωσε @(στήλη(3)), \"οκ\"\r\n\r\nΔες Στήλη(), $()\r\n
EN:TAB(\r\nΤύπωσε Στήλη(3)\r\nΤυπώνει την θέση της τέταρτης στήλης \r\nΤύπωσε @(Στήλη(2)),100, @(Στήλη(1)),400\r\n                        400           100\r\nΤύπωσε Στήλη*3=Στήλη(3)\r\n      -1\r\n\r\nΤύπωσε $(,10),Στήλη=10      \r\nΔες Στήλη, $()      \r\n
EN:STOCK\r\nΚάθε πίνακας μπορεί να χρησιμοποιηθεί ως στοκ τιμών.\r\n1)ΣΤΟΚ πινακ(δεικτης) απο τιμη1, τιμη2, τημη3$\r\n2) ΣΤΟΚ πινακ(δεικτης) σε  μεταβλ1, μεταβλ2, μεταβήτη$\r\n3.1) ΣΤΟΚ πινακ(δεικτης) για 20, πινακ(δεικτης+100) \r\n3.2) ΣΤΟΚ πινακ(δεικτης) για 20, πανακ2(δείκτης+100)\r\n4.1) ΣΤΟΚ πινακ(δεικτης) θεσε 100                                       (αδειάζει όλα τα στοιχεία)\r\n4.2 ΣΤΟΚ πινακ(δεικτης) θεσε 100. κλαση1()     σες ΚΛΑΣΗ\r\n\r\n\r\n
EN:TARGETS\r\nΣΤΟΧΟΙ ΝΕΟΙ\r\nΚαθαρίζει την μνήμη που απασχολούσαν οι στόχοι. Δεν αλλάζει την οθόνη. Το ίδιο γίνεται με την ΤΥΠΟΣ και ΠΑΡΑΘΥΡΟ αλλά έχουμε και καθαρισμό της οθόνης.\r\n
EN:TARGET AND MENU\r\nΣΤΟΧΟΙ ΚΑΙ ΕΠΙΛΟΓΗ\r\nΑΛΛΑΓΗ, ΕΠΙΛΟΓΗ, ΣΑΡΩΣΕ, ΣΤΟΧΟΙ, ΣΤΟΧΟΣ\r\n
EN:TARGET\r\nΣΤΟΧΟΣ ΕΔ,\"ΜΠΙΠ\",60,3,7,5,5,\"ΠΑΤΑ ΕΔΩ ΜΕ ΤΟ ΑΡΙΣΤΕΡΟ ΠΛΗΚΤΡΟ ΤΟΥ ΠΟΝΤΙΚΙΟΥ\"\r\nΣΤΟΧΟΣ ΕΔ, 0\r\nΣΤΟΧΟΣ ΕΔ,1\r\n\r\nΔΕΣ ΕΝΤΟΛΗ ΑΛΛΑΓΗ\r\n\r\nΠαρατήρηση:\r\nΔημιουργία - Πρώτα θέτουμε τον δρομέα χαρακτήρων (εντολή ΔΡΟΜΕΑΣ ή με την ΤΥΠΩΣΕ) κατόπιν δίνουμε μια μεταβλητή (εδώ ΕΔ) όπου αυτή μετά την εκτέλεση της εντολής θα έχει έναν αριθμό που θα δείχνει τον συγκεκριμένο στόχο - μεταβλητή χειρισμού στόχων. Μετά ακολουθεί η οδηγία που θα εκτελεί ο στόχος. Αμέσως μετά ακολουθεί το πλάτος και το ύψος τα οποία δεν αλλάζουν μέχρι να σβήσουν όλοι οι στόχοι με μια εντολή οθόνης ΤΥΠΟΣ.  Ακολουθεί το χρώμα πλαισίου καθώς και το χρώμα φόντου. Τέλος δυο σημαντικοί παράμετροι ακολουθούν, ο τύπος του στόχου και η φράση που θα εμφανίζει.\r\nΟ τύπος του στόχου παίρνει τιμές:\r\nΠου ορίζουν θέση της φράσης και τρόπος εκτέλεσης οδηγίας\r\n1 2 3  Θέση της φράσης σχετικά με το πλαίσιο\r\n4 5 6  Το 5 σημαίνει στο κέντρο του πλαισίου\r\n7 8 9  Αν προσθέσουμε το 10 τότε η οδηγία δεν εκτελείται αλλά στέλνεται σαν να την πληκτρολογούσαμε. Δοκιμάστε στο παράδειγμα με τύπο 5 και με 15.\r\nΕνεργοποίηση.\r\nΜε ΣΤΟΧΟΣ μεταβλητή, 0 απενεργοποιούμε τον στόχο ενώ μες τιμή 1 ενεργοποιούμε και επανασχεδιάζουμε. Κάθε εντολή ΑΛΛΑΓΗ επανασχεδιάζει τον στόχο.\r\nΤέλος μπορούμε να δώσουμε σαν οδηγία το όνομα ενός τμήματος ώστε να εκτελέσουμε πολλαπλές εντολές.\r\n\r\nΑν καθαρίσουμε την  οθόνη με την εντολή ΟΘΟΝΗ οι στόχοι παραμένουν νοητά και αν είναι ενεργοί τότε με το αριστερό πλήκτρο του ποντικιού πάνω σε μια περιοχή στόχου θα έχουμε ενεργοποίηση αυτού. Δες εντολή ΣΤΟΧΟΙ ΝΕΟΙ που σβήνει από την μνήμη τους στόχους.\r\n\r\n\r\n
EN:ROUND(\r\n1. Τύπωσε Στρογγ(12.123231, 3)\r\nκάνει στρογγυλοποποίηση στο 3 δεκαδικό.\r\n2. Τύπωσε Στρογγ(12.123231764234432) \r\nκάνει στρογγυλοποίηση στο 13 δεκαδικό (εξ ορισμού).\r\n\r\n\r\n
EN:WRITER\r\nΣΥΓΓΡΑΦΕΑΣ\r\nΤυπώνει το όνομα του συγγραφέα της γλώσσας Μ2000\r\n\r\n
EN:EDIT\r\nΣΥΓΓΡΑΦΗ ή Σ\r\n1) Δημιουργία Τμήματος\r\n      Σ αλφα\r\n            Αν δεν γράψουμε κάτι στο τμήμα τότε δεν δημιουργείται τμήμα\r\n      Σ αλφα, 50\r\n            Μας μεταφέρει τον δρομέα κειμένου στην θέση 50\r\n2) Σ \"αλφα.txt\"\r\n Επεξεργασία αρχείου κειμένου απ' ευθείας από τον δίσκο. Πρέπει να έχει κατάληξη gsb ή txt.\r\n \r\n3) Δημιουργία συνάρτησης (καθολικής) Σ α( ή Σ α$( ή Σ α%( ή όπου Σ βάλε ΣΥΓΓΡΑΦΗ\r\n\r\n4) Σ\r\nΑνοίγει την λίστα γραμμών εντολών (από την οποία με τα βελάκια επιλέγουμε το προηγούμενο, όταν είμαστε στην γραμμή εντολών). Δουλεύει μόνο στη γραμμή εντολών  (Ούτε με ΘΕΣΕ δεν μπορούμε να την εκτελέσουμε μέσα από τμήμα), γιατί ελέγχει αν είναι σε αυτό το σημείο και μετά ενοίγει την λίστα. Δεν δίνει λάθος αν την έχουμε μέσα σε τμήματα.\r\n\r\n5) Σ ! 4\r\nθέτει στους 4 χαρακτήρες την εσοχή, και το πλάτος του TAB χαρακτήρα μόνο για την διόρθωση\r\n\r\nΠαρατήρηση\r\nΌταν ανοίγουμε τον διορθωτή (Editor) καμία αλλαγή δεν γίνεται στην οθόνη. Το πλαίσιο κειμένου βρίσκεται σε ξεχωριστό επίπεδο.  Υπάρχει κάθετη μπάρα ολίσθησης όταν οι γραμμές είναι περισσότερες, αλλά συνήθως είναι κρυμμένη και για να εμφανιστεί πρέπει να πάμε στην άκρη δεξιά το ποντίκι.  Μπορούμε όμως να την εμφανίσουμε όταν ολισθαίνουμε τις γραμμές χωρίς αυτήν. Αυτό γίνεται με το κράτημα του αριστερού πλήκτρου του ποντικιού και την μετακίνηση προς τα εκεί που θέλουμε. Αν δεν έχουμε αναδίπλωση λέξεων ενεργή τότε οι χαρακτήρες εκτός οθόνης εμφανίζονται καθώς πάμε τον δρομέα. Με το ποντίκι μπορούμε να μεταφέρουμε το δείκτη και αυτόματα θα έχουμε οριζόντια ολίσθηση. Δεν υπάρχει για το λόγο αυτό οριζόντια μπάρα ολίσθησης.\r\n\r\n      συντομεύσεις που υπάρχουν και στο αναδυόμενο μενού\r\n      ESC -  τερματίζουμε τον διορθωτή. \r\n      shift ESC  - τερματίζουμε χωρίς αλλαγές. \r\n      F1 - ενεργοποιεί την αναδίπλωση λέξεων ή την απενεργοποιεί ανάλογα.\r\n      F2 - αναζητεί προς τα πάνω το μαρκαρισμένο κείμενο και αν το βρει το μεταβαίνει εκεί\r\n      F3 - αναζητεί προς τα κάτω το μαρκαρισμένο κείμενο και αν το βρεί μεταβαίνει εκεί\r\n      ctrl + F1 ανοίγει την βοήθεια (επειδή το ίδιο στοιχείο χρησιμοποιείται και για εισαγωγή κειμένου σε μεταβλητή, σε εκείνη την περίπτωση η βοήθεια είναι αυτή που φτιάχτηκε με την ΠΕΡΙ)\r\n\r\n      (δεν χρειάζεται να είναι στα αγγλικά το πληκτρολόγιο για να κάνουμε τους συνδυασμούς)\r\n      \r\n      ctrl + X   αποκοπή\r\n      ctrl + C   αντιγραφή\r\n      ctrl + V  επικόλληση\r\n      \r\n      Άλλες συντομεύσεις που δεν φαίνονται στο αναδυόμενο μενού\r\n     \r\n      shift + βελάκι  - μαρκάρουμε το κείμενο\r\n      ctrl + A  \r\n            - Επιλογή όλων\r\n      shift ctrl + A  \r\n            - Επιλογή κανένα\r\n      ctrl + Z  \r\n            - Αναίρεση (υπάρχουν απεριόριστα επίπεδα αναίρεσης)\r\n      ctrl + Y        \r\n            - Αναίρεση αναίρεσης (καταγράφονται τα ctrl+z μέχρι να γράψουμε κάτι καινούργιο)\r\n      Προσοχή το Break (\"Pause/Break\") πλήκτρο είναι το \"Reset\" του μεταφραστή (ευτυχώς βγαίνει μήνυμα)\r\n      \r\nΠερί \"μεταφοράς και απόθεσης\" ή \"σύρε και άφησε\". Το να αφήσουμε από άλλο στοιχείο κάποιο κείμενο είναι αποδεκτό πάντα. Το να σύρουμε όμως είναι απενεργοποιημένο και πρέπει να ενεργοποιηθεί από το αναδυόμενο μενού. Η χρήση του είναι πιο απλή εδώ. Στο μαρκαρισμένο κείμενο κάνουμε διπλό κλικ μέχρι που εμφανίζεται το βελάκι με το τετράγωνο.  Αν θέλουμε μπορούμε χωρίς να πατάμε κανένα πλήκτρο να μετακινήσουμε τον δρομέα με το ποντίκι ακόμα και στις γραμμές που δεν βλέπουμε (θα τις δούμε όπως κάνουμε την μετακίνηση). και απλά κάνουμε ένα κλίκ και γίνεται η μεταφορά. Για να σύρουμε εκτός αυτού του στοιχείου σε άλλο πρόγραμμα πρέπει να κρατάμε κάτω το αριστερό πλήκτρο του ποντικιού. Σε κάθε περίπτωση το ESC αναιρεί τη κατάσταση της μεταφοράς και απόθεσης. \r\n\r\nΑν θέλουμε να περάσουμε ένα κείμενο σε μια μεταβλητή τότε δες ΕΙΣΑΓΩΓΗ\r\n\r\n\r\n\r\n
EN:COMPARE(\r\nα%=5\r\nβ%=3\r\n? ΣΥΓΚΡΙΝΕ(α%,β%)\r\n      1\r\nα=5\r\nβ=13\r\n? ΣΥΓΚΡΙΝΕ(α,β)\r\n      -1\r\nΠΙΝΑΚΑΣ β$(10)=\"αα\"    ' στοιχεία από 0 μέχρι 9 και εδώ βάζουμε σε όλα το \"αα\"\r\nα$=\"αα\"\r\n? ΣΥΓΚΡΙΝΕ(α$,β$(4))\r\n      0\r\nΣυγκρίνει μόνο δυο μεταβλητές αριθμητικές ή αλφαριθμητικές. Μπορούμε να δώσουμε και στοιχεία πίνακα για σύγκριση.\r\nΕίναι πιο γρήγορη αυτή η σύγκριση γιατί οι τιμές περνάνε με αναφορά και όχι με αντιγραφή στην εσωτερική ρουτίνα. \r\nΕπιστρέφει 0 για ίσο 1 για το πρώτο μεγαλύτερο και -1 για το δεύτερο μεγαλύτερο.\r\nΜπορούμε να την χρησιμοποιήσουμε σε μια ΕΠΙΛΕΞΕ ΜΕ  αν θέλουμε διαφορετική απόκριση σε κάθε μια από τις τρεις δυνατές τιμές 1 0 και -1.\r\n\r\nΕπίσης μόνο για αριθμητικές μεταβλητές υπάρχουν και οι γρήγορες ΜΙΚΡΟ() και ΜΕΓΑΛΟ()\r\n\r\nΑν θέλουμε να συγκρίνουμε παραστάσεις υπάρχει ο spaceship operator  <=>\r\nΤύπωσε 10+2<=>10+2, \"ααα\"<=>\"ββ\"\r\n\r\n\r\n
EN:COLLIDE(\r\nΤυπωσε  Συγκρουση(2,100)\r\nΤυπωσε Συγκρουση(2,100,10000,1800,12000,3800)\r\n\r\nμας λέει αν ο παικτης 2 συγκρούστηκε με το 1, το 100 σημαίνει ότι θα χρησιμοποιηθεί όλο (100%) το εμβαδόν του παίκτη (στο νοητό τετράπλευρο που σχηματίζει η εικόνα του). Μειώνοντάς του κάνουμε τις πλευρές του παίκτη αναίσθητες.\r\n\r\nΤυπωσε Συγκρουση(2,100,10000,1800,12000,3800)\r\n      εδώ βλέπουμε αν ο παίκτης 2 καλύπτει το τετράπλευρο με κορυφή πάνω αριστερά 10000,1800 και κάτω δεξιά 12000,3800 (δηλαδή εδώ είναι απόλυτες οι συντεταγμένες, και όχι σχετικές με την πρώτη κορυφή)\r\n\r\n      Υπάρχουν 32 παίκτες όπου ο 1 δεν συγκρούεται με κανέναν ενώ ο 32 με όλους τους άλλους. Ο 32 είναι ο πιο κοντινός μας...δεν θα τον καλύψει κανείς. Κάθε παίκτης έχει μέγεθος και εικόνα. Μπορούμε να αλλάζουμε την εικόνα του και ταυτόχρονα και το μέγεθός του, και αυτό είναι το επίπεδό του. Από κάθε παίκτη μπορούμε να πάρουμε το επίπεδό του και να το χειριστούμε ως οθόνη.\r\n\r\n      Γιατί υπάρχει παίκτης και επίπεδο που αντιστοιχούν στο ίδιο πράγμα; Η απάντηση είναι απλή. Ο παίκτης χειρίζεται το επίπεδο με διαφορετικό τρόπο, πιο άμεσο, μετακίνηση, εμφάνιση και εξαφάνιση (αλλά παραμένει στην θέση του), αλλαγή εικόνας και αν έχει ή όχι κάποια διάφανα σημεία καθώς και αλλαγή προτεραιότητας. Αντίθετα το επίπεδο καλεί μια ομάδα εντολών και προετοιμάζει το επίπεδο για γραφικά και τύπωση γραμμάτων. Η ομάδα εντολών έχει εντολές που θα έπαιζαν και στην οθόνη. Μπορούμε να μετακινήσουμε το επίπεδο με την ίδια εντολή που μετακινούμε την οθόνη. Επιπλέον με την Τυπος μπορούμε να αλλάξουμε τύπο γραμμάτων (μέγεθος) καθώς και το μέγεθος του επιπέδου για να χωρέσουμε ας πούμε μια εικόνα! Επιπλέον μπορούμε να ορίσουμε στόχους πάνω στα επίπεδα όπως ορίζουμε και στην οθόνη.\r\n      \r\n      Υπάρχει τρόπος να χειριστούμε εικόνες αντικείμενα βάζοντάς τα το ένα δίπλα στο άλλο ώστε να φτιάξουμε ένα τοπίο που θα βρίσκεται στο παρασκήνιο (δες την ΔΙΑΦΑΝΟ) και να χρησιμοποιήσουμε τους παίκτες για κινούμενες εικόνες και μερικά επίπεδα για να γράφουμε σκορ!\r\n
EN:MERGE.DOC\r\nΣΥΓΧΩΝΕΥΣΕ.ΕΓΓΡΑΦΟ έγγραφο$\r\n\r\nΣυγχωνεύει ένα κείμενο από αρχείο σε ένα έγγραφο στην μνήμη.\r\n\r\n\\\\ γράψε κάτι και πάτα esc\r\nΣυγγραφή \"alfa1.txt\"\r\n\\\\ γράψε κάτι και πάτα esc\r\nΣυγγραφή \"alfa2.txt\"\r\nΈγγραφο α$\r\nΦόρτωσε.Έγγραφο α$, \"alfa1.txt\"\r\nΣυγχώνευσε.Έγγραφο α$,\"alfa2.txt\"\r\nΑναφορά α$\r\n\r\n\r\n
EN:COMPRESS\r\nΣΥΜΠΙΕΣΗ ονομα_βασης$\r\nτο όνομα βάσης πρέπει να έχει το τύπο π.χ. .mdb\r\n\r\nχρησιμοποίησε το ΚΛΕΙΣΕ ΒΑΣΗ κατ$+ονομα_βασης$+\".mdb\"\r\nγια να κλείσεις τυχόν ανοικτή σύνδεση με τη βάση\r\n
EN:COS(\r\nΕπιστρέφει το συνημίτονο μιας γωνίας σε μοίρες\r\n\r\n
EN:FUNCTION\r\n1) Κανονικές Συναρτήσεις\r\nΟρίζονται πριν την χρήση τους.  Ο ορισμός της συνάρτησης πρέπει να εκτελεστεί για να υπάρχει η συνάρτηση. Αυτό σημαίνει ότι μπορούμε να επιλέγουμε ορισμούς πριν την χρήση βάζοντας τις επιλογές σε μια δομή ΑΝ ή σε Επίλεξε  (ή Επέλεξε είναι το ίδιο για τη Μ2000)\r\nΌ,τι μεταβλητές ορίζουμε είναι εξ ορισμού τοπικές. Δεν μπορούμε να δούμε μεταβλητές έξω από τη συνάρτηση εκτός αν είναι γενικές και δεν υπάρχει τοπική με ίδιο όνομα (σκιάζει την γενική).\r\nΔείτε το παράδειγμα (σε ένα τμήμα έστω Α)\r\n      Αδειασε\r\n      Βαλε 1,2,3\r\n      Συναρτηση αλφα {\r\n            Σωρος   ' μας δείχνει τα στοιχεία του\r\n            διαβασε κ, δ\r\n            = κ*δ\r\n      }\r\n      τυπωσε αλφα(10,5)\r\n      δες ολακαλα {\r\n            τυπωσε αλφα()\r\n      }\r\n      τυπωσε ολακαλα\r\n      σωρος\r\nΟι συναρτήσεις διαφέρουν από τα τμήματα γιατί χρησιμοποιούνται σε αριθμητικές και αλφαριθμητικές παραστάσεις. Π.χ. εδώ μπορεί κάποιος να προσθέσει ένα 20 στο αλφα(10,5)\r\nΤυπωσε αλφα(10,5)+20\r\n\r\nΜπορούν να συνυπάρχουν οι αλφα(), αλφα$() και αλφα%()\r\n\r\nΤο σύμβολο % λέει ότι θα γυρίσει η συνάρτηση ακέραια τιμή, το σύμβολο $ λέει ότι θα γυρίσει η συνάρτηση αλφαριθμητική τιμή.\r\n\r\nΚάθε συνάρτηση έχει δικό της σωρό τιμών και όταν την καλούμε βάζουμε τιμές στο δικό της σωρό ενώ όταν τερματίζει αυτός ο σωρός  χάνεται με όποιες τιμές και να έχει μέσα. \r\n\r\nΜια συνάρτηση μπορεί να καλέσει τον εαυτό της, με το όνομά της ή με το Λάμδα() ή Λάμδα$() τα οποία λειτουργούν για οποιαδήποτε συνάρτηση και σημαίνει τη τρέχουσα συνάρτηση.\r\n\r\nΥπάρχει όπως για το τμήμα και εδώ η ιδέα της στατικής μεταβλητής, δηλαδή μια μεταβλητή που υπάρχει μέσα σε μια συνάρτηση και κρατάει μια τιμή που μπορεί να αλλάζει, και σε κάθε κλήση σε αυτή την συνάρτηση θα υπάρχει εκεί για να χρησιμοποιηθεί. Ακόμα και σε αναδρομή αυτή η μεταβλητή θα μένει εκεί!  Αν καλούμε με αναδρομή, η στατική είναι θεατή σε κάθε κάθε κλήση, κατά την αναδρομή. Δες Στατική\r\n\r\nΟι συναρτήσεις μπορούν να περαστούν με αναφορά σε κλήση.\r\n\r\nΣυνάρτηση Α(Χ) {\r\n\t=Χ**2+3\r\n}\r\nΣυνάρτηση Β(Χ) {\r\n\t=Χ**3+30\r\n}\r\n\r\nΤμήμα Διάγραμμα (Αρχ, Τελ, Βημ, &Φ()) {\r\n\tΓια ι=Αρχ έως Τελ ανα Βημ\r\n\t\tΤύπωσε Φ(ι),\r\n\tΕπόμενο\r\n\tΤύπωσε\r\n}\r\n\r\nΔιάγραμμα 10, 50, 10, &Α()\r\nΔιάγραμμα 10, 50, 10, &Β()\r\n\r\n\r\nΣυνάρτηση μιας γραμμής κάνει η Κάνε πχ Κάνε Α(χ)=χ**2  και είναι πάντα τοπική\r\nΓενικές φτιάχνουμε με την Γενική\r\n\tΣυνάρτηση Γενική α {\r\n\t\tΔιάβασε Χ\r\n\t\t=Χ**2\r\n\t}\r\nΜέσα σε ομάδες (θα περάσουμε με αναφορά μια συνάττηση που αλλάζει και μια μεταβλητή στην ομάδα ότην την καλούμε):\r\n\tΟμάδα Αλφα {\r\n\t\tΚ=100\r\n\t\tΣυνάρτηση Α(χ) {\r\n\t\t\t=χ*.Κ\r\n\t\t\t.Κ++\r\n\t\t}\r\n\t}\r\n\tΒήτα=Αλφα\r\n\tπ->Αλφα   'δείκτης π δείχνει το Αλφα το οποίο θα υπάρχει μέχρι να σβηστεί το τμήμα που το δημιούργησε.\r\n\tπ1->(Αλφα) ' δείκτης π1 δείχνει σε ένα αντίγραφο του Αλφα (πτητική ομάδα, ο αριθμός δεικτών κρατάει την ομάδα)\r\n\tΆλφα.Κ++\r\n\tΤύπωσε π=>Α(10), π1=>Α(10)\r\n\tπ1=>Κ++\r\n\tΤύπωσε π=>Α(10)= π1=>Α(10)\r\n\t\r\n\tΤμήμα Εσωτερικό (&φ()) {\r\n\t\tΤύπωσε φ(10)\r\n\t}\r\n\t\r\n\tΕσωτερικό &Άλφα.Α()\r\n\tΤύπωσε Αλφα.Κ=104, π=>Κ=104  ' (το π=>Κ είναι το Αλφα.Κ)\r\n\tπ->Βήτα\r\n\tΤύπωσε Αλφα.Κ=104, π=>Κ=100  ' (το π=>Κ είναι το Βήτα.Κ)\r\n\tΓια π1 {\r\n\t\tΕσωτερικό &.Α()\r\n\t}\r\n\tΤύπωσε π1=>Κ=104\r\n\tπ=π1   ' δουλεύει και το -> ο π δείχνει αυτό που δείχνει ο π1\r\n\tΤύπωσε π=>Κ=104   ' τώρα το π=>Κ δείνχει ότι το π1=>Κ\r\n\r\n\r\nΓενικά μέσα σε συναρτήσεις μπορούμε να βάζουμε τμήματα και νήματα, και το ίδιο συμβαίνει και στα τμήματα και στα νήματα. Οι συναρτήσεις έχουν όνομα όπως και τα τμήματα ενώ τα νήματα έχουν αριθμό χειρισμού (γράφεται σε μια μεταβλητή) και χρησιμοποιούν το όνομα του τμήματος που τα δημιούργησε. Αυτό σημαίνει ότι μπορούν να δουν και να αλλάξουν τις μεταβλητές του τμήματος που τα δημιούργησε.\r\nΔες ΚΛΗΣΗ ΣΥΝΑΡΤΗΣΗ( και ΣΥΝΑΡΤΗΣΗ$(\r\n\r\nΥπάρχουν δυο αντικείμενα που χειρίζονται συναρτήσεις. Η λάμδα συνάρτηση, και το Γεγονός.\r\nΗ λάμδα συνάρτηση συνδυάζει κλεισίματα με μια συνάρτηση. Το γεγονός έχει μια λίστα συναρτήσεων και μπορούμε να προσθέτουμε ή να αφαιρούμε από τη λίστα συναρτήσεις. (όχι τις απλές συναρτήσεις).\r\n\r\nΗ λάμδα συνάρτηση είναι μεταβλητή και συνάρτηση ταυτόχρονα. Το γεγονός καλείται με μια σειρά παραμέτρων οι οποίες πάνε σε όλες τις συναρτήσεις του γεγονότος, ως μια πολλαπλή κλίση. Το ενδιαφέρον με το γεγονός είναι ότι είναι μεταβλητή, και αφενός μπορεί να πάρει άλλη τιμή, και αφετέρου μπορεί να περαστεί είτε με τιμή είτε με αναφορά. Οι κλήσεις συναρτήσεων στο Γεγονός γίνονται σαν κλήσεις τμημάτων.\r\n\r\nΜια συνάρτηση μπορεί να κληθεί  με τη Κάλεσε. Δες ΚΑΛΕΣΕ\r\n\r\n\r\n2) Απλές Συναρτήσεις\r\nΟι απλές συναρτήσεις γράφονται στο τέλος ενός τμήματος ή μιας συνάρτησης. Δεν έχουν δικό τους σωρό τιμών,  δεν μπορούν να περαστούν με αναφορά, δεν μπορούν να κληθούν με την κάλεσε. Οι απλές συναρτήσεις βλέπουν όλες τις μεταβλητές και ότι έχει το τμήμα ή η συνάρτηση που τις καλεί.  Μπορούν να βρίσκονται εκεί που τις καλούμε, στο τέλος του κώδικα, ή στο κώδικα που αρχικά υπήρχε ο κώδικας που τρέχουμε, αδιάφανα για το πρόγραμμά  μας. Για τοπικές μεταβλητές χρησιμοποιούμε την Τοπική ή Τοπικές (ορίζει και πίνακες)\r\nΌ,τι δημιουργούμε μέσα στη Συνάρτηση διαγράφεται όπως και στη Ρουτίνα. Ενώ οι ρουτίνες έχουν μεγάλο βάθος αναδρομής, οι απλές συναρτήσεις έχουν λίγο μεγαλύτερο από τις κανονικές συναρτήσεις. Δεν ορίζουμε απλές συναρτήσεις ή ρουτίνες εντός μιας απλής Συνάρτησης (δεν υπάρχει έλεγχος αν όντως βάλουμε μια άλλη συνάρτηση στην ίδια συνάρτηση αλλά το όνομα της συναρτησης λειτουργεί σαν Τέλος)\r\n\r\n\r\nΥποχρεωτικά το όνομα έχει παρενθέσεις ακόμα και αν δεν έχει παράμετρο.\r\nΤύπωσε @Α()\r\nΣυνάρτηση Α()\r\n\t=100\r\nΤέλος Συνάρτησης\r\n\r\nΜπορούμε να βγούμε πιο νωρίς με την Έξοδος Συνάρτησης. Μπορούμε να έχουμε ετικέτες εντός και να εκτελούμε διακλαδώσεις ακόμα και έξω από το κώδικα της συνάρτησης αρκεί να γίνει η αναμενόμενη επιστροφή. Το Τέλος Συνάρτησης είναι ίδιο με το Τέλος Ρουτίνας΄ιδιο με την Επιστροφή χωρίς παραμέτρους.\r\n\r\nΟνόματα μπορούν να είναι το Α(), Α%(), Α$() όπου Α ότι όνομα αρχίζει από γράμμα και μετά μπορεί να υπάρχουν γράμματα, αριθμοί, η κάτω παύλα _ και η τελεία. Για κλήση χρειάζεται η @ πριν\r\n\r\nΑν ένα όνομα υπάρχει στο βασικό λεξιλόγιο της Μ2000 δεν μπορεί να γίνει απλή συνάρτηση, αλλά μπορεί να αλλαχθεί προσωρινά σε ένα τμήματα με μια κανονική συνάρτηση. Στις συναρτήσεις με όνομα από το βασικό λεξιλόγιο το @ στην αρχή καλεί την αυθεντική συνάρτηση, είτε υπάρχει άλλη που την άλλαξε προσωρινά είτε όχι. Για το λόγο αυτό ακόμα και αν φτιάξουμε την Συνάρτηση Απολ() ... Τέλος Συνάρτησης, με @Απολ() θα καλέσουμε την αυθεντική Απολ(). Είναι εύκολο να δούμε ποιο όνομα δεν χρησιμοποιούμε στον διορθωτή, γιατί οι λέξεις του βασικού λεξιλόγιου χρωματίζονται διαφορετικά. \r\n\r\n\r\n
EN:FUNCTION$(\r\nΤΥΠΩΣΕ ΣΥΝΑΡΤΗΣΗ$(\"ΟΝΟΜΑΣΥΝΑΡΤΗΣΗΣ$\", 1,4,5)\r\nΤΥΠΩΣΕ ΟΝΟΜΑΣΥΝΑΡΤΗΣΗΣ$(1,4,5)\r\n\r\nΤύπωσε Συνάρτηση$(\"{=Μεσ$({1234567890},αριθμός,αριθμός)}\", 3, 4)\r\nΣυνάρτηση Άλφα$ (χ){\r\n      Αν χ>100 Τότε {\r\n            =\"Μεγάλο\"+γραφή$(χ)\r\n      } Αλλιώς =\"Μικρό\"+γραφή$(χ)\r\n}\r\nα$=&Άλφα$()\r\nΤύπωσε Συνάρτηση$(α$,200), Συνάρτηση$(α$,50)\r\n
EN:FUNCTION(\r\nΤΥΠΩΣΕ ΣΥΝΑΡΤΗΣΗ(\"ΟΝΟΜΑΣΥΝΑΡΤΗΣΗΣ\", 1,4,5)\r\nΤΥΠΩΣΕ ΟΝΟΜΑΣΥΝΑΡΤΗΣΗΣ(1,4,5)\r\nΣυνάρτηση Άλφα (χ){\r\n      Αν χ>100 Τότε {\r\n            =χ*500\r\n      } Αλλιώς =χ\r\n}\r\nα$=&Άλφα()\r\nΤύπωσε Συνάρτηση(α$,200), Συνάρτηση(α$,50)\r\n\r\n
EN:CONTINUE\r\n1. Σε ένα μπλοκ εντολών πηδάει στο τέλος και αν υπάρχει επανάληψη συνεχίζει από την αρχή της. Σε αντίθεση με την ΕΞΟΔΟΣ η οποία τερματίζει την επανάληψη άμεσα.\r\n2. Σε ένα μπλοκ σε μια ΜΕ (δες ΕΠΙΛΕΞΕ ΜΕ) συνεχίζει την ροή μετά το ΤΕΛΟΣ ΕΠΙΛΟΓΗΣ (συνδιάζεται με το ΔΙΕΚΟΨΕ). Μια ΕΞΟΔΟΣ απλά τερματίζει τι μπλοκ (θα πετάξει τις υπόλοιπες εντολές) αλλά δεν διώξει την ΔΙΕΚΟΨΕ (οπότε αν συνεχίζουν τα ΜΕ θα εκτελεστούν και αυτά, χωρίς να εκτελεστούν οι έλεγχοι συνθηκών).\r\n\r\na=5\r\nb=10\r\nselect case  A\r\ncase 1, 5 to 20\r\n      { print \"ok\"\r\n             if b=10 then  break\r\n      }\r\ncase 2,4\r\n      {print \"and ok\"\r\n            continue\r\n      }\r\ncase 3\r\n      { print \"that\"\r\n            print \"and that\"\r\n      }\r\nelse\r\n      print \"??\"\r\nend select\r\n\r\n\r\nfor i = 1 to 1000 {\r\n      if i> 10 then exit\r\n      print i\r\n}\r\nprint i  ' 11\r\n\r\nfor i = 1 to 1000 {\r\n      if i> 10 then continue\r\n      print i\r\n}\r\nprint i  ' 1001\r\n\r\n\r\n
EN:MOVIE.DEVICE$\r\n? ΣΥΣΚΕΥΗ.ΠΡΟΒΟΛΗΣ$\r\nμας δίνει το όνομα της συσκευής προβολής\r\n\r\n
EN:WIN\r\n      ανοίγουμε την αριθμομηχανή των Windows\r\nΣΥΣΤΗΜΑ \"CALC\"\r\n      ανοίγουμε τον κατάλογο που ο διερμηνευτής σώνει και φορτώνει τμήματα\r\nΣΥΣΤΗΜΑ ΚΑΤ$\r\n      ανοίγουμε τον επεξεργαστή κειμένου Wordpad\r\nΣΥΣΤΗΜΑ \"WORDPAD\"\r\n\r\nΣΥΣΤΗΜΑ \"WORDPAD\", \"μονοπάτι και όνομα αρχείου χωρίς διαστήματα ή άλλες εντολές\"\r\nΣΥΣΤΗΜΑ \"WORDPAD\", ΠΑΡΑΘΕΣΗ$(\"μονοπάτι και όνομα αρχείου με διαστήματα εδώ\")\r\n\r\nΜε την εντολή ΣΥΣΤΗΜΑ ή ΣΥΣ τρέχουμε μια εξωτερική εφαρμογή.\r\nΑν θέλεις να τρέξεις ένα άλλο πρόγραμμα gsb (πρόγραμμα του διερμηνευτή) παράλληλα με το τρέχον πρόγραμμα δες την ΧΡΗΣΗ όπου μας δίνει τρόπο να επικοινωνήσουμε με αυλό δεδομένων.\r\nΔες ΑΥΛΟΣ\r\n\r\n
EN:FREQUENCY(\r\n\r\nΕπιστρέφει την συχνότητα για την οκτάβα και τον αριθμό νότας\r\n\r\n\r\n
EN:DRW$(\r\nΔίνουμε ένα όνομα αρχείου WMF χωρίς κατάληξη και εξάγει αν υπάρχει το αρχείο το πλήρες όνομά του (με τη διεύθυνσή του και την κατάληξη WMF) αλλιώς παίρνουμε κενό αλφαριθμητικό\r\n\r\n
EN:DRAWINGS\r\nΣΧΕΔΙΑ\r\nΜας δίνει όλα τα αρχεία τύπου wmf  στον τρέχον κατάλογο\r\nΊδιο με το ΑΡΧΕΙΑ \"wmf\"\r\n\r\nΚΑΤΑΛΟΓΟΣ \"C:\"\r\nΣΧΕΔΙΑ\r\nΑΡΧΕΙΑ \"wmf\"\r\nΣΧΕΔΙΑ !  ' ΤΑΞΙΝΟΜΗΣΗ ΜΕ ΟΝΟΜΑ\r\n\r\n
EN:THREAD.PLAN\r\n1) ΣΧΕΔΙΟ.ΝΗΜΑΤΩΝ ΤΑΥΤΟΧΡΟΝΟ\r\n      Εκτέλεση μια εντολή από κάθε νήμα. Αν οι εντολές είναι σε μπλοκ {} τότε εκτελείται όλο το μπλοκ. Η εντολή ΑΝ καλό είναι να μπει σε παρενθέσεις αν έχουμε και την Αλλιώς. \r\n2) ΣΧΕΔΙΟ.ΝΗΜΑΤΩΝ ΔΙΑΔΟΧΙΚΟ   \\\\ ΕΞ ΟΡΙΣΜΟΥ\r\n      Εξ ορισμού αυτό είναι το σχέδιο των νημάτων. Κάθε φορά ένα νήμα ολοκληρώνει τις εντολές του και δίνει τη θέση του σε άλλο.\r\nΔεν μπορούμε να αλλάξουμε σψέδιο αν έχουμε νήματα στη λίστα νημάτων  (threading pool)\r\n\r\n
EN:STACK\r\n1) ΣΩΡΟΣ\r\nΜας εμφανίζει τα στοιχεία του σωρού χωρίς να ανασύρει κάποιο. \r\n2) ΣΩΡΟΣ Α$\r\nΚαταχωρεί στο σωρό το περιεχόμενο σωρού που έχουμε φτιάξει στο Α$ δες ΣΩΡΟΣ$(\r\nκαι αδειάζει το A$\r\n3) ΣΩΡΟΣ Α$, \"ΝΝ\"\r\nδίνουμε εντολή να βγουν από το σωρό Α$ δυο αριθμοί και να μπουν στο Σωρό του τμήματος ή της συνάρτησης (Τα τμήματα έχουν κοινό σωρό ενώ οι συναρτήσεις και τα νήματα έχουν το δικό τους)\r\nΟυσιαστικά το \"ΝΝ\" είναι ίδιο με το Φακελος$(Σωρος$(2, 20.5))\r\nΟ Σωρός αδειάζει ή διαβάζοντας τις τιμές ή με την εντολή ΑΔΕΙΑΣΕ FLUSH\r\nΜπορεις να αντιγράψεις αυτές τις εντολές σε ένα τμήμα που θα ανοίξεις με την Σ Α (έστω Α το τμήμα), το Σ είναι συντομογραφία της εντολής ΣΥΓΓΡΑΦΗ, ή μπορείς να δώσεις μια προς μια τις εντολές για να δεις το αποτέλεσμα στον διερμηνευτή γραμμής εντολών\r\n            ΠΙΝΑΚΑΣ Α$(10)\r\n            Α$(2)=ΣΩΡΟΣ$(1,2,\"ΟΚ\")\r\n            ΣΩΡΟΣ Α$(2)\r\n            ΣΩΡΟΣ\r\n            ΤΥΠΩΣΕ ΜΗΚΟΣ(Α$(2))\r\n\r\n4) ΣΩΡΟΣ ΕΚΦΡΑΣΗ_ΑΛΦΑΡΙΘΜΗΤΙΚΗ\r\nΑν δεν ξεκινάει η έκφραση από υπάρχουσα αλφαριθμητική μεταβλητή ή πίνακα, τότε επεξεργάζεται o διερμηνευτής την έκφραση και αφού κάνει έλεγχο ότι είναι λίστα σωρού τότε το τοποθετεί στο σωρό.\r\n\r\n5)  ΣΩΡΟΣ ΝΕΟΣ\r\n      ΑΔΕΙΑΣΕ\r\n      ΣΕΙΡΑ 1,2,3,4\r\n      ΣΩΡΟΣ ΝΕΟΣ {\r\n            ΒΑΛΕ 10,20\r\n            ΣΕΙΡΑ 1,2\r\n            ΣΩΡΟΣ\r\n      }\r\n      ΣΩΡΟΣ\r\n6) Μεταβλητή Τύπου Σωρού - Μπορούν να μπουν οπουδήποτε, σε πίνακες, σε καταστάσεις, σε αλλους σωρούς.\r\n    α=ΣΩΡΟΣ\r\n    α=ΣΩΡΟΣ:=1,2,3  ' ότι θέλουμε ακόμα και σωρό με (Σωρός:=1,2,3)\r\n    β=ΣΩΡΟΣ ΑΝΩ Α, 2  ' θα βάλει τα 1,2 στο β και θα αφήσει το 3 στο α\r\n    α=ΣΩΡΟΣ:=1,2,3\r\n    β=ΣΩΡΟΣ ΚΑΤΩ Α, 2  ' θα βάλει τα 2,3 στο β και θα αφήσει το 1 στο α\r\n    Τύπωσε β ' 2,3\r\n    α=ΣΩΡΟΣ:=!α,!β\r\n    Τυπωσε α   ' 1,2,3\r\n      \\\\ Χρήση του ! στο όρισμα για να περάσει το αντικείμενο σωρός ως ορίσματα στη συνάρτηση\r\n      Συνάρτηση β (α,β) {\r\n            =α**β\r\n      }\r\n      σ1=Σωρός:=3,2\r\n      σ2=Σωρός:=100,2\r\n      Τύπωσε β(2,4), β(!σ1) , β(!Σωρός(σ2))\r\n      Τύπωσε Μήκος(σ1), Μήκος(σ2)\r\n\r\n      \\\\ Παράδειγμα\r\n      Α=ΣΩΡΟΣ  \\\\  άδειος σωρός\r\n      ΣΩΡΟΣ Α { ΒΑΛΕ 1,2,3 }  '  3 2 1\r\n      ΣΩΡΟΣ Α { ΣΕΙΡΑ 1,2,3 }  '  3 2 1 1 2 3\r\n      ΑΔΕΙΑΣΕ ' Αδειάζουμε το σωρό του τμήματος\r\n      ΣΕΙΡΑ 1,2,3  ' βάζουμε στο σωρό του τμήματος  1 2 3\r\n      ΣΩΡΟΣ Α  ' Αδειάζουμε τον Α στο σωρό τμήματος 1 2 3 3 2 1 1 2 3\r\n      ΣΩΡΟΣ  ' Μας δείχνει το σωρό\r\n      Α=[]   ' νέος σωρός στον Α με ότι έχει ο σωρός τμήματος. Ο σωρός τμήματος άδειασε\r\n      Τύπωσε Α\r\n      ΣΩΡΟΣ ΣΩΡΟΣ(Α,3)  ' δίνουμε ένα αντίγραφο από τα τρία πρώτα\r\n      ΣΩΡΟΣ\r\n      ΤΥΠΩΣΕ Α   ' ο Α δεν άδειασε\r\n      ΑΔΕΙΑΣΕ\r\n      ΣΕΙΡΑ 1,2,3,4\r\n      Α=ΣΩΡΟΣ:=20,10,1,2\r\n      ΣΩΡΟΣ Α {\r\n            ΣΩΡΟΣ\r\n            ΠΕΤΑ 2\r\n            ΣΩΡΟΣ\r\n      }\r\n      ΣΩΡΟΣ\r\n      ΤΥΠΩΣΕ ΤΙΜΗΣΩΡΟΥ(Α), ΜΗΚΟΣ(Α)  \\\\ 1   2\r\n      ΣΩΡΟΣ Α {\r\n            ΔΙΑΒΑΣΕ Χ, Υ\r\n            ΓΙΑ ΑΥΤΟ {  \\\\ ΠΡΟΣΩΡΙΝΟΙ ΟΡΙΣΜΟΙ\r\n                  ΠΙΝΑΚΑΣ Μ(10)=5\r\n                  ΒΑΛΕ Μ()\r\n            }\r\n      }\r\n      Ν=ΣΩΡΟΣ(Α)  \\\\ ΑΝΤΙΓΡΑΦΟ\r\n      ΣΩΡΟΣ Ν {\r\n            ΓΙΑ ΑΥΤΟ {\r\n                  ΔΙΑΒΑΣΕ Κ  \\\\ ΠΙΝΑΚΑΣ ΣΕ ΜΕΤΑΒΛΗΤΗ\r\n                  Κ+=100\r\n                  ΒΑΛΕ Κ\r\n                  ΤΥΠΩΣΕ Κ  \\\\ ΟΛΑ 105\r\n                  ΣΩΡΟΣ Α {\r\n                        ΔΙΑΒΑΣΕ Μ()\r\n                        ΤΥΠΩΣΕ Μ()   \\\\ ΟΛΑ 5\r\n                  }\r\n                  ΤΥΠΩΣΕ ΜΗΚΟΣ(Α)  \\\\ 0\r\n            }\r\n      }\r\n      Α=ΣΩΡΟΣ:=\"ΑΛΦΑ\",\"ΒΗΤΑ\", 100\r\n      ΤΥΠΩΣΕ ΜΗΚΟΣ(Α), ΜΗΚΟΣ(Ν)  \\\\ 3 & 1\r\n      Ν=ΣΩΡΟΣ(Α,Ν)  \\\\ ΝΕΟΣ ΣΩΡΟΣ ΩΣ Α+Β\r\n      ΣΩΡΟΣ Ν {\r\n            ΣΩΡΟΣ    \\\\ ΜΑΣ ΔΕΙΧΝΕΙ ΤΙ ΣΤΟΙΧΕΙΑ ΕΧΕΙ\r\n      }\r\n      ΣΩΡΟΣ Α {\r\n            ΣΩΡΟΣ\r\n      }\r\n      Α=ΣΩΡΟΣ(Α,-3)  \\\\ ΑΝΑΣΤΡΟΦΗ, ΤΟ ΤΕΛΕΥΤΑΙΟ ΓΙΝΕΤΑΙ ΠΡΩΤΟ\r\n      ΣΩΡΟΣ Α {\r\n            ΣΩΡΟΣ   \\\\ ΜΑΣ ΔΕΙΧΝΕΙ ΤΙ ΣΤΟΙΧΕΙΑ ΕΧΕΙ\r\n      }\r\n      ΣΩΡΟΣ ΣΩΡΟΣ(Α,-2) {  \\\\ ΒΓΑΖΕΙ ΑΝΤΙΓΡΑΦΟ ΤΟΥ Α\r\n      \\\\ ΤΑ ΔΥΟ ΤΕΛΕΥΤΑΙΑ ΣΤΟΙΧΕΙΑ ΕΙΝΑΙ ΣΕ ΑΝΑΣΤΡΟΦΗ\r\n      \\\\ Ο Α ΠΑΡΑΜΕΝΕΙ ΩΣ ΕΧΕ\r\n            ΣΩΡΟΣ\r\n      }\r\n      ΣΩΡΟΣ Α {ΠΕΤΑ} \\\\ ΠΕΤΑΕΙ ΤΗ ΚΟΡΥΦΗ\r\n      Α=ΣΩΡΟΣ(Α,-ΜΗΚΟΣ(Α))\r\n      ΝΝ=ΚΑΘΕ(Α)\r\n      ΕΝΩ ΝΝ {\r\n            ΤΥΠΩΣΕ ΤΙΜΗΣΩΡΟΥ$(ΝΝ)\r\n      }\r\n      \r\n
EN:STACK$(\r\nα$={Παράγραφος 1\r\n      Παράγραφος2\r\n      }\r\n\\\\ Η σωρός$() βάζει τα αλφαριθμητικά με δείκτη μήκους\r\n\\\\ έτσι μπορεί να πάρει ότι θέλουμε στο αλφριθμητικό!\r\n\\\\ δεν παίρνει όμως αντικείμενα (χρησιμοποιούμε αντικείμενο σωρό, όπως το α,  για να περάσουμε αντικείμενα)\r\nβ$=Σωρός$(10, α$, 300)\r\nΤύπωσε Φάκελος$(β$)   ' NSN\r\nα=Σωρός\r\nΣωρός α {\r\n      \\\\ τροφοδοσία σωρού από αλφαριθμητικό φτιαγμένο από το Σωρός$()\r\n      \\\\ μπορούμε να πάρουμε μόνο αυτά που θέλουμε\r\n      \\\\ το β$ θα μειωθεί αυτόματα\r\n      Σωρός β$, \"NS\"\r\n      \\\\ ή τα παίρνουμε όλα με Σωρός β$\r\n}\r\n\r\nΑναφορά ΤιμήΣωρού$(α, 2)\r\nΣωρός β$\r\nΔιάβασε Κ\r\nΤύπωσε Κ\r\n\r\n\r\n
EN:STACK(\r\nα=Σωρός:=1,2,\"αλφα\",4,5\r\nβ=Σωρός:=6,7,8,9\r\nβ=Σωρός(α,β,α)\r\nΤύπωσε α\r\nΤύπωσε β\r\n\r\n
EN:STACKTYPE$(\r\nβ=(1,2,3,4)    \\\\ δείκτης σε αντικείμενο mArray\r\nΠίνακας β1(10)=1   \\\\ αντικείμενο mArray\r\n\\\\ στο σωρό μπαίνουν δείκτες προς τους πίνακες\r\nα=Σωρός:=1,\"hello\", β, β1()\r\nΣωρός α {\r\n      \\\\ η Σωρός αντικείμενο {}\r\n      \\\\ βάζει το αντικείμενο ως τρέχον σωρό\r\n      \\\\ και στην έξοδο βάζει τον παλιό στη θέση του!\r\n      Τύπωσε Φάκελος$()   ' NSAA πάντα στα αγγλικά\r\n      Τύπωσε Ταύτιση(\"NSAA\")   \\\\ αγγλικά γράμματα\r\n      Τύπωσε Ταύτιση(\"ΑΓΠΠ\")  \\\\ ελληνικά γράμματα\r\n}\r\n\r\nδ=Κάθε(α)  \\\\ Επαναλήπτης\r\nΕνώ δ {\r\n      Τύπωσε ΣωρούΤύπος$(δ)   \\\\ Τυπώνει ονόματα Number, String, mArray, mArray\r\n}\r\nΤύπωσε ΣωρούΤύπος$(α, 2)\r\nΤύπωσε ΤιμήΣωρού(α,1), ΤιμήΣωρού(α)\r\nΤύπωσε ΤιμήΣωρού$(α, 2)\r\nΤύπωσε ΤιμήΣωρού(α, 3) ' 1 2 3 4\r\nΤύπωσε Πίνακας(ΤιμήΣωρού(α, 3), 3)   ' 4\r\nΤύπωσε ΤιμήΣωρού(α, 4) ' 1 1 1 1 1 1 1 1 1 1\r\n\r\n
EN:SAVE\r\nΑπό την έκδοση 9 σώνει τα επιπέδου 0 (γενικά) τμήματα και συναρτήσεις ως γενικά. Εκτός και αν χρησιμοποιήσουμε το Σώσε Τοπικά\r\nΑπό την έκδοση 7 σώνει σε utf-8, ενώ διατητεί την παλιά κωδικοποίση στα παλιά αρχεία. Επίσης μετονομάζει το παλιό αρχείο πριν γράψει το νέο με το ίδιο όνομα, με αλλαγή κατάληξης  bck\r\n\r\n1) Απλό σώσιμο όλων των τμημάτων στον δίσκο\r\nΣΩΣΕ ΤΟΠΙΚΑ  ονομα\r\nΣΩΣΕ ονομα \r\nΣΩΣΕ \"ονομα με διαστήματα\"\r\n  στον τρέχον κατάλογο σώνουμε το ονομα.gsb\r\n2) Όπως η (1) αλλά να τρέχει απ' ευθείας ένα τμήμα αμέσως μετά την φόρτωση\r\nΣΩΣΕ ονομα, τμημα1\r\n3) Όπως τα (1) και  (2) αλλά κωδικοποιημένα με το βασικό κλειδί, έτσι ώστε να μην εμφανίζει τα περιεχόμενα των τμημάτων.\r\n ΣΩΣΕ ονομα  @, τμημα1\r\n ΣΩΣΕ ονομα  @\r\n4) Όπως το (1) αλλά κωδικοποιημένο με δικό μας κωδικό\r\nΣΩΣΕ \"ονομα\" @@ \"ΚΩΔΙΚΟΣΜΟΥ\"\r\n    Ακόμα και να φορτώσουμε ένα τέτοιο τμήμα αυτό δεν αναγνωρίζεται εάν στην εντολή φόρτωσης δεν δώσουμε τον κατάλληλο κωδικό ΚΩΔΙΚΟΣΜΟΥ\r\n    \r\n 
EN:SAVE.DOC\r\nΣΩΣΕ.ΕΓΓΡΑΦΟ έγγραφο$,  όνομα_αρχείου$, τυπος_αρχείου\r\nτύπος αρχείου:\r\n0 UTF-16LE\r\n1 UTF-16BE\r\n2 UTF-8 \r\n3 ANSI\r\nεξ ορισμού είναι Utf-8\r\n\r\n\\\\ εδω αν υπάρχει αρχείο name1.txt θα \"πατηθεί\" από νέο αρχείο\r\n\\\\ με ίδιο όνομα αλλά με κενό περιεχόμενο\r\nΈγγραφο αλφα$={Μια μόνο παράγραφος\r\n}\r\nΣώσε.Έγγραφο αλφα$,\"name1.txt\"\r\n\\\\ έστω μια άλλη φορά ή σε άλλο πρόγραμμα:\r\n\\\\ θέλουμε να προσθέσουμε\r\nΈγγραφο βήτα$={Μια άλλη παράγραφος\r\n}\r\nΑν Υπάρχει(\"name1.txt\") τότε {\r\nΠρόσθεσε.Έγγραφο βήτα$,\"name1.txt\"\r\n} αλλιώς {\r\nΣώσε.Έγγραφο βήτα$,\"name1.txt\"\r\n}\r\n\\\\ τώρα διαβάζουμε όλο μαζί\r\nΈγγραφο καππα$\r\nΦόρτωσε.Έγγραφο καππα$, \"name1.txt\"\r\nΑναφορά καππα$\r\n\r\n
EN:MOVIE, MEDIA\r\nΌπως και η ΜΟΥΣΙΚΗ μπορεί να εκτελεί σύγχρονα ή ασύγχρονα ταινίες (με αναμονή του προγράμματος ή όχι)\r\nΕπίσης υπάρχουν:\r\nΗ μεταβλητή ΤΑΙΝΙΑ (ΑΛΗΘΕΣ αν παίζει ή ΨΕΥΔΕΣ αν έχει τελειώσει)\r\nΗ μεταβλητή ΔΙΑΡΚΕΙΑ\r\nΑν κάνουμε απλό αριστερό κλικ του ποντικιού πάνω στην ταινία τότε αυτή κλείνει αμέσως.\r\n1) Ασύγχρονη λειτουργία\r\nΤΑΙΝΙΑ αρχειο1$, αρχειο2$\r\nΤΑΙΝΙΑ   (κλείνει αμέσως την ταινία)\r\n      \r\n2) Σύγχρονη λειτουργία\r\nΤΑΙΝΙΑ αρχειο1$, αρχειο2$;\r\n\r\n3) Προβολή με αλλαγή μεγέθους και θέσης\r\nΜέχρι την έκδοση 2.1 οι ταινίες έβγαιναν στο κέντρο της οθόνης και στο μέγεθος που είχαν αρχικά.\r\nΤΑΙΝΙΑ θεσηΧ, θεσηΥ, ταινια$\r\nΤΑΙΝΙΑ θεσηΧ, θεσηΥ, πλατος, ταινια$\r\nΤΑΙΝΙΑ θεσηΧ, θεσηΥ, πλατος, υψος, ταινια$\r\nΤα θεσηΧ, θεσηΥ έχουν σχέση με το Παραθυρο\r\nΑν θέλουμε να τα κάνουμε σχετικά με το επιπεδο που τυπώνουμε τότε πρέπει να προσθέτουμε τα κινηση.χ και κινηση.ψ\r\nΑν μετακινηθεί το επίπεδο...δεν μετακινείται η ταινία μαζί,πρέπει να δώσουμε εντολή για να μετακινηθεί. Δες νέες εντολές:\r\nΤΑΙΝΙΑ θεσηΧ, θεσηΥ\r\nΤΑΙΝΙΑ θεσηΧ, θεσηΥ, πλατος, υψος  (από την έκδοση 6 μπορούμε να αλλάξουμε μέγεθος στην ταινία όποτε θέλουμε, καθορίζοντας διαφορετική αναλογία πλάτους με ύψος αλλάζουμε το πώς βλέπουμε την ταινία π.χ. 16/9 ή 4/3\r\nΜπορούμε να δώσουμε και άλλες ταινίες να παίζουν σε σειρά αλλά όλες θα βγουν στο ίδιο μέγεθος και θέση.\r\n\r\nΑπό την έκδοση 6 έχει επεκταθεί η λειτουργία της εντολής!\r\nΕδώ είναι ένα πρόγραμμα που ανοίγει μια ταινία και τυπώνει δυο καρέ από αυτήν.\r\nMOVIE LOAD \"SECOND\"  ' φορτώνει την ταινία σε κατάσταση παύσης\r\nMOVIE TO 2                          ' στο 2 δευτερόλεπτο (μπορούμε να δώσουμε δεκαδικά)\r\nMOVIE 1000+motion.x,1000+motion.y             ' βάζει το παράθυρό στο 1000,1000 του επιπέδου που τυπώνουμε\r\nMOVIE SHOW                      ' Μας δείχνει την ταινία (είναι σε παύση)\r\nA$=GRABFRAME$             ' αντιγράφει το καρέ (μονο αν βλέπουμε την ταινία)\r\nCOPY 1000,1000 USE A$ ' αντιγράφουμε το καρέ πίσω ακριβώς από την ταινία (η οποία εμφανίζεται σε δικό της επίπεδο)\r\nMOVIE HIDE                         ' τώρα κρύβουμε την ταινία \r\n                                                 '(αλλά δεν το καταλαβαίνουμε γιατί βλέπουμε την ίδια εικόνα από πίσω τυπωμένη)\r\nMOVIE TO 3                         ' πάμε στο τρίτο δευτερόλεπτο\r\nMOVIE 5000+motion.x,1000+motion.y             ' καθορίζουμε άλλη θέση (μπορούμε να αλλάξουμε και το ύψος και πλάτος)\r\nMOVIE SHOW                     ' εμφανίζουμε το καρέ\r\nA$=GRABFRAME$            ' το καταχωρούμε \r\nCOPY 5000,1000 USE A$ ' και το τυπώνουμε\r\nMOVIE                                    ' κλείνουμε την ταινία\r\n\r\nΕντολές:\r\nMOVIE LOAD \"FILENAME OR PATH AND FILENAME\"\r\nMOVIE PLAY\r\nMOVIE PAUSE\r\nMOVIE HIDE\r\nMOVIE SHOW\r\nMOVIE RESTART\r\nMOVIE TO 0.01\r\n\r\nΤΑΙΝΙΑ ΦΟΡΤΩΣΕ \"SECOND\"  'ΥΠΑΡΧΕΙ ΤΟ ΑΡΧΕΙΟ SECOND.AVI ΣΤΟΝ ΚΑΤΑΛΟΓΟ ΚΑΤ$\r\nΤΑΙΝΙΑ ΠΑΙΞΕ\r\nΤΑΙΝΙΑ ΚΡΑΤΗΣΕ\r\nΤΑΙΝΙΑ ΚΡΥΨΕ\r\nΤΑΙΝΙΑ ΔΕΙΞΕ\r\nΤΑΙΝΙΑ ΞΕΚΙΝΑ\r\nΤΑΙΝΙΑ ΣΤΟ 0.01\r\n      \r\n\r\nΌταν είναι σε κατάσταση Play τότε η ταινία θα κλείσει στο πέρας. Σε κατάσταση Restart στο πέρας δεν κλείνει, πρέπει να τη κλείσουμε με MOVIE. Επίσης στην κατάσταση Play με κλικ στην ταινία κλείνει. Σε κατάσταση Restart με κλικ σταματάει αν έπαιζε η ταινία ή ξεκινάει αν ήταν σταματημένη. \r\n\r\nMovie 1.2  είναι ίδιο με Movie to 1.2\r\nMovie 0 είναι ίδιο με Movie Restart (και όχι με Movie to 0)\r\nMovie -1 είναι ίδιο με Movie Pause\r\nΠως ελέγγχουμε αν μια ταινία έχει φορτωθεί;\r\nΑν έχει φορτωθεί ταινία τότε έχει Διαρκεια  Duration\r\nΤυπωσε Διαρκεια\r\nΑν μια ταινία παίζει σε κατάσταση PLAY τότε δίνει στο MOVIE το -1\r\nΑλλά μπορεί να  τρέχει μουσική στο περιθώριο και τότε να έχουμε πάλι το ίδιο αποτέλεσμα\r\nΤυπωσε ΤΑΙΝΙΑ, ΤΑΙΝΙΑ.ΜΕΤΡΗΤΗΣ\r\nΗ μεταβλητή ΤΑΙΝΙΑ.ΜΕΤΡΗΤΗΣ μας δίνει το δευτερόλεπτο (και τα δεκαδικά του) που εκείνη τη στιγμή δείχνει η ταινία.\r\nΑν δεν έχουμε φορτώσει ταινία τότε ο μετρητής είναι στο -1\r\nΜπορεί να εκμεταλλευθεί κανείς την μεταβλητή αυτή για να φτιάξει σημεία επιστροφής, ή αλλιώς κεφάλαια!\r\n\r\n\r\n
EN:MOVIE.COUNTER\r\nΔίνει -1 αν δεν υπάρχει ταινία!\r\nΔίνει το μετρητή (ανά χιλιοστό δευτερολέπτου)\r\nΓια όλη τη διάρκεια δες το ΔΙΑΡΚΕΙΑ\r\n
EN:MOVIE_as variable\r\nΔίνει ΑΛΗΘΕΣ όταν έχουμε κάποια ταινία ή ένα μουσικό κομμάτι σε εκτέλεση.\r\nσυνώνυμα MEDIA, ΜΟΥΣΙΚΗ\r\n
EN:MOVIES\r\nΤΑΙΝΙΕΣ\r\nΜας δίνει όλα τα αρχεία τύπου avi  στον τρέχον κατάλογο\r\nΊδιο με το ΑΡΧΕΙΑ \"avi\"\r\n\r\nΚΑΤΑΛΟΓΟΣ \"C:\"\r\nΤΑΙΝΙΕΣ\r\nΑΡΧΕΙΑ \"avi\"\r\n\r\n\r\n
EN:ORDER\r\nΤΑΞΗ κ$, \"ΛΟΓΑΡΙΑΣΜΟΙ\", \"ΤΙΤΛΟΣ\", ΑΥΞΟΥΣΑ\r\n\r\nΜπορούμε να δηλώσουμε και ΦΘΙΝΟΥΣΑ και μέχρι δέκα πεδία συνολικά\r\nΧρειάζεται μόνο μια φορά να δηλωθεί η τάξη\r\nΑν δεν δώσουμε πεδία τότε διαγράφουμε την ταξινόμηση για αυτόν τον πίνακα (εδώ ΛΟΓΑΡΙΑΣΜΟΙ)\r\n\r\n\r\n
EN:ORDER(\r\nΤύπωσε Τάξη(\"ΑΛΦΑ1232\",\"ΑΛΦΑ800\")\r\n\r\nκάνει σύγκριση με υπολογισμό των αριθμών μέσα στο αλφαριθμητικό. Εδώ θα δώσει 1, δηλαδή το πρώτο είναι μεγαλύτερο.\r\nδίνει -1 όταν είναι το δεξιό μεγαλύτερο, και μηδέν αν είναι ίσα. Μπορούμε να έχουμε αριθμούς ανάμεσα από γράμματα, και όσο βρίσκει ίδια γράμματα κάνει ταξινόμηση βάση αριθμού. Η συγκριμένη συνάρτηση χρησιμοποιείται στην Κατάσταση για ταξινόμη ως αριθμός.\r\n\r\n
EN:SORT\r\nΓια έγγραφα και καταστάσεις και πίνακες\r\n\r\nΤΑΞΙΝΟΜΗΣΗ [φθίνουσα] έγγραφο$ [, αρχή, τέλος [, θέση για αρχή σύγκρισης]]\r\nΣτα έγγραφα ο εξ ορισμού τρόπος σύγκρισης είναι η σύγκριση ως κείμενο.\r\nΜπορεί να θέλουμε όμως μια ειδική περίπτωση όπου έχει σημασία η γλώσσα στη ταξινόμηση, και ο στανταρ τρόπος να μην είναι αυτό που θέλουμε!\r\nΜπορούμε να επέμβουμε με εντολή Μέθοδο (το έγγραφο είναι αντικείμενο)\r\n\r\n\r\n\r\n1)\r\n\\\\ χρησιμοποίησε κάποιο πλήκτρο γιατί η Αναφορά σταματάει το κείμενο για να διαβαστεί!\r\nΈγγραφο άλφα$={ένα\r\n      δύο\r\n      τρία\r\n      τέσσερα\r\n      πέντε\r\n      έξι\r\n      επτά\r\n      οκτώ\r\n      εννιά\r\n      δέκα\r\n      } \r\nΤαξινόμηση άλφα$, 1, 10\r\nΑναφορά άλφα$\r\nΤύπωσε \"***************\"\r\nΤαξινόμηση φθίνουσα άλφα$, 1, 10\r\nΑναφορά άλφα$\r\nΤύπωσε \"***************\"\r\nΤαξινόμηση άλφα$, 1, 5\r\nΑναφορά άλφα$\r\n\r\nΕδώ αλλάζουμε το τρόπο σύγκρισης. Υπάρχουν τέσσερις επιλογές SetTextCompare (default), SetBinaryCompare, SetDatabaseCompare και η τελευταία που παρουσιάζεται εδώ και είναι η μόνη που δέχεται προεραιτικά τιμή (αν δεν δώσουμε θα πάρει την διαθέσιμη τιμή τοπικού αναγνωριστικού (πχ το έχουμε δώσει στη φόρτωση από το αρχείο).)\r\n\r\nΈγγραφο α$={péché\r\n            sin\r\n            peach\r\n            pêche\r\n            }\r\nΤύπωσε \"Με 1036 Γαλλικά\"\r\nΜέθοδος α$, \"SetLocaleCompare\", 1036\r\nΤαξινόμηση Αύξουσα α$, 1,4\r\nΑναφορά α$\r\nΤύπωσε \"Με 1033 Αγγλικά\"\r\nΜέθοδος α$, \"SetLocaleCompare\", 1033\r\nΤαξινόμηση Αύξουσα α$, 1,4\r\nΑναφορά α$\r\n\r\n\r\n2)\r\nΈγγραφο α$={1234βήτα\r\n      4567άλφα\r\n      1212ζήτα\r\n      9921έψιλον\r\n      }\r\nΤαξινόμηση φθίνουσα α$, 1,4, 5\r\nΑναφορά α$\r\n3)\r\nΤαξινόμηση Άυξουσα inventory1 ως κείμενο\r\nΤαξινόμηση Φθίνουσα inventory1 ως κείμενο\r\nΤαξινόμηση Άυξουσα inventory1 ως κείμενο, τρόπος\r\nΤαξινόμηση Φθίνουσα inventory1 ως κείμενο, τρόπος\r\nΤρόπος:\r\n0 Σύγκριση Δυαδική\r\n1 Σύγκριση Κειμένου\r\n2 Σύγκριση βάσεων δεδομένων\r\nαριθμός τοπικού (πχ 1032 είναι τα ελληνικά)\r\n\r\nΤαξινόμηση Άυξουσα inventory1 ως αριθμός\r\nΤαξινόμηση Φθίνουσα inventory1 ως αριθμός\r\nΤαξινόμηση inventory1 ως κείμενο, 1\r\nΤαξινόμηση inventory1 ως κείμενο, 0\r\nΤαξινόμηση Inventory1 ως αριθμός, 1\r\nΤαξινόμηση inventory1 ως αριθμός, 0\r\n\r\n\r\n\r\nΚατάσταση  α=\"sin\",\"pêche\",\"péché\",\"peach\"\r\nΤαξινόμηση α ως κείμενο, 1\r\nΤύπωσε α, \"κανονική αύξουσα\"\r\nΤαξινόμηση α ως κείμενο, 0\r\nΤύπωσε α, \"κανονική φθίνουσα\"\r\nΤαξινόμηση αύξουσα α ως κείμενο, 1036\r\nΤύπωσε α, 1036\r\nΤαξινόμηση αύξουσα α ως κείμενο, 1033\r\nΤύπωσε α, 1033\r\n\r\n\r\n\r\n
EN:SORT(DOCUMENT)\r\nΔες ΤΑΞΙΝΟΜΗΣΗ\r\n\r\n
EN:MATCH(\r\n> Βάλε \"αλφα\",1,2\r\n> Τύπωσε Ταύτιση(\"αα\")\r\n      -1\r\n> Τύπωσε Ταύτιση(\"ααγ\")\r\n     -1\r\n> Τύπωσε Φάκελος()\r\nNNS               εδώ εξάγει πάντα κεφαλαία και στα αγγλικά, για όλα όμως τα στοιχεία του σωρού\r\n          \r\nΗ συνάρτηση Ταυτιση() κοιτάει από το παρεχόμενο αλφαριθμητικό αν ανιστοιχεί ο τύπος στο σωρό στην  αντίστοιχη θέση ξεκινώντας από την κορυφή.\r\nΤο αλφαριθμητικό παίρνει τα παρακάτω(μικρά ή μεγάλα):\r\n[Α]ριθμός, [Ο]μάδα, Γ[Ε]γονός, [Δ]ιάρθρωση, [Κ]ατάσταση, [Π]ίνακας,[Λ]άμδα, [Γ]ράμματα, [Σ]ωρός\r\nτο Γ είναι για τα αλφαριθμητικά.\r\n\r\nΆδειασε \\\\ αδειάζει το σωρό\r\nΠίνακας Α(10)\r\nΚατάσταση Αλφα=1,2,3\r\nΔιάρθρωση Κενή Βήτα ως Μακρύς *10\r\nΟμάδα Δέλτα {Χ=10}\r\nΛ=Λάμδα->100\r\nΣυνάρτηση Ζήτα {=100}\r\nΓεγονός Κ {Διάβασε Χ}\r\nΑ=Σωρός:=1,2,\"οκ\",3\r\nΒάλε \"οκ\", Λ ,Α(), Αλφα, Βήτα,Κ, Δελτα, Ζήτα(), Σωρός(Α)\r\nΤύπωσε Μέγεθος.Σωρού\r\nΣωρός\r\nΤύπωσε Φάκελος$(), Ταύτιση(\"CNGEBIAFS\"), Ταύτιση(\"ΣΑΟΕΔΚΠΛΓ\")\r\n\r\nδες Match( για τα αγγλικά γράμματα      \r\n      \r\n
EN:OPERATORS\r\nΓια αντικείμενα μόνο\r\nΕΙΝΑΙ\r\nδείκτης αντικειμένου ΕΙΝΑΙ δείκτης αντικειμείνου, δείκτης αντικειμένου ΕΙΝΑΙ ΤΙΠΟΤΑ\r\nΓια ομάδες\r\nδείκτης_ομάδας ειναι δείκτης_ομάδας, δείκτης_ομάδας ειναι ομάδα\r\n(δεν ισχύει το ομάδα είναι ομάδα)\r\n\r\nΑριθμητικοί Τελεστές\r\nτο -3^2 δίνει το 9, το 0-3^2 δίνει το -9\r\n+ - * /\r\n^ ** ύψωση σε δύναμη\r\nΔια\r\nΔια#  (Ευκλείδεια διαίρεση)\r\nΥπόλοιπο Υπόλ\r\nΥπόλοιπο# Υπόλ# (Εκλείδειο υπόλοιπο)\r\n< > <> <= >= = == \r\n<=> (τελεστής διαστημόπλοιο, δίνει μια από τρεις τιμές 1, 0, -1)\r\nΗ ΚΑΙ  ΑΠΟ ΟΧΙ  (OR AND XOR NOT)\r\n(,)  κενός πίνακας\r\n(1,) πίνακας ενός στοιχείου\r\n(1,2) πίνακας δυο στοιχείων\r\n\r\nΤελεστές για μεταβλητές (πχ Α++ ως μια εντολή)\r\nΔεν ισχύουν για ιδιότητες ομάδων  (όχι μεταβλητές ομάδων) πρέπει να ορίσουμε τους τελεστές\r\n+=\r\n-=\r\n*=\r\n/= \r\n-!  αλλαγή προσήμου\r\n~ \\\\ ψευδές <-> αληθές\r\n++\r\n--\r\nΤελεστές για Αλφαριθμητικά\r\n+\r\n< > <> <= >= =\r\n~ ( όπως η Like στη VB6)\r\n<=> (τελεστής διαστημόπλοιο, δίνει μια από τρεις τιμές 1, 0, -1)\r\n\r\n\r\n
EN:END\r\nΤΕΛΟΣ\r\nΤερματίζει την λειτουργία του μεταφραστή.\r\nΠαρατήρηση\r\nΗ εντολή ΤΕΛΟΣ είναι κατανοητή μόνο από τον μεταφραστή γραμμής και όχι από τον μεταφραστή τμημάτων. Για να εκτελέσουμε όμως την εντολή αυτή μέσα από ένα τμήμα τότε πρέπει έμμεσα να στείλουμε την εντολή αυτή με την εντολή ΘΕΣΕ\r\nΘΕΣΕ ΤΕΛΟΣ\r\n\r\n
EN:EOF(\r\nΔέχεται ως όρισμα τον αριθμό ενός ανοιχτού αρχείου και δίνει ΑΛΗΘΕΣ αν η προηγούμενη ενέργεια διαβάσματος του αρχείου έφθασε στο τέλος αυτού.\r\n\r\n
EN:TICK\r\nΔίνει τον αριθμό τικ (παλμών) του συστήματος των νημάτων. Όσο είναι μηδέν σημαίνει ότι κανένα νήμα δεν έχει τρέξει.\r\n\r\nΌρισε ρολοι Από \"winmm.timeGetTime\" {}\r\nΓια ι=1 έως 100 {\r\n      Τύπωσε ρολοι()\r\n}\r\n\r\n
EN:NUMBER\r\nΣηκώνει την αριθμητική τιμή της κορυφής του σωρού (και την διώχνει από εκεί). Αν είναι ο σωρός είναι  κενός ή έχει λέξη και όχι αριθμό στην κορυφή τότε βγαίνει λάθος. Λέμε \"σηκώνει\" γιατί την αφαιρεί από το σωρό.\r\nσυνώνυμο ΑΡΙΘΜΟΣ\r\nΜπορούμε να σηκώσουμε πίνακα ή ομάδα με τα Πίνακας και Ομάδα ως μεταβλητές μόνο για ανάγνωση\r\nΜπορούμε να πάρουμε Κατάσταση ή Αντικείμενο σωρό από το σωρό με την ΤιμήΣωρού() ή ΤιμήΣωρού(1) (είναι το ίδιο)\r\nΜετά με την Πέτα πετάμε την κορυφή.\r\n\r\nΜπορούμε να γνωρίζουμε με την Ταύτιση() αν υπάρχουν συγκεκριμένοι τύποι τιμών στο σωρό\r\nΜπορούμε με την ΣωρούΤύπος$() να διαβάζουμε το τύπο (περιφραστικά στα αγγλικά)\r\nΜπορούμε με την Φάκελος$() να πάρουμε ένα αλφαριθμητικό με γράμμα σε  κάθε θέση στο σωρό, που δείχνει τον τύπο του.\r\n\r\n
EN:VAL(\r\nσυνώνυμο ΑΞΙΑ(\r\n1) Με αλφαριθμητική παράσταση\r\nΤΥΠΩΣΕ ΤΙΜΗ(\"123\")\r\nΤΥΠΩΣΕ ΤΙΜΗ(\"1 2 3\")=123\r\nΤΥΠΩΣΕ ΤΙΜΗ(\"123.233\")\r\nΤΥΠΩΣΕ ΤΙΜΗ(\"123,233\", \",\")\r\nΤΥΠΩΣΕ ΤΙΜΗ(\"123-233\", \"-\")\r\nΤΥΠΩΣΕ ΤΙΜΗ(\"123,233\", 0)\r\nΤΥΠΩΣΕ ΤΙΜΗ(\"123,233\", 1032)\r\nΤΥΠΩΣΕ ΤΙΜΗ(\"123.233\", 1033)\r\n2) Με αριθμητική παράσταση\r\n\\\\ Χρησιμοποίησέ το για αλλαγές τύπου\r\nΚάνε ΤύποςΠαράστασης$(Ν)=Τύπος$(Ν)\r\nΤύπωσε ΤύποςΠαράστασης$(10)    ' Double\r\nΤύπωσε ΤύποςΠαράστασης$(Τιμή(10->0@))    ' Decimal\r\nΤύπωσε ΤύποςΠαράστασης$(Τιμή(10->0#))    ' Currency\r\nΤύπωσε ΤύποςΠαράστασης$(Τιμή(10->0&))    ' Long\r\nΤύπωσε ΤύποςΠαράστασης$(Τιμή(10@))    ' Double\r\nΤύπωσε ΤύποςΠαράστασης$(Τιμή(10#))    ' Double\r\nΤύπωσε ΤύποςΠαράστασης$(Τιμή(10&))    ' Double\r\nΤύπωσε ΤύποςΠαράστασης$(Τιμή(10#->0@))    ' Decimal\r\nΤύπωσε ΤύποςΠαράστασης$(Τιμή(10&->0@))    ' Decimal\r\nΤύπωσε ΤύποςΠαράστασης$(Τιμή(10@->0#))    ' Currency\r\nΤύπωσε ΤύποςΠαράστασης$(Τιμή(10&->0#))    ' Currency\r\nΤύπωσε ΤύποςΠαράστασης$(Τιμή(10@->0&))    ' Long\r\nΤύπωσε ΤύποςΠαράστασης$(Τιμή(10#->0&))    ' Long\r\n\r\nαντί για μηδέν και σύμβολο μπορούμε να χρησιμοποιήσουμε ονόματα όπως:\r\nΑριθμός (Decimal)\r\nΛογιστικό (Currency)\r\nΔιπλός (Double)\r\nΑπλός (Single)\r\nΜακρύς (Long)\r\nΛογικός (Boolean)  ' μόνο έτσι υπάρχει για μετατροπή, αλλιώς κάνουμε το (παράσταση)<>0 το οποίο δίνει αληθές για μη μηδενική τιμή.\r\n\r\nΑ=Τιμή(Β->λογιστικό)\r\n\r\n3) Επιστροφή μήκους όπου υπάρχει ο αριθμός στην αρχή του αλφαριθμητικού, ή -1 αν δεν υπάρχει\r\nΣυνάρτηση Αριθμός(α$) {\r\n      Κάνε β\r\n      =Τιμή(Ψευδές->Λογικός)\r\n      Δες {\r\n            Αν ΕινΓρ Τότε {\r\n                  z=Τιμή(α$,γράμμα$, β)\r\n            } Αλλιώς.Αν ΕινΑρ Τότε {\r\n                  z=Τιμή(α$,αριθμός, β)\r\n            } Αλλιώς z=Τιμή(α$,\"\", β)\r\n            =β>Μήκος(α$)\r\n      }\r\n}\r\nΣυνάρτηση ΑκέραιοςΑριθμός(α$) {\r\n      Κάνε β\r\n      =Τιμή(Ψευδές->Λογικός)\r\n      Δες {\r\n            z=Τιμή(α$,\"Ακ\", β)\r\n            =β>Μήκος(α$)\r\n      }\r\n}\r\nΤύπωσε ΑκέραιοςΑριθμός(\"1221213123213\")=Αληθές\r\nΤύπωσε ΑκέραιοςΑριθμός(\"1221213.123213\")=Ψευδές\r\nΤύπωσε Αριθμός(\"123131232131231231.23123123\")=Αληθές\r\nΤύπωσε Αριθμός(\"-123131232131231231.23123123e112\")=Αληθές\r\nΤύπωσε Αριθμός(\"-123131232131231231.23123123e112\", \",\")=Ψευδές\r\nΤύπωσε Αριθμός(\"-123131232131231231.23123123e112\", 1036)=Ψευδές\r\nΤύπωσε Αριθμός(\"-123131232131231231.23123123e112\", 1033)=Αληθές\r\nΤύπωσε Τιμή(\"233.44sec\", 1033)=233.44\r\nα$=\"233.44sec\"\r\nβ=0\r\nΤύπωσε Τιμή(α$, 1033, β)=233.44\r\nΑν β>0 Τότε Τύπωσε Mid$(α$, β)=\"sec\"\r\n\\\\ οποιοδήποτε αλφαριθμητικό με μήκος >1 για χαρακτήρα δεκαδικών εξαιρεί τα δεκαδικά.\r\nΤύπωσε Τιμή(α$, \"??\", β)=233\r\nΑν β>0 Τότε Τύπωσε Mid$(α$, β)=\".44sec\"\r\n\r\n\r\n\r\n\r\n
EN:STACKITEM$(\r\nΒΑΛΕ \"ΑΛΦΑ\",\"ΒΗΤΑ\"\r\nΤΥΠΩΣΕ ΤΙΜΗΣΩΡΟΥ$(), ΤΙΜΗΣΩΡΟΥ$(2)\r\nΒΗΤΑ         ΑΛΦΑ\r\n\r\nαν δεν υπάρχει στην θέση τιμή τότε παίρνουμε λάθος\r\nαν δεν υπάρχει αλφαριθμητικό - λέξη- στη θέση που ζητάμε τότε παίρνουμε λάθος\r\n\r\nΔουλεύει και για αντικείμενο σωρού\r\n\r\nα=Σωρός\r\nΣωρός α {\r\n      Σειρά \"άλφα\", \"βήτα\"\r\n}\r\nΤύπωσε τιμήσωρού$(α), τιμήσωρού$(α,2)\r\n\\\\ old Σωρός deleted an α show new one\r\nα=Σωρός:=\"άλφα1\", \"βήτα1\"\r\nΤύπωσε τιμήσωρού$(α), τιμήσωρού$(α,2)\r\nΆδειασε  \\\\ Αδειάζει τον τρέχον σωρό\r\nΣειρά \"αλφα2\", \"βήτα2\"\r\nα=[]   \\\\ το α δείχνει παίρνει τον δείκτη του τρέχοντα σωρού και ο τρέχον σωρός παίρνει νέο αντικείμενο\r\nΤύπωσε Κενό  \\\\ -1 σημαίνει αληθές\r\nΤύπωσε τιμήσωρού$(α), τιμήσωρού$(α,2)\r\nΣειρά \"ένα ακόμα\"  \\\\ στον τρέχον σωρό\r\nΣωρός α     \\\\ τώρα το α είναι κενό και ο τρέχον σωρός πήρε τα στοιχεία του α στο τέλος\r\nΤύπωσε Μήκος(α)  ' 0\r\nΤύπωσε Μέγεθος.Σωρού ' 3\r\nΣωρός  \\\\ μας δείχνει τα στοιχεία του στη κονσόλα\r\nΔιάβασε α1$, α2$, α3$\r\nΤύπωσε Κενό  \\\\ -1 σημαίνει αληθές\r\nα=Σωρός:=α1$, α2$, α3$\r\nΤύπωσε Μήκος(α)  ' 3\r\n\r\n\r\n
EN:STACKITEM(\r\nΒΑΛΕ 1,2,3\r\nΤΥΠΩΣΕ ΤΙΜΗΣΩΡΟΥ(2), ΤΙΜΗΣΩΡΟΥ()\r\n2      3\r\nτιμησωρου(1) είναι η κορυφή του σωρού και είναι ίδιο όπως τιμησωρου()\r\n\r\nΑν δεν υπάρχει τιμή στη θέση που ζητάμε τότε έχουμε λάθος\r\nΑν δεν υπάρχει η θέση που ζητάμε τότε έχουμε λάθος\r\n\r\nχρησιμεύει με την ΠΕΤΑ, το ΜΕΓΕΘΟΣ.ΣΩΡΟΥ και την ΤΙΜΗΣΩΡΟΥ$() για να φτιάχνουμε πλαίσια παραμέτρων στο σωρό.\r\n\r\n
EN:TITLE\r\nΤΙΤΛΟΣ \"παράδειγμα της Μ2000\" είναι ίδιο με ΤΙΤΛΟΣ \"παράδειγμα της Μ2000\",1\r\nΤΙΤΛΟΣ \"Αλλος\", 0\r\n\r\nΕμφανίζει στην γραμμή εργασιών (δίπλα στο ΕΝΑΡΞΗ) ένα πλαίσιο που περιέχει τον τίτλο που δώσαμε και το εικονίδιο της Μ2000. Μπορούμε να αλλάξουμε το εικονίδιο, δες ΕΙΚΟΝΙΔΙΟ.\r\nΤο πλαίσιο που εμφανίζεται είναι χρήσιμο γιατί:\r\n1) Μας επαναφέρει στην Μ2000 μετά από εναλλαγή προγραμμάτων με τα alt και tab\r\n2) Μετά από επιλογή του μας εμφανίζει αμέσως την Μ2000\r\n3) Μας δίνει την δυνατότητα με άνοιγμα του σχετικής λίστας επιλογών (δεξί κλικ πάνω στο πλαίσιο) να κλείσουμε αμέσως την γλώσσα\r\n4) Επιπλέον από την έκδοση 6.2.3 μπήκε και μια δεύτερη παράμετρος για Ελαχιστοποίηση στο πλαίσιο. Με 0 έχουμε μόνο το πλαίσιο στη γραμμή εργασιών και εξαφανίζουμε το παράθυρο του Περιβάλλοντος! Με 1 το εμφανίζουμε. Οι διάλογοι άνοιγμα αρχείου και σώσιμο, καθώς και επιλογή χρώματος, γραμματοσειράς, ιδιότητες εκτυπωτή, εμφανίζονται και χωρίς το περιβάλλον να εμφανίζεται! Το ίδιο επίσης ισχύει και για το ΡΩΤΑ( ή ASK(\r\n5) Μπορούμε από το πλαίσιο, στη σχετική λίστα να επιλέξουμε Ελαχιστοποίηση ή Επαναφορά.\r\nΜπορούμε κατά βούληση να αλλάζουμε τον τίτλο και το εικονίδιο. Επίσης με μια επανάληψη της εντολής χωρίς όρισμα αφαιρούμε το πλαίσιο αυτό. Αν αφαιρέσουμε το πλαίσιο τότε αν το περιβάλλον είχει αποκρυφτεί θα εμφανιστεί.\r\n\r\n\r\n\r\n\r\n
EN:TITLE$(\r\nΤύπωσε τιτλος$(\"γιώργος καρράς\")\r\nΓιώργος Καρράς\r\n\r\n
EN:FILE.TITLE$(\r\nΔίνει το τίτλο αρχείου, όπως φαίνεται στον explorer (το παράθυρο που βλέπουμε τα αρχεία ενός φακέλου)\r\nΤύπωσε Τίτλος.Αρχείου$(\"TXT\") \r\n
EN:MODULE\r\nΔημιουργία τμήματος ή αλλαγή ονόματος σε υπάρχον τμήμα κατά την εκτέλεση!\r\n\r\nΜπορούμε να δημιουργήσουμε τμήματα μέσα σε άλλα τμήματα τα οποία θα έχουν ζωή μέχρι να τερματίσει το τμήμα που τα δημιούργησε.\r\n\r\nΤμήμα αλφα {\r\n      διαβασε α\r\n      Αν α Τότε {\r\n            Τμήμα βητα {\r\n                  Τύπωσε \"ενα\"\r\n            }\r\n      } ΑΛΛΙΩΣ {\r\n            Τμήμα βητα {\r\n                  Τύπωσε \"one\"\r\n            }\r\n      }\r\n      βητα\r\n}\r\nΤο τρέχουμε:\r\n>αλφα 1\r\nενα\r\n>αλφα 0\r\none\r\n\r\n2) Αν θέλουμε να έχουμε δυο ή περισσότερα σύνολα μεταβλητών μπορούμε να αλλάζουμε το όνομα του τμήματος  (προσωρινά κατά την εκτέλεση), δες το παράδειγμα\r\nΤμήμα Α {\r\n      α=45\r\n      Τμήμα βητα\r\n      α=23\r\n      λιστα\r\n}\r\n\r\nΤο τρέχον όνομα του τμήματος μπορούμε να το διαβάσουμε με την μεταβλητή μόνο για ανάγνωση Τμήμα$\r\n3) Μπορούμε να περάσουμε αναφορά σε ένα τμήμα χρησιμοποιώντας ως ισχνή αναφορά την επιστροφή από το Τμήμα$\r\nΤμήμα Β {\r\n      Διάβασε Α, Β\r\n      Τύπωσε Α*2, Β**2\r\n}\r\nΤμήμα Γ {\r\n      Διάβασε Α$\r\n      Α$.Β 20\r\n}\r\nΓ Τμημα$, 20\r\n\r\n\r\n
EN:MODULE$\r\n? τμημα$\r\nμας δίνει το όνομα από το τρέχον τμήμα ή συνάρτηση\r\n\r\n
EN:MODULE(\r\nΤύπωσε Τμήμα(Α)\r\nδίνει -1 αν υπάρχει το τμήμα Α\r\n\r\n\r\n
EN:MODULES\r\nΤΜΗΜΑΤΑ\r\n      Δείνει στην έξοδο τα τμήματα στην μνήμη και στο τωρινό φάκελο στο δίσκο\r\nΤΜΗΜΑΤΑ !\r\n      ότι και το απλό αλλά τα τμήματα του δίσκου τα ταξινομεί κατ' όνομα\r\nΤΜΗΜΑΤΑ ?\r\n      Δείνει μόνο τα τμήματα της μνήμης\r\nΤΜΗΜΑΤΑ ?, \"alfa\"\r\n      Δείνει μόνο τα τμήματα της μνήμης που ξεκινούν από alfa\r\nΤΜΗΜΑΤΑ ?, \"*alfa\"\r\n      Δείνει μόνο τα τμήματα της μνήμης που  περιέχουν το alfa στο όνομα\r\nΤΜΗΜΑΤΑ ?, \"\", \"ΠΙΝΑΚΑΣ \"\r\n      Δείνει μόνο τα τμήματα της μνήμης που έχουν στο κώδικα το Πίνακας ή με οποιοδήποτε συνδυασμ πεζών και κεφαλαίων,\r\nΤΜΗΜΑΤΑ ?, \"alfa\", \"ΠΙΝΑΚΑΣ \"\r\n      Δείνει μόνο τα τμήματα της μνήμης που  περιέχουν το alfa στο όνομα και έχουν στο κώδικα το Πίνακας ή με οποιοδήποτε συνδυασμ πεζών και κεφαλαίων\r\n\r\n\\\\ για να βρούμε ονόματα αρχείων και εκείνα τα αρχεία που έχουν συγκεκριμένες λέξεις χρησιμοποιούμε το ΑΡΧΕΑ\r\nΑΡΧΕΙΑ \"GSB\", \"PRINT|DIM\"  ' ψάχνει σε αρχεία GSB εκείνα που έχουν το PRINT και το DIM\r\n\r\nΜπορούμε να σώνουμε και να φορτώνουμε τμήματα από οπουδήποτε στο δίσκο. Αλλά υπάρχει ένας κατάλογος, ο κατάλογος χρήστη ο οποίος είναι εξ ορισμού ο φάκελος με το που ξεκινάει το περιβάλλον της Μ2000. Σε περίπτωση που εκκινήσουμε ένα τμήμα από το δίσκο, τρέχοντας ένα αρχείο gsb, τότε το περιβάλλον θα έχει για αρχικό κατάλογο το κατάλογο του αρχείου. Αν θέλουμε να χρησιμοποιήσουμε ένα τμήμα από το δίσκο, ως μια βιβλιοθήκη τμημάτων, τότε μπορούμε να την έχουμε στο κατάλογο χρήστη\r\n\r\nΚΑΤΑΛΟΓΟΣ ΧΡΗΣΤΗ\r\n\r\nwin ΚΑΤ$\r\nανοίγουμε τον explorer στο φάκελο χρήστη. Από εκεί μπορούμε να διαγράψουμε ή να μεταφέρουμε τμήματα.\r\n\r\n\r\n
EN:TONE\r\nΑυτή η εντολή δεν δουλεύει σε εικονικό περιβάλλον. Επειδή χρησιμοποιεί συσκευή που στο εικονικό περιβάλλον δεν μπορεί να αναπαρασταθεί.\r\n\r\nΚάθε υπολογιστής από τα Windows Xp και πάνω έχει γενήτρια τόνου\r\n\r\n1) ΤΟΝΟΣ \r\nπαίζει 1000Hz για 0,1 του δευτερολέπτου\r\n2) ΤΟΝΟΣ 200\r\nπαίζει 1000Hz για 0,200 του δευτερολέπτου\r\n3) ΤΟΝΟΣ 200, 5000\r\nπαίζει 5000Hz για 0,200 του δευτερολέπτου\r\n\r\nΣτο τμήμα B έχουμε την TUNE η οποία είναι μια σύνθετη ΤΟΝΕ\r\n\r\nModule A {Module AA {\r\nFor i=1 To 10 {\r\nTone 50, 150\r\nTone 25, 300\r\n}\r\n}\r\nFor i=1 To 5 {\r\nAA\r\nWait 200\r\nAA\r\nWait 800\r\n}\r\n}\r\nModule B {For i = 1 To 10 {\r\nTUNE \"cac \"\r\nWait 200\r\n}\r\n}\r\nModule C {For i=100 To 8000 Step 20 {\r\nTone 2,i\r\n}\r\n}\r\n\r\n\r\n\r\nΌταν δίνουμε εντολή ΤΟΝΟΣ ακούμε ένα ήχο και εκείνη την ώρα σταματάει κάθε νήμα να λειτουργεί! Δεν είναι παράξενο γιατί αυτή η λειτουργία γίνεται με το Kernel των windows το ίδιο που \"σκανδαλίζει\" τα νήματα του περιβάλλοντος. Μπορεί κανείς να παίξει έτοιμους ήχους με την Ηχος η οποία τρέχει παράλληλα! Αλλά το ίδιο κάνει και η Μουσική και η Παιξε.\r\n\r\nI=0\r\nTHREAD {\r\nPRINT I\r\nI=I+1\r\n} AS L\r\nTHREAD L INTERVAL 40\r\nWAIT 1000\r\nTONE 1000,3000\r\nWAIT 1000\r\n\r\n\r\n\r\n\r\n
EN:ATN(\r\nΤύπωσε Εφαπ(45)\r\nΤύπωσε Τοξ.εφ(1)  'σε μοίρες\r\n\r\n
EN:LOCAL\r\n1) Τοπική Α\r\nΙσχύει και το Τοπικές\r\nΗ εντολή αυτή δημιουργεί πάντα νέες μεταβλητές ακόμα και αν υπάρχουν τοπικές με το ίδιο όνομα\r\nΓια όσο υπάρχει η τοπική που φτιάχνουμε, άλλες τοπικές με το ίδιο όνομα δεν θα φαίνονται.\r\nΤο μπλοκ Για Αυτό { } διαγράφει ότι νέο φτιάχνουμε, οπότε οι τοπικές Χ και Υ στο παράδειγμα θα διαγραφούν και θα αφήσουν τις παλιές για χρήση.\r\n\r\nΠαράδειγμα:\r\nΣτη Χ=4, Υ=5\r\nΓια Αυτό {\r\n      Τοπικές Χ=10, Υ=30\r\n      αλφα()\r\n}\r\nαλφα()\r\nΤέλος\r\nΡουτίνα αλφα()\r\n      Τύπωσε Χ, Υ\r\nΤέλος Ρουτίνας\r\n\r\n2) Σε ορισμό Ομάδας έχει άλλη έννοια.\r\n\\\\ Στο παρακάτω παράδειγμα (έχει δυο μέρη), βλέπουμε τη λειτουργία της τοπικής (εδώ η λέξη Τοπικές έχει ίδια ισχή. Προσοχή η λέξη Τοπικά ή Τοπικό δεν έχει ίδια ισχή και εντός του ορισμού της ομάδας είναι λάθος το οποίο δεν εμφανίζεται άμεσα, απλά κάνει την ομάδα να μην διαβάζει όλο τον ορισμό.\r\nΤοπική μπορεί να είναι μια συνάρτηση ή και ένα τμήμα στην Ομάδα. Και αυτά δεν μεταφέρονται σε πέρασμα με αναφορά, και δεν αλλάζουν ορισμούς σε κλειστές ομάδες (σε πίνακες δηλαδή).\r\n\r\nΟμάδα Άλφα {\r\n      Τοπικές Χ=10, Πίνακας Μ(3)=1\r\n      Ζ=3\r\n}\r\nΆλφα.Μ(2)=1000\r\nΆλφα.Χ++\r\nΤύπωσε Άλφα.Χ, Άλφα.Μ(2)  \\\\ 11  1000\r\nΒάλε &Άλφα   \\\\ βάζουμε στο σωρό την ισχνή αναφορά στο Άλφα\r\nΔιάβασε &Βήτα  \\\\ η Διάβασε συνδέει την ισχνή αναφορά στο Βήτα, αλλά παραβλέπει ότι έχει δηλωθεί με τις εντολές Τοπική/Τοπικές\r\nΤύπωσε Έγκυρο(Βήτα.Χ), Έγκυρο(Βήτα.Μ(2)) \\\\ οι τοπικές δεν περιλαμβάνονται σε πέρασμα με αναφορά\r\n\\\\ Όμως σε ισχνή αναφορά γίνεται, επειδή απευθείας χρησιμοποιούμε το αρχικό\r\nΑ$=ισχνή$(Αλφα.Χ)\r\nΤύπωσε Εκφρ(Α$.)  \\\\ θα μπορούσαμε εδώ να μην βάλουμε την τελεία. Όμως δείχνει καλύτερο!\r\n\\\\  με χρήση ισχνής αναφοράς διαβάζουμε τοπικές σε εσωτερικό τμήμα\r\nΤμήμα Εσωτερικό {\r\n      Διάβασε Α$\r\n      Τύπωσε Μορφή$(\"Εσωτερικό {0}\", Έκφραση(Α$.Χ))   \\\\ και Εκφρ() είναι το ίδιο\r\n}\r\nΕσωτερικό Ισχνή$(Άλφα)\r\nΘήτα=Άλφα  \\\\ Στην αντιγραφή μπαίνουν οι αρχικές τιμές στις τοπικές της ομάδας\r\nΤύπωσε Έγκυρο(Θήτα.Χ), Θήτα.Χ, Θήτα.Μ(2)\r\n\\\\ Μέρος 2ο. Δείχνει πώς λειτουργή η τοπική μεταβλητή σε κλειστή ομάδα (σε πίνακα)\r\nΠίνακας Α(10)\r\nΑ(0)=Άλφα \\\\ στην αντιγραφή περνάει η αρχική τιμή του Χ το 10\r\nΆλφα.Χ+=20  \\\\ η Χ είναι όμως 11 στην Άλφα\r\nΤύπωσε Άλφα.Χ   \\\\ 31\r\nΑ(0).Χ+=20   \\\\ γίνεται η πρόσθεση αλλά η τιμή στο επόμενο διάβασμα...\r\nΤύπωσε Α(0).Χ   \\\\ 10    ..γυρνάει στην αρχική, όπως ορίστηκε στην δήλωση της Ομάδας\r\nΓια Α(0) {\r\n      .Χ+=20\r\n      Τύπωσε .Χ  \\\\ 30  εδώ φαίνεται ακόμα η νέα τιμή γιατί δεν έχει κλείσει η ομάδα\r\n      \\\\ αν είχαμε συναρτήσεις εντός της ομάδας που έβλεπαν την Χ τότε θα έβλεπαν και την νέα τιμή\r\n      \\\\ και αυτό δηλώνει ότι η συνάρτηση τρέχει σε ανοικτή ομάδα.\r\n      \\\\ ένας λόγος ύπαρξης αυτών των τοπικών είναι για να μπορούμε να καταλαβαίνουμε μέσω κώδικα\r\n      \\\\ την κατάσταση της ομάδας.\r\n      \\\\ παρακάτω καλούμε το τμήμα Εσωτερικό με αναφορά στο Αυτό, που εδώ είναι η ανοικτή ομάδα του Α(0)\r\n      Εσωτερικό &Αυτό\r\n}\r\nΤύπωσε Α(0).Χ  \\\\ δίνει 10 γιατί άνοιξε ξανά, άρα πήρε την αρχική τιμή.\r\n\r\n\r\n
EN:LOCALE\r\n1) ΤΟΠΙΚΟ κωδικός\r\n  Bάζει και το αλφαριθμητικό για τους λογικούς (γνωρίζει τα ελληνικά και τα αγγλικά)\r\n2) ΤΟΠΙΚΟ \";\\Ν\\α\\ί;Ό\\χ\\ι\"  \\\\ μπορούμε να δώσουμε δικά μας ονόματα\r\n3) ΤΟΠΙΚΟ \"\"  \\\\ ακυρώνουμε όποια επιλογή και θέτουμε το βασικό αλφαριθμητικό (δίνει το αληθές ως True)\r\n\r\nΤο περιβάλλον δουλεύει με Unicode χαρακτήρες στην οθόνη, στα αλφαριθμητικά, στον διορθωτή, στις βάσεις δεδομένων και σε αρχεία που δηλώνονται με το αναγνωριστικό ΕΥΡΙΑ, αλλά μπορεί να χειριστεί αλφαριθμητικά όπου οι χαρακτήρες του ανήκουν σε κάποιο ΤΟΠΙΚΟ σύστημα, όπως το 1032 που είναι για την Ελλάδα.\r\nκάθε Τοπικο αλλάζει την κωδικοσελίδα και το σύνολο χαρακτήρων, για τις συναρτήσεις που τις χρησιμοποιούν. Το περιβάλλον θα συνεχίσει να λειτουργεί με όλους τους χαρακτήρες του Unicode συνόλου. Πρόβλημα θα υπάρξει αν θέλουμε να εμφανίσουμε έναν χαρακτήρα που δεν περιέχεται στην γραμματοσειρά που χρησιμοποιούμε. Το οποίο θα εμφανίζει τον ζητούμενο χαρακτήρα ως ένα τετράγωνο\r\nΓια να χρησιμοποιήσουμε διάφορες γλώσσες δεν χρειαζόμαστε την εντολή ΤΟΠΙΚΟ. Αυτό που αλλάζει αυτή η εντολή και φαίνεται καθαρά στο παρακάτω παράδειγμα είναι οι χαρακτήρες που αντιπροσωπεύουν τα νούμερα από το 33 μέχρι το 255 αν και πολλά από αυτά είναι ίδια σε όλα τα σύνολα χαρακτήρων.\r\nΓια παράδειγμα μπορούμε να δούμε το σύνολο χαρακτήρων της Τουρκικής γλώσσας:\r\n\r\nΤοπικο 1055     ' μπορούμε να βάλουμε τόνους στις εντολές που είναι στα Ελληνικά.\r\nΓια Ι=33 Εως 255 {\r\n      Τυπωσε Χαρ$(Ι);\r\n}\r\nΤυπωσε             ' αλλαγή γραμμής\r\n\r\nΔοκιμάστε με το 2077 για Φιλανδία, 1037 για Ισραήλ.\r\nΟυσιαστικά όλοι οι χαρακτήρες μπορούν να τυπωθούν και ανακατεμένοι\r\nΤυπωσε χαρ$(254,2077), χαρ$(249,1037)\r\n\r\nΑν προσθέσουμε γλώσσες στο πληκτρολόγιο μπορούμε να γράφουμε με οποιαδήποτε και με οποιοδήποτε πληκτρολόγιο.\r\n\r\n\r\n
EN:LOCALE$(\r\nΦόρμα 60, 30\r\nΔιπλά\r\nΤύπωσε \"Example 1.0\"\r\nΚανονικά\r\nΚύλιση Χώρισμα 2  ' ή Οθόνη ,2  για να καθαρίσει και το κάτω μέρος\r\nΤοπικό 1033 ' για ελληνικά 1032\r\nΓια ι=0 έως 255 {\r\n      Αν Τοπικό$(ι)<>\"\" τότε {\r\n            \\\\ Η Αναφορά σταματάει αυτόματα σε κάθε 3/4 των γραμμών που εμφανίζει στο κάτω μέρος\r\n            \\\\ όπου έχουμε κύλιση οθόνης\r\n            Αναφορά Μορφή$(\"{0::-3}. Τοπικό$(0x{1})={2}\", ι, Δεκαεξ$(ι,1),Παράθεση$(Τοπικό$(ι)))\r\n      }\r\n}\r\n\r\n
EN:LOCALE(\r\n1) βρες το τοπικό για το αλφαριθμητικό\r\nΤύπωσε Τοπικό(\"ΓΑΒ\")\r\n      1032\r\n2) Βρες αν τα γράμματα ανήκουν σε κάποιο τοπικό\r\nΤύπωσε Τοπικό(\"ΓΑΒ\",1032)\r\n      -1\r\nΤύπωσε Τοπικό(\"ΓΑΒ\",1033)\r\n      0\r\n\r\n
EN:PATH$(\r\n\\\\ δίνει τα \"μονοπάτια\" ή \"τόπο\" στο δίσκο βάσει αρίθμησης, ειδικών φακέλων των Windows\r\nΓενική Σταθερή CSIDL_ADMINTOOLS  = 0x30\r\nΓενική Σταθερή  CSIDL_ALTSTARTUP  = 0x1D\r\nΓενική Σταθερή  CSIDL_APPDATA  = 0x1A\r\nΓενική Σταθερή  CSIDL_BITBUCKET  = 0xA\r\nΓενική Σταθερή  CSIDL_COMMON_ADMINTOOLS  = 0x2F\r\nΓενική Σταθερή  CSIDL_COMMON_ALTSTARTUP  = 0x1E\r\nΓενική Σταθερή  CSIDL_COMMON_APPDATA  = 0x23\r\nΓενική Σταθερή  CSIDL_COMMON_DESKTOPDIRECTORY  = 0x19\r\nΓενική Σταθερή  CSIDL_COMMON_DOCUMENTS  = 0x2E\r\nΓενική Σταθερή  CSIDL_COMMON_FAVORITES  = 0x1F\r\nΓενική Σταθερή  CSIDL_COMMON_PROGRAMS  = 0x17\r\nΓενική Σταθερή  CSIDL_COMMON_STARTMENU  = 0x16\r\nΓενική Σταθερή  CSIDL_COMMON_STARTUP  = 0x18\r\nΓενική Σταθερή  CSIDL_COMMON_TEMPLATES  = 0x2D\r\nΓενική Σταθερή  CSIDL_CONNECTIONS  = 0x31\r\nΓενική Σταθερή  CSIDL_CONTROLS  = 0x3\r\nΓενική Σταθερή  CSIDL_COOKIES  = 0x21\r\nΓενική Σταθερή  CSIDL_DESKTOP  = 0x0\r\nΓενική Σταθερή  CSIDL_DESKTOPDIRECTORY  = 0x10\r\nΓενική Σταθερή  CSIDL_DRIVES  = 0x11\r\nΓενική Σταθερή  CSIDL_FAVORITES  = 0x6\r\nΓενική Σταθερή  CSIDL_FONTS  = 0x14\r\nΓενική Σταθερή  CSIDL_HISTORY  = 0x22\r\nΓενική Σταθερή  CSIDL_INTERNET  = 0x1\r\nΓενική Σταθερή  CSIDL_INTERNET_CACHE  = 0x20\r\nΓενική Σταθερή  CSIDL_LOCAL_APPDATA  = 0x1C\r\nΓενική Σταθερή  CSIDL_MYPICTURES  = 0x27\r\nΓενική Σταθερή  CSIDL_NETHOOD  = 0x13\r\nΓενική Σταθερή  CSIDL_NETWORK  = 0x12\r\nΓενική Σταθερή  CSIDL_PERSONAL  = 0x5   ' My Documents\r\nΓενική Σταθερή  CSIDL_MY_DOCUMENTS  = 0x5\r\nΓενική Σταθερή  CSIDL_PRINTERS  = 0x4\r\nΓενική Σταθερή  CSIDL_PRINTHOOD  = 0x1B\r\nΓενική Σταθερή  CSIDL_PROFILE  = 0x28\r\nΓενική Σταθερή  CSIDL_PROGRAM_FILES  = 0x26\r\nΓενική Σταθερή  CSIDL_PROGRAM_FILES_COMMON  = 0x2B\r\nΓενική Σταθερή  CSIDL_PROGRAM_FILES_COMMONX86  = 0x2C\r\nΓενική Σταθερή  CSIDL_PROGRAM_FILESX86  = 0x2A\r\nΓενική Σταθερή  CSIDL_PROGRAMS  = 0x2\r\nΓενική Σταθερή  CSIDL_RECENT  = 0x8\r\nΓενική Σταθερή  CSIDL_SENDTO  = 0x9\r\nΓενική Σταθερή  CSIDL_STARTMENU  = 0xB\r\nΓενική Σταθερή  CSIDL_STARTUP  = 0x7\r\nΓενική Σταθερή  CSIDL_SYSTEM  = 0x25\r\nΓενική Σταθερή  CSIDL_SYSTEMX86  = 0x29\r\nΓενική Σταθερή  CSIDL_TEMPLATES  = 0x15\r\nΓενική Σταθερή  CSIDL_WINDOWS  = 0x24\r\nΛίστα\r\nΤύπωσε Τόπος$(CSIDL_PROGRAM_FILES)\r\n\r\n
EN:FILE.PATH$(\r\nμας δίνει το μονοπάτι ενός αρχείου (τον τόπο που θα γράψουμε ή που θα ανοίξουμε ένα αρχείο)\r\nΠεριλαμβάνει τον οδηγό (π.χ. το τμήμα C: του σκληρού δίσκου) και όλη τη σειρά φακέλων και υποφακέλων. Δεν περιλαμβάνει το όνομα του αρχείου.\r\n
EN:THEN\r\nΔΕΣ ΑΝ\r\n\r\n\r\n\r\n
EN:BANK(\r\nΕίναι ίδια με την Round() της VB6\r\nστρογγυλοποιεί στο μισό προς τον ζυγό αριθμό.\r\nπαίρνει και δεύτερη τιμή για να αφήσει δεκαδικά\r\n\r\n
EN:MODE\r\n1)  Ορίζουμε μέγεθος γραμμάτων, πλάτος σε twips και ύψος σε twips\r\nΤΥΠΟΣ τυπος_οθονης, πλάτος, υψος\r\n2)Με αυτόματο υπολογισμό ύψους (θα έχει την αναλογία ύψους προς πλάτος με την επιφάνεια εργασίας)\r\nΤΥΠΟΣ τυπος_οθονης,2 πλάτος\r\n3) Αλλάζουμε μόνο το μέγεθος των γραμμάτων (άρα αλλάζει και ο αριθμός γραμμών και πόσα γράμματα μπορούν να τυπωθούν)\r\nΤΥΠΟΣ τυπος_οθονης\r\n\r\nΠαρατήρηση\r\nΟ τύπος οθονης είναι το μέγεθος χαρακτήρων. Π.χ. ΤΥΠΟΣ 16 σημαίνει γράμματα 16 στιγμών. Ανάλογα το μέγεθος γραμμάτων αλλάζει και το ΠΛΑΤΟΣ και ΥΨΟΣ που μας δείχνουν πόσους χαρακτήρες χωρούν στην γραμμή και στην στήλη αντίστοιχα.\r\n\r\nΟι μεταβλητές μόμο ανάγνωσης κλιμαξ.χ και κλιμαξ.υ μας δείχνουν το μέγεθος της οθόνης μας σε twips\r\n\r\nΜπορούμε να φτιάξουμε οθόνη μεγαλύτερη από το περιθώριο. Όμως δεν θα είναι όλη ορατή. \r\nΜπορούμε να την μετακινούμε σε οποιαδήποτε διεύθυνση με την εντολή ΚΙΝΗΣΗ\r\nΜε την ΠΑΡΑΘΥΡΟ τυπος_οθονης,0 επαναφέρουμε την οθόνη στο πλήρες μέγεθος όπου όλη να είναι στο μέγιστο ορατή.\r\n\r\nΣτην έκδοση έξι μπορούμε να έχουμε 32 επίπεδα σαν οθόνες. Αυτά τα 32 επίπεδα είναι οι Παικτες. Κάθε παίκτης μπορεί να πάρει εικόνα και να δηλώσουμε ποιο χρώμα θα είναι το διάφανο καθώς και ποια άλλα κοντινά χρώματα θα είναι επίσης διάφανα, όπως επίσης και τι μέγεθος θα έχει η εικόνα (το μέγεθος του παίκτη σε σχέση με την αρχική εικόνα). Αν θέλουμε όμως να χρησιμοποιήσουμε τον Παικτη σαν Οθόνη, και δεν θέλουμε να έχει διάφανα σημεία και δεν θέλουμε εικόνα για φόντο, τότε καλούμε την ΕΠΙΠΕΔΟ με τον αριθμό του επιπέδου που θέλουμε και δημιουργούμε ένα επίπεδο όμοιο με την οθόνη ή το επίπεδο απ΄όπου κλήθηκε η εντολή. Εδώ λοιπόν η Τυπος δεν αλλάζει το μέγεθος σε υψος και πλατος του επιπέδου (αν δώσουμε μέγεθος απλά θα το αγνοήσει) παρά μόνο το μέγεθος γραμμάτων. Προσοχή εδώ να μην δώσουμε τέτοιο μέγεθος που δεν θα χωράει ένα γράμμα στο επίπεδο!  Μπορούμε να δώσουμε την ΠΑΡΑΘΥΡΟ με μέγεθος γραμμάτων και διαστάσεις του επιπέδου. Μπορούμε να αλλάξουμε την γραμματοσειρά με την εντολή ΓΡΑΜΜΑΤΟΣΕΙΡΑ.\r\n\r\nΗ Τυπος και η εντολή Παραθυρο απενεργοποιούν τους στόχους στο επίπεδο όταν τις καλούμε. Οι στόχοι σβήνουν ή με την εντολή ΣΤΟΧΟΙ ΝΕΟΙ ή με την εντολή ΑΡΧΗ\r\n Δες ΣΤΟΧΟΣ\r\n \r\n 
EN:TYPE$(\r\nα=10\r\nβ=(1,2,3,4)\r\nΤύπωσε Τύπος$(α), Τύπος$(β) ' double mArray\r\n\r\n
EN:FILE.TYPE$(\r\nΔίνει τον τύπο ενός αρχείου, αφαιρόντας τόπο (μονοπάτι) και όνομα\r\n\r\n
EN:MODE_variable\r\nΔίνει το τύπο γραμμάτων σε σημεία pt (12 pt = 1440/72 twips  - 1440 twips = 1 λογική ίντσα - σε εκτυπωτές είναι πραγματική ίντσα)\r\nγράμματα 12 pt έχουν ύψος (πλαισίου μιας γραμμής) (1440twips/72pt)*12pt=240twips\r\nΜπορούμε να ορίζουμε ΤΥΠΟ με την εντολή ΤΥΠΟ. \r\nΑπό την έκτη έκδοση μπορούμε να αλλάζουμε τύπο χωρίς να καθαρίζουμε την οθόνη, όπως και με την εντολή ΓΡΑΜΜΑΤΟΣΕΙΡΑ μπορούμε να αλλάζουμε τη μορφή των γραμμάτων. Στις προηγούμενες εκδόσεις έπρεπε να χρησιμοποιήσουμε την εντολή ΕΠΙΓΡΑΦΗ για να τυπώσουμε με οποιαδήποτε γραμματοσειρά και οποιοδήποτε μέγεθος (υπάρχει ακόμα), με τη διαφορά ότι τυπώνει σε θέσεις γραφικών και οχι χαρακτήρων, και επίσης μπορούμε να δώσουμε και περιστροφή σε μοίρες.\r\n\r\n
EN:PRINT\r\n1) Μπορούμε για ευκολία να βάζουμε το ? αντί για Τυπωσε ή Print\r\n? 2+3=5 και 2-1>0\r\n2) Τύπωσε 1, 2+4, \"Λέξη \"+α$   \\\\ αν δεν χωράνε στη γραμμή συνεχίζουν από κάτω κατά στήλες\r\n3) Τύπωσε \"Όνομα:\";α$;\" \";β$\r\n4) Τύπωσε @(10,10),\"Στη θέση 10, 10\"\r\n5) Τύπωσε $(3,8),100,200,\"Λέξη\",300    \\\\ ορίζουμε στήλη 8 χαρακτήρων και στοίχιση δεξιά\r\n6) Τύπωσε   \\\\σκέτο αλλάζει γραμμή, στη τελευταία κάτω γραμμή η αλλαγή προκαλεί ολίσθηση γραμμών προς τα πάνω\r\n7) Δεκαεξ 0xFF00+0x0055       \\\\ Η Τύπωσε σε εξαγωγή δεκαεξαδικού\r\n                  0xFF55\r\n8) Τύπωσε #Α, \"Μια γραμμή στο αρχείο με μεταβλητή χειρισμού το Α\"\r\n H Τύπωσε #Α απλά βάζει δυο χαρακτήρες για αλλαγή γραμμής\r\n Η Τύπωσε #Α,123,456 βάζει το 123456\r\n (δεν βάζει διαχωριστικό χαρακτήρα, μπορούμε να βάλουμε , \" \", )\r\n Η Γράψε βάζει διαχωριστικά\r\n Ο χαρακτήρας ; μπορεί να μπει, και αν είναι τελευταίος τότε δεν μπαίνει αλλαγή γραμμής.\r\n Οι αριθμοί γράφονται βάσει της επιλογής \"+DEC\" (με τελεία για δεκαδικά) ή \"-DEC\" (με ότι έχει το σύστημα ως χαρακτήρα δεκαδικών)\r\n Μπορούμε να το αλλάξουμε με την Τοπικό 1032 (ελληνικά) ή άλλο νούμερο πχ Τοπικό 1033 (αγγλικά), μέχρι όμως να το δώσουμε ξανά ή να δώσουμε την Θέσε Διακόπτες \"+DEC\"  (ή \"-DEC\")\r\n9)  Τύπωσε $(\"#,###,###.00\", 20), 112313.3788   \\\\ 20 το πλάτος στήλης\r\n   \\\\ το ίδιο δίνει και αυτό: Τύπωσε $(\"#,###,###.00\", 20), τιμη(μορφη$(\"{0:2}\",112313.3788))\r\n10) Τύπωσε μορφή$(\"αριθμός με δυο δεκαδικά:{0:2} και εδώ μια λέξη:{1}\", 10.678, \"ΟΚ\")  \r\n                                                              \\\\ η μορφή$() είναι γενική συνάρτηση, ο αριθμός μετά το : δείχνει το τελευταίο δεκαδικό αν υπάρχει\r\n\r\n      νέες προσθήκες στην έκδοση 8\r\n   'Ολες οι αλλαγές χρωμάτων και στηλών και τρόπου εκτύπωσης περιορίζονται στην εντολή\r\n   Εξ ορισμού οι \"φόντο\", \"πάνω\",\"υπό\", \"μέρος\" τυπώνουν αναλογικά, το $(4)\r\n11) Τύπωσε πάνω $(2), \"Στη μέση της οθόνης\"  \\\\ εξ ορισμού σβήνει όλη τη γραμμή χαρακτήρων (φόντο) εκτός από μια λεπτή γραμμή\r\n                                                                                      \\\\ δεν αλλάζει γραμμή\r\n                                                                                       \\\\ από κάτων και τυπώνει σε μια στήλη όσο το πλάτος της οθόνης\r\n12) Τύπωσε υπό ~(#ff0066),\"κάτω από μια γραμμή\"  \\\\ εξ ορισμού γράφει μια γραμμή λεπτή και αλλάζει γραμμή χαρακτήρων\r\n                                                                                                   \\\\ εδώ με χρώμα γραμμάτων ~()\r\n13) Τύπωσε μέρος \"Χωρίς αλλαγή γραμμής\"   \\\\ δεν αλλάζει γραμμή, δεν σβήνει το φόντο.\r\n14) Τύπωσε Φόντο 1,2,3,4,5 \\\\ τυπώνει αφού καθαρίσει τη γραμμή με το χρώμα φόντου (οθόνης), ίσως καθαρίσει και άλλες γραμμές αν χρειαστεί.\r\n15) Τύπωσε #-2, μορφή$(\"Hello\\n\\there\\t100\\t500\\6000\")\r\nΜε το πρόγραμμα παρακάτω δοκιμάζουμε τι θα πήγαινε σε αρχείο, στην οθόνη, χωρίς να δώσουμε όνομα\r\nΆνοιξε \"\" Για Εξαγωγή ως #F    ' το F θα γίνει -2\r\nΤύπωσε #F, μορφή$(\"Hello\\n\\there\\t100\\t500\\6000\")\r\nΚλείσε #F\r\n\r\nΔες τα @(), $(), ~()\r\n\r\nΠολύπλοκη εντολή. Μπορεί να γράφει νούμερα, γράμματα, πλαίσια, εικόνες, σχέδια, να αλλάζει πλάτος στηλών, να διαμορφώνει την εκτύπωση των αριθμών, των ημερομηνιών κ.λ.π. Προσοχή η Τυπωσε δεν σβήνει το χώρο που τυπώνει, δηλαδή εμφανίζει το γράμμα και το κενό χώρο του γράμματος μπορεί να φαίνεται το φόντο. Για το λόγο αυτό όταν θέλουμε να ξαναγράψουμε γράμματα σε μια περιοχή στην οθόνη θα πρέπει με την @( να βάψουμε το φόντο, ή να βάλουμε μια εικόνα. Η οθόνη που γράφουμε στη τελευταία γραμμή αν περάσουμε την κάτω δεξιά άκρη τυπώνοντας θα κάνει ολίσθηση και θα μας φέρει μια κενή γραμμή (εκεί δεν χρειάζεται να προετοιμάσουμε το φόντο). Μπορούμε με την εντολή Οθόνη να ορίσουμε το χρώμα του φόντου και την γραμμή από την οποία θα χάνονται οι γραμμές, με συνέπεια αυτό το τελευταίο να μας δίνει κάποιες γραμμές που δεν θα αλλάζει η ολίσθηση (αυτό λέγεται split screen)\r\n\r\nΑπό την έκδοση 6 μπήκε και η αναλογική γραφή, δηλαδή με χρήση ως οδηγούς τις θέσεις των χαρακτήρων στην μη αναλογική γραφή (όπου το κάθε γράμμα είναι κάτω απο το άλλο, ενώ στην αναλογική δεν μπορεί να συμβεί αυτό αφού το κάθε γράμμα έχει άλλο πλάτος) μπορούμε να τοποθετούμε με την στοίχηση που θέλουμε επιγραφές. Στις παλαιότερες εκδόσεις έπρεπε να χρησιμοποιήσει κανείς την ΕΠΙΓΡΑΦΗ και δεν μπορούσε να στοιχίσει κατάλληλα.\r\nΗ αναλογικη γραφή μπαίνει με τον κατάλληλο κωδικό σε μια $() ή άμεσα με της Τύπωσε πάνω|υπό|μέρος\r\n\r\nΤΥΠΩΣΕ 12*3+4*5, \"ΚΑΛΗΜΕΡΑ\"\r\nΟΘΟΝΗ ΧΡΩΜΑ(128,100,50)\r\nΤΥΠΩΣΕ $(,10),1,2,3\r\nΤΥΠΩΣΕ $(,20),1,2,3\r\nΤΥΠΩΣΕ -(128+100*2**16+50*2**16)\r\nΤΥΠΩΣΕ 1,2,3,4,5,,6,7,8,9,10\r\nΤΥΠΩΣΕ \"ΜΠΡΑΒΟ ΜΟΥ\"\r\nΤΥΠΩΣΕ \"3 στο τετράγωνο =\"; 3**2\r\nΑ=13\r\nΤΥΠΩΣΕ Α, Α*10\r\nΤΥΠΩΣΕ @(10,10),\"ΕΔΩ\"\r\nΤΥΠΩΣΕ @(1,1,Κ-1,9,Β$+\"paral031.jpg\");\r\n\r\nΔες και τους 9 διαφορετικούς τρόπους τυπώματος (παρατήρησε τις διαφορές αριθμών και αλφαριθμητικών)\r\n\r\nFOR I=0 TO 8 {\r\nPRINT $(I,14),145355,\"George Karras\", \"The Best\"\r\n}\r\nprint\r\nprint\r\nprint $(0,1), string$(\"1234567890\",5)\r\nprint $(4,8), 321321,\"asdaddsd xc c xcv v xv  12  sdfdsfsd 1  s srsr\",\"aasasa\"\r\n\r\n\r\n\r\n\r\nΔες αναλυτικό πίνακα για τις ενσωματωμένες λειτουργίες @() και $()\r\n\r\n\r\n            Οθονη  \r\n            Ανανεωση 1000 ' το 25 είναι το κανονικό. \r\n            τυπωσε $(,4);\r\n            Για ι=1 εως 1000 {\r\n            τυπωσε ι,\r\n            'το κόμμα λέει να τυπώσει μετά στο επόμενο πεδίο ή στήλη εκτύπωσης \r\n            }\r\nδοκιμάστε  χωρίς το , και επίσης χωρίς το Οθονη (το σβήσιμο της οθονης)\r\n\r\nΕκτός από την Τυπωσε η 6 έκδοση έφερε και την Αναφορα μια εντολή που τυπώνει αναλογικά για κείμενα, και με την οποία μπορούμε να φτιάχνουμε στείλες, να ορίζουμε τον τρόπο φορμαρίσματος, και να τυπώνουμε συγκεκριμένες γραμμές συγκεκριμένου πλάτους από ένα όριο αριστερά του κειμένου που μπορούμε να καθορίσουμε. Επίσης αυτή η εντολή διαχειρίζεται αυτόματα την κράτηση της οθόνης για να διαβάζουμε το κείμενο. Μπορεί να χρησιμοποιηθεί για να τυπώνει κείμενα σε εκτυπωτή με αυτόματο γύρισμα λέξεων word warp (εκεί δεν λειτουργεί η κράτηση οθόνης).\r\n\r\n\r\n
EN:RND\r\nΤύπωσε Τυχαίος  \\\\ δίνει έναν αριθμό  >=0 και <1\r\n\r\n
EN:RANDOM(\r\nΤύπωσε Τυχαίος(1,10) \\\\ δίνει έναν αριθμό μεταξύ 1 και 10 \r\nΤύπωσε Τυχαίος   \\\\ δίνει έναν αριθμό >=0 και μικρότερο του 1\r\nΧ=Τυχαίος(!12345) \\\\ βάζει την γεννήτρια τυχαίων από συγκεκριμένο βήμα και το προηγούμενο  βήμα το θέτει σε μια στοίβα ενός επιπέδου\r\nΧ=Τυχαίος(!)  \\\\ παίρνει από τη στοίβα το αποθηκευμένο βήμα\r\nΔες Random()\r\n\r\n
EN:NOW\r\nΔίνει έναν αριθμό που αντιπροσωπεύει την τωρινή ώρα.\r\nΤΥΠΩΣΕ ΧΡΟΝΟΣ$(ΤΩΡΑ)\r\nΤΥΠΩΣΕ ΓΡΑΦΗ$(ΤΩΡΑ, \"hh:mm AMPM\")\r\n\r\nα=Σήμερα+Τώρα '(όλα μαζί, το ακέραιο μέρος είναι η ημέρα, και τα δεκαδικά η ώρα)\r\n
EN:Y.TWIPS\r\nΜέγιστα σημεία Υ στην ΟΘΟΝΗ ή στο ΠΕΡΙΘΩΡΙΟ (ΔΕΣ ΠΕΡΙΘΩΡΙΟ)\r\nσυνώνυμο με ΚΛΙΜΑΞ.Υ\r\n
EN:EXIST(\r\n1) Χρησιμοποιώντας μια αλφαριθμητική έκφραση\r\nΑΝ ΥΠΑΡΧΕΙ(\"C:\\AUTOEXEC.BAT\") ΤΟΤΕ ΤΥΠΩΣΕ \"OK\"\r\n\r\n2) Χρησιμοποιώντας ένα αντικείμενο Κατάσταση ως πρώτο όρισμα (κάνει χρήση πίνακα κατακερματισμού)\r\nΚάνει αναζήτηση και υψώνει μια σημαία στο αντικείμενο αν βρεθεί το ζητούμενο\r\n\r\nΚατάσταση αλφα=1,2:=200,\"βήτα\":=1000, \"100\":=\"οκ\"\r\nΤύπωσε αλφα\r\nΑν Υπάρχει(αλφα, 2) τότε Τύπωσε Εκφρ$(αλφα), Εκφρ(αλφα)\r\nΑν Υπάρχει(αλφα, 1) τότε Τύπωσε Εκφρ$(αλφα)\r\nΑν Υπάρχει(αλφα, 100) τότε Τύπωσε Εκφρ$(αλφα)\r\nΑν Υπάρχει(αλφα, \"100\") τότε Τύπωσε Εκφρ$(αλφα)\r\n\r\nΧωρίς αναζήτηση μπορεί να βγει λάθος!\r\nΤύπωσε αλφα$(\"100\")  'οκ\r\nΤύπωσε αλφα(500)  ' θα βγει λάθος\r\n\r\n3) Χρήση τρίτης παραμέτρου για ουρές (τύπος κατάστασης με όμοια κλειδιά)\r\nα=ουρά:=1,2:=\"2α\",2:=\"2β\",3,4:=\"4α\",4:=\"4β\",5, 2:=\"3β\"\r\nμ=Κάθε(α)\r\nΤύπωσε $(4),\"τιμή ως αλφαριθμητικό\",@(στήλη(2)), \"θέση - από το μηδέν\",@(στήλη(4)),\"κλειδί σε εισαγωγικά\"\r\nΤύπωσε $(0),\r\nΕνώ μ {\r\n      Τύπωσε εκφρ$(μ),@(στήλη(2)), εκφρ(μ!),@(στήλη(4)), παράθεση$(εκφρ$(μ, μ^))\r\n}\r\n\\\\ νέα παράμετρος για την συνάρτηση Υπάρχει() όταν έχουμε πρώτη παράμετρο ουρά (είδος κατάστασης)\r\n\\\\ με τιή 0 μας επιστρέφει τον αριθμό στοιχείων (ή 0 αν δεν υπάρχουν) με το ίδιο κλειδί\r\n\\\\ το κλειδί μπορεί να είναι αλφαριθμητικό  ή αριθμός  (εσωτερικά είναι αλφαριθμητικό)\r\nΤύπωσε Υπάρχει(α,2, 0)=3  '  αληθές\r\n\\\\ μια θετική τιμή δηλώνει θέση (αν δεν υπάρχει δίνει 0 αν υπάρχει δίνει -1)\r\nΑν Υπάρχει(α,2,1) Τότε Τύπωσε εκφρ$(α)=\"2α\"  '  αληθές\r\n\r\n\\\\ μια αρνητική τιμή δίνει θέση από το τέλος, με -1 το τελευταίο με το ζητούμενο κλειδί\r\n\\\\ και εδώ επιστρέφει 0 αν δεν υπάρχει ή -1\r\nΑν Υπάρχει(α,2,-3) Τότε Τύπωσε εκφρ$(α)=\"2α\"  ' αληθές\r\n\r\nΤύπωσε Υπάρχει(α,4,0)=2\r\n\\\\ σε συνδυασμό με την Για μπορούμε να δούμε όλα τα στοιχεία με το ίδιο κλειδί\r\nΓια ι=-Υπάρχει(α,4,0) έως -1 \r\n      Αν Υπάρχει(α,4, ι) Τότε Τύπωσε εκφρ$(α),  ' we get 4α 4β\r\nΕπόμενο ι\r\nΤύπωσε\r\n\r\n
EN:EXIST.DIR(\r\nΤυπωσε υπαρχει.καταλογος(\"d:\")\r\nτυπώνει 0 αν δεν έχουμε CD \r\nτυπώνει -1 αν έχουμε CD  (υποθέτουμε ότι το D είναι το CD ROM)\r\n\r\nμπορούμε να βρούμε ποιο είναι το CD-ROM\r\nμε την συνάρτηση ΟΔΗΓΟΣ$()\r\n
EN:SUPERCLASS\r\nΜπήκε από  στην έκδοση 8.9 αναθεώρηση 38.\r\nΗ Υπερκλάση είναι ομάδα και όχι συνάρτηση που φτιάχνει ομάδες. Όμως μπορεί να φτιάχνει ομάδες όπως όλες οι ομάδες που αντιγράφουν τον εαυτό τους. Εδώ αντιγράφει και έναν δείκτη στο ειδικό αντικείμενο της Υπερκλάσης. Αυτό μπορεί να έχει μοναδικές μεταβλητές, τις οποίες τις βλέπουν όλα τα αντικείμενα που φέρουν τον δείκτη στην Υπερκλάση. Για να το δουν πρέπει να ανοίξουν μια Για Υπερκλάση {}\r\nΩς ομάδα η ΑΛΦΑ δεν έχει προσβάσιμα μέλη. Δηλαδή δεν μπορούμε να χειριστούμε τα μέλη της πχ ΑΛΦΑ.Χ\r\nΜπορούμε να βάλουμε κατασκευαστή αλλά δεν παίρνει παραμέτρους.  Δεν μπορούμε να βάλουμε μια υπερκλάση πάνω από μια υπερκλάση. Πάντα μια ομάδα μπορεί να έχει ή να μην έχει μια υπερκλάση, αλλά μόνο μία. Βέβαια μια ομάδα μπορεί να συσταθεί με \"αθρώματα\" τμηματικά. αλλά θα έχει δικά της όλα τα στοιχεία. Εδώ με την Υπερκλάση όλα τα παραγόμενα από το ΑΛΦΑ μπορούν να παράξουν ομάδες με κοινές μεταβλητές. Οι μεταβλητές της Υπερκλάσης μπορεί να είναι ότι θέλουμε αλλά μόνο οι δημόσιες και οι μοναδικές μπορούν να λογιστούν ως πεδία της κλάσης. Έξω από την κλάση δεν υπάρχει πρόσβαση ακόμα και στα δημόσια, γιατί στην ουσία τα δημόσια γυρίζουν το πεδίο του αντικειμένου και όχι της κλάσης. Πρόσβαση στα πεδία αυτά υπάρχει μόνο μέσα από τα αντικείμενα που \"γνωρίζουν\" την υπερκλάση τους.\r\nΤο πεδίο Μοναδικό (Unique) μπήκε για να μην δημιουργούνται πεδία/μεταβλητές σε αυτά που φτιάχνουμε από την Υπερκλάση. Έτσι αυτά τα πεδία είναι \"κοινά\" σε όλα τα αντικείμενα που κληρονομούν το δείκτη στην Υπερκλάση.\r\nΜπορούμε να την κάνουμε Γενική με το Υπερκλάση Γενική Άλφα { }\r\n\r\n\r\nΥπερκλάση ΑΛΦΑ {\r\n      Μοναδικό:\r\n            Χ, Υ\r\n            Πίνακας Α(20)\r\n      Δημόσιο:\r\n      \\\\ η Κ θα υπάρχει και ως Κ της υπερκλάσης και ως Κ του αντικειμένου\r\n            Κ=10\r\n            Τμήμα Εμφάνισε {\r\n                  Για Υπερκλάση, Αυτό {\r\n                        \\\\ εμφανίζουμε το Κ της κλάσης και του αντικειμένου\r\n                        Τύπωσε .Κ, ..Κ\r\n                        \\\\ Τα .Χ και .Υ είναι μόνο για τη κλάση\r\n                        .Χ++\r\n                        Τύπωσε .Χ, .Υ\r\n                        \\\\ Και πίνακες μπορούμε να βάλουμε ως μοναδικά στοιχεία.\r\n                        Τύπωσε .Α()\r\n                  }\r\n            }\r\n}\r\nΚ=ΑΛΦΑ\r\nΚ.Εμφάνισε\r\n\r\nΚλάση Δέλτα {\r\n      Ιδιότητα ΜόνοΑνάγνωση {Αξία} = 1234321\r\n      Τμήμα Δέλτα (Αυτό) {}\r\n}\r\nΜ=Δέλτα(ΑΛΦΑ)\r\nΜ.Εμφάνισε\r\nΤύπωσε Μ.ΜόνοΑνάγνωση\r\n\\\\ εδώ ο Α() έχει τα τμήματα κοινά για όλα τα στοιχεία.\r\n\\\\ και επιπλέον όλα τα στοιχεία έχουν σύνδεση με την κλάση του ΑΛΦΑ\r\n\\\\ ακόμα και να \"χαθεί\" το ΑΛΦΑ, η σύνδεση διατηρεί το αντικείμενο με τα στοιχεία.\r\nΠίνακας Α(100)=Δέλτα(Αλφα)\r\nΑ(4).Εμφάνισε\r\n\r\n\r\nΕδώ είναι το μεγαλύτερο παράδειγμα, με διπλή υπερκλάση, σε ένα αντικείμενο με δυο ομάδες. Κάθε ομάδα μπορεί να πάρει μια υπερκλάση, αλλά κάθε ομάδα μπορεί να έχει οποιοδήποτε αριθμό εμφωλευμένων ομάδων.\r\n\r\nΥπερΚλάση Κάπα1 {\r\n      χ=10\r\n      Τμήμα Εμφάνισε {\r\n            Για ΥπερΚλάση {\r\n                  .χ++\r\n                  Τύπωσε .χ, Αυτό.χ\r\n            }\r\n      }\r\n}\r\nΥπερΚλάση Κάπα2 {\r\n      χ=50\r\n            Τμήμα Εμφάνισε {\r\n            Για ΥπερΚλάση {\r\n                  .χ++\r\n                  Τύπωσε .χ, Αυτό.χ\r\n            }\r\n      }\r\n}\r\nΟμάδα Άλφα {\r\n      Ομάδα Βήτα {\r\n            \\\\ δεν θα βάλουμε εδώ ορισμούς γιατί έχει η ΥπερΚλάση\r\n            \\\\ αλλά θα μπορούσαμε να ξαναπαίξουμε τον ορισμό και να αλλάξουμε\r\n            \\\\ ακόμα και ένα τμήμα που ορίστηκε στην υπερκλάση για τη συγκεκριμένη ομάδα.\r\n      }\r\n}\r\n\\\\ Πρώτα θα συγχωνεύσουμε τη ΥπερΚλάση (θα φτιάξει νέα μέλη και θα δώσει και ένα δείκτη)\r\nΆλφα.Βήτα=Κάπα2\r\nΆλφα=Κάπα1\r\n\\\\ Τώρα έχουμε δυο ΥπερΚλάσεις, μια για την εξωτερική Ομάδα, και μια για την εσωτερική Ομάδα\r\nΆλφα.Εμφάνισε              \\\\ 11 10\r\nΆλφα.Βήτα.Εμφάνισε   \\\\ 51 50\r\n\r\nΖ=Άλφα\r\n\r\nΖ.Εμφάνισε                      \\\\ 12 10\r\nΖ.Βήτα.Εμφάνισε           \\\\ 52 50\r\nΆλφα.Εμφάνισε              \\\\ 13 10\r\nΆλφα.Βήτα.Εμφάνισε   \\\\ 53 50\r\n\r\nΠίνακας Α(10)\r\nΑ(3)=Ζ\r\nΑ(3).Εμφάνισε               \\\\ 14 10\r\nΑ(3).Βήτα.Εμφάνισε     \\\\ 54 50\r\n\r\nΚατάσταση Κατ1= 100:=Ζ\r\n\\\\ τα κλειδιά είναι αλφαριθμητικά, απλά φαίνονται και ως αριθμοί!\r\nΚατ1(\"100\").Εμφάνισε               \\\\ 15 10\r\nΚατ1(100).Βήτα.Εμφάνισε     \\\\ 55 50\r\n\r\n\r\n\r\n
EN:CDATE(\r\nΥπολογισμός μέρας. Χρησιμοποιεί μια αριθμητική τιμή ως αριθμητικό μέρας και τρεις τιμές για έτη μήνες μέρες τα οποία προσθέτει ή αφαιρεί (ανάλογα το πρόσημο της κάθε τιμής) από την πρώτη τιμή\r\nα=Σήμερα\r\nΤύπωσε Ημέρα$(ΥπΜερ(α, 0,4,0))  \\\\ 4 μήνες μετά\r\nΤύπωσε Ημέρα$(ΥπΜερ(α, 0,0,100))  \\\\ 100 μέρες αργότερα\r\nΤύπωσε Ημέρα$(ΥπΜερ(α, 0,0,-1))  \\\\ χθες\r\n
EN:SUBDIR\r\nΔες {\r\n      ΥΠΟΚΑΤΑΛΟΓΟΣ ΑΛΦΑ\r\n}\r\nΚΑΤΑΛΟΓΟΣ ΑΛΦΑ\r\nΔημιουργούμε τον ΑΛΦΑ αν δεν υπάρχει και τον επιλέγουμε\r\n\r\n
EN:MOD\r\nΤύπωσε 13 υπολ 3\r\n1\r\nΤύπωσε 13.5 υπολ 3\r\n1.5\r\n
EN:MOD#\r\nΕκλείδειο υπόλοιπο.\r\nα=-20\r\nβ=6\r\n\\\\ Ευκλείδεια διαίρεση και υπόλοιπο\r\nγ=α Διά# β\r\nδ=α Υπόλ# β\r\nΤύπωσε γ, δ  ' -4   4\r\nΤύπωσε α=β*γ+δ\r\n\\\\ Κανονική διαίρεση και υπόλοιπο\r\nγ=α Διά β\r\nδ=α Υπόλ β\r\nΤύπωσε γ, δ ' -3  -2\r\nΤύπωσε α=β*γ+δ\r\n\r\n\r\n
EN:COMPUTER$\r\nΔίνει το όνομα του υπολογιστή\r\nΤυπωσε Υπολογιστης\r\n\r\n\r\n
EN:MEMO\r\nχρησιμοποιείται στην εντολή ΑΡΧΕΙΟ\r\n\r\n
EN:CTIME(\r\nΜπορούμε να κάνουμε υπολογισμούς με ώρες, λεπτά, δευτερόλεπτα\r\nΤΥΠΩΣΕ ΓΡΑΦΗ$(ΥΠΩΡΑ(0,10,5,3),\"hh:mm:ss\")\r\nΔες παράδειγμα παρακάτω:\r\nα=τώρα+σήμερα\r\nβ1=ΥπΩρα(α,0,100,0)  ' 100  λεπτά αργότερα\r\nβ2=ΥπΩρα(α,100,0,0)  ' 100 ώρες αργότερα\r\nΤύπωσε Γραφή$(α,\"dd-mm-yyyy hh:nn:ss\")\r\nΤύπωσε Γραφή$(β1,\"dd-mm-yyyy hh:nn:ss\")\r\nΤύπωσε Γραφή$(β2,\"dd-mm-yyyy hh:nn:ss\")\r\n\r\nΓράψε το παρακάτω  σε ένα αρχείο με Σ \"ωρα.gsb\" και απλά το αντιγράφουμε και πατάμε Esc\r\nΤΜΗΜΑ Α {\\\\ Αναλογικό ρολόι-ξυπνητήρι\r\nΟθόνη 5,0\r\nΠενα 14\r\nΠεριθώριο {Πένα 14}\r\nΆναψε\r\nΕπιφάνεια 220, 5\r\n\\\\ ανοίγει με ctrl+f1\r\nΠερί ! \"Μ2000 Ρολόι\", 10000, 6000,{Ρολόι 12 ωρών, και ξυπνητήρι 12 ωρών\r\n      Πλήκτρα:\r\n            Μεσαίο πλήκτρο του ποντικιού βάζει/βγάζει το ξυπνητήρι/ σταματάει το κουδούνισμα\r\n            Αριστερό/Δεξί πλήκτρο αλλάζει το ξυπνητήρι ανά λεπτό\r\n            Μαζί με το μεσαίο αλλαζει το ξυπνητήρι ανά 10 λεπτά\r\n            Τα βελάκια αριστερά - δεξιά αλλάζει επίσης το ξυπνητήρι\r\n            Μαζί με το άνω βελάκι αλλάζει το ξυπνητήρι ανά 10 λεπτά\r\n            Το κάτω βελάκι βάζει/βγάζει το ξυπνητήρι/ σταματάει το κουδούνισμα\r\n            Το Enter αλλάζει τους δείκτες σε εμφάνιση (ανά ολόκληρες ώρες ή αναλογικά)\r\n            Το διάστημα κλείνει το πρόγραμμα\r\n      }\r\nκχ=χ.σημεία-4000\r\nκυ=4000\r\nαπ1=3000\r\nαπ2=600\r\nαπ3=απ1-απ2\r\nκυκλ=πι*2\r\nκυκλ60=κυκλ/60\r\nΞυπνητήρι=0\r\nΞυπνητήριΟκ=Ψευδής\r\nΠαίξεΉχο=Ψευδής\r\nΟλόκληρεςΏρες=Ψευδές\r\nΑναβοσβήνει=Ψευδής\r\nΑρχικόςΧρόνος=20*10 \\\\ 20 δευτερόπλεπτα\r\nΧρόνοςΜπιπ=ΑρχικόςΧρόνος\r\nΩρα=0\r\nΩρα12=0\r\nλεπτό=υπωρα(0,0,1,0)\r\nΘέση κχ, κυ\r\n\\\\ η χρώμα { } ; φτιάχνει περιοχή μόνο για εμφάνιση\r\nΧρώμα { Κύκλος Γέμισμα 2, απ2+απ1 } ;\r\nΘέση κχ-απ2-απ1, κυ-απ2-απ1\r\nΒάψε 2*(απ2+απ1),2*(απ2+απ1), 7,1,1\r\nΘέση κχ, κυ-απ1*3/4\r\nΤίτλος \"Μ2000 Ρολόι\"\r\nΕπιγραφή \"Μ2000 Ρολόι\",\"Arial Black\",18,0,2\r\nΘέση κχ, κυ\r\n\\\\ με χρώμα 5 αντί για #2277ff γίνεται διάφανο\r\n\\\\ έχουμε δηλώσει το 5 (ματζέντα) στην εντολή Επιφάνεια\r\nΠένα #2277ff {Κύκλος Γέμισμα #2277ff, απ3/2}\r\nπ=2\r\nι=0\r\nΓια ν=0 εως 59 \r\n      Αν ν υπολ 5 = 0 τότε {π=4} αλλιώς π=1\r\n      Πάχος π {\r\n            Βήμα γωνια ι, απ1\r\n            Χάραξε γωνία ι, απ2\r\n            Βήμα γωνια ι, -απ2-απ1\r\n      }\r\n            ι+=κυκλ60\r\nΕπόμενο ν\r\nΚράτησε\r\nΑνανέωση 1000\r\nΚάθε 100  {\r\nΑναβοσβήνει~   \\\\ αντιστροφή λογικής  (Αναβοσβήνει = Δεν Αναβοσβήνει)\r\nΆφησε\r\nΩρα=Τώρα\r\nΩρα12=(τιμη(γραφη$(Ωρα,\"h\")) υπολ 12) *60+τιμη(γραφη$(Ωρα,\"n\"))\r\nΘέση κχ, κυ+απ1/2\r\n      Αν Ωρα12<60 τότε {\r\n            Επιγραφή Γραφη$(υπωρα(0,12,Ωρα12,τιμη(γραφη$(Ωρα,\"s\"))), \"hh:nn:ss\"), \"Verdana\", 18,0,2\r\n      } Αλλιώς {\r\n            Επιγραφή Γραφη$(υπωρα(0,0,Ωρα12,τιμη(γραφη$(Ωρα,\"s\"))), \"hh:nn:ss\"), \"Verdana\", 18,0,2\r\n      }\r\nΠένα -ΞυπνητήριΟκ*8+4 {      \r\n      Βήμα , +απ1/8\r\n      Επιγραφή \"+\"+Γραφη$(υπωρα(0,0,(ξυπνητήρι-Ωρα12+720) υπολ 720,0), \"hh:nn \"), \"Verdana\", 18,0,2\r\n      Βήμα , +απ1/8\r\n\r\n      Αν ξυπνητήρι<60 τότε {\r\n            Επιγραφή Γραφη$(υπωρα(0,12,ξυπνητήρι,0), \"hh:nn\"), \"Verdana\", 18,0,2\r\n      } Αλλιώς {\r\n            Επιγραφή Γραφη$(υπωρα(0,0,ξυπνητήρι,0), \"hh:nn\"), \"Verdana\", 18,0,2\r\n      }\r\n}\r\nΘέση κχ, κυ\r\nγωνία_ξυπν=-ξυπνητήρι*πι/360+πι/2\r\nΑν  Αναβοσβήνει ή όχι ΞυπνητήριΟκ τότε {\r\n      Πάχος 2 {\r\n            Βήμα Γωνία γωνία_ξυπν, απ3\r\n            Χάραξε Γωνία γωνία_ξυπν, απ2, 13\r\n                  Βήμα Γωνία γωνία_ξυπν, -απ2\r\n            Βήμα Γωνία γωνία_ξυπν, -απ3\r\n      }\r\n}\r\nΑν ΟλόκληρεςΏρες Τότε {\r\n       γωνια_ώρα=-(τιμη(γραφη$(Ωρα,\"h\")) υπολ 12)*πι/6+πι/2\r\n} Αλλιώς  γωνια_ώρα=-(τιμη(γραφη$(Ωρα,\"h\")) υπολ 12+τιμη(γραφη$(Ωρα,\"n\"))/60)*πι/6+πι/2\r\nΠάχος 2 {\r\n      Χάραξε Γωνία γωνία_ώρα+πι/20, απ3/2\r\n      Χάραξε Γωνία γωνία_ώρα-πι/20, απ3/2\r\n      Χάραξε Γωνία γωνία_ώρα+πι/20, -απ3/2\r\n      Χάραξε Γωνία γωνία_ώρα-πι/20, -απ3/2\r\n}\r\nΑν ΟλόκληρεςΏρες Τότε {\r\n      γωνία_λεπτά=-τιμη(γραφη$(Ωρα,\"n\"))*πι/30+πι/2\r\n} Αλλιώς {\r\n      γωνία_λεπτά=-(τιμη(γραφη$(Ωρα,\"n\"))+τιμη(γραφη$(Ωρα,\"s\"))/60)*πι/30+πι/2\r\n}\r\nΠάχος 2 {\r\n      Χάραξε Γωνία γωνία_λεπτά+πι/20, απ1/2\r\n      Χάραξε Γωνία γωνία_λεπτά-πι/20, απ1/2\r\n      Χάραξε Γωνία γωνία_λεπτά+πι/20, -απ1/2\r\n      Χάραξε Γωνία γωνία_λεπτά-πι/20, -απ1/2\r\n}\r\nγωνία_δευτ=-τιμη(γραφη$(Ωρα,\"s\"))*πι/30+πι/2\r\nΠάχος 2 {\r\n      Χάραξε Γωνία γωνία_δευτ, απ3, 15\r\n      Βήμα Γωνία γωνία_δευτ, -απ3\r\n}\r\nΑν Πατημένο(1) ή Πατημένο(0x25) τότε {\r\nΑν Πατημένο(4) ή Πατημένο(0x26) τότε {ξυπνητήρι-=10: ΞυπνητήριΟκ=Αληθής} αλλιώς ξυπνητήρι-- \r\n      ξυπνητήρι=(ξυπνητήρι+720) υπολ 720\r\n} Αλλιως.Αν Πατημένο(2) ή Πατημένο(0x27) τότε {\r\nΑν Πατημένο(4)  ή Πατημένο(0x26) τότε {ξυπνητήρι+=10: ΞυπνητήριΟκ=Αληθής} αλλιώς ξυπνητήρι++ \r\n      ξυπνητήρι=(ξυπνητήρι+720) υπολ 720\r\n}\r\nΑν Πατημένο(32) τότε Έξοδος\r\nΑνανέωση 1000\r\nΑν ΞυπνητήριΟκ και ΧρόνοςΜπιπ>0 Τότε {\r\n      Αν (τιμη(γραφη$(Ωρα,\"h\")) υπολ 12 )*60+τιμη(γραφη$(Ωρα,\"n\"))=ξυπνητήρι τότε {\r\n            ΠαίξεΉχο=Αληθής\r\n      }\r\n}\r\nΑν ΞυπνητήριΟκ και όχι (Πατημένο(2) ή Πατημένο(1)) Τότε {\r\n      Αν Πατημένο(4) ή Πατημένο(0x28) Τότε ΠαίξεΉχο=Ψευδής: ΞυπνητήριΟκ=Ψευδής : ΧρόνοςΜπιπ=ΑρχικόςΧρόνος\r\n} Αλλιώς.Αν Πατημένο(4) ή Πατημένο(0x28) Τότε {\r\n            ΞυπνητήριΟκ=Αληθής\r\n            ΧρόνοςΜπιπ=ΑρχικόςΧρόνος\r\n}\r\nΑν ΠαίξεΉχο Τότε {\r\n      Αν ΧρόνοςΜπιπ υπολ 3 =0 τότε Μπιπ\r\n      ΧρόνοςΜπιπ-- \r\n      Αν ΧρόνοςΜπιπ=0 Τότε ΠαίξεΉχο=Ψευδής: ΞυπνητήριΟκ=Ψευδής\r\n}\r\n\r\nΑν Πατημένο(13) τότε ΟλόκληρεςΏρες~  \\\\ αντιστροφή αληθές<>ψευδές\r\n}\r\nΟθόνη \\\\ επαναφορά από το περιορισμό περιοχής της Χρώμα\r\nΕπιφάνεια 255\r\n\r\n}\r\nΑ:Τέλος\r\n\r\n\r\n\r\n
EN:HEIGHT\r\nΔίνει το ύψος σε χαρακτήρες της ΟΘΟΝΗΣ (ή του ΠΕΡΙΘΩΡΙΟΥ, ΔΕΣ ΠΕΡΙΘΩΡΙΟ)\r\n\r\n
EN:TWIPSY\r\nΥΨΟΣ.ΣΗΜΕΙΟΥ\r\nμας δίνει το ύψος σημείου της οθονης σε twips\r\n\r\n\r\n
EN:ENVELOPE$(\r\n1) Τυπωσε Φακελος$()\r\n      τυπώνει ένα αλφαριθμητικό με τον τύπο των στοιχείων του σωρού \"εργασίας\", του τρέχοντος, δηλαδή του σωρού που είναι κοινός στα τμήματα, ενώ στις συναρτήσεις χρήστη είναι ιδιωτικός.\r\n2) Τυπωσε Φακελος$(α$)\r\n      τυπώνει το φάκελο του σωρού α$  (που έχει δημιουργηθεί με την Σωρός$())\r\n\r\n\r\nΤμημα A {      \r\n      α$=Σωρος$(1,3,\"ονομα\",4,\"περιοχη\",6)\r\n      Τυπωσε \"NNSNSN\"\r\n      Τυπωσε Φακελος$(α$)\r\n}\r\nΔιαβάζουμε με την ΦΑΚΕΛΟΣ$() τι περιλαμβάνει η μεταβλητή α$ όπου έχουμε δώσει μια σειρά δεδομένων ως σωρός. \r\nΤα γράμματα που επιστρέφει είναι στα αγγλικά (ενώ δέχεται στα ελληνικά)\r\nTo F είναι για την συνάρτηση Λάμδα  [N]umber, [G]roup, [E]vent, [B]uffer, [I]nventory, [A]rray, [F]unction, [S]tring, Sta[C]k\r\n(οι συναρτήσεις που μπαίνουν με αναφορά - εκτός λάμδα- έχουν τύπο αλφαριθμητικού και γενικά ότι μπαίνει με αναφορά είναι αλφαριθμητικόι και η μετατροπή γίνεται στην Διάβασε)\r\nΑ=10\r\nΒάλε &Α\r\nΤύπωσε Φάκελος$()\r\nΔιάβασε &Β\r\nΒ++\r\nΤύπωσε Α\r\n\r\nΓια να δούμε τι έχει ένα αντικείμενο σωρός πρέπει να το κάνουμε πρόσκαιρα τρέχον σωρό\r\nα=Σωρός:=1,2,3,4\r\nΣωρός α {\r\n      Τύπωσε Φάκελος$()\r\n}\r\n\r\n
EN:SHOW$(\r\nΜετατρέπει ένα κρυπτογραφημένο αλφαριθμητικό σε ένα αλφαριθμητικό (μισού μήκους). Δέχεται για όρισμα το προς αποκρυπτογράφηση αλφαριθμητικό, ένα αλφαριθμητικό για κωδικό καθώς και έναν αριθμό που επίσης διαφοροποιεί τον κωδικό.\r\nδες ΚΡΥΦΟ$()\r\n\r\n
EN:BOLD\r\nΦΑΡΔΙΑ : ΤΥΠΩΣΕ \"ΑΥΤΑ ΕΙΝΑΙ ΓΡΑΜΜΑΤΑ\": ΦΑΡΔΙΑ\r\nκάθε φορά που χρησιμοποιούμε την εντολή ΦΑΡΔΙΑ αυτή αλλάζει το πάχος από φαρδύ σε λεπτό και πάει λέγοντας... \r\nΑΛΛΟΣ ΤΡΟΠΟΣ\r\nΦΑΡΔΙΑ 1  - κάνει τα γράμματα φαρδιά\r\nΦΑΡΔΙΑ 0 - κάνει τα γράμματα λεπτά\r\n\r\n
EN:SHIFT\r\n1) ΦΕΡΕ 5\r\n2) ΦΕΡΕ \r\n3) ΦΕΡΕ Ν, Μ\r\n\r\nΦέρνουμε το 5ο στοιχείο του σωρού στη κορυφή (αν δεν υπάρχει 5ο στοιχείο τότε βγαίνει λάθος)\r\nΗ δεύτερη περίπτωση είναι ισοδύναμη με το ΦΕΡΕ ΜΕΓΕΘΟΣ.ΣΩΡΟΥ\r\nΣτην τρίτη περίπτωση ζητάμε από το Ν να φέρει Μ στοιχεία.\r\nΥπάρχει και το αντίστροφο ΦΕΡΕΠΙΣΩ\r\n\r\nΑΔΕΙΑΣΕ    ' καθαρίζει το σωρό\r\nΣΕΙΡΑ 1,2,3,4,5      ' βάζει τη σειρά στο τέλος του σωρού με το τελευταίο στοιχείο...τελευταίο\r\nΦΕΡΕ 3\r\nΣΩΡΟΣ\r\n      3 1 2 4 5\r\n' μπορούμε να αλλάξουμε το μεταφερόμενο στοιχείο και να το βάλουμε στη θέση του\r\nΒΑΛΕ ΑΡΙΘΜΟΣ+100               ' εδω διαβάζουμε τη κορυφή - άρα πετάμε το στοιχείο - και ξαναβάζουμε το αποτέλεσμα\r\nΦΕΡΕΠΙΣΩ 3\r\nΣΩΡΟΣ\r\n      1 2 103 4 5\r\n      \r\n      \r\n
EN:SHIFTBACK\r\n1) ΦΕΡΕΠΙΣΩ 5\r\n2) ΦΕΡΕΠΙΣΩ\r\n3) ΦΕΡΕΠΙΣΩ Ν, Μ\r\nφέρνει τη κορυφή του σωρού στη 5η θέση\r\nη δευτερη περίπτωση στέλνει τη κορυφή στο πάτο.\r\nΤρίτη περίπτωση: Στέλνουμε Μ στοιχεία στη Ν θέση. \r\nΔες ΦΕΡΕ, ΠΑΝΩ, ΠΕΤΑ, ΣΩΡΟΥΤΙΜΗ(), ΣΩΡΟΥΤΙΜΗ$(),\r\n      ΑΡΙΘΜΟΣ, ΓΡΑΜΜΑ$, ΕΙΝΑΡ, ΕΙΝΓΡ, ΑΔΕΙΟ, ΑΔΕΙΑΣΕ, ΣΩΡΟΣ\r\n\r\n
EN:DESCENDING\r\nΧρησιμοποιείται στην εντολή ΤΑΞΗ\r\nκαι στην Ταξινόμηση\r\n
EN:FILTER$(\r\n? ΦΙΛΤΡΟ$(\"ΑΒΓΔΕΖ\",\"ΒΓΖ\")\r\nΑΔΕ\r\n\r\nκαθαρίζει το πρώτο αλφαριθμητικό από τη λίστα χαρακτήρων στο δεύτερο αλφαριθμητικό.\r\nδες την ΑΛΛΑΓΗ$(\r\nτο παράδειγμα παραπάνω ως σειρές της ΑΛΛΑΓΗ$()\r\nα$=\"ΑΒΓΔΕΖ\"\r\nα$=ΑΛΛΑΓΗ$(α$,\"Β\")\r\nα$=ΑΛΛΑΓΗ$(α$,\"Γ\")\r\nα$=ΑΛΛΑΓΗ$(α$,\"Ζ\")\r\n\r\n
EN:GRADIENT\r\nΜπορούμε να γεμίσουμε την οθόνη ή το περιθώριο ή την σελίδα του εκτυπωτή με ένα φόντοι ενός η δυο χρωμάτων.\r\n\r\nΦΟΝΤΟ χρωμα1\r\nΦΟΝΤΟ χρωμα1, χρωμα2\r\nΦΟΝΤΟ χρωμα1, χρωμα2, οριζόντια \r\n\r\nοριζόντιο= 0 ή 1\r\n\r\nΠΑΡΑΔΕΙΓΜΑ\r\nΤΜΗΜΑ Α {\r\n      τυπος 12, 8000\r\n      περιθωριο {\r\n            επιφανεια\r\n            χρωμα ! {φοντο 1,2}\r\n      }\r\n}\r\n\r\n
EN:FORM\r\n1) ΦΟΡΜΑ 10\r\nη εντολή αυτή κάνει και για τον εκτυπωτή και για τα επίπεδα.\r\n2) ΦΟΡΜΑ 80,25\r\nη εντολή αυτή κάνει και για τα επίπεδα (αλλά δεν αλλάζει την απόσταση γραμμής αυτόματα)\r\n3) ΦΟΡΜΑ\r\n4) ΦΟΡΜΑ ;\r\n5) ΦΟΡΜΑ 10,25;\r\n\r\nη εντολή ΦΟΡΜΑ αλλάζει τον τυπο των γραμμάτων (το μέγεθος) της Οθονης ώστε να πετύχει το πλάτος σε αριθμό χαρακτήρων που θέλουμε ή και το ύψος σε αριθμό χαρακτήρων, στο παράθυρο που έχουμε ορίσει.\r\nΤο πρόβλημα εδώ είναι ότι αν δώσουμε πολύ μεγάλο νούμερο απλά δεν θα βλέπουμε γράμματα!\r\nΑν δεν δώσουμε ύψος τότε δίνεται αυτόματα το μέγιστο που μπορεί να δώσει.\r\nΜια φορμα 20 και μια φορμα 20,80 θα δώσουν δυο διαφορετικές οθόνες που θα έχουν όμως ίδιο πλάτος σε χαρακτήρες.\r\n\r\nΗ τρίτη περίπτωση κάνει το σύστημα να κόψει το περιθώριο γύρω από την οθόνη\r\n\r\nΗ τέταρτη περίπτωση κάνει το σύστημα να επαναφέρει το περιθώριο γύρω από την οθόνη (καλύπτει δηλαδή όλη την επιφάνεια εργασίας).\r\n\r\nΗ πέμπτη κάνει ότι η 2 και η 4 μαζί και επιπλέον βάζει Διαστιχο 0\r\nΣτις 1,2,5 το ! μετά το αναγνωριστικό Φόρμα αφήνει ένα μικρότερο πλαίσιο για να μην καλύπτεται σε οθόνες όπου ένα μέρος της οθόνης κρύβεται (αυτό γίνεται σσε τηλεοράσεις). Δοκιμάστε το Φόρμα 60,32 και το Φόρμα ! 60,32\r\n\r\nΑν θέλουμε να φτιάξουμε μια οθόνη σαν στήλη, με 20 γράμματα στη γραμμή και 60 γραμμές χαρακτήρων τότε:\r\nΦορμα ;     \r\nΦορμα 20,60 \r\nΦορμα\r\n' τώρα θα την στείλω αριστερά, θα κόψω είκοσι γραμμές και θα την τοποθετήσω πάνω αριστερά\r\nκινηση.π 0 \r\nφορμα 20,40 \r\nκινηση 0,0  \r\nφορμα \r\n
EN:CONTROL$\r\nΤΥΠΩΣΕ ΦΟΡΜΑ$\r\nδίνει το όνομα της ενεργής φόρμα αν είναι μια από τα ΤΑΙΝΙΑ, ΚΥΡΙΟ, ΒΟΗΘΕΙΑ ή κάποιο παράθυρο χρήστη (φόρμα)\r\nΑν έχουμε πίνακα παραθύρων τότε θα δώσει το όνομα της φόρμας με παρενθέσεις και το νούμερο της φόρμας.\r\n\r\nΜπορούμε να ελέγχουμε αν στηνεφαρμογή μας είναι στο προσκήνιο ένα από αυτά τα τρία. Αν είναι κάποιο τότε παίρνουμε το όνομα. Αν έχουμε το περιβάλλον σε ελαχιστοποίηση τότε μας επιστρέφει ένα άδειο αλφαριθμητικό.\r\n\r\n
EN:FORMATTING_STRINGS\r\nΓια την ΓΡΑΦΗ$( και την εσωτερική συνάρτηση της ΤΥΠΩΣΕ την $(\r\n\r\n1)@\r\nΘέση εκτύπωσης ενός χαρακτήρα αν υπάρχει στο προς φορμάρισμα αλφαριθμητικό, διαφορετικά τυπώνει το διάστημα\r\n2)&\r\nΘέση εκτύπωσης ενός χαρακτήρα αν υπάρχει στο προς φορμάρισμα αλφαριθμητικό, διαφορετικά δεν τυπώνει καθόλου χαρακτήρα\r\n3)<\r\nΜετατρέπει σε πεζά τους χαρακτήρες που ακολουθούν\r\n4)>\r\nΜετατρέπει σε κεφαλαία τους χαρακτήρες που ακολουθούν\r\n5)!\r\nΑλλάζει την καθορισμένη φορά εκτύπωσης\r\n\r\n
EN:FORMATTING_NUMBERS\r\nΓια την ΓΡΑΦΗ$( και την εσωτερική συνάρτηση της ΤΥΠΩΣΕ την $(\r\n1)0\r\nΤυπώνει αριθμό ή το 0 \r\n2)#\r\nΤυπώνει αριθμό ή τίποτα\r\n3).\r\nΘέση υποδιαστολής\r\n4)%\r\nΜετατροπή σε ποσοστό. Η έκφραση πολλαπλασιάζεται επί 100 και μπαίνει σε αυτή την θέση το σύμβολο %\r\n5),\r\nΔιαχωριστής χιλιάδων\r\n6) E- E+ e- e+\r\nΕπιστημονική γραφή αριθμών\r\n\r\n
EN:FORMATTING_ANY TYPE\r\nΓια την ΓΡΑΦΗ$( και την εσωτερική συνάρτηση της ΤΥΠΩΣΕ την $(\r\n\\\r\nτυπώνει τον επόμενο χαρακτήρα που θα βρει στο αλφαριθμητικό φορμαρίσματος\r\nΕξαιρούνται τα : a, c, d, h, m, n, p, q, s, t, w, y, / και :\r\n(\"  ... \")\r\nΤυπώνει τους περιεχόμενους χαρακτήρες (εδώ ... )\r\n\r\n
EN:FORMATTING_DATE AND TIME\r\n1):\r\nδιαχωριστικό ώρας\r\n2)/\r\nδιαχωριστικό ημερομηνίας\r\n3)c\r\nολόκληρη ώρα/ημερομηνία\r\n4)d\r\nημέρα ως αριθμός χωρίς 0 στην αρχή (1 - 31)\r\n5)dd\r\nόπως η d αλλά με αρχικό 0 αν χρειάζεται\r\n6)ddd\r\nημέρα με τρία γράμματα\r\n7)dddd\r\nημέρα με όνομα\r\n8)ddddd\r\nπλήρες ημερομηνία με ονόματα\r\n9)w\r\nαριθμός μέρα με νούμερο, 1 για Κυριακή και 7 για Σάββατο\r\n10)ww\r\nΑριθμός εβδομάδας έτους (1-54)\r\n11)m\r\nΑριθμός μήνα χωρίς αρχικό 0   (1-12))\r\n12)mm\r\nόπως το m αλλά με αρχικό 0\r\n13)mmm\r\nμήνας με τρία γράμματα\r\n14)mmmm\r\nολόκληρο το όνομα του μήνα\r\n15)q\r\nΑριθμός τριμήνου του έτους(1-4)\r\n16)y\r\nΑριθμός μέρας του έτους (1-366)\r\n17)yy\r\nέτος με μόνο τα δυο τελευταία νούμερα\r\n18)yyyy\r\nαρθιθμός έτους (100-9999)\r\n19)h\r\nώρα χωρίς αρχικό 0 (0 - 23)\r\n20)hh\r\nώρα με αρχικό 0 αν χρειαστεί (0 - 23)\r\n21)n\r\nλεπτά χωρίς αρχικό 0 (0 - 59)\r\n22)nn\r\nλεπτά με αρχικό 0 αν χρειαστεί  (00 - 59)\r\n23)s\r\nδευτερόλεπτα χωρίς αρχικό 0 (0 - 59)\r\n24)ss\r\nδευτερόλεπτα με αρχικό 0 αν χρειαστεί (00 - 59)\r\n25)ttttt\r\nώρα πλήρης μορφή\r\n26)AM/PM\r\nενδεικτικό δωδεκάωρου με κεφαλαία \r\n27)am/pm\r\nενδεικτικό δωδεκάωρου με πεζά\r\n28)A/P\r\nΕνδεικτικό δωδεκάωρου με ένα γράμμα\r\n29)AMPM\r\nΧρήση ενδεικτικού δωδεκάωρου του συστήματος\r\n
EN:TIMECOUNT\r\nΜας δίνει τον αριθμό χιλιοστών του δευτερολέπτου που έφθασε ένας εσωτερικός μετρητής του ΑΝΑΛΥΤΗ\r\n\r\nΔες εντολή ΑΝΑΛΥΤΗΣ\r\n\r\n
EN:LOAD\r\nΑπό την έκδοση 9, αποθηκεύονται τα φορτώματα, και όταν ζητάμε ξανά να φορτώσουν διαβάζονται από τα αποθηκευμένα, μπορούμε να αναιρέσουμε το διάβασμα των αποθηκευμένων με την Φόρτωσε Νέο\r\n(και Νέα παίρνει)\r\nΜε Φόρτωσε Τμήματα θα φορτώσει χωρίς να τρέξει εντολές για τμήματα (θα τις πετάξει) \r\nΥπάρχει και ο συνδυασμός Φόρτωσε Νέα Τμήματα\r\n\r\nΑπό την έκδοση 7 μπορούμε να ανοίξουμε UTF-8, UTF-16 και ANSI αρχεία (τα gsb αρχεία της Μ2000 είναι αρχεία κειμένου, εκτός από τα κωδικοποιημένα)\r\n\r\n\r\n\r\n1) Φόρτωση τμημάτων\r\nΦΟΡΤΩΣΕ \"ονομα\" [ && \"αλλο όνομα\"\r\nΦΟΡΤΩΣΕ ονομα && ονομα3 && \"άλλο όνομα\"\r\nΑν είχαμε σώσει και άμεσης εκτέλεσης εντολή τότε αυτή θα ενεργοποιηθεί\r\nΑν είχαμε σώσει κωδικοποιημένα τα τμήματα του αρχείου \"ονομα\", με το βασικό κλειδί τότε δεν θα μπορούμε να βλέπουμε τον κώδικα αυτών\r\n2) Φόρτωση κωδικοποιημένων τμημάτων με δικό μας κωδικό\r\nΦΟΡΤΩΣΕ \"ονομα\", \"ΚΩΔΙΚΟΣΜΟΥ\"\r\nΦΟΡΤΩΣΕ ονομα,  \"ΚΩΔΙΚΟΣΜΟΥ\"  \r\n\r\nΠαρατήρηση.\r\nΜπορούμε να κάνουμε φόρτωση τμημάτων μέσα από άλλα τμήματα. Όταν το τμήμα που κάλεσε την ΦΟΡΤΩΣΕ τερματίσει τότε διαγράφονται και τα φορτωμένα τμήματα της φόρτωσης.\r\nΘα μπορούσε κανείς να έχει δυο ή περισσότερες παραλλαγές ενός τμήματος και να επιλέγει ανάλογα να φορτώνει αυτή που χρειάζεται τη δεδομένη στιγμή.\r\nΕπίσης κάποια τμήματα θα μπορούσαν να είχαν μόνο εντολές καταχώρισης τιμών στο σωρό και με την φόρτωσή τους να μας παρείχαν αυτές τις τιμές.\r\n\r\nΜπορούμε να φορτώσουμε κώδικα στα ελληνικά αν έχει στην αρχή το ΚΛΑΣΗ ή ΤΜΗΜΑ ή ΣΥΝΑΡΤΗΣΗ\r\n\r\n\r\n
EN:LOAD.DOC\r\nΦΟΡΤΩΣΕ.ΕΓΓΡΑΦΟ έγγραφο$, όνομα_αρχείου$\r\n\r\nονομα$=\"Γιώργος\"\r\nΚείμενο utf-8 alfa.txt { Γραμμές Κειμένου\r\n                  Εδώ βάζουμε μια τιμή \"##ονομα$##\"\r\n                  Άλλες γραμμές\r\n                  }\r\n\r\nΈγγραφο α$\r\nΦόρτωσε.Εγγραφο α$, Προσωρινό$+\"alfa.txt\"\r\nΑναφορά α$\r\n\r\n
EN:SCORE\r\n     SCORE 3, 1000, \"C5F#@2B@2C5F#@2B\"\r\n     SCORE 1, 1000, \"D@2E@2C#3 @2D5@2V90 @3F#4V127\"\r\n                    '/ C C# D D# E F F# G G# A A# B  \r\n                    '/\r\n     PLAY   1, 19, 3, 22  ' VOICE, INSTRUMENT\r\n   \r\nΥπάρχουν 16 φωνές\r\nΦωνη 12, 1000,\"C5\"\r\nβάζουμε στη φωνή 12 να παίξει μια νότα από την 5η οκτάβα για 1000 χιλιοστά\r\nαν βάλουμε @2 θα παίξει σε χρόνο 1000/2, μέχρι @6 δηλαδή 1000/32\r\nαν βάλουμε V και έναν αριθμό από 1 μέχρι 127 αλλάζουμε την ένταση\r\nαν δεν βάλουμε γράμμα νότας και βάλουμε διάστημα τότε παίζει παύση με το διαιρέτη @ αν υπάρχει\r\nΓια να παίξουμε τη κάθε φωνή αρκεί να δώσουμε μια εντολή ΠΑΙΞΕ ή PLAY\r\nόπου συνδιάζουμε φωνή και όργανο\r\nη Παιξε 0 κλείνει την μουσική.\r\nη Ενταση αλλάζει την ένταση του ήχου συνολικά.\r\nη Επιλεξε.Οργανο δίνει το νούμερο στο όργανο που θα επιλέξουμε από μια λίστα οργάνων για να το χρησιμοποιήσουμε στην Παιξε (το διαβάζουμε με την ΕΠΙΛΟΓΗ)\r\n\r\n\r\n
EN:JPG$(\r\nΔίνουμε ένα όνομα αρχείου JPG χωρίς κατάληξη και εξάγει αν υπάρχει το αρχείο το πλήρες όνομά του (με τη διεύθυνσή του και την κατάληξη JPG)\r\n
EN:X.TWIPS\r\nΜέγιστα σημεία Χ στην ΟΘΟΝΗ ή στο ΠΕΡΙΘΩΡΙΟ (ΔΕΣ ΠΕΡΙΘΩΡΙΟ)\r\nσυνώνυμο με ΚΛΙΜΑΞ.Χ\r\n
EN:CHR$(\r\n\r\nΕπιστρέφει έναν χαρακτήρα (ως αλφαριθμητικό) βάσει τις αριθμητικής τιμής που δίνουμε ως όρισμα. Αντίθετη εντολή της ΚΩΔ(\r\nΤΥΠΩΣΕ ΧΑΡ$(ΚΩΔ(\"λ\"))\r\n δες και το ΧΑΡΚΩΔ()  και τα ΧΑΡΚΩΔ$()\r\n\r\nα$=Γραφή$(\"Hello\")\r\n\\\\ το α$ γράφεται σαν Ansi αλφαριθμητικό, ένα byte ανά χαρακτήρα.\r\nΤύπωσε Μήκος(α$)=2.5\r\nΤύπωσε \"Bytes:\"=Μήκος(α$)*2  ' 5 bytes\r\nΤύπωσε Μήκος(χαρ$(α$))=5\r\nΤύπωσε α$\r\n\r\n\r\n
EN:CHARSET\r\nΧΑΡΑΚΤΗΡΕΣ 161 (όμοιο με εντολή ΕΛΛΗΝΙΚΑ)\r\nΧΑΡΑΚΤΗΡΕΣ 0 (όμοιο με εντολή ΛΑΤΙΝΙΚΑ)\r\nΤΥΠΩΣΕ ΧΑΡΑΚΤΗΡΕΣ\r\n   161\r\nΜπορούμε να ορίσουμε κωδικοσελίδα για οθόνη, περιθώριο, επίπεδα και εκτυπωτή.  \r\nΑΛΛΑΖΕΙ ΤΗΝ ΚΩΔΙΚΟΣΕΛΙΔΑ ΣΤΗΝ ΕΚΤΥΠΩΣΗ ΣΤΗΝ ΟΘΟΝΗ (Η ΣΤΟΝ ΕΚΤΥΠΩΤΗ ΑΝΑΛΟΓΑ)\r\nΔΕΣ ΕΛΛΗΝΙΚΑ, ΛΑΤΙΝΙΚΑ\r\nΑπό τις ΡΥΘΜΙΣΕΙΣ μπορούμε να αλλάξουμε την από εκκίνηση τιμή της κωδικοσελίδας\r\n\r\n
EN:DRAW\r\n1) Καρτεσιανές Συντεταγμένες\r\nΧΑΡΑΞΕ σχετικη_θεση_χ, σχετικη_θεση_ψ, χρωμα\r\n2) Πολικές Συντεταγμένες\r\nΧΑΡΑΞΕ ΓΩΝΙΑ  απολυτη_γωνια_χ, αποσταση,  χρωμα \r\n      απόλυτη γωνία σημαίνει ότι το 0 θα δίνει πάντα κατεύθυνση δεξιά\r\n      οι γωνίες είναι σε ακτίνια (2*πι είναι πάλι το 0, κατεύθυνση δεξιά)\r\n      Το χρώμα και στις δυο περιπτώσεις μπορεί να είναι:\r\n       α) Σταθερά χρώματα των WINDOWS από 0 έως 15\r\n       β) RGB (RED GREEN BLUE) με πρόσημο -\r\n       μπορεί κανείς να χρησιμοποιήσει την συνάρτηση ΧΡΩΜΑ( κόκκινο,  πράσινο, μπλε)\r\n       τα βασικά χρώματα δέχονται τιμές 0 .. 255. Η συνάρτηση αυτή μπορεί να χρησιμοποιηθεί οπουδήποτε έχουμε να δώσουμε τιμή χρώματος και δίνει ένα αρνητικό νούμερο. Η έκτη έκδοση περνάει και τιμές δεκαεξαδικές..π.χ. -oxffffff είναι το άσπρο (το - χρειάζεται γιατί τα θετικά νούμερα τα βλέπει ο διερμηνευτής ως χρώματα των Windows)\r\n      γ) 0Χ80000001 (δεκαξαδικός αριθμός) δίνει χρώμα του συστήματος των Windows (για προχωρημένους)\r\n3)  Χαραξε εως 3000,4000\r\n      Χαραξε εως 3000,4000, 4\r\n      Χαράζει γραμμή από τη θέση του δρομέα γαφικών  έως τις απόλυτες συντεταγμένες 3000, 4000 που θα γίνουν η νέα θέση του δρομέα.\r\n      \r\nΠΑΡΑΔΕΙΓΜΑ\r\n      ΘΕΣΗ 3000,3000\r\n      ΧΑΡΑΞΕ 2000,0\r\n      ΧΑΡΑΞΕ 0,2000,15\r\n      ΧΑΡΑΞΕ -2000,0\r\n      ΧΑΡΑΞΕ 0,-2000,14\r\n      ΧΑΡΑΞΕ ΓΩΝΙΑ ΠΙ/4,2000,5\r\n      \r\nΘΕΣΗ μετακινεί σε απόλυτη θέση τον δρομέα γραφικών\r\nΒΗΜΑ μετακινεί σε σχετική θέση τον δρομέα γραφικών (έχει και ΒΗΜΑ ΓΩΝΙΑ όπου η γωνία είναι απόλυτη και παρέχουμε και την απόσταση)\r\nΧΑΡΑΞΕ μετακινεί σε σχετική θέση τον δρομέα γραφικών (έχει και εδώ ΧΑΡΑΞΕ ΓΩΝΙΑ)\r\nΧΑΡΑΞΕ ΕΩΣ μετακινεί σε απόλυτη θέση\r\n\r\nΔΕΣ ΠΟΛΥΓΩΝΟ ΚΑΜΠΥΛΗ\r\nΔΕΣ PATH (ΧΡΩΜΑ) και ΠΑΧΟΣ (γραμμών)\r\nΜπορούμε να φτιάχνουμε πλαίσια σε όρια       χαρακτήρων με την ΤΥΠΩΣΕ με την εσωτερική εντολή της @()\r\n      \r\n      \r\n      
EN:CHRCODE$(\r\nΤύπωσε Χαρκωδ$(0x0645)\r\nεπιστρέφει τον Unicode χαρακτήρα των 16bit\r\nή διπλό χαρακτήρα 2*16bit για χαρακτήρες με αριθμό > 0x10000\r\n\r\n
EN:CHRCODE(\r\nΤυπωσε Χαρκωδ(Χαρκωδ$(0x0645))\r\nεπιστρέφει την 16bit τιμή του πρώτου χαρακτήρα ενός αλφαριθμητικού.\r\n\r\n
EN:FILE OPERATIONS\r\nΧΕΙΡΙΣΜΟΣ ΑΡΧΕΙΩΝ\r\nΑΝΟΙΞΕ, ΑΡΧΕΙΑ, ΓΡΑΜΜΗ ΕΙΣΑΓΩΓΗΣ, ΓΡΑΨΕ, ΔΩΣΕ, ΕΙΚΟΝΕΣ, ΗΧΟΙ, ΚΛΕΙΣΕ, ΜΕΤΑΘΕΣΗ, ΟΝΟΜΑ, ΠΑΡΕ, ΣΧΕΔΙΑ, ΤΑΙΝΙΕΣ\r\n
EN:MODULE COMMANDS\r\nΧΕΙΡΙΣΜΟΣ ΤΜΗΜΑΤΩΝ\r\nΑΛΤ, ΑΥΛΟΣ, ΔΙΑΚΟΠΗ, ΔΙΑΦΥΓΗ, ΕΝΘΕΣΗ, ΕΝΩΣΕ, ΛΑΘΟΣ, ΝΗΜΑ, ΝΗΜΑΤΑ, ΡΟΥΤΙΝΑ, ΣΥΝΑΡΤΗΣΗ, ΤΜΗΜΑ, ΤΜΗΜΑΤΑ, ΧΡΗΣΗ\r\n
EN:OPERATORS IN PRINT\r\nΧΕΙΡΙΣΤΕΣ ΤΗΣ ΤΥΠΩΣΕ\r\nΕΛ$, ΕΛ@, ΕΛ~\r\n
EN:HSL(\r\nΠένα ΧΚΦ(60,100,50) ' χροιά 60 μοίρες, κορεσμός 100%, φωτεινότητα 50%\r\n\r\n
EN:USE\r\n1) Χρηση HELLO.GSB 1,\"AAAA\", 3\r\n2) Χρηση \"HELLO\" 1,\"AAAA\", 3\r\n3) Α$=\"HELLO\" : Χρηση Α$ 1,\"AAAA\", 3\r\n4) Χρηση \"προγραμμα\"  \"αυτο\",\"εκεινο\" Στο α$ Ως Λ\r\n   Νημα Λ Καθε 200\r\n   περιμένουμε στο α$ να πάρουμε στοιχεία τα οποία θα βάλει όποιος γνωρίζει το αναγνωριστικό του αυλού. Εδώ στέλνοντας στο \"προγραμμα\" τα δυο αλφαρηθμητικά πάει και το αναγνωριστικό του αυλού.\r\n\r\n4.1) α$=\"ονομααυλου\": Χρηση προγραμμα1 στο Α$\r\nξεκινάει άμεσα ο αυλός με ένα νήμα κάθε 100 χιλιοστά του δευτερολέπτου με όνομα αυλού το α$. Μετά τη εντολή χρήση το α$ έχει το πλήρες όνομα του αυλού και εφόσον σβήσουμε το περιεχόμενο ξεκινάμε να διαβάζουμε (αν μας στέλνει κάποια άλλη εφαρμογή)\r\n\r\n5) Χρηση Αυλου Στο α$ Ως Λ : Νημα Λ Καθε 200\r\n   φτιάχνουμε ένα αυλο χωρίς να εκινήσουμε κάποια εφαρμογή. Αυτό μπορεί να το κάνει η εφρμογή που ξεκίνησε με το 4 και να δώσει στο αρχικό πρόγραμμα το νούμερο του δικού του αυλού ώστε και τα δυο προγράμματα θα περιμένουν να λάβουν στοιχεία βάσει νήματος (ανά προκαθορισμένο χρονικό διάστημα) και θα μπορούν να στέλνουν (με δοκιμή σφάλματος) όταν ο αντίστοιχος αυλός είναι καθαρός, δεν έχει δηλαδή δεδομένα για να διαβαστούν.\r\n\r\n5.1) Και εδώ μπορούμε να ορίσουμε όνομα αυλού γράφοντάς το στην αλφαριθμητική μεταβλητή \r\n\r\n\r\n
EN:TIME$(\r\nΔέχεται όρισμα μια αριθμητική παράσταση ώρας (δεκαδικός αριθμός όπου τα δεκαδικά φανερώνουν κλάσμα της ημέρας) και δίνει την ώρα ως αλφαριθμητικό με ώρα και λεπτά.\r\nΩ=ΤΩΡΑ\r\nΤΥΠΩΣΕ ΧΡΟΝΟΣ$(Ω), ΓΡΑΦΗ$(Ω, \"hh:nn\")\r\nΤύπωσε χρόνος$(Τώρα,)\r\nΤύπωσε χρόνος$(Τώρα,1033)\r\nΤύπωσε πεζ$(χρόνος$(Τώρα,1033, \"hh:mm:ss tt\"))\r\nΤύπωσε πεζ$(χρόνος$(Τώρα,1032, \"hh:mm:ss tt\"))\r\nΤύπωσε πεζ$(χρόνος$(Τώρα,1033, \"Long Time\"))\r\nΤύπωσε πεζ$(χρόνος$(Τώρα,1033, \"Short Time\"))\r\nΤύπωσε Χρόνος$()   'εμφανίζει τη ρυθμισμένη από το σύστημα ζώνη ώρας\r\nΤύπωσε Χρόνος(Χρόνος$()) ' γυρνάει την διαφορά τοπικής με UTC ώρα\r\nΤύπωσε Χρόνος$(Χρόνος(\"UTC\"))  ' εμφανίζει την τρέχουσα ώρα σε UTC (περιλαμβάνει και την διαφορά θερινής ανάλογα την περίοδο)\r\n\r\nΔες Χρόνος()\r\n
EN:TIME(\r\nΜετατροπή ώρας από αλφαριθμητικό σε αριθμητικό\r\nΤύπωσε Χρόνος(Χρόνος$(\"10:20\"))\r\n\r\n\r\n
EN:COLOR\r\n1) όλα τα γραφικά μέσα στις αγκύλες θα φτιάχνουν μια περιοχή με χρώμα\r\nΧΡΩΜΑ χρωμα [, τρόπος εμφάνισης χρώματος] {\r\nεντολές\r\n}\r\nο τρόπος εμφάνισης είναι από 0 έως 7, με το 1 να μην δείχνει καθόλου φόντο!\r\nτα 2 3 4 5 6 7  είναι διαγραμμίσεις.\r\n\r\n2) όλα τα γραφικά μέσα στις αγκύλες θα φτιάχνουν μια περιοχή με χρώμα που θα αναστρέφει τα υπάρχοντα χρώματα της οθόνης (δυο φορές η ίδια εντολή κάνει τα γραφικά να εξαφανίζονται\r\nΧΡΩΜΑ ! χρωμα [, τρόπος εμφάνισης χρώματος]  {\r\nεντολές\r\n}\r\nΕπειδή χρησιμοποιεί το Xor (ή Από όπως λέγεται στη Μ2000) δεν μπορεί να χρησιμοποιηθεί με το Ομαλά Ναί (GDI+), και αυτόματα και πρόσκαιρα αλλάζει σε Ομαλά Όχι (GDI)\r\n   Δες παράδειγμα στην εντολή ΚΑΜΠΥΛΗ\r\n3) όλα τα γραφικά τυπώνονται με το χρώμα της πένας χωρίς γέμισμα. \r\nΧΡΩΜΑ { \r\nεντολές\r\n}\r\nΑυτό μάλιστα κάνει και για την ΤΥΠΩΣΕ, δες παράδειγμα παρακάτω:\r\n' Εκτύπωση γραμμάτων με εξωτερική γραμμή - outline)\r\nΤΜΗΜΑ Α{\r\nΔΙΠΛΑ\r\nΠΕΝΑ 2\r\nΔΡΟΜΕΑΣ 5,5\r\nΠΑΧΟΣ 10 {ΧΡΩΜΑ ! {ΤΥΠΩΣΕ \"ΓΙΩΡΓΟΣ\"} }\r\nΔΡΟΜΕΑΣ 5,5\r\nΧΡΩΜΑ ! 4 {ΤΥΠΩΣΕ \"ΓΙΩΡΓΟΣ\"} \r\nΚΑΝΟΝΙΚΑ\r\nΠΕΝΑ 11\r\nΤΥΠΩΣΕ \"ΟΚ\"\r\n}\r\n\r\n\r\n\r\n4) Καθορισμός περιοχή τυπώματος\r\nΚαι αυτή η επιλογή έχει να κάνει με το GDI και όχι το GDI+\r\nΑν μετά την αγκύλη βάλουμε το ; τότε η περιοχή δεν θα χρωματιστεί αλλά όλα τα γραφικά από δω και πέρα θα εμφανίζονται μόνο σε αυτήν την περιοχή. Μάλιστα μπορεί η περιοχή να έχει πολλά τμήματα.\r\nΤμημα Α {\r\nχρωμα {\r\nθεση 5000,4000\r\nΠΟΛΥΓΩΝΟ 4, ΓΩΝΙΑ ΠΙ/4,3000,-ΠΙ/4,3000,ΠΙ/4,-3000,-ΠΙ/4,-3000\r\nθεση 200,200\r\nπολυγωνο 4, 5000,0,0,1000,-5000,0,0,-1000\r\n};\r\nφοντο 3,5\r\nθεση 3000,3000\r\nκυκλος 3000\r\n' Το παρακάτω χρειάζεται για την επαναφορά της αρχικής περιοχής\r\nθεση 0,0\r\nχρωμα {πολυγωνο 0, χ.σημεια,0,0,υ.σημεια,-χ.σημεια,0,0,-υ.σημεια};\r\n} \r\nή καλύτερα χρώμα {};\r\nΗ αρχική περιοχή ξαναεμφανίζεται πάντα μετά από μια εντολή ΟΘΟΝΗ.\r\n\r\n\r\n\r\n
EN:COLOR(\r\nΠΕΝΑ ΧΡΩΜΑ(100,50,255)\r\nΔίνει το χρώμα με κόκκινο 100, πράσινο 50 και μπλε 255\r\nτο μαύρο είναι το ΧΡΩΜΑ(0,0,0)\r\nτο άσπρο είναι το ΧΡΩΜΑ(255,255,255)\r\n\r\nΠένα #FF0015 \r\nΠένα Χρώμα(\"FF0015\")\r\nΠένα Χρώμα (#FF0015)\r\nΠένα Χρώμα (0Χ1500FF)   \\\\ στο δεκαεξαδικό είναι BGR, δηλαδή το νούμερο 15 σημαίνει (0,0,15) στο RGB.\r\n\r\n\r\n
EN:COLORS\r\nΤΥΠΩΣΕ ΧΡΩΜΑΤΑ\r\nτυπώνει τον αριθμό χρωμάτων που υποστηρίζει η επιφάνεια εργασίας (άρα και η οθόνη μας)\r\n\r\n\r\n
EN:PSET\r\nΧΡΩΜΑΤΙΣΕ\r\nΧΡΩΜΑΤΙΣΕ 15\r\nΧΡΩΜΑΤΙΣΕ ΧΡΩΜΑ(100,100,500)\r\nΧΡΩΜΑΤΙΣΕ 15, 6000,6000\r\nΧΡΩΜΑΤΙΣΕ ΧΡΩΜΑ(100,100,500), 6000,6000\r\n\r\n
EN:FALSE _2\r\nΔΙΝΕΙ 0\r\nΟΠΩΣ Η ΨΕΥΔΗΣ\r\n\r\n
EN:FALSE\r\nΔίνει τιμή 0\r\n\r\n(υπάρχει και η ΨΕΥΔΕΣ - εκδ.4)\r\n\r\n
EN:BYTE\r\nχρησιμοποιείται στην εντολή ΑΡΧΕΙΟ\r\nΕπίσης χρησιμοποιείται στην εντολή Δομή και στο αντικείμενο Διάρθρωση και στην Επιστροφή σε διάρθρωση, όπως και στην Εκφρ() όταν έχουμε ανάγνωση από θέση μνήμης.\r\n\r\n
GR:#ΑΘΡ(\r\nDim A(10)=1\r\nPrint A()#sum()\r\nk=(1,2,3,4)\r\nprint k#sum()\r\n\\\\this is ok\r\nm=k#sum()+k#sum()\r\nThis is an error m=(1,2,3,4)#sum()+(1,2,3,4)#sum()    '  after operators we can't place an auto array.\r\n\\\\these are ok\r\nm=(1,2,3,4)#sum()\r\nm=(1,2,3,4)#sum()+10\r\nPrint (1,2,3,4)#sum()
GR:#ΑΝΑΠ(\r\n\r\nPrint (1,2,3)#rev()\r\n     3      2      1\r\n
GR:#ΑΝΤ(\r\n\r\na=(1,2,3,4,5,6,7,8,9)\r\nfold2=lambda ->{\r\n\tShift 2\r\n\tPush letter$+\"-\"+letter$\r\n}\r\nodd=lambda (x)->x mod 2=1\r\nb=a#Filter(odd, (,))\r\nPrint b ' 1,3,5,7,9\r\nmap1=lambda ->{\r\n\tPush chrcode$(number+64)\r\n}\r\nz=a#Filter(odd)#Map(map1)\r\nPrint z  ' A C E G I\r\nPrint \"[\"+a#Filter(odd)#Map(map1)#Fold$(fold2, \"CODE\")+\"]\"=\"[CODE-A-C-E-G-I]\"\r\n\r\n
GR:#ΕΚΦΡ$(\r\nSee #Eval$()\r\n\r\nclass alfa$ {\r\n\tvalue (X) {\r\n\t\t=str$(500*x)\r\n\t}\r\n}\r\nz$=alfa$()\r\nprint z$(5)\r\nm=(alfa$(), alfa$())\r\nk$=m#val$(0)\r\nprint k$(5)\r\nprint m#eval$(0, 5)\r\nprint \"done\"
GR:#ΕΚΦΡ(\r\nUsed for array pointers (or tuples). Can execute a lambda function, or a group which return a value. Also can used to access items by order for arrays, for stack and inventory objects. When return an array simple return the pointer (#val() return a copy).\r\nFor string values we use the #eval$(). But be careful when we apply multiple #statements we can use a #xx$() statement as the last one.\r\n\r\n\r\nm=(1,2,(100,(200,201,202),300),4)\r\nPrint m#eval(2,1,2)=202\r\nPrint m#val(2)#val(1)#val(2)=202\r\nclass alfa {\r\n\tvalue (x){\r\n\t\t=500*x\r\n\t}\r\n}\r\nm=(1,2,(lambda (x)->500*x), alfa())\r\nPrint m#eval(2,3)=500*3, m#eval(3,3)=500*3\r\ninventory queue k=1,2,3:=300,4\r\nm=(1,2,k)\r\nPrint k(3)=300, k(2!)=300, m#eval(2,2)=300\r\n\\\\ this type of inventory dosn't guarantee the item position\r\ninventory k1=1,2,3:=1000,4,5\r\nm=(1,2,k1)\r\ndelete k1, 2, 4\r\nIf exist(k1, 3) then k1_item_pos=eval(k1!)\r\nPrint m#Eval(2,k1_item_pos)=1000\r\n\\\\ to access by key from m we need a link to the second array interface\r\nlink m to m()\r\nPrint m(2)(3)=1000\r\n\r\n
GR:#ΘΕΣΗ(\r\nUou can't mix strings and numbers in search list\r\n\r\nc=(1,1,0,1,1,1,1,0,1,1,0)\r\nPrint c#pos(1,0,1) ' 1  means 2nd position\r\nPrint c#pos(5->1,0,1) ' 6  means 7th position\r\nc=(\"hello\",\"1\", \"hello\",\"2\")\r\nPrint c#pos(0->\"hello\", \"2\")=2 ' 3rd position
GR:#ΜΕΓ$(\r\n\r\na=(\"a\",\"b\",\"c\")\r\nPrint a#max$()=\"c\"\r\n\r\nz=-1\r\nprint (\"a\",\"b\",\"c\",\"a\")#max$(z)=\"c\", z=2
GR:#ΜΕΓ(\r\n\r\na=(1,2,3)\r\nPrint a#max()=3\r\n\r\nz=-1\r\nprint (1,2,3,-3)#max(z)=3, z=2
GR:#ΜΕΡΟΣ(\r\n\r\na=(1,2,3,4,5)\r\nPrint a#slice(1,2)  '  2 3\r\nPrint a#slice(1,2)#rev()  ' 3 2\r\nPrint a#slice(2) ' 3 4 5\r\nPrint a#slice(,2) ' 1 2 3
GR:#ΜΙΚ$(\r\n\r\na=(\"a\",\"b\",\"c\")\r\nPrint a#min$()=\"a\"\r\nz=-1\r\nPrint  a#min$(z)=\"a\", z=0 ' position
GR:#ΜΙΚ(\r\n\r\n\r\nPrint (1,2,3)#min()  ' we can't use sign or put it in expression (unless in first place)\r\na=(1,2,3)\r\nPrint -a#min()  ' but this we can use it everywhere\r\nDim a(3)\r\na(0)=1,2,3\r\nPrint a()#min()\r\n\r\nz=-1\r\nPrint a()#min(z)=1, z=0  ' position in a()\r\n
GR:#ΠΑΚ$(\r\n\r\na=(\"a\",\"b\",\"c\")\r\nfold1=lambda m=1 ->{\r\n      Shift 2\r\n      If m=1 Then\r\n            m=0\r\n            Drop\r\n            Push \"\"\"\"+ucase$(letter$)+\"\"\"\"\r\n      Else\r\n            Push letter$+\",\"+\"\"\"\"+ucase$(letter$)+\"\"\"\"\r\n      End If\r\n}\r\nPrint \"[\"+a#fold$(fold1)+\"]\" ={[\"A\",\"B\",\"C\"]}
GR:#ΠΑΚ(\r\na=(1,2,3,4,5,6,7,8,9)\r\nfold1=lambda ->{\r\n      push number+number\r\n}\r\nPrint a#fold(fold1)=a#sum()\r\nPrint a#fold(fold1,10)=a#sum()+10\r\n\r\nlook #filter(), #map(), #fold$(), #pos()
GR:#ΤΑΞΙΝΟΜΗΣΗ(\r\n\r\nPrint (10,3,4,1)#SORT(1)\r\n10 3 4 1\r\nPrint (10,3,4,1)#SORT()\r\n1 4 3 10\r\nPrint (10,3,4,1)#SORT(0,1,3)\r\n10 1 3 4
GR:#ΤΙΜΗ$(\r\n\r\na=(1,\"A\",2,\"B\")\r\nPrint a#val(1)=\"A\"\r\n
GR:#ΤΙΜΗ(\r\n\r\na=(1,2,3)\r\nPrint a#val(0)=1\r\n
GR:#ΦΙΛΤΡΟ(\r\n\r\na=(1,2,3,4,5,6,7,8,9)\r\nfold1=lambda ->{\r\n      push number+number\r\n}\r\neven=lambda (x)->x mod 2=0\r\nb=a#filter(even, (,))\r\nPrint b ' 2 4 6 8\r\nPrint a#filter(even)#fold(fold1)=20
GR:ΑΔΕΙΑΣΕ\r\n\r\nFLUSH\r\nempty the stack\r\nTwo more variants\r\nFLUSH ERROR  ' empty last error message\r\n\\\\ Not used form 9.4  version FLUSH GARBAGE ' run manual garbage collector \r\n\r\n\r\nStack Lesson\r\nA module hold parent stack. A function start a new stack every time run.\r\nSo calling a module we can search stack for returned values.\r\nWe can pass values and references to values.\r\n\r\nUse PUSH to push on top (Last in First Out)\r\nUse DATA  to merge values at the bottom (First In First Out)\r\nPUSH 1,2,3\r\nSTACK\r\nDATA 1,2,3\r\nDATA 4,\"string also\", 5,6\r\nSTACK\r\n3  2 1 1 2 3 4 \"string also\" 5 6\r\n\r\nTo pop values use Number for numbers and Letter$ for strings\r\n\r\nUse READ to pass values to variables\r\nflush : push 10 : read x : print x\r\nB=10 : push &B : read &K: print K=B\r\n&B will be a string as a name for used as reference to K. Only Read (and special Commit) can found references..\r\nB=10 : push \"B\" : read &K: print K=B\r\nIf FF isn't a variable a Push &ff  produce error. But if we push \"FF\" and before the reading we make a FF variable the link can happen..errorless.\r\n\r\nLook SHIFT, OVER, DROP, STACKITEM(), STACKITEM$(), NUMBER, LETTER$, ISNUM, ISLET, EMPTY, FLUSH, STACK, ENVELOPE$() STACK.SIZE() STACK$(), READ, COMMIT
GR:ΑΚ(\r\n\r\n>PRINT INT(12.5)\r\n          12\r\nAlways return lower or equal integer\r\nfor 1.9 gives 1\r\nfor 1.1 gives 1\r\nfor -1.1 gives -2\r\nfor -1.9 gives -2\r\n\r\nUse Round(-1.9, 0) to get -2\r\n' there is a rounding function when we place number to integer variable\r\na%=-1.9\r\nPrint a%\r\n          -2\r\nAlso works in For Next loop and For {} loop\r\n\r\nWe can make integers or round values at final stage\r\nWe can define decimal point char, using Locale\r\nLocale 1032 ' set Greek locale, and now we get coma for decimal point.\r\nPrint Format$(\"{0:0} {0:1} {0:2:-8}\", -1.8)\r\n\r\n
GR:ΑΚΕΡΑΙΟ.ΔΥΑΔΙΚΟ(\r\na=0xFAAA\r\nPrint  Sint(a), Sint(a,2)  ' second as negative\r\na=0xFFFFFAAA\r\nPrint  Sint(a)    ' negative number\r\nPrint a   ' as usnigned integer\r\nHex Uint(Sint(a)) \r\n\r\n\\\\ Use Uint() for reverse function\r\n
GR:ΑΚΕΡΑΙΟΣ\r\n\r\nUsed in TABLE for Databases
GR:ΑΛΗΘΕΣ\r\n\r\nTrue is -1
GR:ΑΛΗΘΗΣ\r\n\r\ntrue is -1\r\nfalse is 0\r\n
GR:ΑΛΛΑΓΗ\r\nchange Target_Handler, pen 15\r\nafter handler we can put name of attribute and a value, in any order\r\nattributes:\r\nTEXT, PEN, BACK, BORDER, COMMAND\r\n\r\nWe use SCAN to give time to work. We can put action in threads (look THREAD) so we can process clicks on targets while we do something else (mostly checking flags).The idea for the targets is to make indicators that take acknowledge from user by clicking and then for responce we can change text or color or both and any other attribute.\r\n\r\nTargets are visual objects in M2000 environment\r\nWe can create targets on any of 32 Layers, and in basic forn and in the background.\r\nTargets can act to send keypress to environment (inside only), or can run a specific module (global)\r\nTargets wotks with handlers that we hold in variables.\r\nWe can make easy a target to move a layer or the envirinment own window.\r\n\r\n \r\n\r\nLook TARGET
GR:ΑΛΛΑΓΗ$(\r\n\r\nPrint Replace$(\"a\",\"b\",\"AABAAABBBBAAA\")\r\nBBBBBBBBBBBBB\r\n\r\nLook some string functions\r\nFILTER$( QUOTE$( FORMAT$( \r\nSTRING$( STR$( MID$( RIGHT$(\r\nTRIM$( MIN.DATA$( MAX.DATA$(\r\n\r\nFor variables only and array items\r\nIs very fast because internal copied references.\r\nSWAP a$, b$\r\nHere  also the searching done without copied the string\r\n? COMPARE(a$,b$)\r\n-1 for a$>b$, 0 for A$ equal to b$, and 1 for a$<b$)\r\n\r\nLook special object Document (for big text)\r\n
GR:ΑΛΛΑΞΕ\r\n\r\nSWAP numeric var, numeric var \r\nSWAP numeric array item, numeric array item\r\nSWAP string var, string var\r\nSWAP string array item, string array item\r\n\r\nSwap is 2 times and more faster for swapping string variables and  6 times more faster for numeric variables\r\nI f  a string is a Document (which is an object) then there is no problem to swap with a string that it isn't document.\r\n\r\nInternal all arrays and variables are variant, so swap copy only the 16 byte per variant. Document is an object with the reference in a variant. So a copy of that variant is a copy of the reference.\r\n\r\n\r\na=10\r\nb=3\r\nc=0\r\n\\* we set FAST !  with no refresh  - we can't put comments to a SET line command\r\nset fast !\r\nprofiler   ' resetting the counter\r\nfor i=1 to 10000 {\r\n      a=b\r\n      b=c\r\n      c=a\r\n}\r\nprint timecount\r\nprofiler\r\nfor i=1 to 10000 {\r\n      swap a, b\r\n}\r\nprint timecount\r\n\\* restore to normal speed which we can control the Esc and Break buttons.\r\nset fast \r\n\r\n\r\nAnother way to control the speed can be the use of REFRESH.\r\nREFRESH 400\r\nand at the end \r\nREFRESH 25  ' normal\r\ngive a time close to SET FAST !\r\n
GR:ΑΛΛΙΩΣ\r\n\r\nLook IF and SELECT\r\n
GR:ΑΛΛΙΩΣ.ΑΝ\r\nsee If
GR:ΑΛΤ\r\n\r\nHalt send execution to console. We can use Continue to  continue execution.\r\n
GR:ΑΛΦΑΡΙΘΜΗΤΙΚΑ\r\nSTRING FUNCTIONS\r\n#EVAL$(, #FOLD$(, #MAX$(, #MIN$(, #VAL$(, ADD.LICENSE$(, ARRAY$(, ASK$(, BMP$(, CHR$(, CHRCODE$(, DATE$(, DRIVE$(, DRW$(, ENVELOPE$(, EVAL$(, FIELD$(, FILE$(, FILE.APP$(, FILE.NAME$(, FILE.NAME.ONLY$(, FILE.PATH$(, FILE.TITLE$(, FILE.TYPE$(, FILTER$(, FORMAT$(, FUNCTION$(, GROUP$(, HEX$(, HIDE$(, IF$(, INPUT$(, JPG$(, LAZY$(, LCASE$(, LEFT$(, LEFTPART$(, LOCALE$(, LTRIM$(, MAX.DATA$(, MEMBER$(, MEMBER.TYPE$(, MENU$(, MID$(, MIN.DATA$(, PARAGRAPH$(, PARAM$(, PATH$(, PIECE$(, PIPENAME$(, PROPERTY$(, QUOTE$(, REPLACE$(, RIGHT$(, RIGHTPART$(, RTRIM$(, SHORTDIR$(, SHOW$(, SND$(, SPEECH$(, STACK$(, STACKITEM$(, STACKTYPE$(, STR$(, STRING$(, STRREV$(, TIME$(, TITLE$(, TRIM$(, TYPE$(, UCASE$(, UNION.DATA$(, WEAK$(\r\n\r\n
GR:ΑΝ\r\nin one line:\r\n\r\nIf condition Then  command(s)  | Else.If condition2 |Then|Else| |  command(s)Else command(s)\r\nIf condition Else command(s)\r\n\r\nIf condition Then NumericLabel   \\\\ same as Then Goto NumericLable\r\nIf condition Else NumericLabel   \\\\ same as Then Goto NumericLable\r\nIf condition Then command1 : command2 ...\r\nIf condition Else Command1 : Command2 ...\r\nIf condition Then { commands in a line separated with : }\r\nIf condition Then  command(s)  Else command\r\n\r\nIf condition Then { command(s) } Else command\r\nIf condition Then {\r\n     a block of commands\r\n  }\r\nIf condition Then {\r\n      a block of commands \r\n} Else command\r\n\r\nIf condition Then {\r\n      a block of commands \r\n} Else {\r\n      a block of commands\r\n}\r\n\r\nIf condition Then {\r\n      a block of commands \r\n} Else.If condition then {\r\n      a block of commands \r\n} Else.If condition then {\r\n      a block of commands ....\r\n....................many Else.If....      \r\n} Else {\r\n      a block of commands\r\n}\r\n\r\nNew from version 8.9 (rev 12), we can split the structure with blocks or line of commands (in the same line of command)\r\n\r\nIf condition Then  a line of commands \r\nElse.If condition then   a line of commands \r\nElse.If condition then {\r\n      a block of commands ....\r\n....................many Else.If....      \r\n} \r\nElse  a line of commands \r\n\r\nAlso we can use Else.If  Else  for reverse logic\r\n\r\n\r\nUsing End if  (no for jump out of structure, because we get error for not computed End If)\r\nIf condition Then \r\n\r\nElse.If  condition1 Then\r\n\r\nElse.If  condition1 Else  ' reverse logic\r\n\r\nElse.If  condition1 Then\r\n\r\nElse\r\n\r\nEnd  if\r\n\r\nor\r\n\r\nIf condition Else  ' no Else.If after Else\r\nEnd if\r\n\r\nany of three conditions  that  not fits skip the line\r\nif false else.if false else.if false else print \"ok\"\r\nif true then if true then if true then print \"ok\"\r\n\r\n\r\n\r\nAbout condition:\r\nYou can use AND OR XOR NOT, >,<,>=,<=,<>, == (this is for rounding before the operation)\r\n\r\nFor strings ~ is the VB6 Like operator\r\na$=\"a\"\r\nprint 2<4 and a$=\"a\" xor false   ' no need brackets\r\nfirst  compute the 2<4 then the a$=\"a\" then the first AND so that condition shrink to this: result xor false\r\nNot  is like a macro and put \"-1-\" plus \"look for expression\", so this is right Print not A$=\"a\" because a$=\"a\" is logical expression, and give a number 0 or -1, so -1- -1 = 0 and -1- 0 = -1.\r\n\r\n{a} is a string,  but we can't use it in an expression for condition.\r\nThis is valid we have a string only expression:\r\nPrint  {1st line\r\n2nd line\r\n3rd} + {1st line too\r\n....\r\n..............\r\n.............}\r\nBut this isn't because there is > inside, so this is a condition expression. We have to use variables or non multiline strings \r\nPrint {1st line\r\n2nd line } > {1st line\r\n...................\r\n}\r\n\r\nThis is valid\r\nPrint \"Aaa\"<\"B\"\r\n\r\n\\\\ Examples\r\na=random(0,2)\r\nPrint a\r\nif a=0 then { goto 100 } else.if a>1 then 300\r\n050 Print \"This is \";\r\n100 Print \"not \";\r\n300 Print \"ok\"\r\n\r\na=random(0,2)\r\nPrint a\r\nif a=0 then {\r\n      goto 100 \r\n} else.if a=1 then {\r\n      goto 50\r\n} else 300\r\n050 Print \"This is \";\r\n100 Print \"not \";\r\n300 Print \"ok\"\r\n\r\n\r\n\r\n\r\n\r\n\r\n΄
GR:ΑΝ$(\r\n\r\nternary operator\r\nlook If()\r\n\r\nPrint If$(true, \"true\",\"false\")\r\n\r\nPrint If$(3,\"one\",\"two\", \"three\", \"four\")\r\n
GR:ΑΝ(\r\n1) ternary operator\r\n    1.1 Using -1 or True and 0 or false\r\n      Κ=5 : N=3\r\n      Print If(K>N->100, 200)\r\n      \r\n      m=true\r\n      Function TwoParam (x,y) {\r\n            =x**y\r\n      }\r\n      \\\\ !(1,2,3) as parameter places 3 parameters in stack for values in function stack\r\n      \\\\ if() for m=true return array (10,2) so we call TwoParam(!(10, 2)) or TwoParam(10, 2)\r\n      Print TwoParam(!If(m -> (10,2), (30,4)))      \r\n      \r\n    1.2 Using 1 and up for execution th Nth expression, we can ommit some expressions (return 0)\r\n      \\\\ only one expression evaluated, all other just skipped\r\n      Print If(Random(1,5) -> 10, 30, 45, 55, 60)\r\n2) elvis operator\r\n2.1 for \"null\" groups (M2000 groups have no null. But in a container we can pass 0 - converted to long- to delete a group)\r\nGroup M {\r\n      X=100\r\n}\r\nDim A(10)\r\n\\\\ we get a copy of M\r\nA(3)=If(A(3)->,M)\r\nM.X++\r\nA(3)=If(A(3)->,M)\r\nPrint A(3).X, M.X  \\\\ 100 101\r\n\\\\ We can place anything in an array (if array not initialized as Array for Group)\r\nA(3)=0  \\\\ this place a Long 0 in A(3)\r\n\\\\ Now because A(3) is 0 we get a copy of M\r\nA(3)=If(A(3)->,M)\r\nPrint A(3).X, M.X  \\\\ 101 101\r\nM.X+=100\r\n\r\n\r\n2.2 For functions, lambda, groups which return values\r\ndef f()=false\r\ndef g()=100\r\nPrint if(f()->,g())  \\\\ 100\r\ndef f()=true\r\nPrint if(f()->,g())  \\\\ -1  true\r\ndef g()=false\r\ndef k()=5000\r\ndef f()=false\r\nPrint if(f()->,if(g()->,k()))  \\\\ 5000\r\nClass Counter {\r\n      x, max\r\n      Value {\r\n            If .x>=.max Then Exit\r\n            .x++\r\n            =True\r\n      }\r\nClass:\r\n      Module Counter (.x, .max) {}\r\n}\r\nF=Counter(10,18)  ' 8\r\nG=Counter(5,6)    ' 1\r\nK=Counter(1,3)  ' 2\r\ncounter=1\r\n\\\\ count 8+1+2= 11 times\r\n\\\\ 10, 5, 1 are before counting\r\n\\\\ print from 11, 5 ,1\r\n\\\\ to 18, 6, 3\r\nWhile if(F->,if(G->,K)) {\r\n      Print F.x, G.x, K.x, counter\r\n      counter++\r\n}\r\n\\\\ to make 12, including 10, 5, 1\r\n\\\\ we cant change F,G,K because are \"properties\"\r\n\\\\ we have to clear them (only clear group object, not group members)\r\n\\\\ In M2000 named groups, all members are exist outside group\r\nClear F,G,K  \r\n\\\\ so we make one more, for including 10,5,1\r\nC=Counter(0,1) ' 1\r\nF=Counter(10,18)  ' 8\r\nG=Counter(5,6)    ' 1\r\nK=Counter(1,3)  ' 2\r\n\\\\ count 1+8+1+2= 12 times\r\n\\\\ we don't want to print C.x\r\ncounter=1\r\nWhile if(C->,if(F->,if(G->,K))) {\r\n      Print F.x, G.x, K.x, counter\r\n      counter++\r\n}            
GR:ΑΝΑΖΗΤΗΣΗ\r\n\r\nSEARCH \"basename\", \"tablename\", Offset, \"field\", operator$, value\r\nSEARCH \"basename\", \"tablename\", Offset, \"field\", operator$, value$\r\n\r\nThis is a more compact RETRIEVE\r\noperator$ \"LIKE\" \">=\" etc\r\nFor like operator string wildcard is % not *\r\n
GR:ΑΝΑΘΕΣΕ\r\nlike Read, the commit statement work only for arrays, member of groups\r\nWe pass the pointer of array to the member name.\r\n\r\n\r\ngroup alfa {\r\n\tdim a()\r\n\tmodule k {\r\n\t\tcommit .a()\r\n\t}\t\r\n}\r\ndim z(20)=1, z1(30)=100\r\nalfa.k  &z()\r\nPrint alfa.a(19)=1\r\nalfa.k  &z1()\r\nPrint alfa.a(19)=100\r\n
GR:ΑΝΑΚΤΗΣΗ\r\n\r\n1. RETRIEVE BaseName$, TableName$, 1, \"\",\"\"\r\nopen base and place to stack on the top the number of records and under the fist row of item values, of theTableName$\r\n2. RETRIEVE BaseName$, Sql$, 1, \"\",\"\"\r\nwe can set a SQL string defining a recordset to read. We get always the number of records and the choosen record\r\n3. RETRIEVE BaseName$, TableName$, 1, \"FieldName\",\"ValueString\"\r\nwe get the 1st record where Fieldname = ValueString\r\n4. RETRIEVE BaseName$, TableName$, 1, \"FieldName\", Value\r\nwe get the 1st record where Fieldname = Value\r\n\r\nUse % not * in a Like operator  ( .. Name Like \"A%\"  )\r\n\r\n\r\n
GR:ΑΝΑΛΟΓΙΟ\r\nWe can open html pages\r\n1) open and show in standard center position smaller than the screen\r\nBROWSER \"www.google.com\"\r\n2) open and show using twips\r\nBROWSER \"www.youtube.com\",1000,1000,5000,3000\r\n3) Cancel and close\r\nBROWSER \"\"\r\n4) Reading from temporary folder\r\nBROWSER \"alfa\"\r\nis equal to BROWSER temporary$+\"alfa.html\"\r\n\r\n\r\nExample\r\nWe make a temporary html file, then we open it in with browser and then we get info from the form in the html\r\nCopy these lines in a module and run it\r\n\r\nshow\r\nusername$ = \"George\" \r\ntext alfa.html {<!doctype html public \"-//w3c//dtd html 3.2//en\">\r\n<html>\r\n<head>\r\n<title>(Type a title for your page here)</title>\r\n<meta name=\"GENERATOR\" content=\"M2000\">\r\n<meta name=\"FORMATTER\" content=\"M2000\">\r\n<meta content=\"this, other, that\" name=keywords>\r\n<meta content=All name=robots> \r\n<meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=windows-1253\">\r\n<meta NAME=\"Author\" CONTENT=\"GEORGE KARRAS\">\r\n<style type=\"text/css\">\r\nbody {\r\n    overflow:hidden;\r\n}\r\n</style>\r\n</head>\r\n<body bgcolor=\"CYAN\" text=\"#000000\" link=\"#0000ff\" vlink=\"#800080\" alink=\"#ff0000\">\r\n<CENTER>This is an Html  form</CENTER></H1><HR>\r\n<script> var m1;var p1;var total;function alfa() { total=\"?onoma=2000\";total=total+\"&username=\"+escape(m1);total=total+\"&password=\"+escape(p1);document.title=total;setTimeout (\"alfa()\",100);return true}</script>\r\n<FORM NAME=\"ValidForm\" action=\"about:blank\" >\r\n<INPUT NAME=\"onoma\" TYPE=\"HIDDEN\" MAXLENGTH=4 SIZE=\"4\" VALUE=\"1000\">\r\n<TABLE ALIGN=CENTER BORDER=0 RULES=NO COLS=\"2\">\r\n<TBODY>\r\n<TR VALIGN=TOP  >\r\n<TD  >User name:</TD>\r\n<TD  ><INPUT NAME=\"username\" TYPE=\"TEXT\" id=\"uname\" MAXLENGTH=16 SIZE=\"16\" VALUE=\"##username$##\" ></TD>\r\n</TR>\r\n<TR VALIGN=TOP  >\r\n<TD  >This is our password:</TD>\r\n<TD  ><INPUT NAME=\"password\" ID=\"pass\" TYPE=\"PASSWORD\" MAXLENGTH=8 SIZE=\"8\"></TD>\r\n</TR>\r\n</TABLE>\r\n<CENTER><BR><HR>\r\n<input type=button value=\"Inform me\" onclick=\"m1=uname.value;p1=pass.value;alfa()\">\r\n</CENTER>\r\n</FORM>\r\n</body>\r\n</html>\r\n}\r\nonoma$=\"\"\r\nbrowser alfa.html\r\nwhile onoma$=\"\"  {refresh}\r\nlist   ' just show all variables\r\nbrowser \"\"\r\ntext alfa.html  ' delete the temporary file\r\nPrint \"ΟΚ\" \r\n\r\n\r\n
GR:ΑΝΑΛΟΓΙΟ$\r\n\r\nPRINT BROWSER$\r\n\r\ngive the title of the page in browser\r\n\r\n\r\n
GR:ΑΝΑΛΥΤΗΣ\r\n\r\nYou can measure the time consuming in a piece of code. Just place PROFILER in the beginning and then copy the TIMECOUNT read only variable.\r\n\r\nProfiler\r\nk=0\r\nFor i=1 to 1000 {\r\n      k++\r\n}\r\nprint timecount\r\n\r\n\r\n\r\n\r\n
GR:ΑΝΑΜΟΝΗ\r\n \r\n1) Wait milliseconds\r\n2) Wait  \r\nthis is like Wait 0\r\n\r\nWait command allow to run threads, so it is a waiting state for  a module, to give time for threads (after the end of the module all threads from that module are erased). \r\n  \r\nWAIT 0 \r\nallow task manager to run some threads  in a thread, except when we Set Fast !\r\n\r\nHere is an example to demonstrate the use of refresh, wait and a high value for refresh to perform only a final refresh\r\n\r\n\\\\Thread.Plan Concurrent\r\nThread.Plan Sequential\r\nClear  \\\\ clear static variables\r\nSet Fast !\r\n\\ Set Fast\r\n\\ Set Slow\r\nForm 80\r\nCls #ffaa22\r\nPen 1\r\nRefresh 50\r\nThread {\r\n      Print @(Width-8,0,width,1,15);str$(now,\"hh:mm:ss\")\r\n} as M interval 20\r\nwait 100\r\nThread M interval 1000\r\ni=0\r\nBatch=100\r\nProfiler\r\nFor n=1 to 3 {\r\n      Thread {\r\n            For k=1 to Batch : move 6000,6000 : draw to random(12000), random(10000) , L: Next k : i+=Batch\r\n            refresh 1000\r\n             } As G Execute Static L=random(100000)\r\n       Thread G interval 20\r\n}\r\nMain.Task 100 {\r\n      if i>8000 then exit    \r\n      if mouse then exit\r\n}\r\nRefresh\r\nX=Timecount\r\na$= Format$(\"Time to complete {0:2}, lines {1}\",X, I)\r\nClipboard a$\r\nPen 15 {print  @(0, height-2),a$}\r\nRefresh 40\r\n\r\n 
GR:ΑΝΑΝΕΩΣΗ\r\nScreen Refresh and Do some Events helper function\r\n1) Refresh\r\nRefresh the output (not for printers)\r\n\r\n2) Refresh 0\r\nReset internal refresh counter\r\n\r\n3) Refresh 100\r\n(also reset the counter(\r\nSets the time period to perform auto refresh. By default has 40 as value. This no a delay. When we have a request for refresh then if the counter is above our limit a refresh happen and clear the refresh counter. \r\n\r\nAuto refresh can be handled from SET SLOW or SET FAST ans SET FAST !  \r\n\r\nFor delay use WAIT  not Refresh. So to perform an AFTER thread we have to perform some WAIT or EVERY or a MAIN.TASK structure and not Refresh. But in a thread for synchronization we have to perform screen refresh after all of our drawings to screen. A thread is like a WAIT if nothing doing inside.\r\n\r\nHere is an example of how we can use software sprites (not PLAYER), which they have transparency for all the image and for a bit only. We use HOLD and RELEASE so we don't have to draw non changing objects. We use a EVERY flow control and we hold the refresh by resetting the internal counter and perform the refresh when we like to do (after the drawing of sprites). A sprite command\r\n\r\nREFRESH  500 \r\nCLS 1,0   ' COLOR BLUE AND  RESET SPLIT SCREEN SETTING TO TOP LINE\r\nPRINT \"This is first line\"    ' WE CANT SEE THE FOUR PRINTS \r\nPRINT \"This is second line\"   'BECAUSE WE SET A HIGH REFRESH RATE\r\nPRINT \"This is third line\"\r\nPRINT \"This is forth line\"\r\nMOVE 0,0\r\nA$=\"\"\r\nCOPY 3000,2000 TO A$\r\nGRADIENT 3, 5   ' CLEAR SCREEN WITH GRADIENT\r\nPRINT @(0,0),\"SPACE BAR TO EXIT\"\r\nCOPY 6000,6000 TOP A$, 10, 200\r\nCOPY 6000,6000 TOP A$, 45\r\nCOPY 2000,2000 USE A$, 45\r\nHOLD  ' save screen\r\nMOVE 6000,6000\r\nI=1\r\nX=MOUSE.X\r\nY=MOUSE.Y\r\nEVERY 20 {\r\n      I++\r\n      IF INKEY$<>\"\" THEN EXIT\r\n      ' YOU CAN MAKE THE SECOND ROTATED OBJECT TO HAVE FLICKERING\r\n      ' IF YOU DO THAT:\r\n      ' COMMENT THE LINE BELOW AND PUT REFRESH TO 10 IN THE FIRST LINE\r\n      REFRESH 0   ' RESET THE REFRESH COUNTER\r\n      RELEASE\r\n      PRINT @(0,1),STR$(NOW,\"HH:MM:SS\")\r\n      MOVE 6000,6000\r\n      SPRITE A$, -1, I\r\n      IF MOUSE=1 THEN {\r\n      X=MOUSE.X\r\n      Y=MOUSE.Y\r\n      }\r\n      MOVE X, Y\r\n      SPRITE A$, 1, I, 200, 80      \r\n      REFRESH   ' DO NOW A SCREEN REFRESH ONLY\r\n}\r\n\r\n
GR:ΑΝΑΠ$(\r\nPrint StrRev$(\"abcd\")=\"dcba\"
GR:ΑΝΑΦΟΡΑ\r\n\r\nREPORT is the command to format multiline text and make columns of text like in a oage maker. Not only use word wrapping but also use spaces with variable length. It is good for reports, to the screen and to the printer.\r\n\r\nReport!4  ' make tab width 4 characters\r\nREPORT \"we can use simple lines or multilines\"\r\nREPORT {This is a multilne text\r\n      this is the second\r\n      }  ' spaces are controled from the position of this bracket so this print\r\nThis is a multilne text\r\nthis is the second\r\n\r\nReport start from POS (cursor X position) and in every line keep that POS for left space indent.\r\nPrint \"                     \";   ' we put some space to the left for each line - each line maybe is a paragraph with many lines when we print\r\nREPORT {This is a multilne text\r\n      this is the second\r\n      }\r\nSo now is time to change the way we report, and some variants\r\nREPORT typeOfreport, A$\r\nREPORT typeOfreport, A$, WidthSeeTheWay\r\nREPORT typeOfreport, A$, WidthSeeTheWay, Lines2Display\r\nREPORT typeOfreport, A$, WidthSeeTheWay, Lines2Display LINE startLine\r\nnew variants\r\n      REPORT typeOfreport, A$, WidthSeeTheWay, Lines2Display AS VAR$  [VAR$()]\r\n      REPORT typeOfreport, A$, WidthSeeTheWay, Lines2Display LINE startLine AS VAR$  [VAR$()]\r\n      (for output each line to string, we can use also a starting line)\r\n      \r\ntypeOfreport:\r\n0 Format left and right\r\n1 Format Right\r\n2 Format Center\r\n3 Format left\r\n\r\nThere is a way before we print to find how many lines needed to print\r\nSee the example here:\r\nc$={s\r\nd\r\ns.\r\n. \r\n..\r\n. .... ....\r\n}\r\nfor i=1 to 20 {\r\ncls\r\ncursor 10,10\r\nprint \"*1234567890\";\r\nreport 2, c$,i,-1000  ' NO PRINT ONLY TO GET REPORTLINES\r\ncursor 10,11\r\nprint \"*\";\r\nk= REPORTLINES\r\nprint @(pos,row, pos+i,row+k, 5,8);\r\nreport 2, c$,i,k\r\nprint i , k\r\nk$=key$\r\n}\r\n\r\nUsing negative number for lines2Display (the absolute number indicate the maximum limit) we get in REPORTLINES the lines of text actually we can print. So after that we can set the start line and the lines to print (on the screen or on the printer).\r\n\r\nWhen we report to the screen there is a system to hold printing after 2/3 of screen height that are printed. We press space or click it with mouse to continue. This system not engaged if we report buy using part of text.\r\nAs we can see Report use cursor to specify left margin and use width in twips to specify the printing width IF the number is larger than the width in chars. So we can put the width in chars or in twips and the command can understand what we want...\r\n\r\nFormatting Proportional and Not Proportional text we can print with PRINT command, but not with wrapping text. In a print command we can use the tab system (equal spaced). See the example (we use operator $() to alter the Formatting and the 8 is the tab distance, or width.\r\n\r\n      FORM 48,32\r\n      FOR I=0 TO 8 {\r\n      PRINT $(I, 8),145355,34.23432,34.222\r\n      }\r\n
GR:ΑΝΑΨΕ\r\nSHOW\r\nWe can SHOW the screen but we can run an application without showing the screen. Show command show the main screen (layers are showing by PLAYER command). First time the show command show both the window and the screen inside.\r\nIf a FIELD command  is executed then automatic the screen is showing. The same for the CLI (command line interpreter). If CLI open and wait for command then automatic the screen showing,\r\nIf we didn't do anything for waiting, then the program close. We can use a$=key$ to wait for a key press.\r\n\r\nThere is a Show read only variable too. It is -1 when form is activated.\r\nSee HIDE, TITLE\r\n
GR:ΑΝΟΙΓΜΑ.ΑΡΧΕΙΟΥ\r\nWe can set the Top Folder. We can go up further than the Top Folder\r\nAll file dialogues are safe for use because we can't delete  or move file or folder, we can't execute any file from it.\r\n\r\n1. OPEN.FILE  ' open a dialog for file(s) selection. Version 7 have a new custom dialog\r\n2. OPEN.FILE  aName$\r\n3. OPEN.FILE  aName$, folderOrIndirectPath$\r\n4. OPEN.FILE  aName$, folderOrIndirectPath$, titleOfDialog$\r\n5. OPEN.FILE  aName$, folderOrIndirectPath$, titleOfDialog$, fileTypes$\r\nResult we found in the Stack\r\nEscape or a click to a square at top left corner have the result an empty string\r\n\r\nwe can omit some parammeters..\r\nfolderOrIndirectPath$ is the Top Folder (we can use \"*\" as the Computer Level, where we can see anything inlcuding the common folders in the LAN)\r\n\r\nOPEN.FILE ,,\"Load Text File\",\"txt\"\r\n \r\nThe new selector always display the path without hidden parts, by using wrapping in slash and space can wrap the path. The new file selector change size and zoom, by dragging the lower right corner. From setup we can  see all the files from all folders under the current, and we can open the multiselection option, and we can change the type of sorting.\r\n \r\n If we press letters on keyboard, these  accumylate the searching filename and we see the finding in progress. Move arrows up down or change chosen one and this reset the search string.\r\n\r\nWe can give \"..\\media\\\" as an indirect path for  folderOrIndirectPath$. If folder doesn't exist an error occur and we see no file selector.\r\nIn fileTypes$ we can give file types separate using \"|\". This is the new way, but selector use the old too (by refine it, holding only strings to match the  file types). The old is from standard selector  \"Bitmap (*.bmp)|*.bmp|Photo (*.jpg)|*.jpg\".\r\n\r\nIn titleOfDialog$ we can pass a multine text but is not suppored by that file selector. If we give a three line string or document, we will see the middle line (all titles centered)\r\n\r\nUsing the current dir as topfolder.\r\nWe can use function FILE$() or FILE$(title$) or FILE$(title$,\"TXT\")    'or we can put | to make multy type selection\r\n\r\nA$=FILE$(\"IMAGE A\",\"JPG\")\r\n\r\n\r\n
GR:ΑΝΟΙΓΜΑ.ΕΙΚΟΝΑΣ\r\nWe can set the Top Folder. We can go up further than the Top Folder\r\nAll file dialogs are safe for use because we can't delete  or move file or folder, we can't execute any file.\r\n\r\n1. OPEN.IMAGE  ' open a dialog for file(s) selection. Version 7 have a new custom dialog\r\n2. OPEN.IMAGE  aName$\r\n3. OPEN.IMAGE  aName$, folderOrIndirectPath$\r\n4. OPEN.IMAGE  aName$, folderOrIndirectPath$, titleOfDialog$\r\n5. OPEN.IMAGE  aName$, folderOrIndirectPath$, titleOfDialog$, fileTypes$\r\n\r\nwe can omit some parammeters..\r\n\r\nOPEN.IMAGE ,,\"Load Photo\",\"jpg\"\r\n\r\nLike OPEN.FILE but can preview images on the file selector\r\n\r\nBy default this is the fileTypes$ \"BMP|JPG|GIF|WMF|EMF|DIB|ICO|CUR\"\r\nWe can open at the Computer Level (showing the drives and the LAN common folders)\r\nOPEN.IMAGE ,\"*\"  \r\n\r\nsee  OPEN.FILE for details.
GR:ΑΝΟΙΞΕ\r\nThis is the ANSI way (1 byte per char)\r\ncommand can define variable_as_file_handle if not exist\r\nEXCLUSIVE IS OPTIONAL\r\n# IS OPTIONAL\r\nOPEN file_name$ FOR INPUT EXCLUSIVE AS #variable_as_file_handle\r\nOPEN file_name$ FOR OUTPUT EXCLUSIVE  AS #variable_as_file_handle\r\nIf we use file_name$ as an empty string  For Output, then Print # send output to screen, for test purposes\r\nOPEN file_name$ FOR APPEND EXCLUSIVE AS #variable_as_file_handle\r\nOPEN file_name$ FOR RANDOM EXCLUSIVE  AS #variable_as_file_handle LEN=total_length_for_a_row_in_chars\r\n\r\nThis is the UNICODE way (2 bytes per char)\r\ncommand can define variable_as_file_handle if not exist\r\nEXCLUSIVE IS OPTIONAL\r\n# IS OPTIONAL\r\nOPEN file_name$ FOR WIDE INPUT EXCLUSIVE AS #variable_as_file_handle\r\nOPEN file_name$ FOR WIDE OUTPUT EXCLUSIVE AS #variable_as_file_handle\r\nIf we use file_name$ as an empty string  For Output, then Print # send output to screen, for test purposes\r\n\r\nOPEN file_name$ FOR WIDE APPEND EXCLUSIVE AS #variable_as_file_handle\r\nOPEN file_name$ FOR WIDE RANDOM EXCLUSIVE AS #variable_as_file_handle LEN=total_length_for_a_row_in_chars\r\n\r\nMaximum LEN is 32766 (but for unicode use 32766/2  form max length of chars)\r\nAlways use an even number because system read as unicode the ansi file and then convert it to ANSI, so in a position for a unicode char we get two ansi chars.\r\n\r\nWe don't have BINARY files in M2000.  You can use WIDE RANDOM as a form of binary file.\r\nWe can provide a new variable as file handle. Number as handle is given automatic. So if variable had a value before Open statement then that value after should be lost.\r\n\r\nFunctions\r\nEOF(i)     ' true when we have end of file situation\r\nRECORDS(i) ' return length of file as bytes  for RANDOM the number of records   \r\neach record is a string of fix length. We can use MID$() to exrtract fields. Use FIELD and FIELD() for input and to create Fields.\r\n\r\nrecords(i)+1 is the first free position to put a new record. You can't delete a record, but you can define a simple field of one char to mark to delete a record when you replicate the file.\r\n\r\nStatements for RANDOM only\r\nGET #i, rec$, pos   ' this pos is record number, not position in bytes.\r\nPUT #i, rec$, pos    '  Seek command and Seek() function NOT work with RANDOM\r\n\r\nFor non RANDOM files:\r\nThese are text files or data files as text with data in each line.\r\nText File\r\nposition=SEEK(#filenumber) ' we can record the position before we write with PRINT or and WRITE\r\nPRINT #filenumber, \"aaaa\";  ' Using to print text lines that we can read with LINE INPUT, use ; for adding without line break\r\nPRINT #filenumber, \"123\",4,\"567\";  overwrite or at the end append 1234567\r\nPRINT #filenumber, \"A text line\",chrcode$(10);  \\\\ now we place linefeed as end of line (using chr$(10) is the same for ANSI)\r\nWRITE #filenumber,\"aaaa\"    ' write string in double quotes and place a comma between fields. All \" inside change to \"\"\r\n(if  we open for append we can change the position...and we can overwrite the file)\r\n\r\nWe can set the position from where we INPUT, LINE INPUT or INPUT$  (positions are in bytes always)\r\nSEEK #filenumber, position\r\n\\\\ Line Input find line break as CR (13) or LF (10) or CRLF or LFLF  (LF is Line Feed, CR is Carriage Return)\r\nLINE INPUT #i, line$   ' When we use WIDE then line breaks can be one of this CRLF LFLF CRCR CR LF\r\nINPUT #filenumber, A$, B     ' read what Write write. Line breaks are throwing. So in A$ we can't put chr$(13) or chr$(10)\r\na$=INPUT$(#filenumber, 20)  ' we can read number of chars. If we use WIDE in the OPEN command then chars are WCHAR (2 bytes)\r\n\r\nNever forget to state  WIDE for  if you use WIDE before because no BOM used here.\r\n\r\nIf you wish more functionality you can use database with many tables, with sorting and memo fields (variable size fields).\r\nlook BASE for information.\r\n\r\nWe can use LINE INPUT for reading lines unicode or not (specified in the OPEN command by WIDE mark). LINE INPUT use line break as a CR or LF or both or CRCR or LFLF \r\nWe can use WRITE #filenumber to make comma delimited lines of text (don't format numbers with comma as decimal)\r\nA Write command bound a string with \"\". Works for unicode type of files too. We can place multiline strings. Also we can place chr(34) and automatic saved as \"\", and when we read from INPUT then this is change to \". INPUT$() and LINE INPUT never process that. Also PRINT # never change output if we use WIDE chars. (for ANSI the actually bytes from string converted to ansi).\r\nAn INPUT #filename command  expects strings from a WRITE #filename command in \"\" and also works for unicode too\r\nA PRINT #f command also work for unicode text. With no CR LF printed\r\n\r\nMODULE A {open dir$+\"uni4.txt\" for wide output as k\r\na$={alfa \"ok\"\r\n      beta\r\n      }\r\nwrite #k, 1,2,3,a$, 5\r\nwrite #k, 100,2,3,\"George\", 5\r\nclose k \r\n}\r\n\r\nMODULE B {open dir$+\"uni4.txt\" for wide input as k\r\nwhile not  eof(k)  {\r\ninput #k, a,b,c,d$,e\r\nprint \"--------------------start---------------------\"\r\nprint a,b,c\r\nreport d$\r\nprint e\r\nprint \"----------------end-----------------------\"\r\n}\r\nclose k \r\n}\r\n\r\nExample for random access\r\n\\\\ for repeat the example - close all files (perhaps we need it) and delete the file too\r\n\\\\ we place a Sleep 300 to give os some time to do the delete\r\nCLOSE \r\ndos \"del \"+quote$( dir$+\"rec.that\"), 300;\r\n\\\\ run once without wide, unhide the remark after next line, and hide next line.\r\nopen dir$+\"rec.that\" for wide random as f len = 20\r\n\\\\open dir$+\"rec.that\" for random as f len = 20\r\nPrint Records(F)\r\na$=field$(\"ok\",10)+field$(\"ΑΒΓΔ\",10)\r\nprint a$\r\nput #f,  a$, 1\r\nPrint Records(F)\r\na$=field$(\"ok2\",10)+field$(\"ΑΒΓΔ2\",10)\r\nput #f,  a$, 2\r\nb$=field$(\"\",20)\r\nget #f, b$, 2\r\nPrint format$(\"Read {0} chars\",  LEN(b$))\r\nprint b$\r\nPrint Records(F)\r\nclose #f\r\n
GR:ΑΝΤΙΓΡΑΨΕ\r\nWe can copy from current layer any part to that layer or a string variable\r\nOr we can copy from a string variable to current layer using rotation angle and zoom factor\r\n\r\n1) from current X and Y\r\nCOPY  x.destination, y.destination, width, height  \r\nmove 2000,2000\r\ncopy 5000,5000,3000,3000\r\n\r\n2) Copy screen to file\r\nCOPY filename$\r\n\r\n3) Copy from current X and Y to a string \r\nCOPY width, height TO variable$\r\n\r\n4) Copy to  X and Y from a string - without altering the graphic cursor\r\nCOPY X,Y  USE variable$\r\n\r\n5) As 4 but with angle and zoom factor\r\nCOPY X, Y  USE variable$, angle\r\nCOPY X, Y  USE variable$, angle, zoom_factor\r\n\r\n6) As 4 but with angle and zoom factor and showing the image under at the corners\r\nCOPY X, Y  TOP variable$, angle\r\nCOPY width, height  TOP variable$, angle, zoom_factor\r\n\r\n\r\nvariable$ can be an item from an array\r\ncurrent X and Y stay as is.\r\n\r\nHot spot  (the rotation point and where the X, Y link to image) is in right top corner of the output bitmap.\r\nWe can use SPRITE with hot spot at the center (also the background, area behind sprite, saved in SPRITE$ for easy remove). Keeping backgrounds we can handle sprites,without actually create objects. So we paint sprites as we copy image, but with some additions: mask color  (for total transparency) and transparency for all other\r\nWe can use PLAYER an advance layer system with rotation but without painting to screen but on top of it. PLAYERS are act as real sprites having transparency with mask color,  using a z-order  system. We can make up to 32 of them. A PLAYER is an object that can be write on them as LAYER, and we can create targets on it, make drawings and copy images, and print using dedicated mode (font size)  and fontname. So we can make toolboxes in a LAYER and move it as a PLAYER.\r\n\r\nFORM 60, 32  \r\nCLS 7\r\nPEN 15\r\nPRINT \"This is first line\" \r\nPRINT \"This is second line\"\r\nPRINT \"This is third line\"\r\nPRINT \"This is forth line\"\r\nMOVE 0,0\r\nCLEAR A$\r\nCOPY 3000,2000 TO A$\r\nGRADIENT 3, 5   ' CLEAR SCREEN WITH GRADIENT\r\nCOPY 6000,4000 TOP A$, 30, 200\r\nCOPY 6000,4000 TOP A$, 45\r\nCOPY 2000,2000 USE A$, 45 \r\n
GR:ΑΠΑΡ\r\nEnumeration is local by default\r\nWe can use Set Enum to make a global one, but we can use it as local, and we can return enum values from functions.\r\n\r\n\\\\ we can use any numeric type including double\r\n\\\\ by default Dog=1, Cat=2\r\n\\\\ we can change it: Dog=0, Cat   ' so now Cat=1\r\n\\\\ we can change it: Dog=100, Cat=200\r\n\\\\ we can put a new line in place of comma\r\n\\\\ or after comma,\r\n\\\\ we can't leave a comma as last character except new lines, in the enum block.\r\nEnum Pets {Dog, Cat}\r\na=Dog\r\nPrint a=1  ' true\r\na++\r\nPrint Eval$(a)=\"Cat\", a=2\r\nk=Each(Pets)\r\nWhile k {\r\n      Print Eval$(k), Eval(k)\r\n      a=Eval(k)\r\n      Print a<Cat\r\n      Alfa(a)\r\n}\r\na=Dog\r\nAlfaByRef(&a)\r\nPrint a=Cat\r\n\r\nSub Alfa(b as Pets)\r\n      Print b\r\nEnd Sub\r\nSub AlfaByRef(&b as Pets)\r\n      Print b\r\n      b++\r\nEnd Sub\r\n\r\nLook Enumeration
GR:ΑΠΑΡΙΘΜΗΣΗ\r\n\\\\ we can use any numeric type including double\r\n\\\\ by default Dog=1, Cat=2\r\n\\\\ we can change it: Dog=0, Cat   ' so now Cat=1\r\n\\\\ we can change it: Dog=100, Cat=200\r\n\\\\ we can put a new line in place of comma\r\n\\\\ or after comma,\r\n\\\\ we can't leave a comma as last character except new lines, in the enum block.\r\nEnumeration Pets {\r\n      Dog\r\n      Cat\r\n}\r\na=Dog\r\nPrint a=1  ' true\r\na++\r\nPrint Eval$(a)=\"Cat\", a=2\r\nk=Each(Pets)\r\nWhile k {\r\n      Print Eval$(k), Eval(k)\r\n      a=Eval(k)\r\n      Print a<Cat\r\n      Alfa(a)\r\n}\r\na=Dog\r\nAlfaByRef(&a)\r\nPrint a=Cat\r\n\r\nSub Alfa(b as Pets)\r\n      Print b\r\nEnd Sub\r\nSub AlfaByRef(&b as Pets)\r\n      Print b\r\n      b++\r\nEnd Sub\r\n\r\n\r\nLook Enum
GR:ΑΠΕΔΩΣΕ\r\nRefer is a variant of Read, we can use it to make references without using & before names\r\nalso we can use it to make references to all members of a group (variables and arrays).\r\nIn the example bellow, x and z$ are private, hidden from outside, but refer can get references (by the order in the list of group members)\r\nWe can't make a second reference to one that exist. We can make references in a block for temporary definitions, like For object { }.\r\n\r\n\r\ngroup alfa {\r\nprivate:\r\n\tx=1, z$=\"ok\"\r\npublic:\r\n\tmodule print {\r\n\t\tPrint .x, .z$\r\n\t}\r\n}\r\nalfa.print\r\n\\\\ now we can refer to private variables\r\n\\\\ from outside the group\r\nrefer from alfa, x1, z1$\r\nPrint x1, z1$\r\nx1++\r\nz1$+=\"....\"\r\nalfa.print\r\n\r\n
GR:ΑΠΕΙΡΟ\r\n\r\nPrint INFINITY, -INFINITY\r\n           1.#INF    -1.#INF  \r\n
GR:ΑΠΛΟΣ\r\n\r\nUsed in TABLE for Databases
GR:ΑΠΟ\r\n\r\nOn Variable GOTO label1, label2, ...\r\n\r\nLabels can be numbers\r\n\r\nJumps can do in the same block of code, forward or backword.\r\n\r\nmodule B {\r\n{\r\n          5 read a\r\n      30 on a goto 100,200,300,400\r\n      50 Print a\r\n      100 Print \"10000\"\r\n      200 Print \"20000\"\r\n      300 Print \"30000\"\r\n      400 Print \"40000\"\r\n      600 Print \"ok\"\r\n}\r\nprint \"OK...............\"\r\n}\r\nB 0\r\nB 1\r\nB 4 \r\nB 100\r\n\r\na<1 exit block\r\na =1 goto 100\r\n...\r\na=4 goto 400\r\na>4 continue to next line (here 50)\r\nSo for a>total number of labels we can have an error condition or a chance to perform a better On GOTO.\r\n\r\n\r\n\r\n\r\n\r\n\r\n
GR:ΑΠΟΘΗΚΕΥΣΗ.ΩΣ\r\n\r\n1. SAVE.AS  ' open a dialog for saving a file. Version 7 have a new custom dialog\r\n2. SAVE.AS aName$\r\n3. SAVE.AS  aName$, folderOrIndirectPath$\r\n4. SAVE.AS  aName$, folderOrIndirectPath$, titleOfDialog$\r\n5. SAVE.AS  aName$, folderOrIndirectPath$, titleOfDialog$, fileTypes$\r\nResult we found in the Stack\r\n\r\nfolderOrIndirectPath$ is the top folder.\r\nIn M2000 we can't  create folder directly from code except by use of OS command (we can send command to OS...if we allowed to do something like this).\r\nSo if we need a folder to write then:\r\n1. We can use temporary folder as Temporary$....DIR TEMPORARY$ or using it in OPEN command\r\n2. We can use USER folder..by the command DIR USER      'note here we are not use a variable a USER$ but an ID that DIR expect.\r\n3. We can make a folder by the user action...using the command DIR to open a folder selector with folder creation capability. So we can set a top folder and allow the user to insert a folder there.\r\n
GR:ΑΠΟΚ$(\r\n\r\nPRINT \"<\"+TRIM$(\"        AAA         \")+\">\"\r\n<AAA>\r\nLocale 1032\r\na$=str$(\" Γιώργος \")  ' to ansi using Locale 1032 Greek\r\nPrint len(a$)=4.5  ' 4.5*2=9 bytes\r\nb$=trim$(a$ as byte)\r\nPrint chr$(b$)=\"Γιώργος\"  ' ansi to  UTF-16LE (using Locale 1032)\r\n\r\n\r\n\r\nPrint \">\"+str$(123)\r\n> 123  (insert a space before 1)\r\nPrint \">\"+str$(123,\"\")\r\n>123  (without a space before 1)\r\nPrint \">\"+str$(123,\"00000\")\r\n>00123  (formatted)\r\n\r\n
GR:ΑΠΟΚ.ΑΡ$(\r\n\r\nPRINT LTRIM$(\"  123\")=\"123\"\r\nk$=STR$(\"  123\")\r\nPRINT CHR$(LTRIM$(k$ AS BYTE))=\"123\"\r\nPRINT LTRIM$(k$ AS BYTE)=STR$(\"123\")
GR:ΑΠΟΚ.ΔΕ$(\r\n\r\nPRINT RTRIM$(\"123  \")=\"123\"\r\nk$=STR$(\"123  \")\r\nPRINT CHR$(RTRIM$(k$ AS BYTE))=\"123\"\r\nPRINT RTRIM$(k$ AS BYTE)=STR$(\"123\")
GR:ΑΠΟΛ(\r\nPRINT ABS(-5)+5\r\n    10\r\n absolute value
GR:ΑΡΓΑ\r\nCLI command only.\r\nSLOW\r\n\r\nInside a module use SET SLOW\r\nEngage the slow operation of interpreter. For any command the interpreter send a refresh to the environment form. \r\n\r\nWe can engage slow as choice in Control Form: use TEST to display variables and or execution code as run, and we see the stack also. You can stop, restart or engage like slow function (not the same)\r\n
GR:ΑΡΙΘΜΗΤΙΚΑ\r\nARITHMETIC FUNCTIONS\r\n#EVAL(, #FILTER(, #FOLD(, #MAP(, #MAX(, #MIN(, #POS(, #REV(, #SLICE(, #SORT(, #SUM(, #VAL(, ABS(, ARRAY(, ASC(, ASK(, ATN(, BACKWARD(, BANK(, BINARY.ADD(, BINARY.AND(, BINARY.NEG(, BINARY.NOT(, BINARY.OR(, BINARY.ROTATE(, BINARY.SHIFT(, BINARY.XOR(, BUFFER(, CAR(, CDATE(, CDR(, CEIL(, CHRCODE(, COLLIDE(, COLOR(, COMPARE(, CONS(, COS(, CTIME(, DATE(, DIMENSION(, DOC.LEN(, DOC.PAR(, DOC.UNIQUE.WORDS(, DOC.WORDS(, DRIVE.SERIAL(, EACH(, EOF(, EVAL(, EXIST(, EXIST.DIR(, FILE.STAMP(, FILELEN(, FLOOR(, FORWARD(, FRAC(, FREQUENCY(, FUNCTION(, GROUP(, GROUP.COUNT(, HIGHWORD(, HILOWWORD(, HSL(, IF(, IMAGE(, IMAGE.X(, IMAGE.X.PIXELS(, IMAGE.Y(, IMAGE.Y.PIXELS(, INKEY(, INSTR(, INT(, JOYPAD(, JOYPAD.ANALOG.X(, JOYPAD.ANALOG.Y(, JOYPAD.DIRECTION(, KEYPRESS(, LEN(, LEN.DISP(, LN(, LOCALE(, LOG(, LOWWORD(, MATCH(, MAX(, MAX.DATA(, MDB(, MIN(, MIN.DATA(, MODULE(, NOT, NOT_2, ORDER(, PARAGRAPH(, PARAGRAPH.INDEX(, PARAM(, POINT(, POINTER(, PROPERTY(, RANDOM(, READY(, RECORDS(, RINSTR(, ROUND(, SEEK(, SGN(, SIN(, SINT(, SIZE.X(, SIZE.Y(, SQRT(, STACK(, STACKITEM(, TAB(, TAN(, TEST(, TIME(, UINT(, USGN(, VAL(, VALID(, WRITABLE(\r\n\r\n
GR:ΑΡΙΘΜΟΣ.ΠΑΡΑΓΡΑΦΟΥ(\r\n\r\n\r\n=PARAGRAPH.INDEX(document_object, variable)\r\nvarIable with id of paragraph, return index number of paragraph (1)\r\nSee Paragraph()\r\n\r\nDocument a$ {paragraph1\r\n                        paragraph2\r\n                        }\r\nN=Paragraph(a$, 1)\r\nM=PARAGRAPH.INDEX(a$, N)\r\nPrint M=1
GR:ΑΡΙΣ$(\r\n\r\nPRINT LEFT$(\"ABCDEF\",2)\r\nAB\r\n\r\nLocale 1032\r\na$=str$(\"Γιώργος\")  ' to ansi using Locale 1032\r\nPrint chr$(Left$(a$,3 as byte))=\"Γιώ\"  ' Chr$() convert ansi to  UTF-16LE (using Locale 1032)\r\n\r\n
GR:ΑΡΙΣΤΕΡΟΜΕΡΟΣ$(\r\n\r\nPrint RightPart$(\"123456789\",\"5\")  ' after 5\r\nPrint LeftPart$(\"123456789\",\"5\") ' before 5
GR:ΑΡΧΕΙΑ\r\n\r\nFILES                              print to screen all txt files in DIR$\r\nFILES \"mdb\"                 print to screen all mdb (databases) files in DIR$\r\nFILES + \"jpg\"                fill list with file names with jpg extension without extension and path\r\nMENU !                           Open the list  - we can add more selections by MENU + \"name\"\r\n\r\nFILES \"gsb\", \"While\"  print to screen all gsb files with  \"While\" included.\r\nFILES \"gsb\", \"While|Black\"  print to screen all gsb files with  \"While\" and \"Black\" included.\r\nFILES !    ' sorted by name\r\nFILES !! \"*\" ' sorted by type\r\nFILES !! \"T*.*\" ' sorted py type\r\n
GR:ΑΡΧΕΙΟ\r\n\r\nMake a table definition\r\nA name for the table and a list of field triplet...name, kind and size\r\nThese arte the kinds of fields\r\nBOOLEAN, BYTE, INTEGER, LONG, CURRENCY, SINGLE, DOUBLE, DATEFIELD, BINARY, TEXT, MEMO\r\n' 0 for length means..the database hide the size.\r\n\r\nTABLE \"mine\" , \"firstTable\", \"field1\", long, 0, \"title1\", text, 40, \"memo1\", memo, 0mo1\", memo, 0\r\n\r\n\r\n\r\n
GR:ΑΡΧΕΙΟ$(\r\nprint file$(\"text file\",\"TXT\")\r\nLoad File$()\r\n\r\n\r\nOpen file selector for one file (if we change to multiselection from setup, we can select a lot but those selections are dropped, only the one that double click or slide return)\r\nWe can put multi type string \"BMP|JPG\"
GR:ΑΡΧΕΙΟΥ.ΜΗΚΟΣ(\r\n\\\\ Example\r\nDocument a$={πρώτη σειρά\r\n      δεύτερη\r\n      τρίτη\r\n      τέταρτη\r\n      }\r\nUTF_16LE=0     \r\nSave.Doc a$, \"checkme.doc\", UTF_16LE\r\nIf Exist(\"checkme.doc\") Then {\r\n      Print Filelen(\"checkme.doc\")\r\n}
GR:ΑΡΧΕΙΟΥ.ΣΤΑΜΠΑ(\r\n\r\nOpen \"one.txt\" For Wide Output Exclusive as #k\r\n      Print #k, \"Hello\"\r\n      Print #k, \"Hello There\"\r\nClose #k\r\nPrint Str$(File.Stamp(\"one.txt\"),\"hh:nn:ss dd/mm/yyyy\") , \"utc creation time - by default\"\r\nPrint Str$(File.Stamp(\"one.txt\" ,1),\"hh:nn:ss dd/mm/yyyy\") , \"utc creation time, 1\"\r\nPrint  Str$(File.Stamp(\"one.txt\" ,-1),\"hh:nn:ss dd/mm/yyyy\"), \"local creation time, -1\"\r\nPrint Str$(File.Stamp(\"one.txt\" ,2),\"hh:nn:ss dd/mm/yyyy\"), \"utc write time, 2\"\r\nPrint  Str$(File.Stamp(\"one.txt\" ,-2),\"hh:nn:ss dd/mm/yyyy\"), \"local write time, -2\"\r\n
GR:ΑΡΧΗ\r\n\r\nSTART   (Cold restart )\r\nSTART \"\",\"\" (WARM RESTART)\r\nSTART \"VERDANA\"  (before 6th version this was the only way to alter font in screen, now we can use FONT)\r\nSTART \"\",\"BEEP:BEEP\"\r\n\r\nFor altering screen size and font, use MODE, WINDOW, FORM, LAYER\r\n\r\n
GR:ΑΥΛΟΣ\r\nAdvance topic.\r\nWe use a base.gsb to run a trg.gsb\r\nwe can call FEED in trg.gsb to feed values to base.gsb\r\nwe can call TERM in trg.gsb to end the loop in base.gsb\r\n\r\n\\* WRITE THIS IN TRG.GSB\r\nMODULE C {\r\n      WINDOW 12, 7000,4000\r\n      FORM 32, 25\r\n      FORM\r\n      SHOW\r\n      MOTION.W 8000,2000\r\n      PRINT \"THIS IS A TARGET\"\r\n      STACK\r\n      READ A$\r\n      PUSH A$, A$\r\n      MODULES\r\n}\r\nMODULE FEED {\r\n      READ PIPE$\r\n      PUSH PIPE$\r\n      O=0\r\n      REPEAT {\r\n            O=O+1\r\n            TRY KK {\r\n                  PIPE PIPE$, 1,2,3\r\n                  WAIT 10\r\n            }\r\n      PRINT KK, O\r\n      } UNTIL KK OR (O=100)\r\n}\r\nMODULE TERM {\r\n      READ PIPE$\r\n      PUSH PIPE$\r\n      O=0\r\n      REPEAT {\r\n            O=O+1\r\n            TRY KK {\r\n                  PIPE PIPE$, 0\r\n                  WAIT 10\r\n            }\r\n            PRINT KK, O\r\n      } UNTIL KK OR (O=100)\r\n}\r\nC\r\n\\**************************** WRITE THIS IN BASE.GSB\r\n\r\nMODULE B {WINDOW 12, 6000,4000\r\nFORM 32, 25\r\nFORM\r\nSHOW\r\nMOTION.W 500,2000\r\nPRINT \"THIS IS THE BASE\"\r\nK$=\"ANAMEFORPIPE\"\r\nUSE TRG.GSB 1,\"MESSAGETXT\",3 TO K$ AS L\r\nTHREAD L INTERVAL 200\r\nC=0\r\nPAR$=\"\"\r\nNM$=\"\"\r\nGETOUT=FALSE\r\nEVERY 200 {\r\n                        C=C+1\r\n                        PRINT C\r\n                        IF INKEY$=\" \" THEN EXIT\r\n                        IF C=1000 THEN EXIT\r\n                        IF K$<>\"\" THEN {\r\n                                          STACK K$\r\n                                          STACK  ' SHOW ONLY\r\n                                          READ NM$, PAR$\r\n                                          FLUSH\r\n                                          IF PAR$=\"N\" THEN GETOUT =TRUE\r\n                                          C=0\r\n                        }\r\n                        IF GETOUT THEN EXIT \r\n                  }\r\nPRINT \"FINISH\"\r\nTHREAD L ERASE\r\n}\r\nB\r\n\r\nnow do this \r\nLoad BASE\r\nso Base is loaded and call B automatic, and then  you see two consoles running, and in second console you can send messages to first one. Use FEED and TERM to end listening in first console
GR:ΑΥΛΟΣ$(\r\nPrint pipename$(OwnPipeHandler)\r\n\r\nUsing Pipe$() and Pipe we can make communications between two environments. The idea is that a \"server\"...open a pipe and wait for requests. Each client can use PIPE to send data. If client wants data to get back can create a second pipe and send the pipename along with data, and then stay to listening for data. For client handle own pipe using a handler. We have to place the path of the pipe so we need pipename$(pipehandler) to take it.\r\n\r\n\r\n\r\n
GR:ΑΥΞΟΥΣΑ\r\n\r\nUsed in ORDER for Databases
GR:ΑΥΤΟ\r\n1. This is the object Group\r\nGroup Alfa {\r\n      X=10\r\n      Module Beta {\r\n            Print This.X, .X\r\n      }\r\n}\r\nAlfa.Beta\r\n2. This in a For This {}\r\n For This {}  used for temporary definitons.\r\n\r\n\r\n
GR:ΑΥΤΟΜΑΤΟΙ_ΠΙΝΑΚΕΣ\r\nTuple as auto arrays using ( ) and at least one comma\r\n\r\na=(,)    len(a)=0\r\na=(1,)  len(a)=1\r\na=(1,2,3,4)\r\nPrint a\r\nm=each(a End to Start)   ' same as each(a,-1,1)\r\nWhile m {\r\n      Print array(m), m^\r\n}\r\nPrint a#sum(), a#min(), a#max()\r\nwhere=-1\r\nPrint a#max(where), where\r\nwhere=-1\r\nPrint a#min(where), where\r\n\\\\ for string\r\nPrint a#min$(where), where\r\nPrint a#max$(where), where\r\n\\\\ shearch for value 3,  from 3rd position (0 is for first position)\r\nPrint a#pos(3), a#pos(2->3)\r\n\\\\ search items in an array\r\nPrint a#pos(1,2), a#pos(2->1,2)\r\nPrint a#pos((1,2)), a#pos(2->(1,2))\r\nPrint a#pos(\"a\",\"b\"), a#pos(2->\"a\",\"b\")\r\nPrint a#pos((\"a\",\"b\")), a#pos(2->(\"a\",\"b\"))\r\n\r\na=(1,2,3,4,5)\r\nPrint a#rev()\r\nPrint a#sum()=15\r\nPrint a#max()=5, a#min()=1\r\nk=-1\r\nL=-1\r\nPrint a#max(K)=5, a#min(L)=1\r\nPrint K=4 ' 5th position\r\nPrint L=0 ' 1st position\r\nPrint a#pos(3)=2 ' 3rd position\r\nPrint a#val(4)=5\r\n\\\\ tuples in tuple\r\na=((1,2),(3,4))\r\nPrint a#val(0)#val(1)=2\r\nPrint a#val(1)#val(1)=4\r\na=(1,2,3,4,5,6,7,8,9)\r\nfold1=lambda ->{\r\n      push number+number\r\n}\r\nPrint a#fold(fold1)=a#sum()\r\nPrint a#fold(fold1,1)=a#sum()+1\r\neven=lambda  (x)->x mod 2=0\r\nb=a#filter(even, (,))\r\nPrint b  ' 2 4 6 8\r\nPrint a#filter(even)#fold(fold1)=20\r\nmap1=lambda (a)->{\r\n      push a+100\r\n}\r\nc=b#map(map1)\r\nPrint c  ' 102,103, 104, 105\r\nnumbers=lambda p=1 (x) ->{\r\n      push x+p\r\n      p++\r\n}\r\noldnumbers=numbers  ' we get a copy of numbers with p=1\r\nc=c#map(numbers)\r\nPrint c  ' 103, 106, 109, 112\r\nzfilter=lambda -> number>106\r\ntostring=lambda -> {\r\n      push chrcode$(number)\r\n}\r\noneline=lambda -> {\r\n             shift 2   ' get second as first\r\n             push letter$+letter$\r\n}\r\nLine$=c#filter(zfilter)#map(tostring)#fold$(oneline,\"\")\r\nprint Line$=\"mp\", chrcode$(109)+chrcode$(112)\r\nzfilter=lambda -> number>200\r\nLine$=\"\"\r\nLine$=c#filter(zfilter)#map(tostring)#fold$(oneline,\"\")\r\n\\\\ lines$ can't change value becuse filter has no items to give\r\nPrint Line$=\"\"\r\n\\\\ if we leave a second parameter without value the we get No Value error\r\nTry {\r\n      Line$=c#filter(zfilter, )#map(tostring)#fold$(oneline,\"\")\r\n}\r\nPrint error$=\" No value\"\r\n\\\\ second parameter is the alternative source\r\nLine$=c#filter(zfilter,(109,112))#map(tostring)#fold$(oneline,\"\")\r\nPrint Line$=\"mp\" \r\nc=(1,1,0,1,1,1,1,0,1,1,0)\r\n\\\\ hard insert \r\nPrint c#pos(1,0,1)  ' 1  means 2nd position\r\nPrint c#pos(3->1,0,1)  ' 6  means 7th position\r\n\\\\ using another tuple\r\nPrint c#pos((1,0,1))  ' 1  means 2nd position\r\nPrint c#pos(3->(1,0,1))  ' 6  means 7th position\r\nt=(1,0,1)\r\nPrint c#pos(t)  ' 1  means 2nd position\r\nPrint c#pos(3->t)  ' 6  means 7th position\r\n
GR:ΑΦΑΙΡΕΣΗ\r\n\r\n1)  Delete database$, tablename$, fieldname$, fieldvalue$\r\nNeed exactly the field value (internal compare the value and if ok then erase the field)\r\nSo first you find the record, you take a copy of a specific field and perform delete. So it is better to not have duplicates (if is a unique key then we get error if we insert another copy of already used key)\r\n\r\n2) Delete database$\r\nDelete database only if created by M2000 (if has the \"original\" M2000 password).\r\n\r\n(When we use BASE to make a database, then if base exist will be erased (checking for password for safety) and then a new empty file get the place of old one.)\r\nWe can use Execute to perform a multi record delete\r\nExecute \"HELP2000\", \"DELETE FROM COMMANDS WHERE GROUPNUM =22;\"
GR:ΑΦΗΣΕ\r\n\r\nRELEASE\r\nrelease the screen which we  hold with HOLD command.
GR:ΒΑΛΕ\r\n Any module, function, thread has a mate stack for values. Modules that called from modules have the parent module stack. So A module can call a module passing values to stack. Functions are parents for the stack . Stacks from parents are lost if parent die..(end or exit). Only running modules, functions and thread have modules. A thread is a special module part that can be run in intervals and share variables from \"brother\" module, but has own stack. \r\n When in a module we call a function some data written in a temporary stack and merded to functions stack. The same happen but without making a new stack when a module call another module. So from a module we can get many values as items on the stack.\r\n\r\n  A function return only one value, but in expressions. Modules cannot used in expressions. Threads have no name, but a handler for each. When a thread call a module then that module use the threads stack. When a thread call a function then new stack created for that function. Every thread run all in a time slice, an interval. So any module or function in the thread are cleared when that slice ends. So anything in those stacks cannot used to return values. The only way for a thread to act to values is by using the same namespace as those of the creator module, and read and alter variables and arrays. \r\n \r\nSome commands from DATABASES and from DIALOGUES uses the stack to return data\r\n\r\nWe can use Push to send a list of items to current stack. If we  use SET PUSH then any variable will be from level 0 (global level) but the stack will be the current.\r\n\r\nPUSH and DATA are the commands that we can use to handle not only by value items but we can include by reference IF we know when they putting and know when we can get.\r\n\r\nA=1\r\nPush &A\r\nread &B\r\nB=5  ' now A=5\r\n\r\nPUSH 1,3,4   ' the last is the first or top in the stack (first that we read)\r\nDATA 1,3,4  ' The last is the last in the stack or in the bottom.\r\n\r\nSo if we place some PUSH commands...we send data to the bottom\r\nBut if we use DATA we spread data as we read, the last line...last, the last item in line...last\r\nSo DATA and READ are like BASIC's     \r\n\r\nWhen we call a MODULE the system make a temporary stack and we pass values like a DATA and then that stack is merged on top of the current stack. So when we read values from the module we know..that there must be some values for us, and so we can get references. The references are strings containing the name of the variable or array that the READ instruction has to link with a new variable or array accordingly. So the linking process can be many times (if we get the value and push it back three times we can create by a three variables reading three clones of the original variable).\r\n\r\nIn some languages to passing values to a function conform a way  as exclusive written in the script. For some languages there is an overloading method, where many definitions have same function name.  But in M2000  any module may have some commands to interpret the stack.  Any module may alter context (by the parent) or use INLINE code, that can import in a string, to run it. So by using the STACK not only we send values, but also we change the behavior of the module. This called interaction. Modules interact with other modules to make things happen. Feedback can be sent through the stack. So a PUSH isn't  only  for sending to the module we call but for sending back to the module that calls.\r\nM2000 uses functions to handle items and read before pop about the type of it (references are string type...only READ understand what that is). See STACK, ENVELOPE$, LETTER$, NUM, ISNUM, ISLET, EMPTY and command DROP\r\nWe can use strings STACKS, a normal string arranged to work as stack (but stacks aren't strings from 6th version)\r\n\r\nWe can push expressions (as results)\r\nPUSH \"a\">a$, 12+4>5\r\n\r\n\r\nExample for use by reference (open a module and copy those lines)\r\n      dim pp(10)\r\n      pp(4)=1234\r\n      push &pp()\r\n      read &kl() ' we make a new name but the data are the same\r\n      print kl(4) \r\n      dim kl(50) ' we redim the pp() array\r\n      g$=\"George Karras\"\r\n      module aa {\r\n            read &kk(), &k$ \r\n            k$=\"The best of \"+k$   'we change some values\r\n            kk(4)=kk(4)*2     \r\n      }\r\n      aa &pp(), &g$  ' we pass by reference to module aa\r\n      print g$\r\n      print pp(4)\r\n\r\n\r\nFrom that addition from a coincidence happen something that was not in plan. The variables and array items are holded in variants. So we can get the reference from a number and link to a string variable. \r\nA$=\"100\"\r\npush &A$\r\nread &A\r\nprint A\r\n' now A=100 and A$=\"100\" both share the same container.\r\nFrom 7th edition, of M2000 language, we have document strings, a modified version of a string that holds paragraphs. We can reference document type strings, and we can link to a number, but if we place a value to that number then the string looses the linked document object and became a number value that can be read as a string.\r\n\r\nA fast info here\r\n1. Documents in stack are pushed as strings\r\n2. References are pushed as strings  \r\n3. Function references are strings as  \"{definition}\". So function reference is a copy. Functions reference from classes (groups) use an expanded form including the reference of group also just after last closed bracket.\r\n4. Declared objects (Word.Application or other) can't exist in Stack. We can use references to variable to pass in a call to module.
GR:ΒΑΛΕ.ΑΔΕΙΑ$(\r\nadd license for dynamic load of activeX (using Declare)\r\nSame as License.add in VB6\r\nOne or Two Strings as parameters: The ProgID and the License Key\r\nInfo: https://msdn.microsoft.com/en-us/library/aa277583(v=vs.60).aspx
GR:ΒΑΣΕΙΣ ΔΕΔΟΜΕΝΩΝ\r\nDATABASES\r\nAPPEND, BASE, COMPRESS, DB.PROVIDER, DB.USER, DELETE, EXECUTE, ORDER, RETRIEVE, RETURN, SEARCH, STRUCTURE, TABLE, VIEW\r\n\r\n
GR:ΒΑΣΗ\r\nFrom version 7, we handle UNICODE text and memo fields. No DAO used, but ADO for mdb only databases\r\nI. Using numeric argument\r\nBase 1   - for arrays from 1,\r\nBase 0   - for arrays from 0\r\n\r\nWe can set any base using (TO): Dim a(-4 TO 4), b(-1 to 1, -1 to 1)\r\nII. Using string argument\r\n1. You can make a database easy\r\nFirst you must define the name of DATABASE\r\n\r\n      BASE \"mine\"   ' SECOND TIME DELETE THE DATABASE  AND CREATE IT AGAIN\r\n\r\n      with a single exist(\"mine.mdb\") we can read if database exist as a filename in current directory\r\n      but we can check if \"mine\" database exist and can connect  with it\r\n      ? CheckBase (\"mine\")  ' not need the type... .mdb\r\n      \r\n                  FUNCTION CHECKBASE {\r\n                        ok = false   ' needed because TRY can't create variable\r\n                        try ok {\r\n                        structure  letter$           ' EXPECT 1 OR 2 STRING VALUES FROM THE STACK\r\n                                                      ' this fill the stack with table names but return also an error when\r\n                                                      ' file not exist \r\n                                                      ' can't connect to base (maybe is exclusively open buy other app)\r\n                                                      '  we can check if a table exist by providing additional parameter\r\n                                                      '  to the function stack  ? CheckBase (\"mine\",\"tablename\") \r\n                        }\r\n                        = ok\r\n                  }\r\n\r\n2.You need a table definition\r\n      A name for the table and a list of field triplet...name, kind and size\r\n      These are the kinds of fields\r\n      BOOLEAN, BYTE, INTEGER, LONG, CURRENCY, SINGLE, DOUBLE, DATEFIELD, BINARY, TEXT, MEMO\r\n\r\n            ' 0 for length means..the database define only (we can do otherway)\r\n\r\n      TABLE \"mine\" , \"firstTable\", \"field1\", long, 0, \"title1\", text, 40, \"memo1\", memo, 0\r\n\r\n3. And you can set the order for simple reading DESCENDING or ASCENDING\r\n      ORDER \"mine\", \"firstTable\", \"title1\", ascending\r\n\r\nYou can put as many tables as you wish.\r\n\r\nYou can put directory and the \".mdb\" in the name of base\r\n\r\nThe base is password protected (no a srtong one) for a reason...To know if this is \"our\" base. If isn't \"our\" base then we can't delete it\r\nYou can delete the database using DELETE. This command finds the key and then if is right then delete it. Using this way we don't perform any reading with our password to find that is invalid. We read the password and then we know.\r\n\r\n      DELETE \"mine\"\r\n\r\nWe can read the structure from any BASE, with STRUCTURE command\r\nUse RETRIEVE το get a row of fields (using SQL if you like)\r\nUse EXECUTE to send a command without returning fields\r\nUse SEARCH το get a row of fields using a filter\r\nUse RETURN to update row with new value\r\nUse APPEND to push new row to any table\r\nUse DELETE to throw a row with a specific value in a specific field\r\nUse VIEW to fill a selection list (a drop down menu, basically) using a \"SELECT DISTINCT field1 FROM table1\" to get a table for one list\r\nUse CLOSE BASE to release the conection (new command)\r\n\r\nYou can COMPRESS the base (to throw deleted rows)\r\n\r\nAbout Language M2000 and how the interpreter can get values and send back to a database\r\nM2000 has a structure as a stack of values (all modules calling other modules in the some stack, but threads and functions has own stack), so when we want a list of data commands place there the data, and in the top the number of data that follows. So if we have a module and a command for a base retrieve field data, that data fill the stack and module can call an other module, as a routine, without passing \"exclusive\" parameters (like in other languages). This cannot be done with functions, but inside function we can call modules, and that modules can use the function stack as own stack.\r\n\r\n
GR:ΒΑΣΗ(\r\n\r\nPrint Mdb(\"name\")\r\nReturn -1 if exist a name.mdb and have the standard password.\r\n
GR:ΒΑΣΗ.ΠΑΡΟΧΟΣ\r\n\r\nDB.PROVIDER \"Microsoft.Jet.OLEDB.4.0\", \"Jet OLEDB\", \"PASSWORD\"\r\n\r\npassword for base encryption
GR:ΒΑΣΗ.ΧΡΗΣΤΗΣ\r\n\r\nDB.USER \"dbusername\", \"dbpassword\"\r\n
GR:ΒΑΨΕ\r\nFill a rectangle with 2 variations, one use windows system fill rectangle call\r\n1) FILL widthTwips, HeightTwips  [,color1 [, color2 [, direction[, part]]]]\r\n      Filling a block from graphic cursor, with width in twips and height in twips,\r\n      Pen color or color1 (1..15 basic colors, -0 to -16777216 , 0x80000001 system windows colors)\r\n      2nd Color is for gradient, direction 0 for left right direction and 1 for top down,\r\n      finally part 0 all gradient as a fill and part 1 as a window of screen filling (mimic a path)\r\n      after execution graphic cursor has the down right corner of fill block      \r\n            \r\n2) FILL @ widthTwips, heightTwips,  way, number, borderTwips\r\n      and a variant of this\r\n      FILL @ widthTwips, heightTwips, StringExpression\r\n      After execution graphic cursor not changed\r\n            Way:\r\n                  0 - Frame\r\n                  1 - Background for letters\r\n                  2 - Draw\r\n                  3 - Draw (Xor) so the second time  the drawing erased without affect the screen\r\n                  4 - Draw some icons from windows\r\n                  5 - Center and print  letters or numbers\r\n                  6 - Like 4 but we can define which frame side we wish to display (1+2+4+8 for all)\r\n                  3D frames: Fill @ 2000,200,4,1\r\n                  We can use the 3rd way to make rectangle non flashing cursors\r\n                  \r\n                  \r\n                  \r\n                  \r\n                  
GR:ΒΗΜΑ\r\n\r\nMoving graphic cursor but not drawing relative distances\r\nSTEP 2000, 3000\r\n\r\nMoving with polar coordinates. Angle always act as compass. Relative distance\r\nSTEP ANGLE pi/4, 1000\r\n\r\n\r\n\r\n\r\n\r\n
GR:ΒΟΗΘΕΙΑ\r\n\r\n1) Show Help \r\nCTRL +F1\r\n\r\n2) Help string expression\r\nsearching Help database using a string\r\n\r\n3) Help identifier\r\nas 2 but using identifier\r\n\r\n\r\n4) Reading all topics from Help2000.mdb (old)\r\n\\\\ Get all English topics from Help Database\r\nForm 80,50\r\nFlush\r\nDocument All$\r\nnl$={\r\n}\r\nDir appdir$\r\n\\\\ for Close Base (is optional here)\r\nbase$=dir$+lcase$(\"HELP2000\")+\".mdb\"\r\nRetrieve \"HELP2000\", \"SELECT * FROM COMMANDS ORDER BY ENGLISH\"\r\nRead n\r\nFor i=1 to N {\r\n      Retrieve \"HELP2000\", \"SELECT * FROM COMMANDS ORDER BY ENGLISH\", i\r\n      Drop \r\n      read Gr$, Memo$, En$, group_id\r\n      If group_id<>22 then {\r\n            Retrieve \"HELP2000\",\"GROUP\", 1,\"GROUPNUM \", group_id\r\n            Drop 2 : Read group_gr_en$\r\n            En$=filter$(En$,\"_\")\r\n            If Right$(En$,1)=\"(\" then En$=En$+\")\"\r\n            Report En$ +\" (\"+Rightpart$(group_gr_en$, \",\"+chr$(160))+\")\"\r\n            All$=En$ +\" (\"+Rightpart$(group_gr_en$, \",\"+chr$(160))+\")\"+nl$\r\n      }\r\n}\r\nPrint\r\nClipBoard All$  ' to clipboard\r\nDir user\r\nSave.Doc All$, \"English.txt\"\r\nWin \"WordPad\", Quote$(Dir$+\"English.txt\")\r\nClose Base base$  \\\\ optional\r\n\r\n5) Read all topics from dat file\r\n\r\nDocument aLL$, doc$\r\nLoad.doc aLL$, appdir$+\"help2000utf8.dat\"\r\nA=Val(paragraph$(aLL$, 1))\r\nB=Val(paragraph$(aLL$, 2+A))\r\nfor i=1 to b\r\n\tm=Val(rightpart$(paragraph$(aLL$,2+A+i+3*B),\"!\"))+1\r\n\tb$=mid$(leftpart$(paragraph$(aLL$,2+A+i+3*B),\"!\"),2)\r\n\tiF right$(b$,1)=\"(\" then b$+=\")\"\r\n\tc$=b$+\" (\"+ Rightpart$(paragraph$(aLL$, m), \",\"+chr$(160))+\")\"\r\n\tPrint #-2, c$\r\n\tdoc$=c$+{\r\n\t}\r\nnext i\r\nSave.Doc doc$,\"English.txt\"\r\nWin \"WordPad\", Quote$(Dir$+\"English.txt\")\r\n\r\n\r\n
GR:ΓΕΓΟΝΟΣ\r\n\r\nAn Event is an object in M2000. We can push it to stack  like a lambda function, and with Match(\"E\") we can check if it is in the top of stack.\r\nEvents can be part of groups also.\r\n\r\nWe can make a global one:\r\nGlobal Event A { }\r\nor a local:\r\nEvent A {\r\n      Read message$\r\n      Read &message_by_reference$\r\n      Function {\r\n            Print message$\r\n      }\r\n}\r\n\r\nWe can use some keywords for handling events:\r\nEvent A Hold\r\nEvent A Clear\r\nEvent A Release\r\nEvent A New aaa() [, bbb()]   ' we can bind some functions for multicast purposes\r\nEvent A Drop aaa() [, bbb()] ' we can drop any function\r\n\r\nExample 1:\r\n\\\\ We use a Lambda which return another Lambda, we feed event c twice (three add and one drop) with the same lambda b\r\n\\\\ We raise event by using Call Event, and then we pass as Event as a parameter to predefined Iterator,\r\n\\\\ so we can use inside a lambda function (or any other) calls to functions (but functions are not global)\r\n\\\\ We see later how we change functions, and how we hold it and release it\r\n \r\nIterator = Lambda -> {\r\n      Read x,z\r\n      =Lambda x, z->{\r\n            Read e\r\n            If x>=z Then Exit\r\n            Call Event e x\r\n            x++\r\n            =True\r\n      }\r\n}\r\n\r\na=Iterator(10,15)\r\nb=Lambda->{Print Number}\r\nEvent c {Read x}\r\n\\\\ multicast\r\nEvent c New b(), b(), b()\r\nEvent c Drop b()\r\n\\\\ FIRST USE\r\nCall Event c 5\r\n\\\\ SECOND USE\r\nWhile a(c) {}\r\nEvent c Hold\r\nCall Event c 5+2\r\n\\\\ nothing happen but addition 5+2 processed\r\nCall Event c 5+b(2)\r\n\\\\ nothing happen but we see 2 because b() run\r\nEvent c Clear\r\n\\\\ now we erase any function from Event and set to Hold\r\nFunction k {Print Number**2}\r\nEvent c New k(), b()\r\n\\\\ reset Iterator\r\na=Iterator(10,15)\r\nWhile a(c) {}\r\n\r\nExample 2:\r\n\\\\ Change Iterator. Now produce a lambda which need a reference to an Event.\r\nIterator = Lambda -> {\r\n      Read x,z\r\n      =Lambda x, z->{\r\n            Read &e   \\\\ now we want by reference call\r\n            If x>=z Then Exit\r\n            Call Event e x\r\n            x++\r\n            =True\r\n      }\r\n}\r\n\r\na=Iterator(10,15)\r\nb=Lambda->{Print Number}\r\nEvent c {Read x}\r\n\\\\ multicast\r\nEvent c New b(), b()\r\nCall Event c 5\r\nEvent c Hold\r\n\\\\ passing by reference\r\nWhile a(&c) {}\r\nEvent c Release\r\nCall Event c 124\r\n\r\n2) Events in groups with WithEvents\r\nThese are light events, without object or specific commands \r\nGroup WithEvents Alfa {\r\n      Events \"a\", \"b\"\r\n      Χ=10\r\n      Module Check {\r\n            Def M as long\r\n            call event \"a\", &M, 20\r\n            Print stack.size, M\r\n       }\r\n       Module CheckB(what$) {\r\n            call event \"b\", what$\r\n      }\r\n}\r\nM=100\r\na=500\r\nb=4000\r\nFunction Alfa_a(New &a,b) {\r\n      M++\r\n      a=M\r\n      Print \"ok\", a, b, M\r\n      push 500  ' can't return using stack, stack is private\r\n}\r\nFunction Alfa_b(a$) {\r\n      Print \"From Event:\";a$\r\n}\r\nAlfa.Check\r\nStack ' print empty line, stack is empty\r\ndim k(10)=alfa\r\nModule Z (M()){\r\n      For i=0 to 9{\r\n                  For M(i) {\r\n                        .check\r\n                  }\r\n      }\r\n      M(5).checkb \"This is M(5)\"\r\n}\r\nZ K()\r\nGroup WithEvents Beta=k(3)\r\nBeta.checkb \"Hello There\"\r\n\r\n\r\nThe same example with event object\r\nhere we have to attach functions (and maybe more than one, so we have passing parameters to all functions in the event list), and also we have to specify the signature of parameters\r\nGroup Alfa {\r\n      Event A {\r\n            Read &a, b\r\n      }\r\n      Event B {\r\n            Read a$\r\n      }\r\n      Χ=10\r\n      Module Check {\r\n            Def M as long\r\n            call event .A, &M, 20\r\n            Print stack.size, M\r\n       }\r\n       Module CheckB (what$) {\r\n                  call event .B, what$\r\n      }\r\n}\r\nM=100\r\na=500\r\nb=4000\r\nFunction Alfa_a(New &a, b) {\r\n      M++\r\n      a=M\r\n      Print \"ok\", a, b, M\r\n      push 500  ' can't return using stack, stack is private\r\n}\r\nFunction Alfa_b(New zz$) {\r\n      Print \"From Event:\";zz$\r\n}\r\n\r\nEvent Alfa.A New Lazy$(&Alfa_a())\r\nEvent Alfa.B New Lazy$(&Alfa_b())\r\nAlfa.Check\r\nStack ' print empty line, stack is empty\r\ndim k(10)=alfa\r\nModule Z (M()){\r\n      For i=0 to 9{\r\n                  For M(i) {\r\n                        .check\r\n                  }\r\n      }\r\n      M(5).checkb \"This is M(5)\"\r\n}\r\nZ K()\r\nGroup WithEvents Beta=k(3)\r\nBeta.checkb \"Hello There\"\r\n
GR:ΓΕΜΙΣΕ\r\n\r\nFill color for any closed line shape\r\n1) FLOODFILL absolute_pos.twips, absolute_pos.twips, color.ID\r\n      Change color to color.ID on the color founding at graphic position\r\n      Color.id: Use the color representation of your choice like, see DRAW\r\n2.  FLOODFILL COLOR absolute_pos.twips, absolute_pos.twips, color.ID\r\n      Change color until found color.iD starting at graphic position with color.ID color.\r\n\r\n            FLOODFILL 2000,2000,5\r\n            FLOODFILL ,,5  ' where graphic posisiton is\r\n            FLOODFILL 1000,1000  'using pen for filling\r\n\r\n   \r\n     
GR:ΓΕΝΙΚΗ\r\n\r\nGLOBAL  A=10, A(10,20)\r\nWe can make global variables and arrays.  They stay alive until creator module or function or sub or inside a For This {} .  We can assign new value bu using <= or using Let. If a global exist then a new command Global with same identifier make a new presence and hide old one (but not delete it). so never use Global in a loop. A global act as static if we never make a local in calling modules or and functions.  \r\n\r\nGlobal A=10, b()\r\nA<=20\r\nA+=10 \\\\ make  global 30\r\nLet A=50\r\nA=100  \\\\ now we have a local A and we hide global, for this module\r\nfor this { dim k(100)=1 : b()=k()}   \\\\ array k erased in for this but not global array b()\r\nPrint b(3)\r\n\r\nWe can also use a function\r\nFunction Feed { dim a(100)=10 : =a() }\r\nb()=Feed()\r\nPrint b(50)\r\n\r\nWe can make global arrays without hide same named array by using SET DIM\r\nSET DIM alfa(100)=2\r\n\r\nSee Local, Let, Dim
GR:ΓΙΑ\r\n\r\n\r\n\r\nWe can use integer (using %) or real or long (declare long in previus statement)  Variable. \r\nAt the beginning  variable searched in the local list and if not found then a new variable defined\r\n\r\nWe can use nested for\r\n\r\nFOR I=1 TO 10 STEP 2 {\r\n      PRINT I\r\n}\r\n\r\nFOR I%=1 TO 10 STEP 2 {\r\n      PRINT I% ' integer\r\n}\r\n\r\nIf start is bigger than end then step used as negative. But if start and end is equal then sign matters, so if we have a negative step then after For value be end plus step ( so if end is 5 and step is -5 then variable get 0)\r\nFor i=100 to 1 {\r\n      print i  ' from 100 to 1\r\n}\r\nFor I=100 to 10 step 10 {      \r\n      print i  ' print 100, 90,80...10\r\n}\r\n\r\n\r\nUse CONTINUE and EXIT in a FOR\r\nFor I=1 ro 100 step 2 {\r\n      IF I >50 Then Exit\r\n      If I>30 and I< 45 Then Continue\r\n      Print I\r\n}\r\nPrint I\r\n\r\n\\\\ without using For\r\ni=10\r\na=Random(1,3)\r\n{\r\n      If i<30 Then Loop  \\\\ change an internal flag only\r\n      If a>1 And i>25 Then Exit\r\n      Print i\r\n      i++\r\n}\r\n\\\\ Without using for or loop in a block\r\ni=10\r\na=Random(1,3)\r\n090 Flag=False\r\n100 If i<30 Then Flag=True\r\n110 If a>1 And i>25 Then 150\r\n120 Print i\r\n130 i++\r\n140 If Flag Then 90\r\n150 Print \"Ok\"\r\n\r\nhere k is global (but erased after module  or function ends running)\r\n\r\nset k=50\r\nfor k=k to 10 {   'here we have a new k that read the only known k, the global k\r\n      print k           'here interpreter choose local first\r\n}\r\nset print k     ' set command send all chars until end of line to CLI the level 0 or global for executions manual commands\r\n                        so at that level only the global variables are listed (without special name reference)\r\n                        \r\n\r\n\r\nIf we pass a name from a global variable (without all path) then a new variable defined so when we read the global variable that was unchanged but the internal *for* control value changed as we wish.\r\n\r\nWarning\r\nIf we set start and end value the same then step go to 0 so value of counter not changed, except we use Step, so change happen one Step.\r\n\r\n\r\nIf you change i inside For then nothing happen for For because actual variable are private to For.\r\nDon' t use For inside threads, because a thread is running in a loop at intervals, so we can adjust the time to make it as fast or slow we want, changing a value with ++ for i (i++)\r\nso\r\n\r\ni=0 \r\nThread {\r\n      i++\r\n      print i\r\n} as  aForThread\r\nthread aForThread interval 100\r\nmain.task 80 {\r\n      if mouse<>0  then exit\r\n}\r\n\r\nCheck the refresh rate!\r\nRefresh 100  ' By default refresh is 25 \r\nProfiler\r\nFor I=1 To 1000 {\r\n      Print I\r\n}\r\nPrint Timecount\r\n\r\nSome additions:\r\n1. We can use global variable (and class variable in a class module), using <= instead of =\r\n\r\nglobal i\r\nmodule beta {\r\n      for i<=1 to 1000 { }    \\\\ operator <= say Use global\r\n}\r\nbeta\r\nprint i  \r\n\r\n2. Negative/positive step for equal start and end point leave proper value\r\nfor i=1 to 1 step -1 {\r\n}\r\nprint i  \\\\ 0\r\n\r\nfor i=1 to 1 step 1 {\r\n}\r\nprint i    \\\\  2\r\n\r\nfor i=1 to 1 {\r\n}\r\nprint i   \\\\ nornal print 1\r\n\r\n\r\n\r\n\r\n\r\n\\\\ USING NORMAL BASIC FOR\r\n\\\\ WE CAN APPLY SWITCH IN COMMAND LINE, OR IN CODE\r\nSET SWITCHES \"+FOR\"\r\nFOR I=10 TO 1\r\n      PRINT I  \\\\ CAN'T EXECUTE LINES\r\nNEXT I\r\nFOR I=1 TO 10 STEP -1\r\n      PRINT I   \\\\ CAN'T EXECUTE LINES\r\nNEXT I\r\n\\\\ FAST FOR BLOCK\r\nFOR I=10 TO 1 {\r\n      PRINT I\r\n}\r\nFOR I=1 TO 10 STEP -1 {\r\n      PRINT I\r\n}\r\n\r\n\\\\ NORMAL FOR M2000\r\n\\\\ USE AUTO DIRECTION -1 HERE\r\n\\\\ ALWAYS EXECUTE FOR\r\nSET SWITCHES \"-FOR\"\r\nFOR I=10 TO 1\r\n      PRINT I\r\nNEXT I\r\nFOR I=10 TO 1\r\n      PRINT I\r\nNEXT   'without use of variable i\r\n\r\n\\\\ FAST FOR BLOCK\r\nFOR I=10 TO 1 {\r\n      PRINT I\r\n}\r\n
GR:ΓΡΑΜΜΑ$\r\n\r\n? letter$\r\nremove a string value from stack and print it. An error produced if no string value is on top of stack\r\n\r\n\r\na$=letter$  ' we remove the top and place to string, if a string value is in top of stack.\r\n\r\nWe can read if we have any item with EMPTY flag, of with STACK.SIZE\r\nWe can  find if we have a letter in the top of stack by using ISLET (is letter)\r\nor by using ENVELOPE$(). if left$(Envelope$,1)=\"S\" then ? \"we have a string value on top of stack\"\r\n\r\nLetter$ read the string value dropping it from the stack.\r\na$=letter$+letter$  ' add the two top item if they are string or error produce\r\n\\* we can push  to the top (last in first out)\r\npush \"a\",\"b\"\r\na$=\"\"\r\ntry ok {      ' this is an error trap\r\n      a$=letter$+letter$\r\n}\r\nif a$<>\"\" then {\r\n? \"we get two string values from the stack\", a$\r\n}\r\n\\* so we print \"ba\"\r\n
GR:ΓΡΑΜΜΑΤΟΣΕΙΡΑ\r\n\r\n\r\n1) FONT \"VERDANA\"\r\n\r\nWe can change font in backgorund, screen, layers.\r\n? FONTNAME$\r\n\r\nWe get the latest fontname$.\r\n2) FONT LOAD \"path\\name.ttf\" [, \"path\\name.ttf\"]\r\nWe can use current dir, so we can givee only the filename.\r\nthis variant of FONT only load fonts, we have to choose using Font \"fontname\" where fontname is different from name.ttf\r\nUsing Choose.Font we get a dialog and pressing End we see the last item which is the new  font from Font Load  \r\n\r\n3) FONT REMOVE \"path\\name.ttf\" [, \"path\\name.ttf\"]\r\nWe can remove one or more fonts if they not used. Using the same current directory if we didn't provide the path. All loaded fonts removed at the end of ececution of M2000 interpreter, so Font Remove is optional.\r\n
GR:ΓΡΑΜΜΑΤΟΣΕΙΡΑ$\r\n? FONTNAME$\r\nprint the current fontname\r\n\r\nwe can change font with font command\r\nfont \"Times\" \r\nIt is better after change font to perform a MODE or a FORM command.\r\n\r\nThere are fonts that are not the same size even we set same size as number to specific property size.\r\nEvery layer and the background cant have any font we choose.
GR:ΓΡΑΜΜΕΣΑΝΑΦΟΡΑΣ\r\n\r\nPrint reportlines\r\nReturn lines from last Report. Report command can be used to compute he needed lines before perform any printing.\r\nHere is a small program. Copy in a module and run it\r\n\r\n\\\\ this is a test text. Put another please.\r\nform 60,25\r\nc$={s\r\n            d\r\n            s.\r\n            . \r\n            ..\r\n            . .... ....\r\n            }\r\nfor i=1 to 10 {\r\n            cursor 10,10\r\n            print \"*1234567890\";\r\n            report 2, c$,i,-1000  ' NO PRINT, using here only to get REPORTLINES\r\n            cursor 10,11\r\n            print \"*\";\r\n            k= REPORTLINES\r\n            print @(pos,row, pos+i,row+k, 5,8);\r\n            report 2, c$,i,k\r\n            cursor 0,20\r\n            print over   $(6), \"Results\"    \\\\ 6 for center and proportional printing\r\n            print under    \\\\ draw a line (underline text)  and then change text line\r\n            print over     \\\\ clear one line\r\n            print part i , k \r\n            k$=key$\r\n}\r\n
GR:ΓΡΑΜΜΗ\r\n\r\nCursor 2,2 : print row\r\n        2\r\nPrint @(2,5), row\r\n        5\r\n        \r\npos, row, tab        \r\n  
GR:ΓΡΑΜΜΗ ΕΙΣΑΓΩΓΗΣ\r\n\r\nLINE INPUT #variable_as_file_handle, variable_string$\r\nLINE INPUT #variable_as_file_handle, variable_string$(index)\r\n\r\nretrieve  characters  from file until find cr or cr+lf or cr+cr or lf+lf founded. That last chars aren't included. So if we want to place the string in a file we must add chr$(13) or chr$(13)+chr$(10)  (or just PRINT # them)\r\n\r\nUse function Eof(#variable_as_file_handle) to find if  we get at the end of file.\r\nUse SEEK #variable_as_file_handle, char_position  if you have store a specific position...at the OUTPUT or at the APPEND.\r\n\r\nLine break found as one CR or one LF or CRLF or LFCR\r\n\r\nSEE INPUT AND INPUT$()\r\n\r\n\r\n\r\n\r\n\r\n
GR:ΓΡΑΦΗ$(\r\n\r\nstr$(12)\r\nstr$(12,\"##.###\")\r\nstr$(\"Abcde\",\"<\")\r\n\r\nstr$(\"String to convert\", localeID) \\\\\r\nusing 0 for localeID we convert to ANSI\r\nuse chr$(converted$, 1049) to make it unicode in specific language.\r\n\r\nHere we get ansi code from greek letters\r\na$=str$(\"Γιώργος\",0)\r\nSo now we can convert back to greek letters\r\nprint chr$(a$,1032)\r\n\r\nSecond parameter is the same as the parameter in format$() in vb6.\r\n\r\n\r\n\\\\ we can use Locale to set  locale id fro Ansi conversion\r\na$=Str$(\"Hello\")\r\n\\\\ a$ has a string as ansi string\r\nPrint len(a$)=2.5\r\nPrint \"Bytes:\"=Len(a$)*2  ' 5 bytes\r\nPrint Len(chr$(a$))=5\r\nPrint a$\r\n
GR:ΓΡΑΦΙΚΑ 2Δ\r\nDRAWING 2D\r\nCIRCLE, COLOR, CURVE, DRAW, FILL, FLOODFILL, MOVE, POLYGON, PSET, SMOOTH, STEP, WIDTH\r\n\r\n
GR:ΓΡΑΨΕ\r\nUsing filename \"\" in Open for Output we send output to screen\r\nwe can change separator for fields and the character for decimal point \r\nif we open file with \"\" as file name then we get Write output to screen\r\nWrite with chr$(9), \",\"\r\nWrite with \",\", \".\"\r\nThere is a third parameter and if it is true then all strings have escape chars exactly as string$(a$) does\r\nWrite #i, A#, B, 12*3242*K, C$, D  \r\nWrite formatted data to file with file number i using comma between values. If we open the file ..FOR WIDE OUTPUT then we send unicode formatted data we have to read by opening FOR WIDE INPUT...see OPEN\r\n\r\nYou can write data in a data file with comma between fields and with quotes to bound strings (and we can use multiline strings also). This format can be readed from Microsoft Excel or similar. Use filetype CSV for your file. Don't use ; but only comma and not as last char. Each line c an have variable number of values. We have to make a same way as we make the file..to read after.\r\nWe can save SEEK(#i) positions and later in a FOR INPUT (or FOR WIDE INPUT) we refer to that. We make a big error if we made a WIDE file (with WCHAR) and we readed without WIDE statement (like an ansi file).\r\n\r\nUse INPUT #i, Var List to read it. Writing and reading can't do for the same file in one time. So one time you have to write data adding one time or more and many other times you can read it. You read from the start unless you use SEEK to change position for reading.\r\nTo change data one way is by duplicating the file with a second name and at the end you can rename it with NAME statement. It is better to use database (see BASE) for altering a lot of records, or for sorting and for computing by using SQL). You can use simple random access files (for getting and putting back records) if no sorting or  havy computing needed.\r\nUsing an open file for APPEND we can move to position of writing with SEEK command anywhere so we can overwrite the file, but it is not recommended\r\n\r\nFrom version 6.7 you can open for WIDE output and for WIDE input, means that you can use WCHAR , 16bit Unicode (as the way vb6 saves strings). So for that file type the WRITE send two bytes per char. \r\nYou can send Multilne Strings as strings variables, for the ANSI and for the UNICODE version. All chr$(34) inside string are changed to double chr$(34), and from the INPUT # we get the right string with one chr$(34).\r\nSo strings must contain text data.  Binary data you can export by using  OPEN... FOR WIDE OUTPUT and PRINT # with ; (but always we have even length of bytes). \r\n\r\n\r\nlook OPEN
GR:ΓΡΗΓΟΡΑ\r\nfast      this is the default handling of refresh rate (one that defined by REFRESH)\r\nfast !    this is the extreme condition. No screen refresh until an input or a return to command line happen\r\nwe can use Refresh command when we want refresh of screen. Using \"set fast !\" we can draw to screen and we can refresh it at the end.\r\n\r\nWe can use REFRESH to do a screen refresh any time\r\nwrite in a module:\r\n\r\nSet Fast !\r\nRefresh 100\r\nProfiler   ' set the special timer\r\nFor i=1 To 1000 {\r\n      Print i     ' the new line from print cause a refresh request. But extreme condition drop this.\r\n      If i Mod 333=0  Then Refresh\r\n}\r\nPrint Timecount\r\n\r\n\r\n' set slow to do automatic refresh more often
GR:ΔΑΠΕΔ(\r\nIt is the same as Int()\r\nPrint Floor(-3.4)=-4, Ceil(-3.4)=-3\r\n\r\nSee Round(), Bank()
GR:ΔΕΙΚΤΗ.ΜΟΡΦΗ\r\n\r\nMOUSE.ICON 2\r\n\r\nMOUSE.ICON DIR$+\"THAT.ICO\"\r\n\r\nMOUSE.ICON SHOW\r\nMOUSE.ICON HIDE\r\nChange the mouse icon. You can hide mouse if you give a total transparent icon\r\n
GR:ΔΕΙΚΤΗΣ\r\nPrint mouse, mouse.X, mouse.Y\r\n1 or 2 for the two buttons or 3 for both.\r\nUse keypress(1) or Keypress(2) to read mouse buttons (return true if now are pressed)\r\n
GR:ΔΕΙΚΤΗΣ(\r\nPointers for groups.\r\nk=Pointer(object)   \\\\ same as k->object   ' point to object (named)\r\nk=Pointer((object))  \\\\ same as k->(object)   ' point to a copy of object (a float object)\r\nk=Pointer(object_array(1,2))   \\\\ same as k->object_array(1,2)   ' point to object in array (must be group, and is a float group)\r\n\r\n\\\\ float or unnamed groups hold by pointers, or in containers like stack, inventories and arrays.\r\n\r\n\\\\Example\r\nclass alfa {\r\n      x=10\r\n}\r\n\\\\ p is a pointer to group\r\n\\\\ now point to a unnamed group. The unnamed group lives untii no pointers point to it.\r\np=pointer(alfa()) \r\n\\\\ this is the same as p->alfa()\r\nPrint p=>x\r\n\r\nz=alfa()\r\n\\\\ now point to a named group (we can't use the pointer if z erased, because has a reference only)\r\np=pointer(z)\r\n\\\\ this is the same as p->z\r\nPrint p=>x\r\np=>x+=10\r\nPrint z.x=p=>x   ' because z.x is the same as p=>x\r\np=pointer((z))   ' look the ( ), we get a copy of z as unnamed group.\r\n\\\\ this is the same as  p->(z)\r\nPrint p=>x\r\np=>x+=10\r\nPrint z.x<>p=>x   ' because z.x is not the same as p=>x\r\nlist  ' show all variables\r\n
GR:ΔΕΙΚΤΗΣ.ΚΟΜ\r\n\r\nMouse.key return the mouse key which pressed when pressed but not the next time if we keep hold the same mouse key pressed\r\nevery 150 {\r\n      print mouse.key, mouse,  keypress(1)\r\n}\r\n\r\nLook  Mouse, Keypress()
GR:ΔΕΙΚΤΗΣ.Υ\r\nPRINT MOUSE.Y\r\nReturn the relative position, on Y coordinate of mouse pointer, on current layer (background, foreground or one of 32 layers)\r\n
GR:ΔΕΙΚΤΗΣ.Χ\r\nPRINT MOUSE.X\r\nReturn the relative position, on X coordinate of mouse pointer, on current layer (background, foreground or one of 32 layers)
GR:ΔΕΙΚΤΗΣΑ.Υ\r\nPRINT MOUSE.Y\r\nReturn the absolute position, on Y coordinate of mouse pointer, from background top left corner
GR:ΔΕΙΚΤΗΣΑ.Χ\r\nPRINT MOUSE.X\r\nReturn the absolute position, on X coordinate of mouse pointer, from background top left corner
GR:ΔΕΙΞΕ\r\n\r\nVIEW \"basename\", \"basetable\", OffsetFrom, OffsetTo\r\nVIEW \"basename\", \"select distinct thisfield from tableone\", OffsetFrom, OffsetTo\r\n\r\n\r\nLook MENU command\r\nView insert items to the MENU listbox\r\nUSE % INSTEAD *  FOR LIKE OPERATOR (M2000 USE ADO NOT DAO ANYMORE)\r\nMenu ' clear the listbox  \r\nMenu + \"<New>\"  '   Add something to extend functionality eg. to make a new record here\r\nView \"HELP2000\", \"SELECT [ENGLISH] FROM COMMANDS WHERE GROUPNUM =\"+Str$(No(selection))+\" ORDER BY [ENGLISH]\", 1, many\r\n\r\n'variable  many is filed before...\r\nThis is from DB_ENG.GSB the helper program to make this help.\r\n\r\n\r\n
GR:ΔΕΚ(\r\nPrint Frac(1.234)\r\n      .234\r\nreturn fractional part of number\r\nalways positive number or zero
GR:ΔΕΚΑΕΞ\r\n\r\nHEX 10, 0X10+0XAF00\r\n\r\nprint hex values (unsigned), 0 or positive. If number is out of range return -??? or +???.\r\n
GR:ΔΕΚΑΕΞ$(\r\nPrint hex$(BINARY.NEG(a))\r\nPrint hex$(BINARY.OR(a,0xaa0000))\r\nPrint hex$(BINARY.AND(a, 0xFFFF))\r\nb=HILOWWORD(0xFFAA, 0x1122)\r\nPrint hex$(HIWORD(b)),hex$(LOWORD(b)\r\nPrint hex$(BINARY.SHIFT(b,3))\r\nPrint hex$(BINARY.ROTATE(b,-6))\r\nPrint SINT(0xFFFFFFFF)  ' an usign integer to sign integer\r\nPrint hex$(UINT(-1)) ' a sign integer converted to unsigned with same bits\r\n\r\nunsigned 32 bit (M2000 use real numbers as unsigned integers, so in a variable we can store more bits)\r\n\r\n0x1234ABCE   ' unsigned hex numbers\r\n\r\nHEX$(unsigned)\r\nHEX$(unsigned, bytes) \r\n\r\nBINARY.NEG(unsigned , unsigned )\r\nBINARY.OR(unsigned   ,unsigned  )\r\nBINARY.AND(unsigned  ,unsigned )\r\nBINARY.XOR(unsigned, unsigned)\r\nUSNG(real or integer) convert to unsigned 32bit , so <0 give 0 and  >0xffffffff  give 0xffffffff\r\nUINT(real as integer or integer) bits are in exact position after conversion. UINT(-1) is 0xffffffff\r\nSINT(unsigned) so SINT(0xffffffff)=-1 \r\n\r\nHIWORD(unsigned)  --> 16 bit\r\nLOWORD(unsigned)\r\nHILOWWORD(unsigned , unsigned)\r\n\r\nBINARY.SHIFT(  ,  -31 TO 31)\r\nBINARY.ROTATE( , -31 TO 31)\r\n\r\nUsing Hex$ to get Binary form\r\nAlso One's Complement, Two's Complement\r\n\r\nread b\r\nfunction bin$ {\r\n      read a\r\n      b$=hex$(a,4)\r\n      dim a$(16)\r\n      a$(0)=\"0000\",\"0001\",\"0010\",\"0011\",\"0100\",\"0101\",\"0110\",\"0111\",\"1000\",\"1001\",\"1010\",\"1011\",\"1100\",\"1101\",\"1110\",\"1111\"\r\n      document aa$\r\n      for i=1 to len(b$) {\r\n            aa$=a$(eval(\"0x\"+mid$(b$,i,1)))\r\n      }\r\n      = aa$\r\n}\r\n\r\nprint \"Binary form for \";b; \" in 32bits\"\r\nprint  bin$(b)\r\nprint  bin$(binary.neg(b)) ,  \" One's Complement -\";b\r\nprint  bin$(binary.neg(b)+1) ,  \" Two's Complement -\";b\r\n\r\n
GR:ΔΕΝ\r\nSee NOT\r\nPrint Not True   ' 0  means false\r\nPrint Not False ' -1 means true
GR:ΔΕΞΙ$(\r\n\r\nPrint Right$(\"alfa\",2)\r\nfa\r\n\r\nis the same as BASIC function RIGHT$()\r\n\r\nLocale 1032\r\na$=str$(\"Γιώργος\")  ' to ansi using Locale 1032\r\nPrint chr$(Right$(a$,3 as byte))=\"γος\"  ' Chr$() convert ansi to  UTF-16LE (using Locale 1032)
GR:ΔΕΞΙΜΕΡΟΣ$(\r\nPrint RightPart$(\"123456789\",\"5\")  ' after 5\r\nPrint LeftPart$(\"123456789\",\"5\") ' before 5
GR:ΔΕΣ\r\n\r\nError trapping\r\n1) using Variable\r\nTry Var {\r\n      block of code\r\n}\r\nif var=0 then we have an error Error$ and Error number can be readable\r\n2) non stopped Try\r\nTry Var {\r\n      block of code\r\n}\r\n\r\n\r\nWe can produce a software error.\r\nError \"this is my error\"\r\nor\r\nError 1000\r\n\r\ntry a {\r\n      error 100\r\n}\r\nif not a then print error : flush error  \\\\ because ERROR 100 is on error stack\r\ntry a {\r\n      x=12/0\r\n}\r\nif not a then print error$\r\ntry {\r\n      Print \"A try Var block can't stop Break command\"\r\n      try a {\r\n            break\r\n      }\r\n      print \"can't print here\"\r\n}\r\nPrint \"A try block can stop Break command\"\r\n\r\nWe can check also an expression with Valid()\r\nprint Valid(thisisnotavariable)\r\n                  0\r\na$=\"1\"\r\nPrint valid(a$)\r\n                  -1\r\n                  \r\nAlso you can use TEST to run step by step and read variables to see any faulty condition..\r\n\r\n            \r\n                        \r\n                                    \r\n                                                            
GR:ΔΙΑ\r\n\\\\ integer division\r\nPrint 10 div 2\r\n5
GR:ΔΙΑ#\r\nEuclidean division\r\n\r\na=-20\r\nb=6\r\n\\\\ Euclidean  div as div#, mod as mod#\r\nc=a div# b\r\nd=a mod# b\r\nPrint c, d  ' -4   4\r\nPrint a=b*c+d\r\n\\\\ normal\r\nc=a div b\r\nd=a mod b\r\nPrint c, d ' -3  -2\r\nPrint a=b*c+d
GR:ΔΙΑΒΑΣΕ\r\nREAD A$, B$\r\ndefines variables (not documents), and  pop values from stack\r\ncannot define array items, but can read for arrays items\r\n\r\nREAD A(1),B%(10,2), C$(10)     \r\nB%() is a two dimension integer array (all arithmetic are double, so this integer is a double with no decimals\r\n\r\nREAD  &A(), &B \r\nWe can read references to arrays and variables (and documents, and groups also). References are stored as strings but READ when  see \"&\" before a name, looking for reference and make local variables (or global if we set SET before). \r\n\r\nWe can pass an array and we can redimension it using the reference. The actual variable always live before start and end a module or function thread that get the reference. \r\n\r\nAny change of one of the reference change the actual data.\r\n\r\nFor documents, each read is an append to document.\r\n\r\nA$=STACK$(1,2,3,4)  ' we can create stacks as strings \r\nREAD FROM A$, K , ,M    'we can read  specific part of the A$.\r\n? K, M\r\n      1      3\r\nWe can read from a Goup in the order that variables are written in Group List, we read always using by reference pass\r\nGroup thisgroup {n, m}\r\nREAD FROM thisgroup, A, B\r\nA=2\r\n? thisgroup.n\r\n\r\n\r\n\r\nWe send the reference from a module's parameter list, or a function's or by using PUSH or DATA. In all these situations we write to stack. So only a READ can create a reference. We can create reference for an array item, but from an array to an array. We can't change reference, if b1 reference a1 then that's all. We can't read a reference if variable exist, but no fault return and reference dropped from stack. We can make many reference for one variable,  one by one or one from one...all references are the same. Look the following example.\r\nA=100\r\nPush &A\r\nRead &b   ' b is a reference to A\r\nPush &b   ' b place the A reference  not the b\r\nRead  &C  'c is a reference to A\r\nc++\r\n? a, b, c\r\n101,101,101\r\n\r\n\r\nThis is a way to misuse the reference system\r\nThis cannot happen if we use Functions  and call them as modules by using CALL command\r\n' this is a  module called \"a\"\r\nflush\r\nalfa=100\r\npush &alfa        ' pushing string \"A.alfa\"\r\nmodule k {       ' we can't call a module with same name of the calling module (normally modules have no recursion)\r\n      module a {     ' so we create k to hold a\r\n            print \"this is a\"\r\n            alfa=150     ' now alfa has a full name A.alfa,  so this variable not created here...is actually the first A.alfa\r\n            stack\r\n            module c {\r\n                  print \"this is c\"\r\n                  stack\r\n                  read &b\r\n                  print b    ' now b is reference then one and only one A.alfa\r\n            }\r\n            c  ' now b is erased\r\n      }\r\n      a    '  in a no variable created (Except in module b in module a)\r\n}\r\nk\r\n? alfa     \r\n150\r\n\r\n\r\n\r\n' example\r\n' we put multiline strings to command Push.\r\npush {aaa\r\n}, {bbb\r\n}\r\na$=\"\"\r\ndocument  a$\r\nread a$\r\nread a$\r\nreport a$\r\nwe see a two line text:\r\naaaa\r\nbbbb
GR:ΔΙΑΓΡΑΦΗ\r\nREMOVE\r\n\r\nWe remove the last created module in memory\r\nwe can see the modules names only in memory with ? switch\r\nMODULES ?\r\nFree library (see Declare)\r\nRemove \"user32\"
GR:ΔΙΑΔΙΚΤΥΟ\r\nPrint Internet\r\nprint True if  pc has connection with Internet
GR:ΔΙΑΔΙΚΤΥΟ$\r\nPrint Internet$\r\n127.0.0.1\r\nor the public ip\r\n
GR:ΔΙΑΚΟΠΗ\r\nUse stop to temporary pause the program flow (threads can be run in the background). The program open a prompt with user name at console and we can use the same in Test form, when we change the prompt of bottom textbox to >  we have to use Delete\r\n\r\nSTOP\r\nWe see that in console\r\nuser_name>_\r\nWe can give Exit to return to execution\r\nuser_name>Exit\r\nWe can use any statement, including loops, alter variables, make new variables, all of them at the point of stop.\r\nThere is another command, HALT similar to STOP.  Halt always return to Console input, and direct commands to command line interpreter, at global name space.
GR:ΔΙΑΚΟΠΤΕΣ\r\nat M2000 console\r\n\\\\ changes stored to windows registry, and by using break, or start command, or when we start a new m2000 environment, switches are loaded with these new values.\r\nswitches \"+DEC -DIV -PRI\"\r\nat a module or function\r\n\\\\by using break, or start command, or when we start a new m2000 environment, switches are loaded with OLD values.\r\nset  switches \"+DEC -DIV -PRI\"\r\n\\\\ we can apply the switches in the command line when we start a gsb file or m2000 editor\r\nThese switches used temporary for current run of interpreter\r\n\r\n\r\nTXT \r\n      -TXT  compare strings  as binary  (> < >= >= <> =)    **by default**\r\n      +TXT compare strings as text  (> < >= >= <> =)\r\nDEC\r\n      -DEC use decimal point as dot\r\n      +DEC use decimal point as local (for code is always dot)   ***by default*** if locale char is dot then a bypass change to -DEC (internal)\r\n      If we use Locale command (Locale 1032) we change decimal point to that locale until  next Switch Command, ot Locale, or a Break by key, or by command using Start at console (or Set Start from code)\r\nDIV\r\n      -DIV like VB6 with integers. Not the same for Double (mod return fractions too)   ***by default***\r\n            Print 10 mod 2.3*2  is Print 10 mod (2.3*2)\r\n      +DIV like Python\r\n            Print 10 mod 2.3*2  is Print (10 mod 2.3)*2\r\nPRI\r\n      -PRI                ***by default***\r\n            Print  True Or False And False\r\n            Print  (True Or False) And False\r\n      +PRI\r\n            And has priority over Or\r\n            Print  True Or False And False\r\n            Print  True Or (False And False)\r\nREC\r\n      -REC\r\n            300 limit for recursion for functions    (if we strart m2000.exe from any other but the m2000.exe, we have to use Set Switches \"-REC\", because execution stack maybe has small size)\r\n      +REC\r\n            3260 limit for recursion for functions  ***by default** (if we start m2000.dll from m2000.exe)\r\n           Change placed after break (using Start as software break or using button break), and for all next loadings of M2000.dll\r\nFOR\r\n      \\\\ only for current running interpreter\r\n      -FOR\r\n            using For loop as normal in M2000, always execution of block, using from step the absolute value, if starting and ending number are different, or using normal value if starting and ending number are equal (to compute the final value for control variable)\r\n      +FOR\r\n            using normal sign step, and if sign of (ending point- starting point) isn't equal to step sign then we get no execution of for loop.\r\n\r\nDIM\r\n      \\\\ only for current running interpreter\r\n      -DIM\r\n            normal  a Dim A(4) has 4 items (0 to 3 or 1 to 4 depends of Base, by default is 0 to 3)\r\n      +DIM\r\n            if base 0 then we get for dimension items>0 one more, so a Dim A(4) has items from 0 to 4, so Len(A())=5\r\n            also these arrays expands from last dimension (right one, but normal is from left one, or using Dim Ole make it from right one)\r\n            \r\nSEC \r\n            \\\\ for all interpreters \r\n            - SEC\r\n                  Old Version 8. This make unsecure conditions like in the example below. If b.alfa exist then b.alfa get a new value, but we want a new local variable.  We can use Local alfa=100. We get more speed for small names.\r\n            +SEC     \r\n                  By default this is the best mode for SECure intrepreting.\r\n            set switches \"-SEC\"\r\n            Module b {\r\n                  alfa=50 : Module c { Module b {alfa=100} : b } : c : Print alfa\r\n            }\r\n            b   \\\\ print 100\r\n            set switches \"+SEC\"\r\n            Module b {\r\n                  alfa=50 : Module c { Module b {alfa=100} : b } : c : Print alfa\r\n            }\r\n            b   \\\\ print 50\r\n\r\nTAB\r\n        +T wAB by default, using tab as character 9.\r\n        -TAB using TAB as spaces.\r\n        when we use character 9 after letters we get various spaces depending the column width (as the tab width)\r\n        when we use -TAB we can't insert character 9. If we change the switch when we have lines with character 9, the characters preserved, but they don't preserved when we copy to clipboard.\r\n        We can set the width of tab using Edit ! number\r\n\r\nSBL\r\n        +SBL show boolean type True/False (depend for the choosen language Greek or Latin)\r\n        -SBL show boolean type as -1/0\r\n        Type of literals True and False is double with values -1 and 0, but a comparison return always a boolean\r\n        we can produce the boolean using a comparison:\r\n                A=True: Print A=True\r\n       we get True if we use +SBL or -1 if we use -SBL\r\n       \r\nINP\r\n        +INP  in FIELD variable which return the cause of exit in FIELD when Enter pressed return 13\r\n        -INP in FIELD variable which return the cause of exit in FIELD when Enter pressed return 1 (default)\r\n\r\nMDB\r\n        +MDB help from Help2000.mdb\r\n        -MDB help from help2000utf8.dat  (default)\r\n        \r\nSpecial switches (for command line)\r\nTest\r\n        +TEST  και -TEST\r\n        start an auto run program in test mode (debug mode)\r\nNorun\r\n        -NORUN  load program without execution of any command except those which create modules and functions.\r\n\r\nSwitches which set the registry values, and used when we run a new interpreter or we press Break or execute the Start command.\r\nLinespace\r\n        +LINESPACE 150 set linespace to 10 pixels when we use 96 dpi screen (1440/96=15 twips per pixel). Values from 0 to 600\r\n         -LINESPACE set to 0\r\nSize\r\n        +SIZE 12  set fontsize to 12pt. Values from 8 to 48 integer only\r\n        -SIZE  set fontsize to 15pt\r\nFont\r\n        -FONT choose Monospac821Greek BT font if exist\r\nBold\r\n        +BOLD  set BOLD for font\r\n        -BOLD  set no BOLD for font\r\nPen \r\n        +PEN 5 set pen (text color) 5 from basic colors 0 to 15. If paper is 5 then set 15-5 as pen\r\n        -PEN  set pen to 0 and paper to 7\r\nPaper\r\n        +PAPER 0 set 0 for screen color. If pen is 0 then set 15-0 for pen\r\n        -PAPER  set pen to 0 and paper to 7\r\nDark\r\n       +DARK choose color set for dark background when we copy or cut code, on the html part of export (editor export text and html to clipboard)\r\n       +DARK choose color set for bright background\r\nCasesensitive\r\n       +CASESENSITIVE for filenames on search/open procedure (always preserve case at save procedure)\r\n       -CASESENSITIVE for filenames, case is not sensitive\r\n       Ths switch make the change immediate.\r\nGreek\r\n       +Greek set dialog messages to Greek language\r\n       -Greek set dialog messages to English language\r\n       we can use Greek or Latin to change this local. We have Latin for second language, because maybe we can change in future the english language with another language, so the Latin is for letters only.\r\n\r\nA second example of faulty old 8.0 interpreter\r\nIf we use a Module Z {}  and we Call k, then we get only 10, and Call Z inside Z not work.\r\nIf we use +SEC then this example run ok.\r\n                  set switches \"-SEC\"\r\n                  Module Z {Print \"Error\" }\r\n                  Module k {\r\n                        global b =10\r\n                        Module Z {\r\n                              Print b\r\n                              b--\r\n                              if b>0 then call Z\r\n                        }\r\n                        call Z\r\n                  }\r\n                  Z\r\n                  call k\r\n                  set switches \"+SEC\"\r\n                                                \r\nUse command Monitor to check switches\r\nWhen we use M2000 interpreter as an object, in another application, then maybe we get a lower stack, so we can use Set Switches \"-REC\" to set limit to 300\r\nSetting of stack can be done to M2000.exe, not to M2000.dll\r\n\r\n\r\n\r\n\\\\example\r\nForm 80, 50\r\nDim Base 0, b$(2)\r\nb$(0)=\"-DEC\",\"+DEC\"\r\n' need global because Set run at global space\r\nglobal aa=each(b$())\r\nwhile aa {\r\n      for skip=false to true {\r\n            Print \"Switches \"+quote$(array$(aa))\r\n            set switches array$(aa)\r\n            def fom1$()=\"{0:1:\"+str$(-tab)+\"}{1:2:\"+str$(-tab)+\"}\"\r\n            if skip else locale 1032 : Print \"locale \";locale\r\n            print format$(fom1$(), -1.66, 2.45)\r\n            print -1.66, 2.45\r\n            if skip else locale 1033 : Print \"locale \";locale\r\n            print format$(fom1$(), -1.66, 2.45)\r\n            print -1.66, 2.45\r\n            print $(3), str$(.66), str$(-.45), $(0),\" never changed\"  ' no 0 and always . for decimal point, space infront for positive number\r\n            print $(3), str$(.66,0), str$(-.45, 0), $(0),\" never changed\"   ' $(3) means right justification on this column and after\r\n            print $(3), str$(.66,1033), str$(-.45, 1033), $(0),\" never changed\"   ' using locale direct\r\n            print $(3), str$( .66,\"\") , str$(-.45,\"\")\r\n            ' $(0) is the default justification, strings may use other columns and have left justification\r\n            ' numbers have right justification\r\n            print $(0),.66, -.45\r\n      }\r\n}
GR:ΔΙΑΜΕΣΟΥ\r\n1) Gosub label or number\r\nSimple call of routines\r\nWe run a batch of commands until a Return founded, and we continue to next line or command\r\n2) Gosub SubRoutine1()     \\\\just call subroutine\r\n2.1) SubRoutine1()  \\\\ without Gosub if no array with same name exist\r\nA subroutine is more advanced from  simple routine for two reasons: Subroutine at the end of execution destroy any new variable, array, module or function that defined when run, and all variables, arrays, modules and functions from calling module or function can  be used as static (exist in any call, subroutines also can be call itself - recursion)\r\n3) Gosub SubRoutine1(X,Y,&A(),B)   \\\\passing parameters byvalue and by reference\r\n3.1) SubRoutine1(X,Y,&A(),B)  \\\\ without Gosub if no array with same name exist\r\nWe can use Local to make variables local to subroutine, but not static (local variables also destroyed on return - exit sub)\r\n\r\n\\\\\\ Indirect call\r\nGosub alpha(100,200)  ' this is the nornal call\r\nb$=\"(100, 200)\"\r\nGosub \"alpha\"+b$\r\nb$=\"alpha(100,200)\"\r\nGosub b$\r\nDim b$(10)\r\nb$(3)=\"alpha(100,200)\"\r\nGosub b$(3)\r\n\r\nSub alpha(x, y)\r\n\tPrint x, y\r\nEnd Sub\r\n\r\n\\\\ Simple Gosub\r\nX=10.5333\r\nGosub alfa : Gosub alfa \r\nGosub alfa\r\nExit\r\n\r\nalfa:\r\n      Print Format$(\"{0}={1:2}    Int({0})={1:0}\",\"Alfa\", X)\r\n      X++\r\n      Return\r\n\r\n\\\\ Write this in another module\r\nLet A$=\"000\"\r\nDef TrimNum$(A)=Trim$(Str$(A)) \r\nDef TrimNum2$(A)=format$(\"{0}\",A)\r\nGosub A_name1(10.05, A$)\r\nPrint A$, Len(A$)\r\nGosub A_name2(10.05, &A$)\r\nPrint A$\r\nSub A_name1(X, B$)\r\n      Print TrimNum2$(X)+B$\r\nExit Sub\r\nSub A_name2(X, &B$)\r\n      B$=TrimNum2$(X)+B$\r\n      Print B$\r\nExit Sub\r\n\r\n\\\\ Example using Local and Exit Sub\r\nk=100\r\nm=50\r\nAlfa(30) \\\\  capital or not is the same for M2000.\r\nalfa(60) \\\\ nothing x>50\r\nalfa(10)\r\nPrint m, k\r\nEnd\r\nSub Alfa(x)\r\n      Local k=Random(1,10)\r\n      If x>50 Then Exit Sub\r\n      Print x*k\r\n      m++\r\nEnd Sub\r\n\r\n
GR:ΔΙΑΡΘΡΩΣΗ\r\nBuffer clear alfa as integer * 100\r\na$=Field$(\"Panther\", 100)\r\nPrint Len(a$), alfa(0)   \\\\ 200 byte, real address at offset 0 \r\n\\\\ We use always Return to place data to buffer (can take list of offsets/values)\r\nReturn alfa, 0:=a$\r\n\\\\ read each character as 2 bytes, and is equal as we read with Mid$()\r\nFor i=0 to 6\r\n      Print Eval(alfa, i), Chrcode(Mid$(a$, i+1,1))\r\nNext i\r\nPrint Len(alfa)  \\\\ 200 (2*100)\r\nm$=Eval$(alfa,0,7*2)\r\nPrint Len(m$), m$\r\nReturn alfa, 30:=65000  \\\\ 0 .. 65535\r\nReturn alfa, 1!:=255 \\\\ at offset +1 byte\r\n\\\\ read from position 30 (x2bytes)\r\n\\\\ we can read per byte\r\n\\\\ 253*256+232=65000\r\n\\\\ position 60 value 232 (Low Byte) and position 61 value 253 (High Byte)\r\n\\\\ in Eval() if we use as byte or abything as ... then first number is an offset in bytes\r\n\\\\ without \"as ...\" is an offset of spaces, here integers (2 bytes)\r\n\\\\ so 30 is +60 offset, but 60 and 61 are equal +60 and +61 offsets\r\nPrint Eval(alfa,30), Eval(alfa, 60 as byte), Eval(alfa, 61 as byte) \r\n\r\n2) use of a structure\r\nStructure MyStruct {\r\n      a as byte*8\r\n      b as integer*20 ' for string is ok\r\n      c as long*4\r\n}\r\n\r\nPrint MyStruct(\"a\") \\\\ offset 0\r\nPrint MyStruct(\"b\") \\\\ offset 8\r\nPrint MyStruct(\"c\") \\\\ offset 48 \r\nPrint Len(MyStruct) \\\\ 64 bytes\r\nBuffer MyBuffer as MyStruct*20\r\nPrint Len(MyBuffer) \\\\1280 ή 64*20 bytes\r\n\\\\ 6th MyStruct (5*length of MyStruct), at b offset (+8)\r\nReturn MyBuffer, 5 ! b :=\"George\"\r\nPrint Eval$(MyBuffer, 5 ! b, 6*2) \\\\ 2 byte each letter\r\nReturn MyBuffer, 3 ! b :=str$(\"George\"+chr$(0)) \\\\ 7 bytes\r\nPrint chr$(Eval$(MyBuffer, 3 ! b, 7)) \\\\ 1 byte per letter\r\n\r\n3)Example with nested structures\r\n\\\\ structures inside are inventrories (objects) \r\n\\\\ values are offsets. Print beta(\"kappa\") return offset\r\n\r\nstructure stringA {\r\n      str as integer*20\r\n}\r\nstructure beta {\r\n      Alfa as byte\r\n      align1 as byte*3\r\n      Kappa as long*20\r\n      name as stringA*10\r\n      kappa2 as double\r\n}\r\nBuffer clear alfa as beta*100\r\nPrint Len(alfa), len.disp(alfa)\r\nPrint 5*len(beta)+ beta(\"kappa\"), beta(\"kappa\")\r\nReturn alfa, 50!kappa!10:=50\r\nsLong=4\r\n\\Return alfa, 5*len(beta)+ beta(\"kappa\")+10*sLong! :=50 as long\r\n\\Print eval(alfa, 5*len(beta)+ beta(\"kappa\")+40  as long)\r\nPrint eval(alfa, 50!kappa!10)\r\nReturn alfa, 50!name!5:=\"George\", 50!name!6:=\"Hello\"\r\nPrint eval$(alfa, 50!name!5, 20)\r\nPrint eval$(alfa, 50!name!6, 20)\r\nPrint Len(alfa), type$(beta)\r\n\r\n\r\n4) Sign/Unsign values\r\nbuffer alfa as long * 50\r\nreturn alfa, 5:=240,6:=uint(-5),30:=3405435354\r\nPrint eval(alfa,5), sint(alfa,6), sint(alfa,30)\r\n\r\n\\\\ a sign long to unsign\r\nA=uint(-500)\r\n\\\\ reverse, an usign to sign long\r\nPrint sint(A)\r\n\\\\ we can use Long B to keep an unsign \r\nLong B=sint(3405435354)\r\nPrint uint(B)\r\n\\\\ we can use normal variables to keep an unsign\r\n\\\\ but these are 8 byte double\r\nAA=3405435354   \\\\\r\nA%=3405435354  \\\\ internal is a double\r\nPrint AA, A%\r\nReturn alfa, 10 :=AA+1 as double  \\\\ 8 bytes - offset 10*4=+40\r\nPrint eval(alfa, 40 as double)  \\\\ offset  40 byte \r\nbuffer alfa1 as integer * 100\r\nReturn alfa1, 10 :=AA as double  \\\\ 8 bytes - offset 10*2=+20\r\nPrint eval(alfa1, 20 as double)  \\\\ offset  20 byte \r\n\r\n5) Execute machine code\r\nLook Execute for example of Buffer Code\r\n\r\n6) Use of Math library\r\n\r\nStructure VecType {\r\n          x As Double\r\n          y As Double\r\n          z As Double\r\n}\r\nStructure Vectors {\r\n      Vec1 as VecType\r\n      Vec2 as VecType\r\n}\r\nPrint Len(VecType), Len(Vectors)\r\nK=Each(VecType)\r\nWhile K {\r\n      Print Eval$(K, K^)+\" offset at \"+Eval$(K)\r\n}\r\nBuffer Clear Alfa as Vectors*10\r\nPrint Alfa(0), Alfa(0,\"Vec1\"), Alfa(0,\"Vec2\")\r\n\r\nPrint Alfa(0, \"Vec1\", VecType(\"X\")) , Alfa(0,\"Vec1\", VecType(\"Y\")), Alfa(0,\"Vec1\", VecType(\"Z\"))\r\nPrint Alfa(0, \"Vec1\", VecType(\"X\")!) , Alfa(0,\"Vec1\", VecType(\"Y\")!), Alfa(0,\"Vec1\", VecType(\"Z\")!)\r\nPrint Alfa(0, \"Vec1\") \r\nPrint Alfa(0, \"Vec1\"!)  ' REMOVE ALFA(0) OFFSET\r\nPrint Alfa(0!) ' ADD BYTES TO OFFSET ALFA(0)\r\n\r\nVecDbl=Lambda Alfa, VecType (n, a$, b$) -> {\r\n      =Eval(Alfa, Alfa(0, a$, VecType(b$)!) as double)\r\n}\r\nDeclare Math Math\r\nPrint Alfa(1)-Alfa(0)\r\nx_offset=VecType(\"x\")\r\nFor N=0 to 9 {\r\n      Method Math, \"Vector\",Alfa(N,\"Vec1\"), 1200,2500,1500\r\n      Method Math, \"Vector\",Alfa(N,\"Vec2\"), 3000,2000,1000\r\n      Print VecDbl(N,\"Vec1\", \"x\")\r\n      Print VecDbl(N,\"Vec1\", \"y\")\r\n      Print VecDbl(N,\"Vec1\", \"z\")\r\n      Print Eval(Alfa, Alfa(N, \"Vec1\", x_offset!) as double )\r\n      Print VecDbl(N,\"Vec2\", \"y\")\r\n     Print VecDbl(N,\"Vec2\", \"z\")\r\n     Method Math, \"VecString\",  Alfa(N, \"Vec1\") as Result$\r\n     Print Result$\r\n     Method Math, \"VecString\",  Alfa(N, \"Vec2\") as Result$\r\n     Print Result$    \r\n}\r\n\r\nDeclare Math Nothing\r\n\r\n\r\n\r\nAnother example using String (BSTR type)\r\nstructure alfa {\r\n      a as long\r\n      c as String*5  ' pointers to string\r\n      z as integer*20\r\n      zero as long\r\n}\r\n\r\nPrint len(alfa) , Type$(alfa(\"c\"))\r\nBuffer clear Mem as alfa*10\r\nReturn Mem, 2!c!4:=\"hello there\"\r\nHex Eval(Mem, 2!c!4)    ' string address in Hex\r\nReturn Mem, 2!z:=Field$(\"Fix String\",20) ' no zero\r\nPrint Eval$(Mem, 2!z, 10*2)  ' need to pass byte number for fix string
GR:ΔΙΑΡΘΡΩΣΗ(\r\n\r\nBuf1=Buffer(\"file name\")\r\nMake a new buffer with a copy of the file name we pass.\r\n\r\nWe can load Png files and we can use Image and Sprite to draw to screen
GR:ΔΙΑΡΚΕΙΑ\r\nPrint DURATION\r\n\r\nprint duration in seconds (as a float number) on a loaded media.\r\n\r\nlook MUSIC, MOVIE, MEDIA\r\n
GR:ΔΙΑΣΤΑΣΗ(\r\nA function to read number of dimensions and items in each dimension of an array.\r\nDIM A(10,20)\r\nPrint  Dimension(A(), 0) \\\\ base of array 1 or 0 \r\nPrint Dimension(A())\r\n      2\r\nPrint Dimension(A(),1), Dimension(A(),2)\r\n      10      20\r\nPrint Dimension(\"A\",1), Dimension(\"A\",2)\r\n      10      20\r\n      \r\nBase of Array can't change if we redim (using Dim command).\r\nWe can assign another array with any base, and the new one get that base.\r\n\\\\Example\r\nBase 0\r\nDim A()\r\nFor This {\r\n      Base 1\r\n      Dim tmp()\r\n      A()=tmp\r\n}\r\n\\\\ now A() has base 1, and tmp not exist\r\n\r\nAn array can change dimensions without loosing items (Except we make an array with less items)\r\n\\\\ B act as generator from 1\r\nB=Lambda x=1 -> {=x : x++}\r\nBase 1\r\nDim A(10)<<B()\r\nDim A(2,5)\r\nPrint A(1,5), A(2,5)\r\nA=(,)   ' pointer to an empty array\r\n' change pointer to array of 5 items\r\n' these arrays are treated as base 0\r\nA=(1,2,3,4,5)\r\nB=(1,)  ' pointer to array with one item (look \",\" at the end)\r\nB=((1,2),(3,4))\r\nPrint Len(A()), Len(A) , Len(B)  ' return number of items \r\nA pointer can changed to point another item (array, inventory, stack), but never point to Null\r\n\r\nFrom version 9.4 revision 4 we can use different low bound for each dimension\r\nDim a(3 to 10, -4 to 8)\r\nlbound1=dimension(a(),1, 0)\r\nubound1=dimension(a(),1, 1)\r\nlbound2=dimension(a(),2, 0)\r\nunound2=dimension(a(),2, 1)\r\nPrint \"Dimensions:\";Dimension(a())\r\nPrint \"Total items:\";Len(a())\r\nPrint \"Array of \";Dimension(a(), 1);\" rows X \";Dimension(a(),2);\" columns\"\r\nPrint \"First dimension form \";lbound1;\" to \"; ubound1\r\nPrint \"Second dimension from\"; lbound2; \" to \"; unound2\r\n\r\n
GR:ΔΙΑΣΤΙΧΟ\r\nPrint Linespace\r\nLinespace 120  ' twips, alter in 2 pixels so 30 twips for twipsX=15\r\nForm 80\r\n
GR:ΔΙΑΦΑΝΕΙΑ$\r\na$=sprite$\r\n\r\nwe can use this once after we do a SPRITE command. This hold the part of the screen that SPRITE command alter.\r\n\r\nIn M2000 we have software sprites and hardware (means handled by the system).  The software sprites can be unlimited and has opacity control (and pixel with 100 transparency). can be rotated.  If we want  to movwe them we have to redraw the screen, so we can HOLD any static backround and then we place sprites. We have REFRESH counter set to a big number like 5000. Before drawing we set REFRESH to zero, then we draw all sprites and we do a REFRESH to move the buffer to screen. After a delay we set refresh to 0 and we  RELEASE the screen that we hold before, anf then we place sprites in other postitions, and at the end we do a refresh (with no parameters). So we see moving sprites and never see the drawing procedure. So for these situations we don't need to read Sprite$.\r\nUsing Players we don't have to redraw anything, this happen by the system. Sprites can be used as brushes too.\r\n
GR:ΔΙΑΦΑΝΟ\r\n\r\nThere are software sprites (from earlier versions).\r\n1) Put a sprite in graphic position - which is the center of sprite (the hot spot is always in the center of image of sprite)\r\nSprite a$  \r\nA$ is a bitmap DIB in a string see Copy and Image\r\n2) \r\nsprite a$, colormask\r\n3)\r\nsprite a$, colormask, angleindegree\r\n4)\r\nsprite a$, colormask, angleindegree, percentSize ' 100 for 100%\r\n5)\r\nsprite a$, colormask, angleindegree, percentSize, transparency [, 1]' 100 for no transparency\r\n6)\r\nsprite a$, colormask, angleindegree, percentSize, transparency_mask$ [, 1] ' 1 or non zero for no copy screen part to feed back area from sprite.\r\n\r\nsprite$ is a read only variable that hold the surface which a sprite command replace. So sprite sprite$ on the same coordinates restore this part of screen.\r\n\r\nrefresh 100\r\nclear a$\r\nmove 0,0\r\ncopy 8000,1000 to a$\r\nmove 1000,1000\r\nsprite a$,,0\r\nevery 50 {\r\n      refresh 0\r\n      sprite sprite$\r\n      move mouse.x, mouse.y\r\n      sprite a$,,random(-30,30), random(30, 90), 50\r\n      refresh\r\n      if mouse>0 then exit\r\n}\r\n\r\nUsing Hold (to hold screen) and Release (to release screen, before writing)\r\nrefresh 100\r\nclear a$\r\nmove 0,0\r\ncopy 3000,1000 to a$\r\nhold\r\nmove 1000,1000\r\nsprite A$,,0\r\nI=1 \r\nevery 30 {\r\n      refresh 0\r\n      i++\r\n      release\r\n      move mouse.x, mouse.y\r\n      ' sprite A$,,i,I*1.3+10, 50\r\n      sprite A$,,i,I*1.3+10\r\n      refresh\r\n      if i>200 then exit\r\n}\r\n
GR:ΔΙΑΦΥΓΗ\r\nEscape on\r\nEscape off\r\n\r\nEsc key is used to stop execution (perform a clean up also). We have Break key to stop execution and erase anything in environment. Esc key by default in manual mode is on. \r\nUsing FAST ! we gain speed but we loose escape functionality (we can get it by using refresh command, and for that time only)\r\nEXAMPLE\r\nSet fast !\r\nFor i=1 to 1000 {\r\n      print i\r\n      \\\\ remove \\\\ from refresh to stop it\r\n      \\\\ refresh\r\n}\r\n
GR:ΔΙΕΚΟΨΕ\r\n\r\n1) Break for SELECT CASE\r\na=5\r\nb=10\r\nselect case  A\r\ncase 1, 5 to 20\r\n      { print \"ok\"\r\n       if b=10 then  break\r\n      }\r\ncase 2,4\r\n      {print \"and ok\"\r\n            continue\r\n      }\r\ncase 3\r\n      { print \"that\"\r\n            print \"and that\"\r\n      }\r\nelse\r\n      print \"??\"\r\nend select\r\n\r\n2) Break for exit from a module (see 1)\r\n\r\nmodule InsideThis {\r\n      print  $(,8)  ' 8 chars Tab\r\n      for i=1 to 20 {\r\n            for k=1 to 10 {\r\n                  Print \"this\",i,k\r\n                  if i=2 And k=2 Then Break\r\n            }\r\n      }\r\n      Print \"This isn't printed\"\r\n}\r\ncall InsideThis   ' \"call\" is optional here\r\nPrint \" This is printed\"\r\n\r\nIf you want to print \"this isn't printed\" then you can work with error creating and resuming\r\nUsing Try {   break },  but if using variable in Τry then break are not stopped. You can use Error as a break:\r\n\r\nmodule InsideThis {\r\n      print  $(,8)  ' 8 chars Tab\r\n      try er {\r\n              for i=1 to 20 {\r\n                  for k=1 to 10 {\r\n                        Print \"this\",i,k\r\n                        if i=2 And k=2 Then error 10\r\n                  }\r\n            }\r\n      }\r\n      Print \"This isn't printed\"\r\n      a=error    \\\\ error =0 now - normaly we read error after a If not er then { print error}\r\n      flush error  \\\\another way to flush error without reading\r\n      ? error, a   \\\\ now error=0 and a=10\r\n}\r\ncall InsideThis   ' \"call\" is optional here\r\nPrint \" This is printed\"\r\n\r\nSo the Error 10 generate a software error with number 10\r\nVariable Er  created and have 0 if an error occur inside TRY  er   {   }\r\n\r\nIf you place Exit where you have Break then the exit are break only one block.\r\nError X break until a try catch it  or  terminate the program if no try exist.\r\nBreak terminate until module level.\r\n\r\nm=0  \\\\ m never get value 100\r\ntry {\r\nfor i=1 to 100 {\r\n      for j=1 to 10000 {\r\n            if i=1 and j=10 then break\r\n      }\r\n      m=100\r\n}\r\n}\r\n? i , j, m\r\n\r\n\r\n
GR:ΔΙΕΡΜΗΝΕΥΤΗΣ\r\nINTERPRETER\r\nABOUT, AND, CLEAR, CLIPBOARD, DIV, DIV#, DOS, EDIT, END, FAST, FKEY, HELP, IS, KEYBOARD, LIST, LOAD, MOD, MOD#, MONITOR, NEW, OPERATORS, OR, PROTOTYPE, RECURSION.LIMIT, REM, REMOVE, SAVE, SCRIPT, SLOW, SORT, START, SWITCHES, TEST, VERSION, WIN, WRITER\r\n\r\n
GR:ΔΙΚΤΥΟ$\r\n? LAN$\r\nreturn IP from our LAN.\r\n\r\nwe can read computer name too from COMPUTER$
GR:ΔΙΟΡΘΩΣΕ\r\nEdit.doc [code]  a$, [position],[title$],[background_color]\r\nopen text editor in lower part of screen (using the split screen height). A **cls , 0** make split screen equal to screen so we edit in full height. Edit code, with code tag, make available the help for M2000 commands.\r\n\r\na$ must be a Document. We can upgrade any string and any array string item to Document by using Document command\r\nusing transparent background over background\r\nhide\r\nback 16 {\r\n      cls\r\n      pen #77eeff\r\n      gradient 1,5\r\n      document a$\r\n      edit.doc a$,,,pen\r\n}\r\nshow
GR:ΔΙΠΛΑ\r\nWe can use DOUBLE for output to Screen / Layers, Background and Printer\r\nWe change text height to DOUBLE so we can print for some lines in double height and then with NORMAL we change to normal height\r\nWe can use switches in PRINT command or we can use REPORT command (multiline text formatting)\r\n\r\ndouble\r\nreport 2, \"center, double and proportional\"\r\nnormal\r\nprint
GR:ΔΙΠΛΟΣ\r\nused as constant in TABLE definitions
GR:ΔΟΚΙΜΗ\r\n1) Test\r\n        Enter test mode (opens the Control Form)\r\n2) Test ModuleName\r\n        Call module in test mode (opens the Control Form\r\n3) Test !\r\n        Close control form by code\r\n4) Test \"name of breakpoint\"\r\n5)  As in 4 but with an added list of expressions for printing in form for each step of execution\r\n\r\n\\\\ A new style for breakpoints\r\n\\\\ just press enter to stop to next breakpoint\r\nTest \"start\", test(\"ok\"), A\r\nFor A=1 to 100 {\r\n      Wait 1\r\n      Print A\r\n      if A=41 then test \"ok\" : test test(\"ok2\")\r\n      if A=81 then test \"ok2\": test\r\n}\r\nTest !\r\n
GR:ΔΟΚΙΜΗ(\r\nWe can use Test \"Breakpoint Name\"  somewhere in our code to change caption to form Control.  Test() can be used to stop at specific Caption, or at specific condition. We have to feed Control Form field named Print with this function, or by code as the example bellow\r\n\r\nFor i=1 to 100 {\r\n      if i=5 then Test \"Start 1\", Test(\"Point 1\"), i\r\n      if i=55 then Test \"Point 1\"\r\n      Print i\r\n}\r\n\r\n
GR:ΔΟΜΗ\r\n\r\nThis is the command to get the structure of database\r\n\r\n1) STRUCTURE \"basename\"\r\n2) STRUCTURE \"basename\", \"tablename\"\r\n3) Look Buffer  - Structure command make types for data for Buffers in memory.\r\n\r\nThis is an example of how we use it\r\nForm 80,50\r\nDB.Provider \"\"   ' reset provider - maybe M2000 Interpreter change this to open an mdb file\r\na=Tab ' save TAB width\r\nPrint $(0,8) ' new tab  width 8 chars\r\nMenu '  without parameter we clear menu list\r\nFiles+ \"mdb\"  ' With plus symbol we send Files output to Menu List\r\n\r\nIf Menuitems>0 Then {  ' if we have something\r\n      Print \"Choose a database:\";\r\n      Menu !                      ' A listbox open now\r\n      If Menu>0 Then { \r\n            base$=Menu$( Menu )\r\n            Print lcase$(base$)+\".mdb\"\r\n            Print \"Structure\"\r\n            Print \"Tables:\";\r\n             Structure base$   'leave values to stack\r\n            Read TablesNum ' we make a new variable TablesNum\r\n                     ' and we get the value from stack\r\n\r\n                        Print  str$(TablesNum)  ' strings are justify left by default\r\n            If  TablesNum>0 Then {\r\n                  For i=1 to TablesNum {\r\n                        Read Tablename$, TableIndexes\r\n                        Print i,\") \"+Tablename$\r\n                        Structure base$, Tablename$\r\n                        Read FieldsNum, TableIndexes\r\n                                    ' So we see if we have number at top on stack.\r\n                        If  FieldsNum>0 Then {\r\n                              For F=1 To FieldsNum {\r\n                                    Read FieldName$, FieldType$, FieldLength  ' Structure command put that in stack\r\n                                    Print \"\",F,\") \"+Field$(FieldName$,17),\"\",FieldType$, FieldLength\r\n                                    ' Field$() function is a function to place spaces or turncate the excess length\r\n                              }\r\n                        }\r\n                        If  TableIndexes>0 Then {\r\n                              Print \"\",\"Order:\"\r\n                              Read FieldsNum\r\n                              If  FieldsNum>0 Then {\r\n                                    For F=1 To FieldsNum {\r\n                                          Read FieldName$, FieldType$' Structure command put that in stack\r\n                                          Print \"\",F,\") \"+Field$(FieldName$,17),\"\",FieldType$\r\n                                    }                              \r\n                              }\r\n                        }\r\n                  }\r\n            }\r\n      }\r\n}\r\nPrint $(0,a)  ' restore TAB length\r\n\r\n\r\n\\\\ using block {} inside structure we make unions\r\n\\\\ so we have access to memory with one or more types\r\n\\\\ byte, integer (2 bytes), and long (4 bytes) are unsign numbers\r\n\\\\ double (8 bytes)\r\n\\\\ there is no string type. We have to use integer*number\r\nStructure stringA {\r\n      str as integer*20\r\n}\r\nStructure beta {\r\n      Alfa as byte\r\n      align1 as byte*3\r\n      Kappa as long*20\r\n      name as stringA*10\r\n      kappa2 as double\r\n}\r\nBuffer clear alfa as beta*100\r\n
GR:ΔΡΟΜΕΑΣ\r\nCURSOR 0, 0\r\nPRINT \"HELLO\"\r\nwe set cursor to 0,0 (left top corner)\r\nPRINT @(0,0);\r\nPRINT @(0,0), \"HELLO\"                              (1)\r\n\r\nPRINT \"AA\", POS, TAB\r\nHere POS is equal to TAB (each row can have equal space tabs)\r\nEach comma (,) advance to next TAB position. except a coma after a print operator. In (1) the @() operator use for own the comma.\r\nTwo comma without parameter is a line break for Print.\r\nPrint \"aa\",,\"bb\",,\"cc\"\r\naa\r\nbb\r\ncc\r\n\r\n
GR:ΔΥΑΔΙΚΗ.ΠΕΡΙΣΤΡΟΦΗ(\r\n\\ -31 to 31\r\na=0xFAAA00A\r\nHex  Binary.Rotate(a,1)\r\nHex  Binary.Rotate(a,2)\r\nHex  Binary.Rotate(a,-1)\r\nHex  Binary.Rotate(a,-2)\r\n\r\n
GR:ΔΥΑΔΙΚΟ\r\nBINARY {\r\n      kwOVA5kDkQMgAKcDkQOhA5ED\r\n}  AS A$\r\nPRINT A$\r\nIn block there is binary data in BASE64. We get in A$ the data as binary (decoded)\r\nWe can use numeric variable to get a Buffer with data. We can use array items, numeric to get buffer, or string to get data in string.\r\nWe can use menu Insert Resource to insert this structure with data from file
GR:ΔΥΑΔΙΚΟ(\r\na=8000000000\r\nPrint usgn(a)=0xFFFFFFFF   ' cut a to maximum\r\na=-34324\r\nPrint usgn(a)=0  ' cut a to minimum\r\na=34324\r\nPrint usgn(a)=34324\r\na=8534324\r\n
GR:ΔΥΑΔΙΚΟ.ΑΚΕΡΑΙΟ(\r\n' Return a unsigned integer with same bits\r\na=-345\r\nPrint Hex$(Uint(a))\r\nHex Uint(a), a   '' second print ???- no negative fot Hex Print\r\n\r\n
GR:ΔΥΑΔΙΚΟ.ΑΝΤΙ(\r\nan unsigned long can be negate, and Binary.Neg() return the same bits binary long as an unsigned long. So when we add binary.neg(a) to uint(a) we get always 0xFFFFFFFF.  To get the signed integer we use sint(), so sint(0xFFFFFFFF)=0xFFFFFFFF&  (which is -1).\r\n\r\n\\\\ a=uint(0xFFFFABCD&)\r\nb=0xFFFFABCD&\r\nPrint a>=0=False\r\nPrint b=-21555\r\nPrint binary.neg(b)=21554\r\nPrint  hex$(uint(b))=\"FFFFABCD\", uint(b)\r\nPrint hex$(binary.neg(b)+uint(b))=\"FFFFFFFF\"\r\nPrint binary.not(uint(b))=21554\r\nPrint hex$(binary.not(uint(b))+uint(b))=\"FFFFFFFF\"\r\n\r\n\r\n\r\n
GR:ΔΥΑΔΙΚΟ.ΑΠΟ(\r\na=0xFAAA\r\nb=0x5550\r\nHex  Binary.Xor(a,b)\r\n
GR:ΔΥΑΔΙΚΟ.Η(\r\na=0xFAAA\r\nb=0x5550\r\nHex  Binary.Or(a,b)\r\n
GR:ΔΥΑΔΙΚΟ.ΚΑΙ(\r\na=0xFAAA\r\nb=0x5550\r\nHex  Binary.And(a,b)\r\n
GR:ΔΥΑΔΙΚΟ.ΟΛΙΣΘΗΣΗ(\r\n\\ from -31 to 31\r\na=0xFAAA\r\nHex  Binary.Shift(a,1)\r\nHex  Binary.Shift(a,2)\r\nHex  Binary.Shift(a,-1)\r\nHex  Binary.Shift(a,-2)\r\n\r\n
GR:ΔΥΑΔΙΚΟ.ΟΧΙ(\r\nget an unsigned number from 0x0 to 0xFFFFFFFF\r\nPrint Hex$(Binary.Not(0xAAAAAAAA))  ' 55555555\r\n\r\nLook Binary.Neg()
GR:ΔΥΑΔΙΚΟ.ΠΡΟΣΘΕΣΗ(\r\nAdd two unsigned 32 bit numbers and return modulo 2^32 of the result.\r\n\r\nHEX BINARY.ADD(0xF0000000,0xF0000001)\r\n\t\t0xE0000001
GR:ΔΥΑΔΙΚΟ_σταθ\r\nBINARY\r\nconstant used in tables in databases\r\n
GR:ΔΥΟΜΙΣΑ(\r\na=0xFAAA\r\nb=0x5550\r\nHex  HiLowWord(a,b)\r\nPrint LowWord(HiLowWord(a,b))=b\r\nPrint LoWord(HiLowWord(a,b))=b\r\nPrint HiWord(HiLowWord(a,b))=a\r\n\r\n\r\n
GR:ΔΩΣΕ\r\n\r\n\r\nPUT #i, rec$, pos\r\n\r\nrec$ must have length of Record as defined in OPEN  type FOR RANDOM. Pos 2 is in 1*Lenght position in file, so pos is the record number starting from 1. Total records are given with RECORDS(i). You can append to a random file when you write to pos records(i)+1.\r\n\r\nYou may work with Put and instead save strings you can save buffers, but you have to use Append and seek to move the file cursor and the Input and seek to read (you can open two or more time a file, making a new cursor each time). If file not exist just open for output once with no data then close so you have the file to append next.\r\n\r\n\r\n\r\n\r\n
GR:ΕΓΓΡΑΦΑ\r\nDOCUMENTS\r\nAPPEND.DOC, EDIT.DOC, FIND, INSERT, LOAD.DOC, MERGE.DOC, OVERWRITE, SAVE.DOC, SORT(DOCUMENT), WORDS\r\n\r\n
GR:ΕΓΓΡΑΦΕΣ(\r\nPrint Records(F)\r\nF is file handler used with OPEN command.\r\nWe get the number of records in a random type file, or the length in chars in any other.\r\n
GR:ΕΓΓΡΑΦΟ\r\nDOCUMENT list of string vars\r\n\r\nCreate or modify string vars to a list of paragraphs (a document). We can modify array items\r\nFor documents the = used to append text\r\n\r\nCLEAR A$  used to clear paragraphs   ' without variable CLEAR clear all variables\r\nWe can use <= operator (this not create a new variable, as = do), only in strings not in arrays.\r\n\r\na$={HELLO\r\nDUDE\r\n}\r\nDOCUMENT A$, B$\r\na$=\"TEST1\"\r\nb$=\"TEST2\"\r\nREPORT A$\r\nREPORT B$\r\nPRINT DOC.LEN(A$),DOC.LEN(B$)\r\n\r\n' example\r\ndim A$(10)\r\nfor i=0 to 2 {\r\n      document A$(i)\r\n}\r\nfor i=1 to 3 {\r\n      A$(0)={0) 11111111111111111\r\n      22222222222222222222222222222\r\n      }\r\n      A$(1)={1) 11111111111111111\r\n      22222222222222222222222222222\r\n      }\r\n      A$(2)={2) 11111111111111111\r\n      22222222222222222222222222222\r\n      }\r\n}\r\nclear a$(2)   ' fast clear\r\na$(2)=\"ok\"\r\nfor i =0 to 2 {\r\n      report A$(i)\r\n}\r\n\r\nWe can use <= to modify global vars  (instead of =)\r\nFor global array items \r\nwrite in CLI\r\nDIM A$(20)       \r\nnow write in a module \r\n' we can't append comment in a SET line. We use SET to access a Level 0 or global array A$()\r\nSET DOCUMENT A$(10)\r\nA$(10)={1st line\r\nsecond line.}  ' Only item 10 is a document var.\r\nA$(10)={ Hello Again\r\n}\r\nREPORT A$(10)\r\n\r\nwe see now 2 lines (one paragraph) because first insert haven't a new line indicator (a line break).\r\n1st line\r\nsecond line. Hello Again\r\n\r\n\r\nAnother way to access a global array is to use reference\r\nSET PUSH &A$()\r\nREAD &A$()   ' now A$() created as local and as a reference to global A$()\r\n\r\nSee Load.Doc and Edit.Doc\r\n\r\n\r\n\r\nEach paragraph has own number. so when we delete or insert paragraphs, those paragraphs that are in document have same number as before.  Check this program. Paragraph(a$, order_no)=paragraph_number. Paragraph.index(a$, paragraph_number)=order_no.\r\nThere is no paragraph_number 0. This is  a fake paragraph_number one before the start and after the end. So when we use Forward from paragraph number 0, we get the next one, any number non zero (means we have a paragraph) or zero (means end of paragraphs)\r\n\r\nForm 60, 40\r\nDocument a$={aaaaaaa\r\nbbbbbbbbb\r\nccccccc}\r\nInsert to 2 a$={\r\n      \r\n      Hello\r\n      \r\n}\r\nm=Paragraph(a$, 0) \r\nflush\r\nIf Forward(a$,m) then {\r\n      While m {\r\n            data m \r\n                  Print Paragraph$(a$,(m))\r\n      }\r\n}\r\nPrint Part \"done\"\r\nPrint Under\r\nk=1\r\nWhile not empty {\r\n      Read x\r\n      Print x=paragraph(a$, k), x, paragraph.index(a$,x)=k, k\r\n      k++\r\n      Print Paragraph$(a$, x)\r\n}\r\nPrint k=doc.par(a$)+1\r\n\\\\ this is the right order of paragraphs\r\nFor i=1 to doc.par(a$) {\r\n      overwrite  paragraph(a$,i),3 a$=\"    \"\r\n      insert to paragraph(a$,i)  a$=trim$(str$(i))\r\n      Print paragraph$(a$, paragraph(a$,i))\r\n}\r\n
GR:ΕΓΓΡΑΦΟΥ.ΛΕΞΕΙΣ(\r\n\r\nDocument a$=\"Hello there and hello World!\"\r\nN=Doc.Words(a$)\r\nWords a$\r\nFor I=1 To N\r\n      Print Ucase$(Letter$)\r\nNext I\r\n\r\nThis example return all words, in ascending order.\r\nIf we want unique words then we have to use Doc.Unique.Words()\r\n
GR:ΕΓΓΡΑΦΟΥ.ΜΗΚΟΣ(\r\nprint doc.len(a$) ' is a fast way to read length. No copy needed (as with the Len())\r\nWorks for strings as normal strings and for documents (structure with paragraphs)\r\n\r\na$={asasafd\r\n      fsdfdsfsfds\r\n      sfsfsf\r\n      }\r\n      document a$\r\nprint doc.len(a$)\r\nprint len(a$)\r\n\r\nSee command DOCUMENT\r\n\r\n\r\ndim a$(3)\r\ndocument a$(2)={1stline\r\n2ndline\r\n3dline\r\n}\r\nprint doc.len(a$(2))
GR:ΕΓΓΡΑΦΟΥ.ΜΟΝΑΔΙΚΕΣ.ΛΕΞΕΙΣ(\r\nDocument a$=\"Hello there and hello World!\"\r\nN=Doc.Unique.Words(a$)\r\nWords a$\r\nFor I=1 To N\r\n      Print Ucase$(Letter$)\r\nNext I\r\n\r\nExample return a sorted list of all words and a number of occurrence for each\r\nCommand  Words place words in the stack. \r\n
GR:ΕΓΓΡΑΦΟΥ.ΠΑΡ(\r\nDocument A$, B$\r\nA$={aaaaaaa\r\n            bbbbbbbbb\r\n            cccccccccc\r\n            }\r\nB$={\r\n}\r\n\r\nPrint Doc.Par(A$),Doc.Par(B$)\r\nReturn Paragraph number
GR:ΕΓΓΡΑΨΙΜΟ(\r\n\r\nPrint writable(\"c:\")\r\n      -1\r\nIf we pass a letter for a non exist drive then we get an error\r\nuse TRY var { }  to catch the error (in Error$)
GR:ΕΓΚΥΡΟ(\r\n1) Valid(numeric expression)\r\nevalute the expression and if no error produced return true\r\nPrint Valid(10/0)\r\n      0\r\nPrint Valid(AA)   \r\n      0   if AA not exist\r\n      -1 if AA exist \r\nWe can use it with threads to see if a thread has make something.\r\nClear a, b\r\nprint valid(\"a+b\"=12)\r\n            0  '  fault in expression\r\n\r\n2) Valid(@id)\r\nlook if id is a visible constant, variable or an array\r\nX=10\r\nA$=\"Yes\"\r\nDim A(10)\r\nPrint Valid(@X)\r\n\r\n3) Valid(@id1 as id2)\r\ncheck if id1 is like id2\r\nif id1 is an object check if id2 is same type of id1\r\nBut if id1 is a group then check if all members in id2 exist in id1, checking only identifiers and not types.\r\nSuperclass Alfa {\r\n      x=10\r\n}\r\nSuperclass Alfa2 {\r\n      x=10\r\n}\r\nEpsilon=Alfa2\r\nBeta=Alfa\r\nDelta=Beta\r\nPrint valid(@beta as Alfa)\r\nPrint valid(@beta as Alfa2)\r\nPrint valid(@Delta as Alfa)
GR:ΕΙΚ$(\r\n\r\nprint bmp$(\"alfa\")\r\nif exist an alfa.bmp in current folder we get full name (path+name+type)\r\n
GR:ΕΙΚΟΝΑ\r\n1)  Display an image to screen (bmp, wmf, emf, jpg, gif, ico)\r\nImage filename$ [, width [, Height]]\r\nImage BufferWithImage [, width [, Height]]\r\n\r\nwe can make image from file to buffers (holding there as files) to use with GDI+\r\nLook Buffer()\r\nif we give Height then we can stretch the image.\r\n\r\n2) Image from file to variable\r\nImage  image$ to newimage$  [(background color to fill transparent pixels)]  \r\n\r\n3) As 2 but with resize\r\nImage image$ to newimage$ [(background color to fill transparent pixels)]  , percentSize   ' 100 for same size\r\n\r\n4) As 2 but resample Width and Height\r\nImage Image$ to newimage$, percentWidth, percentHeight\r\n\r\n5) Export as Bmp\r\nImage image$ Export filename$\r\n\r\n6) Export as jpg \r\nImage image$ Export filename$, percent_compression_quality\r\n 100 percent_compression_quality give bigger file, more accurate to original image\r\n\r\nimage$ can be a filename and a path or an image in a string\r\n\r\n\r\n\r\n\r\n\r\n
GR:ΕΙΚΟΝΑ(\r\nproduce a buffer object from an image in a string \r\nImg1=Image(a$)
GR:ΕΙΚΟΝΑ.Υ(\r\nIf A$ has a bmp we can get the height in twips\r\nPrint Image.Y(A$)\r\nIf A is a buffer loaded with an image file we can get the Height in twips (for current output)\r\nPrint Image.Y(A)
GR:ΕΙΚΟΝΑ.Υ.ΣΗΜΕΙΑ(\r\nIf A$ has a bmp then we can get the height in pixels\r\nPrint Image.Y.pixels(A$)\r\nIf A has a buffer loaded with image file  then  we can get the Height in pixels\r\nPrint Image.Y.pixels(A)
GR:ΕΙΚΟΝΑ.Χ(\r\nIf A$ has a bmp we can get the width in twips\r\nPrint Image.X(A$)\r\nIf A is a buffer loaded with an image file we can get the width in twips (for current output)\r\nPrint Image.X(A)\r\n
GR:ΕΙΚΟΝΑ.Χ.ΣΗΜΕΙΑ(\r\nIf A$ has a bmp then we can get the width in pixels\r\nPrint Image.X.pixels(A$)\r\nIf A has a buffer loaded with image file  then  we can get the width in pixels\r\nPrint Image.X.pixels(A)
GR:ΕΙΚΟΝΕΣ\r\nDIR \"C:\"\r\nBITMAPS                ' SORTED BY DATE & TIME\r\nBITMAPS !              ' SORTED BY NAME\r\nFILES \"bmp\"          ' AS BITMAP\r\nFILES  ! \"bmp\"       ' AS BITMAPS !  \r\nFILES  + \"bmp\"     ' SORTED BY DATE AND TIME  AND STORED AS MENU ITEMS\r\nFILES  ! +  \"bmp\"  ' SORTED BY NAME AND STORED  AS MENU ITEMS\r\nuse MENU ! to open menu\r\n
GR:ΕΙΚΟΝΙΔΙΟ\r\nWe can change the icon for the title in title bar (see TITLE)\r\nICON \"file.ico\"\r\n\r\n\r\n\r\n
GR:ΕΙΝΑΙ\r\nOperator Is\r\n\\\\ only for objects a and b\r\nPrint a is b
GR:ΕΙΝΑΡ\r\nIf stack top is number then\r\nPrint IsNum\r\n      -1\r\n\r\n
GR:ΕΙΝΓΡ\r\nIf stack top is string (letters) then\r\nPrint IsLet\r\n      -1\r\n\r\n
GR:ΕΙΣΑΓΩΓΗ\r\nInput create variables if not exist.\r\n\r\n1) INPUT a$  [,b,b$,b%...] input list of variables\r\nOne prompt, we can advance with a comma or enter. Numbers can have exponent part\r\nNew line after\r\n2) INPUT  string expression, a$  [,b,b$,b%...] input list of variables\r\nOne prompt, we can advance with a comma or enter.\r\nNew line after\r\n3) INPUT a;  \r\nNo new line\r\n4) INPUT \"x,y=\",X,Y\r\nOne prompt only\r\nx,y=1312,445\r\n' use ; as last char for not using a newline\r\nINPUT \"x,y=(\",X,Y; : print \")\"\r\nx,y=(121,454)\r\nyou can use the try structure \r\nTRY er {\r\n      INPUT \"x,y=(\",X,Y; : print \")\"\r\n}\r\nvariable er has 0 if an error occur, so we can take again the values\r\n(you can use the FIELD command if you want more control.\r\n\r\n\r\n1-2-3-4 We can paste code but not copy. You can't use arrows, only backspace for delete. Automatic scrolling up and down. You can input  values in any layer, and in the background. This command give us an easy way to input values, using a floating style, seting values one by one. Use FIELD to construct forms (field use arrows and we can insert and or overwrite text). Both two commands use the non proportional text system. We can change style before these commands, italic, bold, double, pen color. Back color use the one we define with CLS.\r\n\r\n\r\n5) INPUT #filenumber, A$,B$, A\r\nInput from file that we open with OPEN command. Read numbers and strings, that have stored with WRITE command.\r\nFrom OPEN we can can declare if we take UNICODE (WCHAR) or ANSI, using  ...FOR WIDE INPUT or FOR WIDE OUTPUT \r\nExample for export/import csv (unicode, no BOM). delete wide to perform same program for ANSI file (1 byte per char)\r\nWrite with chr$(9), \",\", true  ' true means that strings replaced as json strings\r\nOpen \"my.dat\" for wide output as #k\r\nWrite  #k, \"Row 1\", -213231313132312.23123@, -52322323.32#, -1.2121e+10\r\nWrite  #k, {Line1\r\n                        Line2\r\n                        Line3\r\n                        }\r\nClose #k\r\n\r\nInput With chr$(9), \",\", true  ' true means that strings readed as json strings\r\nOpen \"my.dat\" for wide input as #k\r\nInput #k, R$, M1=0@, Z1=0#, check\r\nInput #k, Txt$\r\nClose #k\r\nPrint R$, M1, Z1, check\r\nPrint Type$(M1), Type$(Z1)\r\nPrint M1\r\nPrint Z1\r\nReport txt$\r\n\r\n\r\n6) INPUT ! A$, Width in chars  [Len =20] by default Len=50\r\n   INPUT ! A, Width in chars\r\n   INPUT ! A%, Width in chars   (work for array items too)\r\n   Field variable give the reason to exit. 99 Esc, -1 or 1 for arrows Up and Down (and for down also the return key)\r\n   we can use Set Switches \"+INP\" to return Field=13 if we press enter (normaly return 1)\r\n7) INPUT ! A$, Width in chars, Height in chars [, Title$]   \r\n7.1) INPUT ! A$, Width in chars, Height in chars[, Title$, cursor_pos\r\n cursor_pos len(a$)+1 set cursor at rightmost  place.\r\nWe use text editor to input text. We can copy & past unicode text, we can drag and drop (drag is by default not enabled, use right menu to change it). Use Ctrl & Z and Ctrl & Y for undo and redo. Use Ctrl & A for selecting all or Shift Ctrl & A to deselect. Use ctrl  &X to cut, ctrl & C to copy and ctrl & V. Text editor has proportional text, at the size and style of the non proportional text.  Use TAB and shift TAB to place spaces at the left (indentation) , you can mark a lot of lines and you can move left to right or in reverse. Use f2 and f3 to find up or down direction the selected text.\r\n\r\nText editor has own layer so after the closing (we can use ESC or we can descard changes with F12). F1 changes from word wrapping to non word wrapping view. You can use unicode text.\r\n\r\nUse LEGEND to display the top part of the text that can be viewed in the same area, as the input area.\r\nFor one line text you can use the 9th variant in $() in Print, which print all letters without word wrap but with cut in the excess\r\n\r\nAlso you can use REPORT to justify (and use word wrapping), to calculate the max lines, to print specific lines.\r\n\r\nPrinting to the screen happen without clearing the background (only INPUT and FIELD clear under the text. In the command line interpreter we have a special version of INPUT, that remember what we input and with up and down arrows (both act as the same button) we view all the list. We can edit that list with a command EDIT without ID for making modules and functions.\r\nIf we want to clear the screen we use CLS. (cls clear the lower part, the scrolling screen or split screen, but CLS,0 set all screen as scrolling screen and erase it using current background color. We can use @() operator in PRINT or the FRAME command to prepare part of background.\r\n\r\nWe can write text as part of the module\r\na$= {1st line\r\n            2n dline\r\n            2dl ine\r\n            } last bracket position used for intendetion (so this space are not insert to the string
GR:ΕΙΣΑΓΩΓΗ$(\r\na$=INPUT$(#filenum, chars)\r\nRead number of chars from open file. If we use WIDE in OPEN command then we read unicode (so 2 bytes for each char)/\r\nUse SEEK #filenum, position to alter the reading position. Reading position change after a reading, or by moving it.\r\nuse records() to find filelength in bytes (so for WIDE type chars we have Records(#filenum)/2 chars).\r\nSEEK always return byte positions, starting from 1. In an empty file, EOF(#filenum) is true because SEEK(#filenum)>RECORDS(#filenum). Each record for an open file of type INPUT, APPEND, OUTPUT has 1 byte length. Do not using in RECORD type file.\r\n\r\nWith INPUT$() we read line breaks as chars too.\r\nusing LINE INPUT we get string as paragraph without the line breaks in the input string.
GR:ΕΚΔΟΣΗ\r\nVersion\r\nas command print version number  (there is a read only variable to check version in code)\r\n
GR:ΕΚΔΟΣΗ_σταθερά\r\n\r\nPrint Version\r\nprints language version
GR:ΕΚΤΕΛΕΣΗ\r\n1. For DataBases\r\nEXECUTE basename, executestring\r\nEXECUTE basename, executestring, timeout\r\nby default timeout = 30  (minimum 10)\r\n\r\n\\* EXAMPLE\r\nBASE \"ALFA\"  ' ERASED IF FOUND THE NAME\r\nEXECUTE \"ALFA\", { CREATE TABLE Employees(ID autoincrement primary key,  LastName   VARCHAR(40) ,  FirstName  VARCHAR(40)  NOT NULL, MyMemo TEXT )}\r\nAPPEND \"ALFA\",\"Employees\",,\"George\",\"йваоаптаЭЭ\",\"Γεια χαρά από Ελλάδα\"\r\nRETRIEVE \"ALFA\", \"Employees\", 1,\"\",\"\"\r\nREAD MANY, ID, LASTNAME$, FIRSTNAMES$, MEMO$\r\nPRINT $(4, 6),  \"BASE:\",\"ALFA\"\r\nPRINT  \"NAME:\",LASTNAME$ + \" \" + FIRSTNAMES$\r\nPRINT \"MEMO:\"\r\nPRINT \"\",\r\nREPORT  MEMO$\r\nCLOSE BASE \"ALFA\"\r\nPRINT\r\n\\\\ ))))))))))) New Example (((((((((((\r\n\\\\ erase stack items\r\nflush\r\n\\\\ erase gEx.mdb if found, create a new one\r\nbase \"gEx\"\r\n\\\\ we use semi colon to separate statements. Don't use semi colon inside strings in execute,\r\nexecute \"gEx\", {\r\n\tcreate table alfa\r\n\t(\r\n\t\tname varchar(50) not null,\r\n\t\tbirth_date date default null\r\n\t);\r\n\tInsert into alfa values (\"George\",\"27-10-1966\")\t;\r\n\tInsert into alfa values (\"Alex\",NULL)\t\r\n}\r\nprint Stack.size=0\r\ndef CheckNull$(a, a$)=If$(type$(a)=\"Null\"->\"NULL\", a$)\r\nexecute \"gEx\", {select * from `alfa`}\r\n\\\\ now we have a rerurn value in stack of values\r\nprint Stack.Size=1, StackType$(1)=\"Recordset\"\r\n\r\nGetListA()\r\n\r\nprint \"ok\"\r\n\r\n\r\n\r\nsub GetListA(RS)\r\nif type$(RS)=\"Recordset\" then\r\n\twith RS, \"EOF\" as new rs.eof, \"fields\" as new fields(), \"fields\" as new fields$(), \"fields\" as new rs.fields\r\n\twith rs.fields, \"count\" as new rs.fields.count\r\n\tprint  \"Test number of fields:\", rs.fields.count\r\n\twhile not rs.eof\r\n\t\tprint $(6),fields$(0),\r\n\t\tprint $(9),\" \";CheckNull$(fields(1), fields$(1))\r\n\t\tmethod rs, \"movenext\"\r\n\tend while\r\n\tprint $(0),,\r\nend if\r\nend sub\r\n\r\n\r\n\r\n2. For executing machine code\r\n\\\\ we make a buffer to use for DATA\r\nBuffer BinaryData as Long*10\r\nReturn BinaryData, 1:=500\r\nBuffer code alfa as byte*1024\r\n\\\\ use https://defuse.ca/online-x86-assembler.htm\r\n\\\\ to find opcodes\r\nPc=0\r\n\\\\ x86 Machine Code\r\nOpLong(0xb8, 5100)  ' mov eax,0xa     ' 10 to eax\r\nOpByteByte(0x83, 0xC0 ,5)  ' add  eax,0x5   ' add 5 to eax\r\nOpByteLong(0x3,0x5, BinaryData(1)) 'add eax, [BinaryData(1)]  ' add eax 500 from second long on BinaryData\r\nOpLong(0xa3, BinaryData(0))  ' mov [BinaryData(0)], eax\r\nrem : OpByte(0x31, 0xC0)  ' now eax=0  ' without this we get 5605 in M\r\nRet() ' return\r\n\\\\ end of code\r\nTry Ok {\r\n      Execute Code alfa, 0\r\n}\r\nM=Uint(Error)\r\nHex M\r\nPrint M\r\nPrint Error, ok\r\nPrint Eval(BinaryData, 0)  ' 5605\r\n\r\nSub Ret()\r\n      Return alfa, pc:=0xC3  \r\n      pc++\r\nEnd Sub\r\nSub OpByteByte() \r\n      Return alfa, pc:=number, pc+1:=number, pc+2:=number\r\n      pc+=3\r\nEnd Sub\r\nSub OpByte()\r\n      Return alfa, pc:=number, pc+1:=number\r\n      pc+=2\r\nEnd Sub\r\nSub OpLong()\r\n      Return alfa, pc:=number, pc+1:=number as long\r\n      pc+=5\r\nEnd Sub\r\nSub OpByteLong() \r\n      Return alfa, pc:=number, pc+1:=number, pc+2:=number as Long\r\n      pc+=6\r\nEnd Sub\r\n
GR:ΕΚΤΥΠΩΣΕΙΣ\r\nPRINTINGS\r\nPAGE, PRINTER, PRINTING, PROPERTIES\r\n\r\n
GR:ΕΚΤΥΠΩΣΗ\r\n\r\nWe can use switch commands (and not block command) by using\r\nPRINTING ON\r\ncommands here\r\nPRINTING BREAK     \\\\  IS LIKE OFF BUT WITHOUT SENDING LAST PAGE\r\nPRINTING OFF\r\n\r\nthis is an old command style from earlier versions of M2000 interpreter, but can be used in threads so we can make background printing using thread.plan concurrent \r\n\r\nSee PAGE and PRINTER
GR:ΕΚΤΥΠΩΤΗΣ\r\n1. We can change the ouput to the printer (for chars and graphics)\r\nPRINTER {\r\n....\r\nexit printing  \\\\ use this to exit without sending the last page\r\n}\r\n2. Or we can define the size of letters  (like modetype)\r\nPRINTER  12 {\r\n....\r\n}\r\n\r\n3. We can change the properties by using a form (as the os give to us). \r\nPRINTER !\r\nsee Properties  (a way to extract in a string all properties and then reuse it later)\r\n4. We can choose from a menu list a printer\r\nPRINTER ?\r\nUse printername$ to read printer name\r\nwe get Menu=0 if no item selected (using Esc) or Menu$(Menu) for the proper name for option 5\r\n\r\n5.We can give a name and port in a string  using that prototype: printername ( portname )\r\nPRINTER 12, that$\r\n\r\nWe can report the printer in use \r\n6. PRINTER\r\n\r\n\r\nWe can't perform a SCROLL UP or DOWN or CLS\r\nIf you wish to change background color you can use GRADIENT for each page.\r\nGRADIENT 1, 1   make blue the printer page.\r\nWe can use Page command to send Page to printer inside a Print { } or outside before to make paper orientation  landscape or portrait .\r\n\r\nPAGE 1\r\nPrinter {\r\nForm 64,66   \\\\ using 64 chars (for non analog printing) with 66 lines'\r\n\\\\ we can use Report to print text with justification.\r\n}\r\n\r\nName of current printer is in Printername$
GR:ΕΚΤΥΠΩΤΗΣ$\r\n? PRINTERNAME$\r\nprinter name and port\r\n\r\n
GR:ΕΚΦΡ$(\r\n1) Using eval$() for get value (string) from pointer\r\na$=\"ok\"\r\nb$=weak$(a$)\r\nb$.=\"yes\"   \\\\ weak reference point to a$, but at every execution\r\nPrint a$\r\nPrint eval$(b$.)  \\\\ \"yes\"  \\\\ look dot after $\r\nPrint eval$(b$)=b$ \\\\ no what point to, but pointer only\r\n\r\n2) Using for Inventory to get key, or get string value\r\nInventory alfa=1,\"200\",3:=500,4\r\nb=each(alfa)\r\nWhile b {\r\n      Print eval$(b!), eval$(b)  ' key, element as string\r\n}\r\n\r\n3)Using for Buffer to get string from memory\r\nStructure alfa {\r\n     A as Long   \\\\ A is an unsinged 32 bit\r\n     B as Integer*40\r\n}\r\nPrint Len(alfa)   \\\\ 4 byte + 2 byte * 40 = 84\r\nBuffer B1 as alfa*20   \\\\ 84*20=1680 Byres\r\nPrint Len(B1)\r\nReturn B1, 3!B:=Field$(\"Hello\",40)\r\n\\\\ Allways use bytes as third parameter\r\nPrint Eval$(B1, 3!B, 40*2)\r\nReturn B1, 10!B:=Str$(\"Good\")  ' 4 bytes, 1 per char\r\nPrint Chr$(Eval$(B1, 3!B, 2*2)) ' read 4 bytes and expand them to 8.\r\n\r\n
GR:ΕΚΦΡ(\r\nX=10\r\nPrint Eval(\"12*X\")\r\n      120\r\n\r\nUse Valid(Eval(A$)) to see if expression in A$ is valid\r\nor use Try\r\nTry Ok {a=eval(a$) } : if not ok then print \"We have a problem with expression\"\r\n\r\nIn version 8 we can use unamed functions:\r\nPrint function(\"{read X,Y : =X**Y}\", 10,2)\r\n      100
GR:ΕΛ ISWINE\r\nPrint IsWinw\r\n\r\n-1 if interpreter run on a Linux os using Wine\r\n\r\n
GR:ΕΛ OSBIT\r\nPrint OsBit\r\nreturn 32 or 64\r\n\r\nLook IsWine, Os$
GR:ΕΛ$\r\nYou can use ? for PRINT\r\n? \"Hello\"\r\nPRINT \"HELLO\"\r\n\r\n$(ColumnSJustifyID) \r\n$(ColumnSJustifyID, ColumnSWidth)\r\n$(StringWay2format$)\r\n$(StringWay2format$ , ColumnSWidth)\r\n\r\n\r\nprint $(\"#.###;(#.###);\\z\\e\\r\\o\", 10),123.21312,3123.45, -3, 0\r\nprint 1,3,4\r\nprint $(\";\\t\\r\\u\\e;\\f\\a\\l\\s\\e\"), -1,0,-1\r\nprint $(\"\")\r\nprint -1,0,-1\r\n\r\nFORM 60,25\r\n? $(3,20),  format$(\"{0:3}\",-12.5678e45)\r\n? $(\"##.##E+###\"),   \\\\ use a coma to prevent a new line\r\n?  -14.56789e33, -14.56789e33, -14.56789e33,   \\\\ last column need a comma  60 width 20 char a column\r\n?  -14.56789e33, -14.56789e33, -14.56789e33,\r\n? $(\"\"),\"OK\"\r\n\r\n\r\n\r\nAfter those operators we put comma (not needed a semi colon). That comma is not a new tab position\r\nPrint 1,2,3 ' we use three columns\r\n      1      2      3\r\nPrint 1,,2,,3 ' we use three lines and put number in the left most column\r\n      1\r\n      2\r\n      3\r\n? $(\"###.##\",10),1.266\r\n      1.27\r\n? str$(1.23,\"0.0\")\r\n1.2\r\nThe StringWay2format$ is the same as the format string of VB6. We use it in STR$() function for formatting before use it or we can use operator $() to do that for all the next prints (until we change that)\r\n\r\nFor numbers and logic expressions \r\n0 = right, 1 = left, 2 = center, 3 = right  - All of these using  one character width for all letters\r\n4 = right, 5 = left, 6 = center, 7,8 = left  - All of these using  each character width and kerning\r\n\r\nFor strings\r\n0 = right, 1 = right, 2 = center, 3 = left  -  All of these using  one character width for all letters  \r\n4 = right, 5 = right, 6 = center, 7 = left , 8 =  left and right  both -  All of these using  each character width and kerning\r\nFor 0 and 4 strings can overwrite next column(s) and advance the cursor to the next one\r\n\r\nexample  - copy this to a module (open it with Edit A  and you can run it by using A)\r\n------------\r\nFlush\r\nj=1\r\nForm 80,32\r\n\r\nCopy this to a module and watch to learn\r\nFlush\r\nj=1\r\nForm 80,32\r\nRepeat {\r\n      j=j+1\r\n      Cls\r\n      Print \"Example for types of Print, Column:\";j;\" charcters\";\r\n      Cursor 0,Row+1\r\n      Data 0,1,2,3,4,5,6,7, 8\r\n      Repeat  {\r\n            Read i\r\n            Print $(I,j),145355,\"George Karras\", \"The Best\",\r\n            Cursor 0,Row+1\r\n      } Until Empty\r\n      Cursor 0,Row+1\r\n      Print $(0);\"press any key\"\r\n      a$=Key$\r\n} Until j=25\r\nPrint
GR:ΕΛ?\r\n\r\nLook Print
GR:ΕΛ@\r\n\r\n@() operator move the cursor, fill a block defined by text coordinates with backcolor and or outline, fill a block with an image\r\nnot needed to place a semi colon to hold the cursor, a nice comma is what we have to put if we have something to put. If not then without a semicolon a CR is automatic added as the last part of a PRINT statement.\r\n      print @(10,10);\r\n      print 1\r\n      is equal to this\r\n      print @(10,10), 1\r\n@(X,Y)\r\n@(X,Y, XlowerRightCorner,YlowerRightCorner, BackColor)\r\n@(X,Y, XlowerRightCorner,YlowerRightCorner, BackColor, Outlinecolor)\r\n@(X,Y, XlowerRightCorner,YlowerRightCorner, BitmapOrFilename$)   ' fill width an image...stretching it to fill the area\r\n@(X,Y, XlowerRightCorner,YlowerRightCorner, BitmapOrFilename$,  1)  ' last parameter says \"keep aspect ratio of image\"\r\n\r\nWhen we PRINT to screen M2000 prints without altering the background, just overwrite the chars. So if we know we have a clear screen then we don't care to fill the background. If we want to overwrite a value in a place that we have write before then we need to clear that part of screen only. Defining outline color can can make lines for columns. M2000 never type above that lines (we have to cross the columns that the line cut those to cut the line with text). Print can be output to the printer, or layers or background layer using @. So we can print to printer page, with lines, background colored forms, and images at text coordinates.\r\n\r\nIf we give a wrong filename (not exist in current dir or the path of file is unknown, or and name not exist), then a bitmap with background color printed on the screen.\r\n\r\nWe can use Bitmap preloaded in a string\r\nIf we open jpg the  IMAGE command look  the orientation and a rotation performed if needed.\r\nuse:\r\n      IMAGE filename$ to bitmapstring$\r\n      \r\n 
GR:ΕΛ~\r\nPrint ~(#12ff00), \"Alfa\"
GR:ΕΛΕΓΧΟΣ\r\nMonitor   in console\r\nor Set Monitor from a module\r\nDisplay information about M2000 environment
GR:ΕΛΕΓΧΟΣ.ΜΕΓΕΘΟΣ.ΣΩΡΟΥ\r\nPrint MONITOR.STACK.SIZE\r\nprint the size of process stack for interpreter\r\nPrint MONITOR.STACK.SIZE-MONITOR.STACK\r\nprint size of free space in stack\r\n\r\n
GR:ΕΛΕΓΧΟΣ.ΣΩΡΟΥ\r\nPrint MONITOR.STACK\r\nreturn the size of used interpreter return stack\r\nM2000 Variables and Arrays are not saved in stack\r\nSubroutines have private return stack, check Recursion.Limit\r\nCalling Functions and modules increase the used stack size\r\nExpressions with operators also increase the used stack size\r\n
GR:ΕΛΛΗΝΙΚΑ\r\nChange charset to Greek. Also change the language of error messages to Greek language\r\n\r\nSee LATIN and CHARSET\r\n\r\n
GR:ΕΛΛΗΝΙΚΑ_μεταβλητή\r\n\r\nPrint Greek\r\nreturn True if  current dialog's messages set to Greek language\r\nSet Switches \"+GREEK\"  set GREEK to true\r\nSet Switches \"-GREEK\"  set GREEK to false\r\nalso GREEK statement set GREEK to true but also change Locale to 1032\r\nLATIN is statement opposite to GREEK, set variable GREEK to false and locale to 1033
GR:ΕΝΑΟΝΟΜΑ$\r\na$=TEMPNAME$\r\nwe create a new file name for temporary use with .tmp file type\r\nWe have to create the file, but it is sure that this is unique
GR:ΕΝΘΕΣΗ\r\nINLINE string_expression$\r\nWe place some commands in line in code.\r\nWith this and module$ and module command I make an example of using pseudo objects...(like objects).\r\n\r\nExample 1\r\na$=quote$(1,\"aaaaaa\",2,3)\r\ninline \"data \"+a$       'put the line data 1, \"aaaaa\", 2, 3\r\n\r\n\r\nExample 2\r\nX=1\r\nModule Alfa {\r\n      \\\\ this is not for calling as a module\r\n      \\\\ because X is not visible\r\n      X++\r\n}\r\n\\ Inline Code just paste code from Alfa and if found  \",\" then past after Inlice code again.\r\nInline code Alfa, Alfa\r\nPrint X\r\n\r\nWe can know if a user module exist using Module() function (also tell as if a user function exist), without call them\r\nPrint Module(Alfa)\r\n\r\n\r\nExample 3\r\n\\\\ This was the fist idea for objects before Group objects exist  in M2000.\r\n\r\nform 60,40\r\nModule ONELEVELDOWN {\r\n' my class has a global var and construction prototype\r\n' I use @@ for replacing with current object at construction stage\r\n' This was my first idea before making the Group object, and the Class command\r\n' I use @Print to direct the interpreter to use it as original Print because\r\n' optimizations are setting to on by default and if we make a new Print\r\n' then always for this context interpreter treat this as user function\r\n'\r\n' See how we use module$ (the name of module) and how I change module name when module run\r\n \r\nglobal mine.global = 1000, last.class$=\"\"\r\nglobal general.proto$ ={\r\n      ' this is a big multiline string using for inline code\r\n      ' BUT BEFORE WE DO THE INLINE ACTION WE HAVE TO REPLACE @@\r\n      ' WITH THE OBJECT NAME  - which is the module name\r\n      push module$   \r\n      module @@\r\n      read parent$  ' now we have our parent module (or object??)\r\n      nextclass$=last.class$\r\n      last.class$<=\"@@\"     \\\\ because last.class$ is global\r\n      a=1  ' this are properties\r\n      b=2\r\n      n$=\"no man\"\r\n      ' this is an array (I found problem with WINE here)\r\n      dim a(10)\r\n      function personal { \r\n            ' this is a member\r\n            ' every object has own personal function\r\n            ' c is local, mine.global is global, @@b is object properties\r\n            c=12\r\n            mine.global++\r\n            =(@@.a+@@.b)*mine.global+c\r\n      }\r\n      module parent$\r\n}\r\nModule me.set {\r\n      Read modulename$ : Module modulename$ ' prepare to insert in object namespace\r\n      Read A, b, n$     ' we can read because we are in right namespace\r\n      Module parent$ ' restore old namespace (using a not global var, but we can make it as global if we like to do....)\r\n}\r\nModule me.print {\r\n      Read modulename$ : Module modulename$\r\n      @Print A, b, n$\r\n      Module parent$ 'restore old namespace\r\n}\r\n' this is first level constructor using classname$ and general.proto$\r\nclassOne$={inline replace$(\"@@\",classname$, general.proto$ )}\r\nPush \"one\", \"two\",\"three\",\"four\"\r\nFor i=1 To 4 {\r\n      Read classname$  \r\n      Inline classOne$   'call construstor\r\n}\r\n' now we have all objects\r\n' lets play with one\r\n' this is a function for any object of our type classOne$\r\nme.set \"one\",1,2,\"a string field for one\"\r\nme.set \"two\", 4,5,\"a string field for two\"\r\nme.set \"three\",7,8,\"a string field for three\"\r\nme.set \"four\", 100, 120, \"a string field for four\"\r\n' and this is a function for any object again\r\nFlush\r\nme.print \"one\"\r\n@Print \"now all together\"\r\nData \"one\", \"two\",\"three\",\"four\"\r\nFor i=1 To 4 {me.print }\r\n\r\n' all properties are read write....\r\n' this is an array inside object\r\n' we can place . in left hand part of assignment if it is a var only, not array or function\r\n' else we have to place @ where . is\r\none.a(4)=1000\r\n@Print \"one.a(4)=\";one.a(4)\r\n' you can use functions inside objects\r\nFor i=1 To 3 {\r\n@Print \"one.personal()=\"; one.personal()   ' as you see this function see properties, local var and a global var for all objects\r\n}\r\nme.set \"two\", 1000,2000,\"George\"\r\n@Print \"three.n$=\";three.n$\r\n@Print \"three.personal()=\";three.personal()\r\nfour.a(6)=4\r\n' and now we access objects as a linked list using nextclass$\r\nshowlist$ = {\r\n      ' pushing first \r\n      repeat {\r\n            module letter$  ' object namespace get it from stack\r\n            ' we can make a variable here..new for the object..\r\n            ' later we can see if is there with VALID\r\n            if not valid(check) then check=true\r\n            if check then {\r\n                  @Print \"Object:\";module$ ,, ' this is the name\r\n                  @Print \">>>>>>>>>>>>>>>>\";n$,,\r\n            }\r\n            push nextclass$ ' this is the next class\r\n      } until nextclass$=\"\"\r\n      read empty$ ' we throw it from stack\r\n      @Print \"module name:\";module$, \" or \";Module.name$\r\n}\r\nPush \"one\"\r\nInline showlist$  ' we use inline because we dont want to erase new value...check...\r\n@Print \"For showlist we prepare a new property named check\"\r\n@Print \"For three we change proprty check to false\"\r\n\\\\ this was an old way to pass a global or a static variable - interpreter make three.check not modulename.three.check\r\nthree@check=False\r\nPush \"one\"\r\nInline showlist$\r\n\r\n' repeat until restore name of module automatic\r\n@Print \"module name:\";Module$, \" or \";Module.name$\r\n\r\n''' list  ' list the variables \r\n' we can't delete an object, but all objects they are destroyed after this module end\r\n' right now!\r\n}\r\nONELEVELDOWN\r\n\r\n      \r\n\r\n      \r\n\r\n\r\n\r\n\r\n\r\n
GR:ΕΝΚΟΜ$\r\na$=inkey$\r\nlook if a key is recorded and remove it passing it as a char in a$\r\nif no key is recorded then \"\" is returned.\r\n
GR:ΕΝΚΟΜ(\r\ncheck keyborad for a delay for a key press between that delay.\r\n\r\nPrint Inkey(1000)\r\n\r\n\r\nA=1\r\nThread {\r\n      A++\r\n} as M interval 10\r\nPrint Inkey(2000)\r\nPrint A\r\n
GR:ΕΝΤΑΣΗ\r\nSound Volume\r\nVolume 100 ' maximum\r\nVolume 0 ' minimum\r\n
GR:ΕΝΤΑΣΗ_μεταβλητή\r\nPrint Volume\r\nprint the audio volume
GR:ΕΝΤΟΛΕΣ ΔΕΙΚΤΗ\r\nMOUSE COMMANDS\r\nJOYPAD, MOUSE.ICON\r\n\r\n
GR:ΕΝΤΟΛΕΣ ΕΙΚΟΝΩΝ\r\nBITMAP COMMANDS\r\nCOPY, IMAGE, PLAYER, SPRITE\r\n\r\n
GR:ΕΝΤΟΛΕΣ ΙΣΤΟΥ\r\nBROWSER COMMANDS\r\nBROWSER, TEXT, HTML\r\n\r\n
GR:ΕΝΤΟΛΕΣ ΚΟΝΣΟΛΑΣ\r\nCONSOLE COMMANDS\r\nBACK, BACKGROUND, BOLD, CHARSET, CLS, CURSOR, DESKTOP, DOUBLE, FIELD, FONT, FORM, FRAME, GRADIENT, GREEK, HIDE, HOLD, ICON, ITALIC, LATIN, LAYER, LEGEND, LINESPACE, LOCALE, MARK, MODE, MOTION, MOTION.W, NORMAL, PEN, REFRESH, RELEASE, REPORT, SCROLL, SHOW, WINDOW\r\n\r\n
GR:ΕΝΤΟΛΕΣ ΣΩΡΟΥ\r\nSTACK COMMANDS\r\nCOMMIT, DATA, DROP, FLUSH, OVER, PUSH, READ, REFER, SHIFT, SHIFTBACK, STACK\r\n\r\n
GR:ΕΝΤΟΛΗ$\r\nPRINT COMMAND$\r\n\r\nprints the filename with path of the last loaded GSB (General Script Basic the prototype name of M2000)\r\n\r\nwhen we load or save we didn't need path and type, just name.\r\nload \"alfa\"\r\nBut we can use path and type, so we can use command$  to save\r\nsave command$\r\na message box open to ask if we want to overwrite the file or not.\r\n\r\ncommand save command$ can be activated with ctrl+A in CLI (or prompt > stage)\r\n\r\n
GR:ΕΝΩ\r\n\r\n\r\nWhile condition {\r\nblock of code\r\n}\r\n\r\nWhile Iterator_Object {\r\n     block of code\r\n}\r\n\r\nuse exit for exit inside block\r\ncontinue or restart  to restart the block without finishing\r\nbreak to exit for module (but break cannot break a block inside a Case)\r\n\r\nYou can nest those Whiles with Do Until or any other block of code.\r\n\r\n\\\\ first variant\r\na=10\r\nWhile a>0 {\r\n      Print a\r\n      a--  ' here a change so condition a>0 maybe change\r\n}\r\n\r\n\r\n\\\\ second variant\r\nk=(1,2,3,4,5)\r\nk1=Each(k,1, 3)\r\nPrint \"k1\"\r\nWhile k1 {\r\n      ' 3 times\r\n      Print Array(k1)\r\n}\r\nk1=Each(k,1, 3)    ' from start to 3rd\r\nk2=Each(k,-1, 3)  ' from end to 3rd (we can use here -3 as 3rd from last)\r\nPrint \"k1, k2\"\r\nWhile k1, k2 {\r\n      ' 3 times\r\n      Print Array(k1)*Array(k2)\r\n}\r\nk1=Each(k,1, 3)\r\nk2=Each(k,-1, 3)\r\nPrint \"k1*k2\"\r\nWhile k1 {\r\n      While k2 {\r\n            ' 3x3 times\r\n            Print Array(k1)*Array(k2)\r\n      }\r\n}\r\n\r\nExist with no block\r\nWhile [comparison or iterator, ] comparison or iterator\r\n\r\nEnd While\r\n\r\n\r\n
GR:ΕΝΩΣΕ\r\n\r\n\\\\ We can link variables to other variables\r\n\\\\ We can't link twice, for same variable in list2\r\n\\\\ We can link more than once a variable in list1, but each time to new name\r\nLink variable_list1 to variable_list2\r\n\\\\ we can link to same name shadowing then old one.\r\nLink variable_list1 local to variable_list2\r\n\\\\ we can link arrays too\r\nLink array1() to array2()\r\nLink array1$() to array2()\r\nLink array1() to array2$()\r\n\\\\ we can link a pointer to array with an array\r\n\\\\ in a new module write:\r\nA=(1,2,3,4)\r\nLink A to Array1()\r\nA+=10\r\nPrint A\r\nPrint Array1()\r\nArray1(3)+=10\r\nPrint Array1(3), Array(A, 3)\r\nReturn A, 0:=5,1:=3,2:=100,3:=\"500\"\r\nPrint A\r\nPrint Array1()\r\nA++\r\nPrint A   \\\\ 4th element stay 500 because is string\r\nLink A to Array1$()\r\nPrint Array1$()\r\nArray1$(3)=\"hello\"\r\nArray1$(1)=\"200\"\r\nA+=500\r\nPrint A\r\nPrint Array1$()\r\n\r\n\r\n\r\na$=\"one\"\r\nLink a$ to b$\r\nPrint b$\r\n\r\nthis is the same as\r\na$=\"one\"\r\nPush &a$  \\\\ push a weak reference as a string in stack\r\nRead &b$  \\\\ read weak reference and make the link\r\nPrint b$\r\n\r\n\r\n\\\\ Example using Lazy$(), weak$() and Link\r\na$=\"{=1000*number+number}\"\r\n\\\\ a$ is a weak reference to anonymous function in a string (has a block {} inside)\r\n\\\\ actually a weak reference to function is a copy of code and sometimes there is\r\n\\\\ a weak reference to object (if it is group member)\r\nLink weak a$ to aa()\r\nPrint aa(10,-100)\r\nm=300\r\nb$=weak$(m)\r\n\\\\ b$ is a weak reference to m\r\nLink weak b$ to d\r\nPrint d\r\nd+=5000\r\nPrint m, m=d, Eval(b$)\r\n\\\\ using a dot in string variable, interpreter expect a weak reference\r\nb$.+=500\r\n\\\\ we can use dot in Eval() but is optional\r\n\\\\ in Eval$() is not optional because without dot return the string not the reference string\r\nPrint m, m=d, Eval(b$.)\r\n\r\nGroup Beta {\r\n      counter=0\r\n      Function Check (x, y) {\r\n            .counter++\r\n            =x**2+y\r\n      }\r\n}\r\nModule CheckThis (&f()) {\r\n      Print f(11,3)\r\n}\r\nLink Beta.Check() to Z()\r\nPrint Z(10,2), Beta.counter\r\nCheckThis &Beta.Check()\r\nCheckThis Lazy$(Beta.Check(number, 30))\r\nCheckThis Lazy$(Beta.Check(20, 30))\r\nPrint Z(12,4), Beta.counter\r\n\r\nLink parent\r\n\\\\ is a variant of Link, used for linking a parent group variable with an local name. Used in Groups in Groups. Only one level up allowed, and only for variables (we can' link a function, except lambda functions, and only if lambda has no references to group variables)\r\nGroup alfa {\r\n      K=10\r\n      m=lambda N ->{\r\n            =100+N*.K\r\n            N++\r\n      }\r\n      Group beta {\r\n              Value {\r\n                  link parent m to m\r\n                  For this   {\r\n                        =m()\r\n                  }\r\n            }\r\n      }\r\n}\r\nFor i=1 to 10 \r\n      Print alfa.m()\r\n      Try {\r\n            m=alfa.beta\r\n            Print m\r\n      }\r\nNext i\r\nalfa.m=lambda N=1000 -> {\r\n            =100+N  \\\\ with no reference to .k\r\n            N++      \r\n}\r\nFor i=1 to 10 \r\n      Print alfa.m()\r\n      Try {\r\n            m=alfa.beta\r\n            Print m\r\n      }\r\nNext i\r\n\r\n\r\n\r\n\r\n
GR:ΕΝΩΣΗ(\r\na=(1,2,3,4,5)\r\nb=Cons(a, (6,7,8), a)\r\nPrint b\r\n\r\n
GR:ΕΝΩΣΗ.ΣΕΙΡΑΣ$(\r\nPrint Union.data$(65, 66,\"C\", \"alfa\", 0x2102)=\"ABCalfaℂ\"\r\n
GR:ΕΞΟΔΟΣ\r\n\r\nExit\r\nused for exit from a block\r\n\r\nExit Sub used for an exit from a Sub\r\nExit For used for an exit in a For Next loop\r\nExit For label  for an exit and jump to label\r\n\\\\ example\r\nFor i=1 to 10\r\n      if i=5 then exit for 10\r\n      print i\r\nNext i\r\n5 print \"not here\"\r\n10 print \"Hello\"\r\n\r\n
GR:ΕΠΑΝ$(\r\n1) Repeat a string n times.\r\nPrint String$(\"A\", 3)\r\nAAA\r\n2) Print String$(a$)\r\ntranslate to escape codes using \\ for some specific chars.\r\n3) Print String$(a$ as json)\r\ntranslate to escape codes using json specific way \r\n\r\na$={alfa\r\n      \"beta\"\r\n      gamma\r\n}\r\nPrint string$(a$)\r\nPrint string$(a$ as json)\r\n' Using fromat$() to change to normal.\r\nReport format$(string$(a$))\r\nReport format$(string$(a$ as json))\r\n4) Print String$(a$ as Encode64)\r\n  Print String$(a$ as Encode64, 1)  ' compact\r\n  Print String$(a$ as Encode64, 0, 6)  ' crlf every 60 chars, 6 chars pad spaces at left\r\n5) Print String$(a$ as Decode64)\r\n    decoding from BASE64\r\n6) Print String$(a$ as UTF8enc)\r\n    encoding to UTF-8\r\n7) Print String$(a$ as UTF8dec)\r\n    decoding from UTF-8\r\n8) Print String$(a$ as URLdec)\r\n   Print String$(a$ as URLdec +)  ' change + with spaces\r\n   Print String$(String$(a$ as URLencHTML5) as URLdec)\r\n9) Print String$(a$ as URLenc)   \r\n    Threre are three types of encoding, simple, HTML5 and RFC3986\r\n    Print String$(a$ as URLencHTML5) \r\n    Print String$(a$ as URLencHTML5 +)   ' spaces to + not to %20\r\n    Print String$(a$ as URLencRFC3986) \r\n    Print String$(a$ as URLencRFC3986 +)   ' spaces to + not to %20\r\n\r\n\r\nExample for URL parseSS\r\n\r\nStack New {\r\n      Data \"foo://example.com:8042/over/there?name=ferret#nose\",  \"urn:example:animal:ferret:nose\" \r\n      Data \"jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true\",   \"ftp://ftp.is.co.za/rfc/rfc1808.txt\"\r\n      Data \"http://www.ietf.org/rfc/rfc2396.txt#header1\",   \"ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two\"\r\n      Data \"mailto:John.Doe@example.com\",   \"news:comp.infosystems.www.servers.unix\",   \"tel:+1-816-555-1212\"\r\n      Data \"telnet://192.0.2.16:80/\",   \"urn:oasis:names:specification:docbook:dtd:xml:4.1.2\",  \"ssh://alice@example.com\"\r\n      Data \"https://bob:pass@example.com/place\",   \"http://example.com/?a=1&b=2+2&c=3&c=4&d=%65%6e%63%6F%64%65%64\"\r\n      data \"ftp://username:password@hostname/\"\r\n      a=Array([])\r\n}\r\nfunction prechar$(a$, b$) {\r\n      if a$<>\"\" then {=quote$(b$+a$)} else ={\"\"}\r\n}\r\nz=each(a)\r\ndocument s$=\"[\"+{\r\n}\r\nWhile z {\r\n      a$=array$(z)\r\n      s1$={           \"uri\": }+quote$(a$)+{,\r\n            \"authority\": }+ quote$(string$(a$ as URLAuthority))+{,\r\n            \"userInfo\": }+ quote$(string$(a$ as URLUserInfo))+{,\r\n            \"username\": }+ quote$(string$(a$ as URLpart 3))+{,\r\n            \"password\": }+ quote$(string$(a$ as URLpart 4))+{,\r\n            \"scheme\": }+quote$(string$(a$ as URLScheme))+{,\r\n            \"hostname\": }+quote$(string$(a$ as UrlHost))+{,\r\n            \"Port\": }+quote$(string$(a$ as UrlPort))+{,\r\n            \"pathname\": }+quote$(string$(a$ as UrlPath))+{,\r\n            \"search\": }+prechar$(string$(a$ as URLpart 6),\"?\")+{,\r\n            \"hash\": }+prechar$(string$(a$ as UrlFragment),\"#\")+{\r\n      } \r\n      s$=\"     {\"+{\r\n      }+s1$+\"     }\"\r\n      if  z^<len(a)-1 then s$=\" ,\"   ' append to document\r\n      s$={\r\n      }\r\n}\r\ns$=\"]\"\r\nReport s$\r\n
GR:ΕΠΑΝΑΛΑΒΕ\r\nA repeat block until structure. Can be used with always. Has alternative name Do\r\n\r\nRepeat {\r\n      If b=3 Then Exit\r\n      if k=5 Then Continue\r\n      ................\r\n} Until A=1\r\n\r\nRepeat {\r\n      IF B=3 Then Exit\r\n      if k=5 Then Continue      \r\n      ................\r\n\r\n} Always\r\n\r\nuse REPEAT or  DO, is the same\r\n\r\nDo {\r\n\r\n} Always\r\n\r\nDo {\r\n\r\n} Until b>3\r\n\r\nWithout Block (scan to find Until, so with block is faster):\r\nDo\r\n\r\nUntil b>3\r\n\r\nDo\r\n\r\nAlways b>3\r\n\r\n\r\n\r\n
GR:ΕΠΑΝΕΛΑΒΕ\r\nSEE REPEAT
GR:ΕΠΙΓΡΑΦΗ\r\n\r\nWe can print in screen, layer, background and printer with many ways using PRINT and REPORT but also we can use LEGEND to print ANGLED text and with specific font for each call. We can include it in a WIDTH { } structure to alter the \"outline\" width of the text. We can also print multine text.\r\nAlways the print starts from graphic cursor (not the text cursor)\r\n\r\nwe can prepare multiline text using { }\r\na$={1st line\r\n      second line\r\n      third line\r\n      }   ' this bracket mark the space to exclude before writing to a$\r\n\r\n1) Print a legend with a specific font and size\r\nLEGEND  a$, \"TAHOMA\", 22\r\n\r\n2) Like (1) with angle in rads (use pi/2 for 90 deg)\r\nLEGEND a$ , \"TAHOMA\", 22, pi*2/3\r\n3) Like (2) but we can format the text, center , right or left \r\nLEGEND a$ , \"TAHOMA\", 22, pi*2/3, 2\r\n1 for right, 2 for center, 3 for left\r\n' no text wrapping like REPORT does\r\n4) like 3  but we can change quality \r\nLEGEND a$ , \"TAHOMA\", 22, pi*2/3, 2, 0\r\n0 or non 0. With 0 quality no anti-alliasing perform so we can take it as sprite and make transparent without small glitches\r\n5) LEGEND a$ , \"TAHOMA\", 22, pi*2/3, 2, 0, 150\r\nlike 4 but we add an extra space in each char. Negative number used for exclude space  (from version 8, rev 42)\r\nLook example at the end \r\n\r\nThis is a special variant used for display multiline text. This isn't use graphic cursor but in chars cursor\r\nWe give a frame as a width and a height and the command show text in a$ without scrolling\r\n6) LEGEND ! text$, width_in_chars, height_in_char_rows\r\nWe need this after we perform a text input with INPUT ! command\r\n\r\n\r\nLegend use the Bold and Italic flag for current layer. In this example we alter these and set again in the previous state, using two variables to store them. Also Legend use pen color, line width,  and color { } to fill color inside text area.\r\n\r\nExample\r\n\r\ncls #ffbb77,0\r\npen #7700ff\r\nanti_aliasing = true  \r\ncenter = 2\r\nmove 6000,6000\r\noldBold = Bold\r\noldItalic = Italic\r\nBold 1 : Italic 1\r\npen #77aaff {\r\n      width 3 {\r\n            color #775511 {\r\n                        LEGEND  {Hello\r\n                        My name is George\r\n                        }, \"Arial Black\", 40, pi/8, center, anti_aliasing,-60  ' 60 twips are 4 pixels in 15 dpi screens or 5 pixels in 12 dpi\r\n            }\r\n      }\r\n}\r\nItalic oldItalic : Bold oldBold\r\nmove 12000, 6000\r\nLEGEND  {Hello\r\nMy name is George}, \"Arial Black\", 40, pi/8, center\r\n
GR:ΕΠΙΛΕΞΕ\r\n\r\nYou can use BREAK and CONTINUE in curly brackets for special purpose in a select case (see that exclusive)\r\nYou can use Goto το jump out of block in a Case or Else clause.\r\nWithout brackets, and in one line of commands that allowed after a Case statement Break and Continue act as normal.\r\nAfter a Case can be one line with commands (separated with colon) or a block of commands, but no a blank line. \r\nYou can use Arithmetic or String variable for cases\r\nYou can have conditions and variables or user functions in every case statement.  All the conditions are investigated if no {Break} command break that, or a condition founded true, and for that case the next line command or block of command executed.\r\nThere are no optimization. Executed as it is. \r\n\r\nSELECT CASE Α\r\nCASE 1 ΤΟ 100, 120, >500\r\n....\r\nCASE 105\r\n{\r\n....\r\n}\r\nELSE\r\n....\r\nEND SELECT\r\n\r\n\r\n\r\n{\r\na=9\r\nhere:\r\na-=4  ' case 5 and then case 1\r\nPrint \"Last Test\"\r\n\\*  break in level of first block after CASE ..break the cases, so all cases run including the conditions in the case\r\n\\* break out of block like case 1.5 or in deeper block like in case 1...are a big break\r\nSelect case A\r\nCase 1\r\n      {if true then { break } else continue} '  check with if false - here break is like in case 1.5\r\nCase 1.5      \r\n      break  ' that is a break for module , or outer block...like the one here..\r\nCase 2\r\n      {if true then break}    ' break the select structure so case 4 and 5 command are run \r\nCase 4\r\n      Print \"case 4\"  : Print \"now we can execute a second statement in same line\"\r\nCase 5\r\n      goto here   ' jump backward\r\nElse\r\n      {\r\n      Print \"this is a block of code\"\r\n      Print  \"No jump can do from here to go out of block\"\r\n      Print \"A break and a continue have specific duty in a block inside case\"      \r\n      }      \r\nEnd Select\r\nprint \"no error\"\r\n}\r\nprint \"end\"\r\n\r\n\r\n\r\n\r\n\r\n\r\n
GR:ΕΠΙΛΕΞΕ.ΓΡΑΜΜΑΤΟΣΕΙΡΑ\r\nCHOOSE.FONT\r\nOpen a custom dialog to choose font.  Dialog has 4 zones. Top zone has the title dialog,  we can move, or we can close clicking the square icon. Next zone is a list box with font names. We can scroll by pushing up or down, holding down left mouse button. Third zone hold attributes editor. We can scroll 3d zone and we can check bold and or italics and edit numbers size and charset, or we can choose from presets. Last zone is for preview and testing. With tab we change from 2 to 3 to 4 zone and in 4th we can press any key to open the editor. We can shift right the 4th zone as OK or just press Enter. Use square at the top for Cancel. Also the dialog is sizable, using the down or right border, or down and right corner.\r\nAll the \r\n\r\nMODULE A  {\r\n\r\n      MODULE SAY {\r\n            READ K\r\n            IF K=0 THEN {\r\n                  PRINT \"NO\"\r\n            } ELSE {\r\n                  PRINT \"YES\"\r\n            }\r\n      }\r\n      \r\n      CHOOSE.FONT\r\n      \r\n      IF NUMBER>0 THEN {\r\n            READ A$, S, C, I, B\r\n            PRINT \"FONT:\";A$\r\n            PRINT \"SIZE:\";S\r\n            PRINT \"CHARSET:\";C\r\n            PRINT \"ITALIC:\";\r\n            SAY I\r\n            PRINT \"BOLD:\";\r\n            SAY B\r\n      } ELSE {\r\n            PRINT \"NOTHING...\"\r\n      }\r\n}\r\n
GR:ΕΠΙΛΕΞΕ.ΟΡΓΑΝΟ\r\n\r\nCHOOSE.ORGAN  ' this is a list of SYNTHESIZER INSTRUMENTS\r\nIF MENU>0  THEN ORGAN=MENU
GR:ΕΠΙΛΕΞΕ.ΧΡΩΜΑ\r\n\r\n1) CHOOSE.COLOR \r\n            default dialog for color picking\r\n\r\n\r\n2) CHOOSE.COLOR  color\r\n            like 1 but display our choice\r\n            \r\nuse arrows left right to rotate columns, so the most left can change by one...as we move up down the color list.\r\nslide the bottom box to send color  (find in the stack)\r\n\r\n            \r\n            \r\n            
GR:ΕΠΙΛΟΓΕΣ\r\n\r\nMenu \"Alfa\",\"Beta\"\r\nPrint Menu\r\nMaybe Menu is 1 or 2 or 0 if no selection done.\r\n
GR:ΕΠΙΛΟΓΕΣ.ΦΑΝΕΡΕΣ\r\nmenu.visible is a read only variable that we use in a thread when a menu is visible...\r\nbecause when a menu is hide maybe a thread run and without reading this variable maybe reopen the menu by changing items\r\n\r\ni=0\r\nthread {\r\n      i++\r\n      if menu.visible then print i, menu$(menu)\r\n} as a\r\nmenu title \"choose\"\r\nafter 100 {\r\n      thread a interval 100\r\n}  ' so we start thread \"a\" when the menu is showing\r\nmenu \"1st line\",\"2nd line\"\r\nprint menu\r\n\r\n' So we want to open.file before open menu and we want a title on the menu\r\n' because title reconstruct the menu after the menu drawing one time\r\n' we have to do some tricks with the threads (because a print in a thread refresh the screen and that isn't good for the menu when has a title to display - titles may have more than one lines using word wrapping - and for that running calculation done in the first display of the menu. A refresh by the print command  cancel the next refresh)\r\n\r\nso the above example if we wish to use title (and need the thread to run) and open a file and for both the thread must run then\r\nwe have to hold the thread when we finish with OPEN.FILE and start MENU and AFTER we can RESTART the thread\r\n\r\ni=0\r\nthread {\r\n      i++\r\n      if menu.visible then {\r\n            print i, menu$(menu)\r\n      } else {\r\n            print i\r\n      }\r\n} as a\r\nmenu title \"choose\"\r\n      thread a interval 100\r\nopen.file \r\nthread a hold\r\nafter 100 {\r\n      thread a restart\r\n}  ' so we restart thread \"a\" when the menu is showing\r\nmenu \"1st line\",\"2nd line\"\r\nprint menu
GR:ΕΠΙΛΟΓΗ\r\nMenu is a special listbox that serves in two major ways:\r\nAs a menu that wait to choose something (like popup), and as a toolbox, floating in the space of environment.\r\nWe can construct menu and then we can choose how to display, or we can do all in one line\r\nSome commands change the style of menu, for all next callings until we change those.\r\nWe don't have sub menus. We can open a new menu with a new title as sub menu.\r\nMenus can give nothing if we press escape or when we click outside. For toolbox a click outside do nothing.\r\nMenu have font size equal to font size from the calling layer, and use line spacing as the calling layer does. Menu open in text coordinates,  but if we use title we can float it anywhere (except if we state HOLD).\r\nAs simple menu popup with one line. \r\nMenu items can choose by Enter, by double click, by slide right\r\nMenu list can scroll by using a hidden scroll bar, or by hold down left mouse button and push to the desired direction.\r\n\r\nMENU \"choose me\",\"or better me\"                   ' we can choose nothing with escape or clicking outside\r\n\r\nNow the interpreter wait us to take action (threads can be run in background, and they can check if we have a MENU.VISIBLE)\r\na simple command MENU clear the internal list. That list we can read using MENU$() and the choice is reading by MENU read only variable. Menu  equal to zero means nothing chosen. In a thread we can read MENU as selected but not chosen. \r\n\r\nMENU    ' clear the list\r\nMENU +\"1st line\",\"2nd line\"   ' append two items\r\nMENU +\"3rd line\",\"4th line\"   ' append two more\r\nMENU !   ' just show the menu \r\n\r\n' Advance example using threads\r\n' copy this in a module\r\ni=0\r\nthread {\r\n      i++\r\n      if menu.visible then print i, menu$(menu)\r\n} as a\r\nmenu title \"choose\"\r\nafter 100 {\r\n      thread a interval 100\r\n}  ' so we start thread \"a\" when the menu is showing\r\nmenu \"1st line\",\"2nd line\"\r\nprint menu\r\n' thread is erased at the end of the running module...or we can erase anytime by using: thread a erase  or inside thread by using: thread this erase\r\n\r\n' example of using multiline title, and new colors\r\n\r\na$={This\r\n      is\r\n      a 3 line menu title\r\n      }\r\n' menu title a$ hold   ' no float menu\r\nmenu title a$   ' use menu title \"\" to delete title lines\r\nmenu frame     ' use  off to disable   frame is always as for buttons..black.\r\nmenu fill color(100,130,200),COLOR(255,255,50),7   ' title color, list color and text color\r\n' MENU FILL 1  ' we reset  list color and text color  to default (reverse pen and background color)\r\nmenu \"I want some space              \", \"next item\", \"next item too\"\r\n
GR:ΕΠΙΛΟΓΗ$(\r\nWe can put strings in menu and then we can read that as an array.\r\nThis is not an array but an internal function.\r\n\r\nstack new {\r\n      menu   \\\\ clear internal store, we need that because we use menu + to add\r\n      data \"alpha\",\"beta\",\"gama\",\"delta\"\r\n      for i =1 to 4 { read a$ : menu + a$ }\r\n      menu !\r\n      if menu>0 then print menu$(menu)\r\n}
GR:ΕΠΙΛΟΓΗ_μεταβλητή\r\nMenu \"Alfa\",\"Beta\"\r\n? Menu\r\n\r\n
GR:ΕΠΙΠΕΔΟ\r\nScreen can have 32 layers. The 32n is at the top..\r\nWe can create by using an image or we can create with the first LAYER command and the size would be the size of the layer from where the LAYER command start to execute. Size of font must selected by using MODE size or FORM to make an automatic size match to a specific char resolution. We can use the WINDOW command to give size and dimensions\r\nIf we run this when the output is to screen the layer take that size\r\n\r\nLAYER 1 {\r\n      Mode 16\r\n      print \"this is 16pt letters  ' this command output to layer 1 but we can't see yet\r\n}\r\nPLAYER 1, 3000,4000  ' now we use player command to set the position\r\nPLAYER 1 SHOW\r\n' OR \r\nLAYER 1 {\r\n      window 6, 10000,8000  ' we set a size or without it the size from the calling layer\r\n      form 32, 20  ' this do a cut bottom and left to display 32 chars X20 lines\r\n      print \"this has resolution 32x20 chars  ' this command output to layer 1 but we can't see yet\r\n}\r\nPLAYER 1, 3000,4000  ' now we use player command to set the position\r\nPLAYER 1 SHOW\r\n' OR\r\nMOVE 0,0\r\nA$=\"\"\r\nCOPY 10000, 8000 TO A$\r\nPLAYER 1, 3000, 4000 USE A$   ' NOW LAYER HAS A PICTURE BACKGROUND\r\nLAYER 1 {\r\n      form 32, 20  ' this do a cut bottom and left to display 32 chars X20 lines\r\n      CLS ' WE REPAINT THE PICTURE\r\n      print \"this has resolution 32x20 chars  ' this command output to layer 1 but we can't see yet\r\n}\r\nPLAYER 1 SHOW   ' NEEDED ONE  TIME TO SHOW THE LAYER\r\n\r\nWe can make TARGETS in the layers see TARGET command\r\n\r\nAnytime we can move or hide and then show again the layer. We can draw and we can open FIELDS for input. We can used with transparent pixels also (but the transparent mask changed only if we change the image we place with SPRITE command/\r\nWe can make threads to move the layers, to show as info in some time after. Use AFTER command in combination to EVERY or WAIT to see the effect.\r\n
GR:ΕΠΙΣΤΡΟΦΗ\r\n1) For databases\r\nRETURN \"THISBASE\",\"SELECT * FROM THISTABLE WHERE THISFIELD LIKE 'MAGELAN%'\" , ,\"EARTH THERE\",\"DATA2\",\"DATA3\"\r\n(use % not * in a string after LIKE, because ADO need %)\r\nRETURN \"THISBASE\",\"THISTABLE\" TO OFFSET, FIELD1, FIELD2....\r\n\r\n\r\nSO we return to base THISBASE, in a table THISTABLE in a record which a field THISFIELD  is like MAGELAN* only 2nd, 3rd and 4th fields (first field is the name so we can skip this with double coma)\r\n\r\nIf we use a table as look up table (using record from an offset) then is another format of RETURN\r\nLets say that we need to change specific field at Selection index\r\n\r\nRetrieve \"HELP2000\",\"GROUP\", Selection,\"\",\"\"\r\n\r\nwe do what we want with that record and then we want to send it back..by OFFSET and no with SQL query\r\n\r\nReturn \"HELP2000\",\"GROUP\" to Selection, ,groupname$  \r\n\r\n2) For flow control\r\nGosub alfa\r\nEnd\r\nalfa:\r\nPrint \"ok\"\r\nReturn\r\n\r\n3) For Inventories, Arrays, Stacks\r\nInventory a=1:=\"Hello\",\"other\":=\"Yes\"\r\n\\\\ Inventory is a list with key and value\r\nReturn a, \"other\":=\"No\", 1:=\"Hello again\"\r\nPrint a$(\"other\"), a$(1)\r\naa=each(a)\r\nPrint \"key\", \"value\"\r\nwhile aa {Print eval$(aa!), eval$(aa)}\r\nb=(1,2,3,4,5)   ' auto array\r\n\\\\ Array(b) is the first item\r\nReturn b,3:=400, 0:=Array(b)+1,1:=Array(b,1)**2  ' for base 0 index 3 is the forth item\r\nPrint b\r\nPrint Array(b,3)\r\nbb=each(b)\r\nWhile bb { Print str$(Array(bb),\"00000\")}\r\n\\\\ Stack is a linked list. Keys are positions from 1. We can move any item easy\r\nm=Stack:=1,2,3,4,5\r\nReturn m, 4:=400,1:=StackItem(m)+1, 2:=StackItem(m,2)**2  ' Stacks have base 1\r\nPrint m\r\nPrint StackItem(m,4)\r\nmm=each(m, -1, 1)\r\nWhile mm { Print str$(Stackitem(mm),\"00000\")}\r\nStack m { Shift 4 : ShiftBack 5} \\\\ send 4th item to 5th position\r\nPrint  m\r\n\r\n\r\n\r\n\r\n
GR:ΕΠΙΦΑΝΕΙΑ\r\nDESKTOP\r\ncopy desktop to a deep background\r\n\r\nDESKTOP 100\r\nFrom 0 (100% transparent) to 255 (0% transparent)  we can control transparency to major form of M2000 (with background and layers).\r\n\r\nDESKTOP  255, 1\r\nthe second parameter is the 100% transparency when the color found. Here color is one from 16 basic. \r\n\r\nDESKTOP  IMAGE A$\r\nA$ is a bitmap in a string or a filename to a bitmap (jpg is ok)\r\n\r\nDESKTOP HIDE\r\nWe can hide the desktop so we can catch something behind it if we set transparency to color (2nf parameter).\r\n\r\nDESKTOP CLEAR\r\nWe can clear the deep  background, and set to non transparency condition.\r\n\r\nDeep Background always have screen size and fit on screen. It is here to block clicks to go down. We can see what happen if we hide this background. \r\nOne good think to do we these commands is the transparent form. We can have 1 as backcolor in form so we can see behind all area that has color  1 (from desktop 255, 1)  and we display an image that is like a water mark, always behind.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
GR:ΕΠΟΜΕΝΑ(\r\n\r\na=((1,2), (3,4), (5, 6))\r\nb=Car(a)\r\nPrint Car(b)  ' 1\r\nPrint Car(Car(a))   ' 1\r\nPrint Cdr(Car(Cdr(Cdr(a))))  ' 6\r\n
GR:ΕΤΟΙΜΟ(\r\nDocument Doc$\r\nBecause an event in a form can be fired twice (if we leave the form and re-activate it again)\r\nInside an event in a M2000 Form:\r\n'  Using Layer there is a callback to Load.Doc to abandon loading\r\n' \r\nIf not Read(Doc$) then exit\r\nLayer FormObject {\r\n      Load.Doc Doc$, Filename$\r\n}\r\n\r\n' Either way there is a Busy property in Document object\r\n' and we can read it\r\nIf not Read(Doc$) then exit\r\nLoad.Doc Doc$, Filename$\r\n\r\n
GR:ΕΥΡΕΣΗ\r\nFIND\r\nFIND document_varOrarrayItem$, string_to_find$ [, starting_position]\r\nWe have to search a srting in a paragraph, so in string_to_find$ no chars below 32 allowed\r\n\r\nReturn to stack one or three values. One if nothing find with value 0. Three if find, and top we have the position, next the paragraph order (or index, here is the same), and paragraph position. No case sensitive.\r\n\r\nExample (text from BBC NEWS 17th August 2015)\r\ndocument alfa$={Dozens of migrants on the Greek island of Kos have begun registering on a passenger ship which will be their temporary shelter as they seek asylum.\r\nThe first to board was a group of Syrian refugees, who have been living rough on Kos since they arrived.\r\n}\r\nreport alfa$\r\nfind$=\"on \"\r\nfind alfa$, find$\r\nread find_pos\r\nwhile find_pos>0 {\r\n      read par_order, par_pos\r\n      print under left$(paragraph$(alfa$, par_order, par_pos), 15)+\"...\"\r\n      print under format$(\"Position {2}, Paragraph {0}, Position {1}\", par_order, par_pos, find_pos)\r\n      find alfa$, find$, find_pos+1 \r\n      read find_pos\r\n}\r\n
GR:ΕΦΑΠ(\r\nPrint Tan(45)\r\na tan for 45 degree\r\n\r\n
GR:ΕΦΑΡΜΟΓΗ.ΑΡΧΕΙΟΥ$(\r\nPRINT FILE.APP$(\"txt\")\r\nWe get the application that os know to open the txt files.\r\n We can use WIN to send a shell command\r\n We can use OS to send an os commad\r\n
GR:ΕΦΑΡΜΟΓΗ.ΚΑΤ$\r\n\r\nPRINT APPDIR$\r\nprint application directory if we have a proper installation else we get a null string\r\n\r\n\r\n\r\n\r\n\r\n
GR:Η\r\nOperator Or\r\n\r\nPrint True Or False
GR:ΗΜ(\r\nPrint SIN(45)\r\nWork in degree
GR:ΗΜΕΡΑ$(\r\nPrint date$(today)\r\nPrint date$(today,1033,\"Long Date\")\r\nPrint date$(today,1033,\"MMMMM d yyyy\")\r\nPrint date$(today) ' use  Greek short day\r\nPrint date$(today,)  ' use current locale\r\nPrint date$(today,1033) ' short date\r\n\r\n
GR:ΗΜΕΡΑ(\r\n\r\nA=Date(\"2015-10-11\")\r\nPrint STR$( A ,\"LONG DATE\")\r\nA=Date(\"March 7 2009\", 1033)\r\nPrint Date$(A, 1033, \"LONG DATE\")
GR:ΗΜΕΡΟΜΗΝΙΑ\r\n\r\nDATEFIELD used in TABLE\r\n
GR:ΗΧΟ$(\r\n? SND$(\"BELL\")\r\nreturn path, name, file type (wav) if BELL.wav exist in current directory or return nothing.\r\n\r\n
GR:ΗΧΟΙ\r\n\r\n\r\n\r\nDIR \"C:\"\r\nSOUNDS\r\nFILES \"wav\"\r\nprint on screen sound files as filenames\r\n\r\n\r\nSOUNDS                ' SORTED BY DATE & TIME\r\nSOUNDS !              ' SORTED BY NAME\r\nFILES \"wav\"          ' AS SOUNDS\r\nFILES  ! \"wav\"       ' AS SOUNDS !  \r\nFILES  + \"wav\"     ' SORTED BY DATE AND TIME  AND STORED AS MENU ITEMS\r\nFILES  ! +  \"wav\"  ' SORTED BY NAME AND STORED  AS MENU ITEMS\r\nuse MENU ! to open menu\r\n
GR:ΗΧΟΙ ΚΑΙ ΤΑΙΝΙΕΣ\r\nSOUNDS AND MOVIES\r\nBEEP, CHOOSE.ORGAN, MOVIE, MEDIA, MUSIC, PLAY, SCORE, SOUND, SPEECH, TONE, TUNE, VOLUME\r\n\r\n
GR:ΗΧΟΣ\r\n\r\nplay wav\r\nSOUND filename$\r\nSOUND \"\"    Stop sound\r\n\r\n
GR:ΘΕΣΕ\r\n\r\n\r\nSET A=10\r\nSET A=23 : DIM K(20)=10 : PRINT \"OK\"\r\nSET command send all text until the end of line to Command Line Interpreter (CLI). This interpreter is part of M2000 Interpreter that  run from command line (from console).\r\nSee that (as example to understand the end of line):\r\nINLINE \"SET A=10 \" : B=20\r\nLIST\r\nThe B variable also became a global variable...because inline leave that:\r\nSET A=10 : B=20\r\nso SET get line \"A=10 : B=20\"\r\n\r\nso we can write that\r\nINLINE {SET A=10\r\n} : B=20\r\nLIST\r\nSo now we have a global and a local variable.\r\nBecause in CLI we can't make remarks, we can't place remarks in the same line that has a SET command\r\nYou can write a number label and maybe a command and after \":\" we can place a Set command but without remarks\r\n1000 print \"ok\" : set a=100\r\n\r\nSee example for FOR var=startValue to endValue step stepValue { code here } \r\n\r\nhere we define k as global (but erased after module  or function ends running)\r\n\r\nset k=50\r\nfor k=k to 10 {   'here we have a new k that read the only known k, the global k\r\n      print k           'here interpreter choose local first\r\n}\r\nset print k     ' set command send all chars until end of line to CLI the level 0 or global for executions manual commands\r\n                        so at that level only the global variables are listed (without special name reference). Look by using LIST var references\r\n\r\nAny array and variable declaration can have Global scope. When the module that call the SET command  ends then those global variables and arrays also erased from memory.\r\n\r\nIn a module A we make a variable A so the real name is A.A (module name + point + variable name)\r\nA global variable has no module name and dot. In the right side in a assignment we read the local variable unless we create a global variable with same name. So global variables are like static but for all loaded modules, and have limited time to exist until the creator terminate action.\r\n\r\n' Let say that before we run any module we create a\r\n      a=10\r\n'Then we write edit a  (we can have a as module name and as variable)\r\n' we put this\r\n      set push &a\r\n      read &b\r\n      b=100\r\nWe press Esc and we run this module\r\n      a\r\nNow we print a\r\n      print a\r\n      100\r\nSecond we read and declare b the same time as a reference to a (because only a READ command can join variables and arrays)\r\nWhy? Because the SET command send PUSH &a to CLI so in the stack (same as for Module a)  a reference to variable \"a\" stay for a read command. Now we put 100 to b but the memory for b is the memory of global a. So when we leave from module a, only the reference to the global variable \"a\" lost, and the name b for that reference, but not the global a (that was declare before the module run).\r\n\r\na++  can be used for global variables\r\na--\r\na+=100\r\na-=100\r\na*=2\r\na/=5\r\na-!\r\n\r\n\r\n
GR:ΘΕΣΗ\r\n\r\nAbsolute moving without drawing, in twips.\r\nMOVE 1000,1000\r\nMOVE 3000\r\nMOVE ,5000\r\n\r\ncurrent cursor at POS.X, POS.Y (read only variables)\r\nLeft top point at 0,0\r\n\r\nRight Bottom point at X.TWIPS, Y.TWIPS (or SCALE.X, SCALE.Y)\r\n\r\n\r\n\r\n
GR:ΘΕΣΗ(\r\nPrint Instr(\"12345\", \"2\")\r\n      2\r\nPrint Instr(\"ΑΒΓΔΕΑΒΓΔ\",\"Α\",2)\r\n      6\r\n\r\n\\\\ Using 8bit/char strings, make them with Str$(string expression), using Locale\r\nLocale 1033\r\nSearch$ = Str$(\"aetabetAbet\")\r\nKeyword$ = Str$(\"bet\")\r\nPrint instr(Search$, Keyword$ as byte)=5\r\nPrint instr(Search$, Keyword$, 6 as byte)=9\r\nPrint instr(Search$, Keyword$, 1 as byte)=5\r\n\\\\ now we get UTF-16LE\r\nSearch$ = \"aetabetAbet\"\r\nKeyword$ =\"bet\"\r\nPrint instr(Search$, Keyword$)=5\r\nPrint instr(Search$, Keyword$, 6)=9\r\nPrint instr(Search$, Keyword$, 1)=5
GR:ΘΕΣΗ.Υ\r\n\r\nMove 3000,5000\r\nPrint pos.y\r\n         5000\r\nPrint the current Y position in graphics coordinates in current layer
GR:ΘΕΣΗ.Χ\r\nMove 3000,5000\r\nPrint pos.x\r\n         3000\r\nPrint the current X position in graphics coordinates in current layer
GR:ΘΕΣΗ_μεταβλητή\r\n\r\nPrint \"ΑΒΓΔΕ\", pos\r\nPrint pos
GR:ΘΕΣΗΔΕΞΙΑ(\r\n\r\na$=\"12345612345612345\"\r\nn=Rinstr(a$,\"34\") ' search from right\r\nm=len(a$)+1\r\nWhile n>0 {\r\n      Print n  ' chars from left\r\n      Print Mid$(a$, n)\r\n       n=Rinstr(a$,\"34\", m-n)  ' second parameter as chars form right\r\n}\r\n\r\nn=Rinstr(a$,\"34\")  ' search form right\r\nWhile n>0 {\r\n      Print n  ' chars from left\r\n      Print Mid$(a$, n) \r\n       n=Rinstr(a$,\"34\", -n)  'chars from left (using negative number)\r\n}\r\n\r\n\\\\ works for Ansi\r\nLocale 1033\r\nSearch$ = Str$(\"aetabetAbet\")\r\nKeyword$ = Str$(\"bet\")\r\nPrint rinstr(Search$, Keyword$ as byte)=9\r\nPrint rinstr(Search$, Keyword$, 1 as byte)=9\r\nPrint rinstr(Search$, Keyword$, 2 as byte)=5\r\n\r\nSearch$ = \"aetabetAbet\"\r\nKeyword$ =\"bet\"\r\nPrint rinstr(Search$, Keyword$,1 )=9\r\nPrint rinstr(Search$, Keyword$,2 )=5\r\n\r\n\r\n
GR:ΙΔΙΟΤΗΤΑ\r\nProperties are groups inside group which return value\r\n1)  Make a property in a group for read only from outside \r\n name$ is read only, but has a private variable [name]$, and can change value\r\n property item has no ++ or -- operator like variable X\r\nGroup Alfa {\r\n      X=10\r\n      Property name$  {value} =\"John\"\r\n      Property item=100\r\n      Module SetNewName {\r\n            Read a$\r\n            .[name]$=a$\r\n      }\r\n}\r\n2) Make a property with a set member\r\nAlpha has two members, a Value and a Set\r\n We can't access easy parent's variables, we need to Link a parent variable/array to a new name\r\n In the example an event from parent group linked to a new name in property member value\r\nGroup Something {\r\n      Event C {\r\n            Read What$\r\n            Function {\r\n                  Print What$\r\n            }\r\n      }\r\n      Property Alpha {\r\n            Value {\r\n                  Link Parent C to C\r\n                  If Alpha>300 Then Call Event C, \"High Value\"\r\n                 \\\\ value is the output variable. So if we change value we change output without changing original value.\r\n            }\r\n            Set { \r\n                  If Value>400 Then Value=400\r\n            }\r\n      } = 10\r\n }\r\nSomething.Alpha=500\r\nM=Something.Alpha  \\\\ Late Raise Event\r\nPrint M\r\n3) A property is a group. we can make anything for this group\r\nGroup Something {\r\n      Property Alpha {\r\n            Value {\r\n                  .[count]++\r\n            }\r\n            Set\r\n      } = 10\r\n      Group Alpha {\r\n           Property count {value}=0\r\n      }\r\n\r\n }\r\nSomething.Alpha=500\r\nFor i=1 to 100 : N=Something.Alpha : Next i\r\nPrint Something.Alpha.count\r\n4) Special care for properties with a name of a read only variable like Double (Double=7 by default)\r\nGroup AnyName {\r\n      Property aNumber {\r\n            Value\r\n            Set {\r\n              .[Double]<=value*2\r\n            }\r\n      }\r\n      Group aNumber {\r\n      \\\\ Because Double=7 as a constant for M2000\r\n      \\\\ macro Propery use =Double so return constant 7\r\n      \\\\ We can make property Double by hand\r\n      Private:\r\n            [Double]\r\n      Public:\r\n            Group Double {\r\n                  value { \r\n                        Link parent [double] to dbl\r\n                        =dbl\r\n                  }\r\n            }\r\n            Operator \"+=\" {\r\n                 Read N\r\n                 Link parent aNumber to a\r\n                 a=a+N\r\n            }\r\n            Function Root {\r\n                  Link parent aNumber to a\r\n                  =sqrt(a)\r\n            }\r\n      }\r\n}\r\n\r\nAnyName.aNumber=100\r\nPrint AnyName.aNumber\r\nPrint AnyName.aNumber.Double\r\nPrint AnyName.aNumber.Root()\r\nAnyName.aNumber+=1000\r\nPrint AnyName.aNumber.Double\r\n5) Properties with parameters\r\nWe can make value or set member of a property to take parameters. Here in the example we make an index as a parameter\r\nParameter list has to put in a list ( ) aftet value or and after set. \r\nClass CheckProperty {\r\nPrivate:\r\n      Dim Base 1, A(3)\r\nPublic:\r\n      \\\\ we make a property as readonly if we make only the value part\r\n      \\\\ (parts are value and set, as functions)\r\n      \\\\ using value  and a list of names (id1, id2,...)  we can make parameters for properties\r\n      Property Name$ {value}=\"CheckProperty\"\r\n      \\\\ a property is a group and we can make properties too\r\n      Group Alfa {\r\n            Property Name$ {value}=\".Alfa(index) - ReadOnly\"\r\n      }\r\n      \\\\ Property make [Alfa] as private variable - no use for here\r\n      Property Alfa {\r\n            Value (index) {\r\n                  Link parent A() to A()\r\n                  Try Ok {\r\n                        value=A(index)\r\n                  }\r\n                  Flush Error\r\n                  If not Ok then Error \"Index out of limits \" \r\n            }\r\n      }\r\nClass:\r\n      Module CheckProperty {\r\n            .A():=100,450,1890\r\n      }\r\n}\r\n\r\nM=CheckProperty()\r\n\\\\ Now M has a read only property Alfa() with one parameter\r\nPrint M.Alfa(1), M.Alfa(2),M.Alfa(3)\r\nPrint M.Alfa.Name$\r\nTry Ok {\r\n      Print M.Alfa(10)\r\n}\r\nPrint \"My name is:\";M.Name$\r\nIf not Ok then Print \"Error\"+Error$\r\n\r\n
GR:ΙΔΙΟΤΗΤΑ$(\r\nWe can make a link to property (with no parameter) in an array or an inventory.\r\nProperty$() used for properties that return or read string\r\nProperty() used for properties that return or read anything but string\r\n\r\nIn the example we make property \"title\" as a link to m$, or using property$() \r\nIf property has a parameter then we use an array name propname$(), so we get property using propname(), without parameter\r\n\r\n\r\ntitle \"\",0\r\ndeclare form1 form\r\nWith form1, \"title\" as title$\r\ndim a$(10)\r\na$(1)=property$(title$)\r\nlink title$ to m$\r\nfunction form1.about {\r\n      about \"help1\",\"bla bla\"\r\n      m$=\"help open\"\r\n}\r\nfunction form1.click {\r\n      a$(1)=\"new title\"\r\n}\r\nmethod form1, \"show\",1\r\ndeclare form1 nothing\r\ntitle \"back again\", 1
GR:ΙΔΙΟΤΗΤΑ(\r\nSee Property$()
GR:ΙΔΙΟΤΗΤΕΣ\r\nProperties for printers have a lot of things to take one  by one and store for later use\r\nThis is a way to get the printer properties in a string. and then to restore them back.\r\n\r\nB$=PROPERTIES$\r\nPRINTER !  ' we change the properties here\r\nA$=PROPERTIES$  ' we store the new properties\r\nPROPERTIES B$\r\nPRINTER !  ' now we return to the old set of properties\r\n\r\n
GR:ΙΔΙΟΤΗΤΕΣ$\r\n\r\nb$=PROPERTIES$\r\nwe can save printer properties in a string.\r\nwe can use PROPERTIES command to setup again the saved properties.\r\n\r\nthis is an example...we save old properties values in b$\r\nthen we open the printer properties dialog\r\nwe get new setup in A$\r\nwe set back the old properties from B$\r\nthen we open the printer properties dialog to see only the change.\r\n\r\nB$=PROPERTIES$\r\nPRINTER ! \r\nA$=PROPERTIES$\r\nPROPERTIES B$\r\nPRINTER ! 
GR:ΙΣΧΝΗ$(\r\n\r\nweak$() return a string with a weak reference For functions return a copy of function code and if it is a member of group, at the end of string is the weak reference to group\r\nIs the only way to make a reference to array item\r\n\r\nDim A(20)=10\r\nPrint A()\r\nA(2)+=10\r\nPrint A(2)\r\n\\\\ expression X-1 evaluated before weak reference produced\r\nX=3\r\na$=Weak$(A(X-1))\r\nPrint Eval(a$)\r\na$.+=20\r\nPrint Eval(a$)\r\nPrint A(2), A(2)=Eval(a$)\r\nPrint a$\r\nM=100\r\na$=Weak$(M)\r\na$.+=20\r\nPrint Eval(a$)\r\nPrint a$\r\n\r\n\r\nAnother example\r\n\r\na$=\"{=1000*number+number}\"\r\n\\\\ a$ is a weak reference to anonymous function in a string (has a block {} inside)\r\n\\\\ actually a weak reference to function is a copy of code and sometimes there is\r\n\\\\ a weak reference to object (if it is group member)\r\nLink weak a$ to aa()\r\nPrint aa(10,-100)\r\nm=300\r\nb$=weak$(m)\r\n\\\\ b$ is a weak reference to m\r\nLink weak b$ to d\r\nPrint d\r\nd+=5000\r\nPrint m, m=d, Eval(b$)\r\n\\\\ using a dot in string variabe, interpreter expect a weak reference\r\nb$.+=500\r\n\\\\ we can use dot in Eval() but is optional\r\n\\\\ in Eval$() is not optional because without dot return the string not the reference string\r\nPrint m, m=d, Eval(b$.)\r\n\r\n
GR:ΚΑΘΑΡΟ\r\nCLEAR\r\nclear all variables and arrays.\r\n\r\nWe can clear statics (so x in example next time get 10)\r\nWrite this in module a (Edit a and then Copy). Every time we execute A we get values from variables z, N and x.\r\nmodule alfa {\r\n      static z=10\r\n      N=20\r\n      module beta {\r\n            static x=10\r\n            x++\r\n            Print x\r\n            if x>=15 then clear  \\\\ clear local static/variables\r\n      }\r\n      beta\r\n      Print z, N\r\n      z++\r\n}\r\nalfa\r\n\r\n\r\nExample for deconctruction in objects\r\nclass alfa {\r\n\tremove {\r\n\t\tprint \"ok\"\r\n\t}\r\n}\r\nk->alfa()\r\n\\\\ clear k engage remove if k is the last pointer to object\r\nclear k\r\nk->alfa()\r\n\\\\ now module end execution\r\n\\\\ so remove engage automatic
GR:ΚΑΘΕ\r\nEvery 100 {\r\n\r\n}\r\nIf block of code need more time then it takes. The block isn't run on a thread, and using a \"wait\" mechanism that threads allowed to run. For better results (about time synchronization) use Main.Task because is a thread, and as all threads is running in background. If threads are running in background then maybe Every can't run commands in the own block of commands.\r\n\r\nYou can nest Every but the inside Every must have If ... Then Exit if we want to get out.\r\n\r\n\r\ncopy this example in a module\r\nRefresh 5000\r\ndesktop 100\r\nd=100\r\nwindow 12,0\r\ncls, height-10\r\ngradient 2,7\r\ni=0\r\nlegend$={this is Verdana Font 20pt\r\n\r\n}  ' this is a multiline assigment\r\nmyangle = pi\r\nbb=0\r\nthread {\r\n            Refresh 5000\r\n            d+=5\r\n            if d<256 then desktop d\r\n            if i<2000 then i+=25\r\n            gradient 2,7\r\n            print @(0,0)\r\n            double : bold : report 2,\"M2000 example using Thread\" : bold : normal\r\n            move i,i*2\r\n            draw to 6000,6000+i\r\n            draw to 8000+i,4000+i\r\n            move mouse.x, mouse.y\r\n            draw angle myangle, 2000\r\n            circle 300\r\n            draw -2000, 2000\r\n            step -400,-400\r\n            legend legend$+ str$( now,\"hh:mm:ss\"),\"VERDANA\", 20, pi/4+myangle\r\n            cls\r\n            print mouse.x, mouse.y, @(tab(3)),time$(now), str$( now,\"hh:mm:ss\"), myangle\r\n            list\r\n            refresh\r\n                  if keypress(38) then {\r\n                        myangle += pi/8\r\n                  } else.if keypress(40) then {\r\n                        myangle -= pi/8\r\n                  }\r\n} as main interval 200\r\naa=0\r\nevery 100 {\r\naa++\r\nif mouse then exit\r\n}\r\ndesktop 255\r\nrefresh 50 \r\n\r\n\r\n\r\n\r\n\r\n\r\n
GR:ΚΑΘΕ(\r\nIterator for objects (not for group)\r\n1)\r\n  N=EACH(A)\r\n2)\r\n  N=EACH(A, 1,3)\r\n3)\r\n  N=EACH(A START TO END)\r\n  \r\n  \\\\ FOR 1,2,3\r\nWhile N {\r\n      Print  N^   \\\\ return number of N cursor\r\n}\r\n\r\nFor step we can reprogram N inside While loop, using a new Each(N, N^+2, -1) \r\nEach Iterator has own cursor, so we can fold two or more for same object\r\n\r\nObjects for A: Array, Inventory, Stack\r\n
GR:ΚΑΙ\r\nOperator AND\r\n\r\nPrint True And False
GR:ΚΑΛΕΣΕ\r\n1) CALL [VOID] [FUNCTION] NAME [parameter list]\r\nClear \\\\ erase all variables\r\nFlush \\\\ Flush Stack for values\r\nFunction Our {\r\n      Read a,b,c,d\r\n      Print b,c,d\r\n      If a=1 Then {\r\n            =0\r\n      } Else {\r\n            =1 \r\n      }\r\n}\r\n\\\\ using Void to drop return value (if any)\r\nCall Void Function Our(0,2,3,4)\r\nCall Void Function Our 0,2,3,4\r\nCall Void Function Our, 0,2,3,4\r\nTry Ok {\r\n      Call Our(0,2,3,4)\r\n}\r\nIf Not Ok Then Print Error$\r\na$=\"Our(\"\r\nCall a$, 1,2,3,4\r\nCall Our(, 1,2,3,4\r\nPush 4,3,2,1  ' 1 goes to top of stack\r\nCall Our(\r\nGlobal x=10\r\nModule Alfa {\r\n      Print \"Ok\", x\r\n      \\\\ here we use recursion, by using Call modulename\r\n      If x>1 Then x-- : Call Alfa\r\n}\r\nAlfa\r\n2) CALL LOCAL NAME (or String)\r\nx=10\r\nFunction alfa {\r\n      x++\r\n      Print x\r\n}\r\nCall Local alfa()  \\\\ 11\r\nCall Local \"alfa()\" \\\\ 12\r\nFunction beta {\r\n      local x=1000\r\n      Call Local alfa()\r\n}\r\nCall Local beta()  \\\\ 1001\r\nCall Local alfa() \\\\13\r\nPrint x  \\\\ 13\r\nFunction delta {\r\n      Read New &x\r\n      Call Local alfa()\r\n}\r\nm=1233\r\nCall Local delta(&m) \\\\ 1234\r\nPrint m \\\\ 1234\r\n\r\n3) When module name is same as a built in command\r\n3.1) When Module is Local\r\nModule Print {      \r\n      while not empty {\r\n            read a\r\n            Print $(\"\\t\\r\\u\\e;\\t\\r\\u\\e;\\f\\a\\l\\s\\e\"), a,$(\"\")\r\n            if width-pos<tab then @print           \r\n      }\r\n}\r\nCall Print -1,0,3\r\n.Print -1, 0, 3\r\nPrint\r\nPrint -1, 0, 3\r\n\r\n3.2) When Module is Global\r\nModule Global Print {      \r\n      while not empty {\r\n            read a\r\n            @Print $(\"\\t\\r\\u\\e;\\t\\r\\u\\e;\\f\\a\\l\\s\\e\"), a,$(\"\")\r\n            if width-pos<tab then @print\r\n      }\r\n}\r\nPrint -1,0,3\r\n@Print -1, 0, 3\r\n\r\n4) Call Event   raise an event, sending parameters to all functions inside Event Object. Look about Event in Definitions.\r\n\r\n5) Call Operator  \"+\"    (we can pass a parameter, a group, or leave it before in stack). \r\n This  Call can be used only in modules, functions, operators in a Group.
GR:ΚΑΜΠΥΛΗ\r\nBezier Curves. Two variations, one with polar coordinates\r\n1) Curve X1,Y1......XN, YN\r\n      CURVE 1000,1000,0,2000,500,1000\r\n      pos.x advance to 1000+0+500 = 1500 twips right\r\n      pos.y advance to 1000+2000+1000=4000 twips left\r\n2) CURVE ANGLE angleRad1, DistanceTwips1,angleRad2, DistanceTwips2,angleRad3, DistanceTwips3, angleRad4, DistanceTwips4\r\n\r\nExample1:\r\n                  CLS,0   \\\\ current background color and reset split screen to start from top\r\n                  MOVE 5000,5000\r\n                  PEN 1\r\n                  FOR Q=PI/8 TO 2*PI STEP PI/8 {\r\n                        MOVE 5000,5000\r\n                        PATH 8 { CURVE ANGLE PI/3+Q,500,PI/4+Q,3000,PI+Q,2000 }\r\n                  }\r\n                  PEN 15\r\nExample2:\r\n                  CLS,0\r\n                  MOVE 5000,5000\r\n                  PEN 1\r\n                  FOR Q=PI/8 TO 2*PI STEP PI/8 {\r\n                        MOVE 5000,5000\r\n                        PATH ! 2 {\r\n                               CURVE ANGLE PI/3+Q,500,PI/4+Q,1000,PI+Q,2000,PI/3+Q,500,PI/4+Q,100,PI+Q,1000 \r\n                              }\r\n                  }\r\n                  PEN 15\r\nExample3:\r\n                  CLS,0\r\n                  MOVE 5000,5000\r\n                  PEN 1\r\n                  FOR Q=PI/8 TO 2*PI STEP PI/8 {\r\n                        MOVE 5000,5000\r\n                        PATH RANDOM(7,15) {\r\n                              CURVE ANGLE PI/4+Q,500,PI/Q,1000,PI*1.3+Q*Q,1000,PI/Q,500,PI/2+Q/2,1000,PI*1.3+Q,4000\r\n                        }\r\n                  }\r\n                  PEN 15\r\n
GR:ΚΑΝΕ\r\n1) Def Currency A, B, C\r\n for numbers\r\n  Decimal, Double, Single, Currency, Long, Integer, Boolean\r\n  all variables are local. If a local exist before def command then error happen.\r\n  these variables have auto conversion when assign new value\r\n  for strings\r\n  String\r\n  \r\n  Def a=0&, b=10#, c=20~, d=2%, e=1000@\r\n\\\\  long currency single integer decimal\r\n  Print Type$(a), Type$(b), Type$(c), Type$(d), Type$(e)\r\n  \r\n \\\\ we can use as type to give number, or special char\r\n \\\\ d get Long as the type of anything else without specific type\r\n \\\\ a Def without type is a Def Double\r\ndef long a=10, b=20, c as double=30, d=40, e=1000@\r\nPrint Type$(a), Type$(b), Type$(c), Type$(d), Type$(e)\r\n  \r\n  \r\n2) DEF A(X)=X**2 : DEF A$(X$)=X$+X$\r\nPRINT A(100), A$(\"00\")\r\n\r\nWe can make functions like old basic, but internally they are normal functions:\r\nFunction A {\r\n      Read X\r\n      =X**2\r\n}\r\nFunction A$ {\r\n      Read X$\r\n      =X$+X$\r\n}\r\n\r\n
GR:ΚΑΝΟΝΙΚΑ\r\n\r\nrevert the command DOUBLE\r\n\r\nNow each row in console occupy one row.\r\n\r\n
GR:ΚΑΤ$\r\n\r\nPrint Dir$\r\n\r\nPrints current directory\r\n\r\nWe can change with DIR statement\r\n\r\nIn a user directory we get a fake root as \".\"\r\nand that dot is usable in that directory.\r\nwe ca return to user folder using dir command\r\ndir user\r\n
GR:ΚΑΤΑΛΟΓΟΣ\r\n\r\nset the current directory to user dir\r\nDIR USER \r\n\r\nset any\r\nDIR \"C:\\\"\r\n\r\nset relative , use ..\\ or ..\\..\\ or more to go up one or more time then go down to this folder\r\nIf we omit the last slash, automatic putting by the command\r\nDIR \"..\\this\"\r\n\r\nOpen dialog (using top folder the previous topfolder or the user dir)\r\nDIR ? \r\n\r\nOpen dialog and we can put a new folder\r\nDIR ? \"?\"\r\n\r\nOpen dialog and we can set top folder\r\nDIR ? \"C:\\\"\r\n\r\nOpen dialog and set top folder and set a caption and we can put a new folder\r\n\r\nDir ? \"C:\\?\" , \"For Output\"\r\nor with two lines \r\nDIR {For Output\r\n------------- } ? \"C:\\?\"\r\n\r\nIn any combination we can use TO S$ for store the path in a variable and not make that the current directory\r\n\r\n' We can't open twice the file/folder selector but \r\n' when we open dialog threads allowed to run in background\r\n' Statement TRY is for error trapping. If error occur in the block after TRY then the variable (here OK) get 0 or FALSE.\r\n' OK is a variable that TRY make (TRY make new variable as READ do, numeric only)\r\n\r\nDIR USER\r\nAFTER 200 {\r\n      PRINT \"CHECK\"\r\n      TRY OK {\r\n                  DIR ?\r\n      }\r\n      IF NOT OK THEN PRINT ERROR$\r\n}\r\nDIR ?\r\n\r\n\r\n\r\n
GR:ΚΑΤΑΣΤΑΣΗ\r\ninventory is an object with keys or keys and values.\r\n\r\n\\\\ keys can be numeric or and strings\r\ninventory alfa = 1,2,3,4:=\"value\",5\r\nprint exist(alfa, 1)  \\\\ true\r\nprint exist(alfa, 100) \\\\ false\r\nappend alfa, 100\r\nprint exist(alfa, 100) \\\\ true\r\ndelete alfa, 3\r\nprint exist(alfa, 3) \\\\ false\r\nprint alfa(1) \\\\ 1 return key\r\nreturn alfa, 1:=1000\r\nprint alfa(1) \\\\ 1000 return value\r\nappend alfa, \"a string\":=\"ok\"\r\nappend alfa, \"func\":=lambda->{=number**2}\r\nfor i=0 to len(alfa)-1 {\r\n      print format$(\"pos. {0} key {1}\",i,eval$(alfa,i))\r\n}\r\nprint alfa(\"func\")(2)  \\\\ 4\r\nfor this {\r\n      \\\\ temp deleted after \"for this\"\r\n      group temp {X=10,Y=30}\r\n      append alfa,3:=temp\r\n}\r\nprint alfa(3).x   \\\\10\r\n\\\\ alfa(3) means item with key 3 in inventory alfa\r\nfor alfa(3) {\r\n      print .x, .y  \\\\10  30\r\n}\r\nalfa(3).x++\r\nprint alfa(3).x   \\\\11\r\ndim a(30)=100\r\nappend alfa, \"array\":=a()\r\nprint alfa(\"array\")(29)  \\\\ 100\r\nprint type$(alfa(3))  \\\\Group\r\nprint type$(alfa(\"array\"))  \\\\ mArray  (object for arrays)\r\nprint type$(alfa(\"func\"))  \\\\ lambda  (object for lambda function)\r\n\\\\ we can copy an item from inventory\r\nm=alfa(\"func\")\r\nprint m(2) \\\\ 4\r\ng=alfa(3)\r\nprint g.x  \\\\11\r\ndim k()\r\nk()=alfa(\"array\")\r\nprint k(29)\r\n\\\\ note the $ after name alfa\r\ns$=alfa$(\"a string\")\r\nprint s$   \\\\ ok\r\n\\\\ this a two stage command\r\n\\\\ first we call exist\r\n\\\\ second we read absolute position\r\n\\\\ positions changed if we delete something\r\n\r\nif exist(alfa,\"func\") then k=eval(alfa!): print k  \\\\ 6\r\nif valid(k) then print eval$(alfa,k)  \\\\ func\r\n\r\ngroup beta {\r\n      inventory m\r\n      x=10\r\n}\r\nbeta.m=alfa\r\ndim a(100)=beta\r\na(0).x+=10\r\n\\\\ property (variable) x is different for each group in array\r\nprint a(0).x, a(1).x  \\\\ 20, 10\r\nprint a(0).m(\"array\")(0)  \\\\ 100\r\na(0).m(\"array\")(0)+=1000\r\n\\\\ inventory m is common for all groups in array and for beta\r\nprint a(0).m(\"array\")(0)  \\\\ 1100\r\nprint a(1).m(\"array\")(0)  \\\\ 1100\r\nprint beta.m(\"array\")(0)  \\\\ 1100\r\ndim copyA()\r\ncopyA()=a()\r\na(0).m(\"array\")(0)+=1000\r\na(0).x=12345\r\nprint copyA(0).m(\"array\")(0) \\\\2100\r\nprint copyA(0).x \\\\ 20  - no common\r\ninventory AnEmptyOne\r\nbeta.m=AnEmptyOne\r\nprint len(beta.m) \\\\ 0 items\r\n\\\\ only reference for beta.m changed\r\nprint len(copyA(0).m) \\\\ 9 items\r\n\r\n\r\n\r\n\r\n\\\\ example 2\r\nFlush\r\nClass Alfa {\r\n      Private:\r\n            Inventory M\r\n      Public:\r\n            Module Alfa {\r\n                  Dim  A(20)\r\n                  Append .M, \"North\":=A(), \"East\":=A(), \"South\":=A(), \"West\":=A()\r\n                  Append .M, \"North.Cursor\":=0, \"East.Cursor\":=0, \"South.Cursor\":=0, \"West.Cursor\":=0\r\n            }\r\n            Module PutValue {\r\n                  Read Where$, A%, V\r\n                  If Exist(.M, Where$) then {\r\n                        .M(Where$)(A%)=V\r\n                        Return .M, Where$+\".Cursor\":=A%\r\n                  }\r\n            }\r\n            Function ReadCurValue {\r\n                  Read Where$\r\n                  If Exist(.M, Where$) then {\r\n                        =.M(Where$)(.M(Where$+\".Cursor\"))\r\n                  }\r\n            }\r\n            Module TestMe {\r\n                  Print Dimension(.M(\"East\"),1)\r\n            }\r\n}\r\nB=Alfa()\r\nB.PutValue \"East\", 2, 1233\r\nPrint B.ReadCurValue(\"East\")\r\nB.Testme\r\n\r\n\\\\example3\r\nFunction B$ {\r\n      Dim A$(10)=\"ok\"\r\n      =A$()\r\n}\r\nInventory Alfa=1:=B$()\r\nPrint Alfa$(1)(3)\r\nIf Exist(Alfa,1) then {\r\n      Print Dimension(\"Alfa$\",1)\r\n}\r\n\r\n\r\n
GR:ΚΑΤΑΣΤΑΣΗ.ΤΑΙΝΙΑΣ$\r\n? MOVIE.STATUS$\r\nwe get the movie status \r\n\r\n
GR:ΚΑΤΑΧΩΡΗΣΗ\r\n\r\nOVERWRITE\r\n1)  Use it with Piece$(), it is the reverse function, for strings and Documents\r\nA$=\"AAA.BBB\"\r\nOverwrite A$, \".\", 1:=\"Hello\",5:=\"one more\"\r\nPrint A$\r\nPrint type$(A$)\r\nDim K$(5)\r\nK$(3)=\"AAA.BBB\"\r\nOverwrite K$(3), \".\", 1:=\"Hello\",5:=\"one more\"\r\nPrint K$(3)\r\nPrint Type$(K$(3))\r\nDocument A$=\"AAA.BBB\"\r\nOverwrite A$, \".\", 1:=\"Hello\",5:=\"one more\"\r\nPrint A$\r\nPrint type$(A$)\r\nDim K$(5)\r\nDocument K$(3)=\"AAA.BBB\"\r\nOverwrite K$(3), \".\", 1:=\"Hello\",5:=\"one more\"\r\nPrint K$(3)\r\nPrint Type$(K$(3))\r\n\r\n\r\n2) Document a$, b$\r\na$={aaaaaaaaaaa\r\n      12345678901234567890\r\n      }\r\nb$=a$\r\ninsert to 2, 10 a$={Hello\r\n      two paragraphs\r\n      }\r\nReport b$\r\nReport a$\r\nClear a$\r\nDocument a$=b$\r\ninsert to 2, 10 a$=\"Hello\"\r\nReport b$\r\nReport a$\r\nClear a$\r\na$=b$\r\nOverwrite 2,10 a$=\"Hello\"\r\nReport b$\r\nReport a$\r\nClear a$\r\na$=b$\r\nOverwrite 2 a$=\"Hello\"  \\\\ replace line\r\nReport b$\r\nReport a$
GR:ΚΑΤΩΜΙΣΟ(\r\n\r\n\r\nA=0xFFEE12C3\r\nPrint Hex$(LOWORD(A),2)\r\nPrint Hex$(HIWORD(A),2)\r\n\r\nHEX LOWORD(A),  HIWORD(A)\r\n\r\nAlso use Lowword() as LoWord()
GR:ΚΕΙΜΕΝΟ\r\nSave or Append formatted text (we can pass variables) to a file in temporary folder as log or html for browser.\r\n\r\nFrom 7 edition there are 2 modifiers,\r\nutf-8 and utf-16  by default  (without modifier we save in ANSI)\r\nText utf-8 name.txt {line 1\r\n}\r\n\r\n1)  \r\n1,1 Using a variable  (also can be used that type in 2,3,4,5\r\na$=\"alfa.txt\"\r\nTEXT alfa.txt { lines of text\r\nsecond line}\r\na file alfa.txt is created to temporary$ (the %temp% folder)\r\n1.2 using a filename inline\r\nTEXT alfa.txt { lines of text\r\nsecond line}\r\na file alfa.txt is created to temporary$ (the %temp% folder)\r\n\r\n2)TEXT alfa.txt + { lines of text\r\nsecond line}\r\nwe can append lines\r\n\r\nExample for 1 & 2\r\n-----------------------\r\n            alfa$=\"ok\"\r\n            b=1\r\n            text t123.txt {First line, we write some variables here \"##alfa$##\", ##b##\r\n                  Second Line\r\n                  Third Line. Text Command insert a CRLF to the last line\r\n                  }   '  from last bracket position excluded the leading spaces from second line and after\r\n            text t123.txt + {We append some lines here\r\n                  And that line too\r\n                  }  '  from last bracket position excluded the leading spaces from second line and after\r\n            ' Now we can look if file exist\r\n            ' temporary files are deleted at the program end\r\n            print exist(temporary$+\"t123.txt\")\r\n            ' \r\n            open temporary$+\"t123.txt\" for input as k\r\n            while not eof(k) {\r\n                  line input #k, a$\r\n                  report a$     ' display line as paragraph here\r\n            }\r\n            close #k\r\n            text t123.txt ' we erase the file\r\n\r\n3) We can write html files and open with BROWSER (no example here)\r\nso we can replace TEXT to HTML and not provide type (provided automatic)\r\n\r\n4) We can set up html forms and we get parameters in variables/\r\n\r\nWe use a simple statement like this:  while onoma$=\"\"  {refresh}\r\nFor waiting the \"send\" button to send information back to us\r\nBelow in the example we make a variable username$ with a value. We have in the text below this ##username$##. This will replaced by the value of username$ before saving to a temporary file.\r\nM2000 take the sending string from  page and make variables (if no name found) and assign to them values .\r\npassword$ is a variable who created when  while loop (above) exit. And exit the loop because the variable onoma$ take a value.\r\nThis is a very old code (more than 10 years) but can run well. The meta tags are for joke. And the title also never displayed.\r\n\r\nPut this in a module\r\n\r\nshow\r\nusername$ = \"George\" \r\ntext alfa.html {<!doctype html public \"-//w3c//dtd html 3.2//en\">\r\n                  <html>\r\n                  <head>\r\n                  <title>(Type a title for your page here)</title>\r\n                  <meta name=\"GENERATOR\" content=\"M2000\">\r\n                  <meta name=\"FORMATTER\" content=\"M2000\">\r\n                  <meta content=\"this, other, that\" name=keywords>\r\n                  <meta content=All name=robots> \r\n                  <meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=windows-1253\">\r\n                  <meta NAME=\"Author\" CONTENT=\"GEORGE KARRAS\">\r\n                  <style type=\"text/css\">\r\n                  body {\r\n                      overflow:hidden;\r\n                  }\r\n                  </style>\r\n                  </head>\r\n                  <body bgcolor=\"CYAN\" text=\"#000000\" link=\"#0000ff\" vlink=\"#800080\" alink=\"#ff0000\">\r\n                  <CENTER>This is an Html  form</CENTER></H1><HR>\r\n                  <script> var m1;var p1;var total;function alfa() { total=\"?onoma=2000\";total=total+\"&username=\"+escape(m1);total=total+\"&password=\"+escape(p1);document.title=total;setTimeout (\"alfa()\",100);return true}</script>\r\n                  <FORM NAME=\"ValidForm\" action=\"about:blank\" >\r\n                  <INPUT NAME=\"onoma\" TYPE=\"HIDDEN\" MAXLENGTH=4 SIZE=\"4\" VALUE=\"1000\">\r\n                  <TABLE ALIGN=CENTER BORDER=0 RULES=NO COLS=\"2\">\r\n                  <TBODY>\r\n                  <TR VALIGN=TOP  >\r\n                  <TD  >User name:</TD>\r\n                  <TD  ><INPUT NAME=\"username\" TYPE=\"TEXT\" id=\"uname\" MAXLENGTH=16 SIZE=\"16\" VALUE=\"##username$##\" ></TD>\r\n                  </TR>\r\n                  <TR VALIGN=TOP  >\r\n                  <TD  >This is our password:</TD>\r\n                  <TD  ><INPUT NAME=\"password\" ID=\"pass\" TYPE=\"PASSWORD\" MAXLENGTH=8 SIZE=\"8\"></TD>\r\n                  </TR>\r\n                  </TABLE>\r\n                  <CENTER><BR><HR>\r\n                  <input type=button value=\"Inform me\" onclick=\"m1=uname.value;p1=pass.value;alfa()\">\r\n                  </CENTER>\r\n                  </FORM>\r\n                  </body>\r\n                  </html>\r\n                  } '  from last bracket position excluded the leading spaces from second line and after\r\nonoma$=\"\"\r\nbrowser alfa.html\r\nwhile onoma$=\"\"  {refresh}\r\nlist\r\nbrowser \"\"\r\ntext alfa.html  ' delete the temporary file\r\nPrint \"ΟΚ\" \r\n\r\n5) text alfa.html\r\ndelete file in temporary$\r\nWe can delete any file in temporary$ (%temp%) if we write simple the name of it after text.  M2000 has no direct delete command except for  the temporary folder.\r\n
GR:ΚΕΙΜΕΝΟ_σταθερά\r\n\r\nText used in TABLE 
GR:ΚΕΝΟ\r\nPrint EMPTY\r\nGive true if stack is empty\r\n\r\nSTACK.SIZE=0 is equal to EMPTY\r\n\r\n
GR:ΚΕΦ$(\r\nreturn the upper case using the system locale\r\nUcase$(string expression) \r\n\r\nUcase$(string_expression, locale_number)    ' local_number apply a filter on string_expression when string has numbers on ANSI range (otherwise we get ?). The encoding is Utf-16Le in Input  and  Output string.\r\n\r\n\r\n\r\n
GR:ΚΙΝΗΣΗ\r\nPOSX and POSY are  given by us\r\n\r\nMOTION CENTER  ' we center the screen (based on the background)\r\nMOTION POSX,POSY ' we move the screen using top left corner\r\nMOTION POSX ' moving horizontal \r\nMOTION ,POSY ' moving vertical\r\n\r\nWe can read the top and left properties as motion.x and motion.y\r\n
GR:ΚΙΝΗΣΗ.Π\r\nWe can move the Window (not the layers, we can move them from PLAYER command)\r\n\r\n\r\nMOTION.W;    ' center window\r\nMOTION.W POSX,POSY  ' we place in specific left and top values\r\nMOTION.W POSX  ' Alter only X coordinate\r\nMOTION.W ,POSY ' Alter only the Y coordinate.\r\n\r\nMaybe we must call DESKTOP (if we call it before)\r\n\r\n
GR:ΚΙΝΗΣΗ.ΠΥ\r\n\r\nMotion.wy is the TOP of current form (always form is the backround in M2000)\r\nMotion.yw is the same
GR:ΚΙΝΗΣΗ.ΠΧ\r\nreturn left position of background form relative to Screen
GR:ΚΙΝΗΣΗ.Υ\r\n\r\nform 32,20;\r\nform\r\ny=motion.y\r\nform 32,20\r\nform\r\nmotion.w ,y\r\n
GR:ΚΙΝΗΣΗ.ΥΠ\r\nMotion.yw is the TOP of current form (always form is the backround in M2000)
GR:ΚΙΝΗΣΗ.Χ\r\nReturn the left position of top left point of console form (MAIN), in relative with Background\r\nAlso used in Layers (1 to 32) (in a block like  Layer 2 {}) but return relative to main\r\n\r\n
GR:ΚΙΝΗΣΗ.ΧΠ\r\nreturn left position of background form relative to Screen
GR:ΚΛΑΣΗ\r\n\r\n A class definition has a body of a Group object and produce a function which return an object. If the returned object assign to a new variable then a new object Group created. If it returns to previous defined group then we get a merge, where members with same name get value from new one, and members which are new added. If it returns to a array item, or inventory item, or stack item (at position through Return command) then only pointer change,  the old one destroyed and the new one take place just using internal a pointer to new one.\r\n\r\nOne Module with same name as the class name used as constructor function (we don't return any value because class function always return Group)\r\n\r\nName for class can be with or without $ as last character. We use $ when we have Value function to indicate to expressions evaluator that the return value is a string.\r\n\r\nWe can include a Class: part  (except of Private: and Public: parts), and any member as class members used only from constructor, and are not included in return group. So we can make constructor, or and some class definitions inside to exist once before the final returned group.\r\nParts Class, Private, Public can be exist more than one time (interpreter use flags to track the state of those parts)\r\nIf we define Properties, then any Private state change to Public automatic. (Properties are groups in group with values, and a link to a private value in parent group.)\r\n\r\nSo we can see the definition of Group.\r\nClass functions in Module or Function body are global (until the exit of Module/Function )\r\nClass can be defined inside group and that is a Group function. Also we can make group members using class name (after definition of class) before name of member.\r\n\r\n\r\n\r\nClass Alfa {\r\nprivate:\r\n      z=10\r\n      dim alfa(10)=5\r\npublic:\r\n      X,Y\r\n      module Alfa {\r\n      read .X, .Y, .z\r\n      .X/=.Z\r\n      }\r\n      Function FillArray {\r\n            =.alfa()\r\n      }\r\n}\r\nMyGroup=Alfa(10,20, 5)\r\nfor MyGroup { \r\n      Print .X, .Y\r\n      Try { Print .z} \r\n      Try {Print .alfa(5)}\r\n}\r\nDim K()\r\nK()=MyGroup.FillArray()\r\nPrint K(3)\r\n\r\n\\\\ Remove (deconstructor) function\r\nGlobal RefAlfa=0\r\nClass Alfa {\r\n      id\r\n      Remove {\r\n            Print \"Remove\"\r\n            RefAlfa--\r\n      }      \r\n  Class:\r\n      module Alfa (.id){\r\n            RefAlfa++\r\n      }\r\n\r\n}\r\nA->Alfa(3)\r\nz->A\r\nPrint refAlfa=1\r\nClear A\r\nPrint refAlfa=1\r\nClear Z\r\nPrint refAlfa=0\r\n
GR:ΚΛΕΙΔΙ\r\nfunction keys F1 =1 to F12=12 and shift+F1 =13 to shift+ F12=24\r\n\r\n1) FKEY 1,\"Help\"\r\n FKEY 1 { commands }\r\n   set a function key\r\n2) FKEY 1\r\n      return key definition\r\n3) FKEY\r\n      return list of Functions Keys (only those with a setting)\r\n4) FKEY CLEAR\r\n     erase all functions keys\r\n5) FKEY 1 ,\"\"\r\n FKEY 1 {}\r\n Clear FKEY
GR:ΚΛΕΙΣΕ\r\n\r\n\r\nCLOSE variable_as_file_handle\r\nCLOSE variable_as_file_handle1, ..., variable_as_file_handleΝ\r\n\r\nCLOSE no parameter close all file and database connections\r\nCLOSE BASE base_name$ [, base_name2$]\r\nwe can close connections by base name.\r\n\r\nhandles can be from 1 to 511\r\nhandles provided from OPEN statement, when we give a variable as file handler.\r\nSo we don't choose number\r\n\r\nWe can use # in front of a variable.\r\nClose #f\r\nor\r\nClose f \r\nis equal
GR:ΚΛΙΜΑΞ.Υ\r\nReturn Layer/Main/Background height size in twips\r\nsame as y.twips
GR:ΚΛΙΜΑΞ.Χ\r\nReturn Layer/Main/Background width size in twips\r\nsame as x.twips
GR:ΚΟΙΝΕΣ ΦΟΡΜΕΣ\r\nCOMMON DIALOGUES\r\nCHOOSE.COLOR, CHOOSE.FONT, DIR, OPEN.FILE, OPEN.IMAGE, SAVE.AS, SETTINGS, SUBDIR, TITLE\r\n\r\n
GR:ΚΟΜ$\r\na$=key$\r\nwait for a key to pressed.\r\nif environment is hide then it showing again.\r\n
GR:ΚΟΝΣΟΛΑ\r\nWhen we use USER mode this command return an error.\r\n\r\n1) dos [, sleep time after call cmd.exe]\r\n    just open the cmd window\r\n\r\n2) dos \"command\" [, sleep time after call cmd.exe]\r\n     Execute the command and cmd window stay opened\r\n\r\n3)  dos \"command\" [, sleep time after call cmd.exe];\r\n     no window open.\r\n\r\n
GR:ΚΡΑΤΗΣΕ\r\n\r\nWe can hold the screen output (only the main screen, not layers, no the background),  and we can alter the screen and then we can release again. Graphic cursors, colors (pen and background) can't hold. We can do nice things with moving things on screen. We can release (with command RELEASE) put some sprites with SPRITE command and then use the REFRESH 0 to refresh display. That is a small sprite engine with software sprites. You can use \"hardware\" sprites, using PLAYER command. You can use both without problem (sprites \r\n\r\nHOLD\r\n\r\n(There is a HOLD mark for Threads  as part of other commands)\r\n
GR:ΚΡΥΦΟ$(\r\nA cryptography function\r\nM$=Hide$(\"alfabeta\", \"mycode\", 100)\r\nPrint M$\r\nPrint Show$(M$, \"mycode\", 100)
GR:ΚΥΚΛΙΚΑ\r\n\r\nLOOP is a command that change the state of a block of code and has effect when a block of code end. So one loop command is enough to change the state of a block of code (in curly brackets). The next time that block run has a non loop state, so if loop command is shadowed then the block at the end exit.\r\ni=0\r\n{ if i<100 then loop\r\n      print i\r\n      i++\r\n}\r\n\r\n\r\nYou can use If condition Then Exit to leave a looping block. A Continue in a loop stated block act as a restart. A Restart is a jump to first line of block.\r\ni=0\r\n{i++\r\n      print i\r\n      if i>100 then exit\r\n      loop\r\n}\r\n\r\n\r\nAvoid to use LOOP in a thread, because threads are run in intervals so they are already in a loop time based.\r\n\r\nThe strength of this command can delivered when we need a multicondition block to run again, so different If choose the Loop command, some other the exit command, some other the continue command\r\n\r\n\r\nI=0\r\n{\r\nI++\r\nIF I<100 THEN LOOP    ' WE SET A LOOP CONDITION HERE\r\nPRINT \"LOOP CONDITION CHECKED IN THE END OF THE BLOCK\"\r\n}\r\nPRINT I\r\n\r\nI=0\r\n{\r\nI++\r\nIF I<100 THEN RESTART    '  THIS IS A COMMAND\r\nPRINT \"THIS PRINT ONLY ONE TIME AT THE END\"\r\n}\r\nPRINT I\r\n\r\n\r\n\r\n
GR:ΚΥΚΛΟΣ\r\nMake a circle at current graphic position\r\n\r\nCIRCLE radiusInTwips, ratio, borderColor, fromStartAngle, tofinishAngle\r\n\r\nCIRCLE FILL color2fill, radiusInTwips, ratio, borderColor, fromStartAngle, tofinishAngle\r\n\r\n      Ratio 1 is circle, but <1 or >1 is eclipse. \r\n      graphic cursor unchanged\r\n\r\n\r\n\r\n\r\n\r\n
GR:ΚΥΛΙΣΗ\r\n\r\nSCROLL UP\r\nSCROLL DOWN\r\nSCROLL SPLIT 5\r\n\r\nCLS ,5 'same except the CLS clear the bottom scrolling part of screen.\r\n\r\nWe can define a layer and scroll it by moving, but here the scrolling is text only, and for rows.\r\n\r\nWhen we REPORT a multiline text, or in MODULES or FILES or same type commands that print multiple lines of text , there is a stop scrolling auto function that wait us to press a key or click the screen to scroll more lines.\r\n\r\nMultiline text can assign by using {}\r\nso\r\nA$={first line\r\n      second line\r\n      third lines\r\n      }\r\n      ' last bracket defines the indent of spaces that not included in the variable\r\n      REPORT A$\r\nOutput:\r\nfirst line\r\nsecond line\r\nthird lines      
GR:ΚΥΡΙΟ.ΕΡΓΟ\r\n\r\nMAIN.TASK 100 {\r\n\r\n}\r\n\r\nLike EVERY but this is a thread so it has time to run as other threads. We can EXIT or perform asn ESC to exit from this. We can't have nested MAIN.TASK in a module.\r\n
GR:ΚΩΔ(\r\n\r\nPrint ASC(\"A\")  \r\nreturn ascii code\r\nSee CHRCODE() 
GR:ΚΩΔΙΚΟΣΕΛΙΔΑ\r\nPrint CodePage\r\nreturn current codepage
GR:ΛΑΒΗ\r\nJOYPAD 0,1  ' use these two joypads\r\n\r\nJOYPAD  ' with no parameters no joystick is in use\r\n\r\nFour functions can be used for joypads\r\n\r\nPrint Joypad(0)  ' read all buttons in onw binary number\r\nPrint Joypand.direction(0) \r\none of that\r\n    DirectionNone = 0\r\n    DirectionLeft = 1\r\n    DirectionRight = 2\r\n    DirectionUp = 3\r\n    DirectionDown = 4\r\n    DirectionLeftUp = 5\r\n    DirectionLeftDown = 6\r\n    DirectionRightUp = 7\r\n    DirectionRightDown = 8\r\n Print Joypad.analog.X(0) , joypad.analog.Y(0)\r\n you have to calibrate before use analog values\r\n    
GR:ΛΑΒΗ(\r\nPRINT JOYPAD(0)\r\nstatus of buttons on joystick 0. Each button is a bit.
GR:ΛΑΒΗ.ΑΝΑΛΟΓΙΚΟ.Υ(\r\nPrint Joypad.Analog.Y(0)\r\nWe have to enable joypad(s) with command Joypad 0, 1 and disable by using Joypad with no parameters\r\n
GR:ΛΑΒΗ.ΑΝΑΛΟΓΙΚΟ.Χ(\r\n\r\nPrint Joypad.analog.x(0)\r\nPrint analog position of joystick.\r\nWe have to enable joypad(s) with command Joypad 0, 1 and disable by using Joypad with no parameters\r\n\r\n
GR:ΛΑΒΗ.ΚΑΤΕΥΘΥΝΣΗ(\r\nConst DirectionNone = 0  \r\nConst DirectionLeft = 1  \r\nConst DirectionRight = 2\r\nConst DirectionUp = 3 \r\nConst DirectionDown = 4 \r\nConst DirectionLeftUp = 5\r\nConst DirectionLeftDown = 6 \r\nConst DirectionRightUp = 7 \r\nConst DirectionRightDown = 8 \r\nIf Joypad.Direction(0)=DirectionRight Then {\r\n      \\\\ do something\r\n}\r\n\r\nWe have to enable joypad(s) with command Joypad 0, 1 and disable by using Joypad with no parameters\r\n\r\n
GR:ΛΑΘΟΣ\r\nError 100  \r\nError \"Problem\"\r\nError \"Problem 1000\"\r\nError 0  \\\\ shutdown environment\r\n\r\nFLUSH ERROR ' use it before Error statement to prevent to merge current message with next one.\r\n\r\n\\\\ Example 1\r\nTry ok {\r\n      a=1/0\r\n}\r\nPrint ok   \\\\ false we have error in the block level\r\nPrint Error\r\n\r\n\\\\ Exanple 2\r\nModule bb {\r\n      a=1/0\r\n}\r\nTry ok {\r\n      bb\r\n}\r\n\\\\use flush error\r\nPrint ok    \\\\ true we don't have error in the block level - is inside bb\r\nPrint Error    \\\\ true\r\nPrint Error$  \\\\ using error$ a \"flush error\" command executed\r\nPrint Error$  \\\\ so now is an empty string\r\n\r\n
GR:ΛΑΘΟΣ$\r\nPrint Error$\r\nprint description of an error produced from a try structure\r\n
GR:ΛΑΘΟΣ.ΤΑΙΝΙΑΣ$\r\n? MOVIE.ERROR$\r\nwe get movie error description\r\n
GR:ΛΑΜΔΑ\r\na=lambda variable list  -> { block of a function body, using non local variable list }\r\na$=lambda$ variable list  -> { block of a function body, using non local variable list }\r\n\r\na=lambda->100\r\nB=100\r\na=lambda B ->B*Number\r\nB-=50\r\nPrint  a(10)   \\\\ 1000\r\nc=lambda B ->B*Number\r\nPrint  c(10)   \\\\ 500\r\nd=lambda -> {\r\n      read B\r\n      =lambda B ->B**Number\r\n}\r\nm=d(3)\r\nPrint m(3)  \\\\ 27\r\n\r\nwe can pass array to variable list as a copy.\r\nwe can pass inventory and buffer and those always passed by reference\r\n\r\nFor recursion we can use Lambda() or Lambda$() inside defintion, because if we use the name then in a copy that name be invalid for a call.\r\nPrint lambda (a) -> {\r\n      =a**2\r\n} (3)  ' =9\r\n\r\n\r\nmakebold$ = lambda$ -> {\r\n      Read fn$\r\n      =lambda$ fn$ -> {\r\n             =\"<b>\"+fn$()+\"</b>\"\r\n       }\r\n}\r\nhello$=lambda$->\"Hello World\"\r\n\r\nPrint hello$()\r\nhello$=makebold$(hello$)\r\nPrint hello$()
GR:ΛΑΤΙΝΙΚΑ\r\nChange charset to Latin. Also change the language of error messages to English language\r\n\r\nSee Greek and CHARSET\r\n\r\n
GR:ΛΕΞΕΙΣ\r\nWORDS document$\r\n\r\n\r\nDocument alfa$ ={ one, two, three\r\n      and more, like this and that, or one and two\r\n      } \r\nPrint Doc.words(alfa$)\r\nM=Stack.size+1\r\nWords alfa$\r\n\\\\ default output all words ascending sort\r\n\\\\ and duplicates\r\nif Stack.Size >= M then {\r\nPrint Stack.Size - M\r\n      For i=Stack.Size to M {\r\n            Print letter$\r\n      }\r\n}\r\nPrint Doc.Unique.words(alfa$)\r\n\\\\ now word change output\r\n\\\\ all words ascending sort\r\n\\\\ and a number at the right place if we have more than one occurance\r\nM=Stack.size+1\r\nWords alfa$\r\nif Stack.Size >= M then {\r\n      For i=Stack.Size to M {\r\n            Print letter$\r\n      }\r\n}
GR:ΛΙΣΤΑ\r\n1) LIST USERS\r\nshow list of users (look USER)\r\n\r\n2) LIST \r\nshow all variables with values  (big string are cropped)\r\nWe can send  to a file\r\nLIST filenumber\r\n\r\n      open dir$+\"thisname.txt\" for output as f\r\n      list f\r\n      close f\r\n      \r\nNow we can read\r\n\r\n      open dir$+\"thisname.txt\" for input as f\r\n      while not eof(f) {\r\n            line input #f, a$\r\n            print a$\r\n      }\r\n      close f\r\n      \r\n\r\n\r\n3) List Com\r\n    List Com to NameofModule\r\n\\\\List declare type statements  for com objects\r\nyou can use choose.object to open the list only (this statement maybe change in later versions)\r\n
GR:ΛΟΓ(\r\nLogarithm base 10\r\n
GR:ΛΟΓΙΚΟΣ\r\nUsed in command TABLE\r\n
GR:ΛΟΓΙΣΤΙΚΟ\r\nused in TABLE command
GR:ΛΟΓΟΣ\r\n\r\n\r\n\r\n\r\nSPEECH \"I can speak english\"\r\nSPEECH \"I am a boy\"!\r\nSPEECH \"SPELLING\"#\r\n\r\nSPEECH \"I can speak english\", voice\r\nSPEECH \"I am a boy\"!, voice\r\nSPEECH \"SPELLING\"#, voice\r\n\r\nprint speech\r\nprints number of voices\r\n\r\nfor i=1 to speech {\r\n      print speech$(i)\r\n}\r\n\r\nprint name of all voices\r\n
GR:ΛΟΓΟΣ ως μεταβλητή\r\n\r\nprint speech\r\nprints number of voices for speech\r\n\r\nfor i=1 to speech {\r\n      print speech$(i)\r\n}\r\n\r\nprint name of all voices\r\n
GR:ΛΟΓΟΣ$(\r\n? speech$(1)\r\nreturn voice name 1 from text to speech system.\r\n
GR:ΛΣ$\r\n? OS$\r\nprint the OS name\r\n
GR:ΛΦ(\r\nNatural Logarithm (base e)
GR:ΜΑΚΡΥΣ\r\n\r\nLONG a, b=12, c=34.5\r\nc has value 34\r\n\r\nThese are Long type variables, with 4 bytes\r\nwe can't make arrays type LONG.\r\nWe use A% for big integers, or we can use long as smaller.\r\nWe can make arrays with big integers (normal integers)\r\n\r\nnormally a A is a double, but LONG change it to LONG type\r\nLong range A value from -2,147,483,648 to 2,147,483,647\r\nBig Integers  A% range value from -494,065,645,841,247 to 494,065,645,841,247\r\n\r\n
GR:ΜΑΚΡΥΣ_ΤΥΠΟΣ\r\n\r\nLONG\r\ntype for TABLE command\r\n\r\nalso is a type for variables see LONG\r\n\r\n
GR:ΜΕ\r\nlook SELECT
GR:ΜΕ_Αντικείμενο\r\nWith statement is complex to describe full here\r\nCan be used for input/output/ attach to a name/ attach to a name with parenthesis to place index\r\nHere is a small example\r\nWe use two properties, ReadyState and RensponseText in two variables.\r\nhtmltext, aa and aa$ have no direct pointer to object, so if we pass to stack for return those, then after module exit, object get Nothing automatic, so anything in stack show nothing too.\r\nWe can pass them by reference to other modules or functions.\r\n\r\nDeclare htmltext \"Microsoft.XMLHTTP\"\r\ntestUrl$ = \"http://httpbin.org/\"\r\nWith  htmltext, \"readyState\" as aa    \r\nMethod htmltext \"open\",\"GET\", testUrl$, true\r\nMethod htmltext \"send\"\r\nWhile aa<>4 {\r\n      Print Over aa\r\n      if mouse then exit\r\n      wait 1\r\n      refresh\r\n}\r\nPrint\r\ndocument bb$\r\nif aa=4 then {\r\n      With  htmltext, \"responseText\" as aa$\r\n      bb$=aa$\r\n}\r\nReport bb$\r\nRem : Clipboard bb$\r\nDeclare htmltext Nothing\r\n\r\nUsing WithEvents to get events from a com object\r\n\\\\ using WScript.Shell\r\nModule UseShell {\r\n      Declare  shell\"WScript.Shell\"\r\n      With Shell, \"Environment\" set env (\"PROCESS\")\r\n      With env, \"item\" as env.item$()\r\n      Print \"SYSTEMROOT=\"+env.item$(\"SYSTEMROOT\")\r\n}\r\nUseShell\r\n\r\nUsing evants, we have to use functions called as subroutines, so we have to place NEW to read to new variables, and form version 9  we have to use & for by reference only to those parameters which passed by reference (the old model made them all by reference in a middle stage)\r\n\r\nModule UsingEvents {\r\n      Form 60, 32\r\n      Cls 5, 0\r\n      Pen 14\r\n      Declare WithEvents sp \"SAPI.SpVoice\"\r\n      That$=\"Rosetta Code is a programming chrestomathy site\"\r\n      margin=(width-Len(That$))/2\r\n      EndStream=False\r\n      \\\\ this function called as sub routine - same scope as Module\r\n      \\\\ we can call it from event function too\r\n      Function Localtxt {\r\n            \\\\ move the cursor to middle line\r\n            Cursor 0, height/2\r\n            \\\\ using OVER the line erased with background color and then print text over\r\n            \\\\ ordinary Print using transparent printing of text\r\n            \\\\ $(0) set mode to non proportional text, @() move the cursor to sepecific position\r\n            Print Over $(0),@(margin), That$\r\n      }\r\n      Call Local LocalTxt()\r\n      Function sp_Word {\r\n            Read New StreamNumber, StreamPosition, CharacterPosition, Length\r\n            Call Local LocalTxt()\r\n            Cursor 0, height/2\r\n            Pen 15 {Print Part $(0), @(CharacterPosition+margin); Mid$(That$, CharacterPosition+1, Length)}\r\n            Refresh\r\n      }\r\n      Function sp_EndStream {\r\n            Refresh\r\n            EndStream=True\r\n      }\r\n      Const  SVEEndInputStream = 4\r\n      Const  SVEWordBoundary = 32\r\n      Const SVSFlagsAsync = 1&\r\n \r\n      With sp, \"EventInterests\", SVEWordBoundary+SVEEndInputStream\r\n      Method sp, \"Speak\", That$, SVSFlagsAsync\r\n      While Not EndStream {Wait 10}\r\n      Call Local LocalTxt()\r\n}\r\nUsingEvents\r\n \r\nAnother example using speech synthesis, and events to print words as the systme speak.\r\n\r\nModule UsingEvents {\r\n      Declare WithEvents sp \"SAPI.SpVoice\"\r\n      That$=\"This is an example of speech synthesis.\"\r\n      EndStream=False\r\n      Function sp_Word {\r\n            Read New StreamNumber, StreamPosition, CharacterPosition, Length\r\n            Rem: Print StreamNumber, StreamPosition, CharacterPosition, Length\r\n            Print Mid$(That$, CharacterPosition+1, Length);\" \";\r\n            Refresh\r\n      }\r\n      Function sp_EndStream {\r\n            Print\r\n            Refresh\r\n            EndStream=True\r\n      }\r\n      Const  SVEStartInputStream = 2\r\n      Const  SVEEndInputStream = 4\r\n      Const  SVEVoiceChange = 8\r\n      Const  SVEBookmark = 16\r\n      Const  SVEWordBoundary = 32\r\n      Const  SVEPhoneme = 64\r\n      Const  SVESentenceBoundary = 128\r\n      Const  SVEViseme = 256\r\n      Const  SVEAudioLevel = 512\r\n      Const  SVEPrivate = 32768\r\n      Const  SVEAllEvents = 33790\r\n \r\n      Const SVSFDefault = 0&\r\n      Const SVSFlagsAsync = 1&\r\n      Const SVSFPurgeBeforeSpeak=2&\r\n \r\n      With sp, \"EventInterests\", SVEWordBoundary+SVEEndInputStream\r\n      Method sp, \"Speak\", That$, SVSFlagsAsync\r\n      While Not EndStream {Wait 10}\r\n}\r\nUsingEvents\r\n
GR:ΜΕΓΑΛΟ(\r\nWork only with variables and array items\r\nA=10\r\nB=3\r\nPrint MAX(A, B)\r\n\r\nDim A(10)=10\r\nA(3)+=10\r\nPrint MAX(A(3),A(5))\r\n\r\n\r\nLook MIN()\r\n\r\nNeed numeric variable or array item (we can't use Array(a(),1)), because is passing by reference to run faster\r\nUse Only 2 parameters.\r\nUse Max.Data() for series of expressions
GR:ΜΕΓΑΛΟ.ΣΕΙΡΑΣ$(\r\n? max.data$(\"aa\",\"bb\")\r\nbb\r\n? max.data$(\"aa1234\",\"ab\",\"aa\",\"bb\") \r\nbb\r\n look MAX.DATA()  for numbers\r\n se also MIN.DATA$() and MIN.DATA() for numbers\r\n 
GR:ΜΕΓΑΛΟ.ΣΕΙΡΑΣ(\r\n\r\n\r\nPrint MAX.DATA(1, 30*5, 2)\r\n\r\nLook MIN.DATA()
GR:ΜΕΓΕΘΟΣ.ΣΩΡΟΥ\r\n\r\nPUSH 100, \"123123\"\r\nPRINT STACK.SIZE\r\n\r\n\r\n\r\n
GR:ΜΕΓΕΘΟΣ.Υ(\r\n\r\nForm 40,25\r\ng$=\"M2000 Interpreter\"\r\np=pi/3\r\n\r\nFor k=22 to 48 step 2 {\r\n      p+=pi/9\r\n      b=Size.X(g$,\"ARIAL\",k,p)\r\n      d=-Size.Y(g$,\"ARIAL\",k,p)\r\n      Move (x.twips-b)/2,(y.twips-d)/2\r\n      Pen Random(7,15) {\r\n            Legend g$,\"ARIAL\",k,p,2\r\n      }\r\n}
GR:ΜΕΓΕΘΟΣ.Χ(\r\n\r\nForm 40,25\r\ng$=\"M2000 Interpreter\"\r\np=pi/3\r\n\r\nFor k=22 to 48 step 2 {\r\n      p+=pi/9\r\n      b=Size.X(g$,\"ARIAL\",k,p)\r\n      d=-Size.Y(g$,\"ARIAL\",k,p)\r\n      Move (x.twips-b)/2,(y.twips-d)/2\r\n      Pen Random(7,15) {\r\n            Legend g$,\"ARIAL\",k,p,2\r\n      }\r\n}
GR:ΜΕΘΟΔΟΣ\r\nWe can call methods for com objects (including user forms in M2000). which we define using Declare, and including document and inventory objects\r\nExample using VbScript, and passing array\r\nGlobal a()\r\nmm=10\r\nModule CallFromVb {\r\n      \\\\ Number get first parameter is numeric else error\r\n      Print Number\r\n}\r\nModule Global CallFromVbGlobal {\r\n      Read X()\r\n      X(0)++\r\n      a()=X()\r\n      ? \"ok\"\r\n}\r\ndeclare global vs \"MSScriptControl.ScriptControl\"\r\ndeclare Alfa Module\r\nPrint Type$(Alfa)  \\\\ name is CallBack2\r\nWith vs, \"Language\",\"Vbscript\", \"AllowUI\", true, \"SitehWnd\",  hwnd\r\nMethod vs, \"Reset\"\r\nMethod vs, \"AddObject\", \"__global__\",  Alfa, true\r\nMethod vs, \"AddCode\",{\r\n      dim M(9), k   ' 0 to 9, so 10 items\r\n      sub main()\r\n            CallModule \"CallFromVb\", 1000\r\n            M(0)=1000\r\n            CallGlobal \"CallFromVbGlobal\", M\r\n            ExecuteStatement \"Print a(0)\"\r\n            k=me.Eval(\"a(0)\")\r\n            CallModule \"CallFromVb\", k\r\n            ' use Let to assign a number to variable\r\n            ExecuteStatement \"let mm=12345\"\r\n            k=me.Eval(\"mm\")\r\n            CallModule \"CallFromVb\", k\r\n            CallModule \"CallFromVb\", M(0)\r\n      end sub\r\n}\r\nmethod vs, \"run\", \"main\"\r\nDeclare vs nothing\r\nIf error then print error$\r\nPrint Len(a())\r\nPrint a()\r\n\r\n****************Example use Document (internal object)*************************\r\n\r\n\r\nDocument a$={péché\r\n            sin\r\n            peach\r\n            pêche\r\n            }\r\n\r\nMethod a$, \"SetLocaleCompare\", 1036\r\nSort ascending a$, 1,4\r\nReport a$\r\nMethod a$, \"SetLocaleCompare\", 1033\r\nSort ascending a$, 1,4\r\nReport a$\r\n\r\n\r\n\r\n\r\n
GR:ΜΕΛΟΣ$(\r\n? MEMBER$(alfa, 3)\r\nprint 3d member's name in group alfa\r\n\r\nlook GROUP
GR:ΜΕΛΟΥΣ.ΤΥΠΟΣ$(\r\nPrint MEMBER.TYPE$(alfa, 2)\r\nprint data type of second member in group alfa\r\n\r\nsee GROUP
GR:ΜΕΛΩΔΙΑ\r\n\r\nUsing tone from KERNEL (if running in an original Windows Machine, no a virtual)\r\nTune melody$\r\nTune duration, melody$\r\n\r\n\r\nModule B {\r\n      For i = 1 To 10 {\r\n            TUNE \"cac \"\r\n            Wait 200\r\n      }\r\n\r\n\r\n\r\n\r\nTune \"C3BC#\"\r\nNumber is the Octave, used to change current octave, Space is Pause.\r\nUse VOICE and PLAY for sending MIDI messages to internal synthesizer (work on virtual machines)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
GR:ΜΕΡΟΣ\r\nif M= true then Part skip block\r\nWhen Part block execute M created if not exist and turn to true.\r\nAt the end of execution of block M turn to False\r\nPart {\r\n      Print  \"ok\", M\r\n} As M\r\n\r\nused where we want code to run without other code run concurrent.\r\nwe can call subroutines or modules from block.\r\n
GR:ΜΕΡΟΣ$(\r\n\r\nPrint Piece$(\"alfa.beta\",\".\", 2)  ' return beta   - numbers from 1\r\nPrint Piece$(\"alfa.beta\",\".\")(1)  ' return beta  -  numbers from 0\r\n' variable a get a new object (mArray) from Piece$() without piece number\r\n' Here we get a pointer to array in right expression\r\na=Piece$(\"alfa.beta\",\".\")   ' is the same: Piece$(\"alfa.beta\",\".\")()\r\nPrint Array$(a, 1) 'return beta\r\nPrint a\r\nDim Β$()\r\n\\\\ Here we get a copy of array in right expression\r\nΒ$()=Piece$(\"alfa.beta\",\".\")\r\nPrint Β$()\r\n\r\n
GR:ΜΕΣ$(\r\nlike in BASIC\r\nPrint Mid$(\"12345\",2)   \\ 2345\r\nPrint Mid$(\"12345\",2,2)  \\ 23\r\n\r\n\r\nLocale 1032\r\na$=str$(\"Γιώργος\")  ' to ansi using Locale 1032\r\nPrint chr$(Mid$(a$,2,2 as byte))=\"ιώ\"  ' Chr$() convert ansi to  UTF-16LE (using Locale 1032)
GR:ΜΕΤΑ\r\n\r\nkk=10\r\nAfter 2000 {kk=20 : keyboard chr$(13)}\r\nInput \"A$=\", A$\r\nIf  kk>10 Then Print \"Big time to response\"\r\nPrint  A$\r\n\r\nIf you don't response in 2 seconds then the thread send a return and close the input\r\n\r\nThis is a thread that start after 2000 ms for one time only.\r\n\r\nWrite this in a module:\r\n\r\nMyVar=100\r\nAfter 1000 {\r\n      Print \"οκ\", MyVar\r\n}\r\nModule InsideThis {\r\n      MyVar=500  ' this is local\r\n      After 500 {Print \"I am in InsideThis\"}\r\n      Wait 2000\r\n      Print \"I am in InsideThis...too\"\r\n}\r\nInsideThis\r\n\r\nExplanation:\r\nCreate Myvar, Establish thread to run once after 1 second, Create Module, Call Module\r\nInside Module: Create Myvar, Establish thread to run once after half second, Wait 2 seconds\r\nFirst thread executed and Print \"I am insideThis\"\r\nSecond thread, from parent module, executed and Print ok 100\r\nEnd of waiting\r\nPrint \"I am in insideThis..too\"\r\nAll threads started at WAIT  (or in a Every or in a Main.Task) see below a typical example\r\n\\\\ look this too\r\nMyVar=100\r\nAfter 1000 {\r\n      Print \"οκ\", MyVar\r\n      After 2000 {\r\n            Print \"οκ2\", MyVar\r\n      }\r\n}\r\nModule InsideThis {\r\n      MyVar=500  ' this is local\r\n      After 500 {Print \"I am in InsideThis\", MyVar}\r\n      Wait 1000\r\n      Print \"I am in InsideThis...too\"\r\n}\r\nInsideThis\r\nWait 2000\r\n\r\n\\\\ Example\r\nWrite in a Module\r\nKK=10\r\nafter 100 {KK=20}\r\nfor i=1 to 100 {\r\n      print i\r\n      wait 0\r\n}\r\nprint KK\r\nIf you shadow wait 0 (make it a remark) then After never run, so KK is 10. Because inside \"for\" there is nothing to give time to thread system. Wait 0 is like Doevents in VB6\r\n\r\n\r\nThis is an example that we use After and Main.Task, these are threads.\r\nYou can have  as many After as you like, and you can set a thread inside a thread.\r\nMain.Task can run  in different modules.\r\n\r\nYou can change Main.Task with Every to see what happen. Every isn't a thread, but give time to threads to run.\r\nexample 1\r\nafter 1000 {\r\n      print \"ok\"\r\n}\r\nwait  2000\r\nprint \"end\"\r\n\r\nexample 2\r\n---------------------------\r\nCls 0,0  ' Black like the night sky, set split screen to 0 row, so not used here\r\nPen 14 ' Yellow like a star\r\nFlag=False\r\n' Internal module\r\nGlobal kk\r\nModule Stars {\r\n      Cls\r\n      For i=1 To 200 {\r\n            x=Random(0,Width-1)\r\n            y=Random(0,Height-2)\r\n            Print Part @(x,y);\"*\"\r\n      }\r\n      kk++\r\n}\r\n' Now we start profiler timer\r\nProfiler\r\nStars\r\nIf False Then {}   ' do nothing, but profiler add the If duration\r\nd=timecount+10 ' plus 10 to be polite to the system\r\nAfter 10*D {Flag=True}\r\nMain.Task D {\r\n      Stars\r\n      If Flag Then Exit\r\n}\r\nCls  7 \r\nPen 1\r\nPrint kk\r\n\r\n\r\n
GR:ΜΕΤΑΒΛΗΤΕΣ ΣΥΣΤΗΜΑΤΟΣ\r\nVARS READ ONLY\r\nABOUT$, APPDIR$, BROWSER$, CLIPBOARD$, CLIPBOARD.IMAGE$, CODEPAGE, COLORS, COMMAND$, COMPUTER$, CONTROL$, DIR$, DURATION, EMPTY, ERROR$, FIELD_as variable, FONTNAME$, GRABFRAME$, GREEK_variable, HEIGHT, HWND, INKEY$, INTERNET, INTERNET$, ISLET, ISNUM, KEY$, LAN$, LETTER$, MEMORY, MENU.VISIBLE, MENU_as variable, MENUITEMS, MODE_variable, MODULE$, MODULE.NAME$, MONITOR.STACK, MONITOR.STACK.SIZE, MOTION.WX, MOTION.WY, MOTION.X, MOTION.XW, MOTION.Y, MOTION.YW, MOUSE, MOUSE.KEY, MOUSE.X, MOUSE.Y, MOUSEA.X, MOUSEA.Y, MOVIE.COUNTER, MOVIE.DEVICE$, MOVIE.ERROR$, MOVIE.STATUS$, MOVIE_as variable, MUSIC.COUNTER, NOW, NUMBER, OS$, OSBIT, PARAMETERS$, PEN_variable, PLATFORM$, PLAYSCORE, POINT, POS, POS.X, POS.Y, PRINTERNAME$, PROPERTIES$, REPORTLINES, RND, ROW, SCALE.X, SCALE.Y, SPEECH as variable, SPRITE$, STACK.SIZE, TAB, TEMPNAME$, TEMPORARY$, THIS, THREADS$, TICK, TIMECOUNT, TODAY, TWIPSX, TWIPSY, USER.NAME$, VOLUME_as variable, WIDTH_as variable, X.TWIPS, Y.TWIPS\r\n\r\n
GR:ΜΕΤΑΘΕΣΗ\r\nSEEK  #L, 10\r\nwe position file cursor to 10th byte.\r\nminimum 1 and maximum the maximum long number.\r\n\r\nIn any case  for ansi or for wide  (unicode)  this is a position in bytes.\r\n\r\nReport 2, \"you make a temporary UTF-16 file\"\r\ntext utf-16 this.txt {alfa\r\n      beta\r\n      gama\r\n      }\r\nL=1\r\nopen temporary$+\"this.txt\" for wide input as L\r\nseek #L, 3  ' for UTF id number\r\nwhile not eof(l) {\r\n      print  seek(#L), @(tab+2),\r\n      line input  #L, a$\r\n      print a$\r\n      }\r\nclose #L\r\n
GR:ΜΕΤΑΘΕΣΗ(\r\n\r\n\\\\ Seek() always return bytes from start of file, and 1 for the first\r\n\r\nM=Stack\r\nFlush\r\nData \"allfa\", \"beta\",\"gama\",\"epsilon\", \"delta\"\r\nopen \"a.dat\" for wide output as #k\r\nWhile Not Empty {\r\n      Print #k, Letter$;\r\n      Stack M { Data Seek(#k)}  ' Data statement push to end\r\n}\r\nclose #k\r\na=1\r\nb=each(M)\r\nopen \"a.dat\" for wide input as #k\r\nWhile b {\r\n      Seek #k, a\r\n      Print Input$(#k, (Stackitem(b)-a)/2)   ''use /2 for Wide (UTF16LE)\r\n      a=Stackitem(b)\r\n}\r\nclose #k
GR:ΜΕΧΡΙ\r\n\r\n\r\nLook REPEAT
GR:ΜΗΚΟΣ(\r\nReturn for:\r\nstring, document :  length as chars (2 bytes)\r\nUse Len.disp() to give positions for print (maybe some chars are top of others)\r\nArray : length in items (like dimensions =1 ), or =0 if dimensions=0\r\nObjects: Inventory, Stack, Arrays =number of items\r\n
GR:ΜΗΚΟΣ.ΕΜΦ(\r\n\\\\ Display Length\r\nPrint LEN.DISP(\"ãz̃\")  ' 2 \r\nPrint Len(\"ãz̃\")     '4
GR:ΜΙΚΡΟ(\r\nNeed numeric variable or array item (we can't use Array(a(),1)), because is passing by reference to run faster\r\nUse Only 2 parameters.\r\nPrint Min(a(2), a(1))\r\nPrint Min(a, a(1))\r\nPrint Min(b,a)\r\nUse Min.Data() for series of expressions\r\n
GR:ΜΙΚΡΟ.ΣΕΙΡΑΣ$(\r\n? min.data$(\"aa\",\"bb\")\r\naa\r\n? min.data$(\"aa1234\",\"ab\",\"aa\",\"bb\") \r\naa\r\n look MIN.DATA()  for numbers\r\n se also MAX.DATA$() and MAX.DATA() for numbers\r\n \r\n\r\n\r\n
GR:ΜΙΚΡΟ.ΣΕΙΡΑΣ(\r\n\r\n\r\nPrint MIN.DATA(1, 50*3,2)\r\n\r\nLook MAX.DATA()
GR:ΜΙΚΡΟΣ.ΚΑΤΑΛΟΓΟΣ$(\r\n? shortdir$(\"C:\\Documents and Settings\\All Users\\Documents\\\")\r\nC:\\DOCUME~1\\ALLUSE~1\\DOCUME~1\\\r\n? shortdir$(\"c:\\notexistfolder\\\")\r\nreturn nonthing\r\n\r\nreturn the DOS name of a folder or and filename.\r\nif file or path not exist then return empty string
GR:ΜΝΗΜΗ\r\nphysical memory (no virtual) free for use in MB\r\n
GR:ΜΟΡΦΗ$(\r\n1) print format$( pattern$, parameter list)\r\nYou can use {0} many times and you can use any number.  Parameter list can't contain empty parameter position.\r\nBut we can omit a parameter in pattern$ like this example:\r\nreport format$(\"label1 {1}\", 12323, 45)\r\nlabel1 45 \r\n\r\nWe can use {} for multiline strings (automatic remove of space for Indentation based of position of last curly bracket)\r\n            a$= format$( {parameters:{0}, \"{1}\"\r\n                              {2}\r\n                              }, \"alfa\", 12, \"ok\")\r\n\r\nPrint format$(\"number {0:2} and {0:4}, 12.3567)\r\nThis is a round function for numbers only. Work for scientific notiation also.\r\nif we provide a string to a number position then we see the numbers  {0:2} and not the string because string always search for {0} for 1st parameter ({1} for second).\r\nPrint format$(\"{0:-20}{1:2:-6},{1:2:6}ok\", \"lead spaces\",10.2)\r\n\r\n2) Process escape codes  (using only one parameter as string with escape codes like json strings)\r\nPrint format$(\"Paragraph1\\r\\nParagraph2\\r\\nParagraph3\")\r\n\\\\ to pass formatted values use two time format$(), one to to process {} and second for escape codes\r\nPrint format$(format$(\"Paragraph1\\r\\nParagraph2 {0}}\\r\\nParagraph3\", 100))\r\nuse String$(\"anything here without escape codes\" as json) to produce escape codes
GR:ΜΟΥΣΙΚΗ\r\n\r\nMUSIC is same as MOVIE and MEDIA but without a Window to show something\r\nSo MUSIC -1 is a pause\r\nMUSIC 1.2 goto 1.2 second\r\nMUSIC 0 restart music\r\n\r\nMUSIC as variable is TRUE if music play\r\nMUSIC.COUNTER is -1 if no music loaded\r\nDURATION is the total duration in seconds (with decimals)\r\nWe can play mp3 or MID or WAV\r\n\r\nFor WAV we have SOUND command also\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
GR:ΜΟΥΣΙΚΗ.ΜΕΤΡΗΤΗΣ\r\nsame as Movie.Counter\r\nreturn -1 if nothing played\r\nreturn for current tune the time of play in msec from start.\r\nLook Duration  (to get duration of tune)\r\n\r\n\r\n
GR:ΜΠΙΠ\r\nBeep  (sound as beep)\r\n\r\nBeep 32 (window sound 32)
GR:ΜΠΡΟΣΤΑ(\r\n\r\nDocument a$={aaaaaaa\r\nbbbbbbbbb\r\nccccccc}\r\nm=Paragraph(a$, 0) \r\nIf Forward(a$,m) then {\r\n      While m {\r\n            Print Paragraph$(a$,(m))\r\n      }\r\n}
GR:ΝΕΟ\r\n\r\nNew\r\nClear stored modules and functions\r\n(Stack and Variables defined in CLI aren't clear. Use Flush for stack and Clear for variables)\r\n
GR:ΝΗΜΑ\r\nA thread is a part of a module that can be run in a time sharing plan.\r\nEach thread can have static variables, and use private stack, for calling modules and subs.\r\n\r\nRefresh command make a refresh to current form output (some versions before Refresh allowed threads to run, but this changed)\r\nWait  1 can be used inside thread in a loop if we want to block that thread and want to run other threads. If we use input command or Key$ to wait for keypress, these  blocks the thread but Interpreter can run other threads (using wait inside).\r\n\r\n1) creation\r\nTHREAD {\r\n      Static A=5   \\\\ this executed once \r\n..............\r\n} AS K \\\\ here we can put a command like Interval or Execute\r\nK has the thread number. That number is the handler of the thread. Threads have no names. They are part of the module where they created. Every thread  has own stack for values but uses the same variables as the module use. So variables and arrays never erased from threads..\r\n\r\n2) Handle\r\nThread K Interval 200\r\nThread K Hold\r\nThread K Restart\r\nThread K Erase\r\nThread K Execute Α=10\r\nin a thread we can use THIS as the handler  (we can't read but command Thread knows what is).  When a thread run, are deleted from a waiting list, a request with the handler miss it, so only THIS can tell to system that we request the current thread. A module or a function has no thread handler, so a request to THIS produce an error.\r\n\r\n\r\n3) Report the TASK manager list of tasks. Internal task as MAIN.TASK and AFTER not showing the hidden handlers.\r\nThreads\r\n\r\n\r\nModule A {\r\n          ' Simple Counter with keyboard interface \r\n          If Version<6 Then Exit    ' no threads for older versions\r\n          Hide\r\n          FORM 50\r\n          Cls 1\r\n          Pen  14\r\n          Print \"THREADS IN M2000\"\r\n          Print \"Internal Thread Example - press space for menu\"\r\n          Pen 15\r\n          Cls 4,2\r\n          Show\r\n          c=1\r\n          THREAD {\r\n                    c=c+1\r\n                    Print c\r\n                                   } As B\r\n          THREADS     ' for information\r\n          THREAD b interval  80\r\n          List\r\n          ex=False\r\n          Main.Task 100 {\r\n                    k$=Ucase$(Inkey$)\r\n                    If k$<>\"\" Then Print k$\r\n                    Select Case k$\r\n                    Case \"A\"\r\n                          THREAD b Hold\r\n                    Case \"B\"\r\n                          THREAD b restart\r\n                    Case \"C\"\r\n                          THREAD b erase\r\n                    Case \"Q\"\r\n                          ex=True\r\n                    Case \"I\"\r\n                          THREADS\r\n                    Case >=\" \"\r\n                    {\r\n                          Print \"A - HOLD\"\r\n                          Print \"B - RESTART\"\r\n                          Print \"C - ERASE\"\r\n                          Print \"Q - QUIT\"\r\n                          Print \"I - INFORMATION\"\r\n                          Print \"ANY OTHER RETURN HERE\"\r\n                    }\r\n                    End Select\r\n                    'An exit from  module  erase all threads created from it\r\n                    If ex Then Exit\r\n          }\r\n}\r\n\r\n\r\nSecond Example Using EVERY and WAIT and AFTER\r\nSee the thread handlers b and c\r\nAFTER create a thread but  hide the handler.\r\nThe b thread has heavy duty\r\nWe can change EVERY with TASK.MAIN\r\nWe can see that line       print \"MOUSE:\",mouse  prints more often in MAIN.TASK\r\nThis is happen because MAIN.TASK is a thread and all threads running in controlable time slices, one by one.\r\nHere  we see a thread C that run as the thread B run for a long time. This can be done because WAIT give time to run another task.\r\nWhen we use MAIN.TASK after the end all threads for that module are erased. EVERY didn't do that. So we see how we can erase threads. When a module end...all threads ends.\r\nBecause a thread is \"Time Loop\" we can avoid to use loops in threads. Here is the bad example. To do better we have only to put in c the I++ and an IF statement to reset the I when became greater from a limit. We have better control and not threads inside threads (it is better to use the thread by thread  story, and because the have each one a time slice, the order of execution maybe changed, and that is the multitasking. Changing intervals we give more time to run as we step down one or step up the time intervals of  others)\r\n\r\n' write in a module\r\nform 60,32\r\ncls 1\r\npen 15\r\nafter 500 {\r\n      print \"One shot thread from AFTER\"\r\n}\r\ni=0\r\nthread {\r\n      print i\r\n} as c\r\nthread c interval 30\r\nthread {\r\n      ' very big thread \r\n      Print \"Big Thread Start\"\r\n      for i=1 to 10 {\r\n            wait 100      ' wait give time to threads to run\r\n      }\r\n      Print \"Big Thread End\"\r\n} as b interval 200\r\nevery 200 {\r\n      if mouse>0 then exit\r\n      print \"MOUSE:\",mouse\r\n}\r\nthreads\r\nthread c erase\r\nthreads\r\nthread b erase\r\nprint \"end\"\r\nthreads\r\n\r\nSame example using Task.Main  (or Main.Task is the same command)\r\nform 60,32\r\ncls 1\r\npen 15\r\nafter 500 {\r\n      print \"One shot thread from AFTER\"\r\n}\r\ni=0\r\nthread {\r\n      print i\r\n} as c\r\nthread c interval 30\r\nthread {\r\n      ' very big thread \r\n      Print \"Big Thread Start\"\r\n      for i=1 to 10 {\r\n            wait 100      ' wait give time to threads to run\r\n      }\r\n      Print \"Big Thread End\"\r\n} as b interval 200\r\nTask.Main 200 {\r\n      if mouse>0 then exit\r\n      print \"MOUSE:\",mouse\r\n}\r\nthreads\r\nthread c erase\r\nthreads\r\nthread b erase\r\nprint \"end\"\r\nthreads\r\n\r\n\r\n\r\nExamples using Thread.Plan\r\n\\\\ Concurrent\r\nThread.Plan Concurrent\r\n\\\\ A=100  we can't use local variable with same name as a Static in thread variable\r\n\\\\ if we do that we get an error.\r\nM=500\r\nN=0\r\nStartThreads(20)\r\n\\\\ using a thread for this task.\r\n\\\\ we can exit by using mouse click or counting threads give zero\r\nTask.Main 50 {\r\n      Threads\r\n      Refresh\r\n      if mouse or N=0 then exit\r\n}\r\nThreads\r\n\r\nEnd\r\nSub Display()\r\n      Print \">>\", N\r\nEnd Sub\r\nSub StartThreads(Many)\r\n      For K=1 to Many {\r\n            N++\r\n            Thread {\r\n                  Print A*M, B  \\\\ static A is used before any local A\r\n                  A--\r\n                  Display()\r\n                  \\\\ block needed after then if concurrent plan used\r\n                  If A=0 then { N-- : thread this erase }\r\n            } as T execute static A=10, B=T\r\n            \\\\ Now we start thread\r\n            Thread T interval random(10,100)\r\n      }\r\nEnd Sub\r\n\r\n\r\n\\\\ Sequential\r\nThread.Plan Sequential\r\n\\\\ A=100  we can't use local variable with same name as a Static in thread variable\r\n\\\\ if we do that we get an error.\r\nM=500\r\nN=0\r\nGosub StartThreads\r\n\\\\ using a thread for this task.\r\n\\\\ we can exit by using mouse click or counting threads give zero\r\nTask.Main 50 {\r\n      Threads\r\n      Refresh\r\n      if mouse or N=0 then exit\r\n}\r\nThreads\r\nEnd\r\nStartThreads:\r\nFor K=1 to 20 {\r\n      N++\r\n      Thread {\r\n            Print A*M, B  \\\\ static A is used before any local A\r\n            A--\r\n            \\\\ changing thread plan we have a problem because\r\n            \\\\ thread this erase is executed without control from If\r\n            \\\\ so we need to use block { N-- : thread this erase }\r\n            \\\\ blocks are executed before task manager change thread\r\n            If A=0 then N-- : thread this erase \r\n      } as T execute static A=10, B=T\r\n      \\\\ Now we start thread\r\n      Thread T interval 100\r\n}\r\nReturn\r\n
GR:ΝΗΜΑΤΑ\r\n1) Threads\r\n      Show all threads\r\n2) Threads Erase  \r\n      Erase all threads (by disposing from thread pool)
GR:ΝΗΜΑΤΑ$\r\n? THREADS$\r\nreturn a list of threads in current module or function, including all the  threads in the lists of parents modules.\r\n
GR:ΞΕΚΙΝΑ\r\nRestart as a command to jump to start of a block\r\n\r\ni=0\r\n{i++\r\nif random(10)>5 then restart   ' this can overdrive the loop so the print command can print number>10\r\nprint \"normal\", i\r\nif i<10 then restart   ' and this condition says that no loop occur if i>=10...after the print command,\r\nprint \"last command\"\r\n}\r\n\r\n\r\nLook THREAD and MOVIE for Restart id (for other purposes)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
GR:ΟΔΗΓΟΣ$(\r\nPrint Drive$(\"A:\\\")\r\nA string contains the type of drive
GR:ΟΘΟΝΗ\r\nScreen coordinate 0,0 is top left corner\r\n\r\n1) CLS 1\r\nclear screen, put blue color (0 to 15 are basic colors, negative numbers represent rgb values, use Color() function, or  HSL())\r\n\r\n2)CLS 1, 2\r\nclear screen and set 3rd row to split screen top line\r\nWe can print anywhere but only the lower part of split screen scroll down (or up)..\r\nSCROLL SPLIT  number expression  ' We can define the split screen without clear it\r\nSCROLL UP and SCROLL DOWN to perform scrolling by text row.\r\n\r\n3) CLS ,3\r\nclear screen with last background color and put the 4th row as split screeen top line.\r\nWe can define scrolling part in Background, Screen and Layers (not on the printer)\r\n
GR:ΟΘΟΝΗ ΚΑΙ ΑΡΧΕΙΑ\r\nSCREEN AND FILES\r\n?, HEX, INPUT, PRINT\r\n\r\n
GR:ΟΚΝ$(\r\n\r\nLazy$() get an expression or a reference to a function, and return a function (as function pattern) with a Module command to change the name space to name of where we create the function, so when we execute this function modules variables and modules and functions are visible.\r\n\r\nWe can use Eval$(\"x+y\") for expressions where variables x and y exist in current module. We can pass a Lazy$(\"x+y\") as parameter when calling a module and we get lazy evaluation, because evaluation happen in each execution of created function\r\n\r\n\r\n\r\nThis is a simple function pattern\r\na$=\"{=100}\"\r\nPrint function(a$)\r\n\r\n\\\\ Example of using Module with lazy evaluation\r\nx=10\r\ny=2\r\nModule Alfa (&f()) {\r\n      Print f()\r\n}\r\nAlfa Lazy$(x**2+y)\r\n\\\\ In M2000 Modules must keep stack clean, because they get parent stack\r\n\\\\ Functions use own stack \r\nModule Alfa1 {\r\n      \\\\ we can check if we have a number\r\n      \\\\ if its true we make a function from it\r\n      \\\\ we can match the stack \"envelope\", or first part of it\r\n      If match(\"N\") then read x : Push lazy$(x) \r\n      Read &f()\r\n      Print f()      \r\n}\r\n\\\\ we can get eager evaluation or lazy evaluation\r\nAlfa1 x**2+y\r\nAlfa1 Lazy$(x**2+y)\r\n\r\n\r\n\\\\ example showing passing multi line function for later evaluation\r\n\\\\ Multiline Function run with same name as this module\r\n\\\\ so x and y are visible\r\n\r\n\\\\ Modules names are not the part we know before execution\r\n\\\\ M2000 define a bigger name, using some rules. So this name is a \"weak reference\" to module\r\n\r\n\\\\ we can see module name (and in a function we have a \"module name\")\r\n\\\\ Subroutines are not modules, they run at module space.\r\n\r\nPrint Module$\r\nx=10\r\ny=2\r\n\\\\ just a function with module name as this module\r\na$=Lazy$(x**2+y)\r\nReport a$\r\n\r\nPrint Function(a$)\r\na$=Lazy$(number**2+y)\r\nPrint Function(a$, 10)\r\nM=12345\r\nFunction MultiLine {\r\n\\\\ read optional, and assign value to new variable x\r\n      Read ? New x\r\n      Rem : Print zz \\\\ this is an error, zz not exist\r\n      \\\\ interpreter can show error position using an auto remark at first line\r\n      Local M=10\r\n      DoSomething(10, 2)\r\n      if x>10 then {\r\n            =x**3+2*y+m\r\n      } else {\r\n            =x**2+y+m\r\n      }\r\n      Sub DoSomething(m1, m2)\r\n            \\\\ Subs can see anything in this function\r\n            m=m1+m2\r\n      End Sub\r\n}\r\na$=Lazy$(&Multiline())\r\n\\\\ Here we see first line as special remark for errors\r\nReport a$\r\nx=50\r\nPrint Function(a$, 10), Function(a$)\r\nPrint Function(a$, 20), Function(a$)\r\nPrint M\r\n\\\\ Search for subs extend to all code of this module\r\n\\\\ without check modules/functions borders\r\n\\\\ if not found in this text, then at a second search interpreter look to parent module, if exist a parent module.\r\n\\\\ Sub DoSomething() run without any reference from where interpreter found it\r\n\\\\ so we get only the code, as this code was on last lines of this module\r\nDoSomething(3,4)\r\nPrint M\r\n\r\n\\\\ example using function as module\r\n\\\\ but this function is like a part of module\r\nClear\r\nZ=100\r\nModule Localmodule {\r\n      Print \"This module can called from parent only\"\r\n}\r\nLocalmodule\r\nModule Global test1 {\r\n      Static M=10\r\n      M++\r\n      Print M\r\n}\r\n\\\\ this is not a ordinary function\r\n\\\\ but a part of this module\r\nFunction fake (&feedback) {\r\n      Z++\r\n      feedback=Z\r\n      test1\r\n      Localmodule\r\n}\r\n\r\nModule Delta {\r\n      Read &func()\r\n      \\\\ we run a part of parent module\r\n      N=0\r\n      Call func(&N)\r\n      Print N\r\n      Call func(&N)\r\n      Print N\r\n      \\ \\  call test1 from Delta\r\n      test1\r\n      test1\r\n}\r\ntest1\r\ntest1\r\n\\\\ we pass a part of this module\r\nDelta Lazy$(&fake())\r\ntest1
GR:ΟΛΑ\r\nINTERPRETER\r\nABOUT, AND, CLEAR, CLIPBOARD, DIV, DIV#, DOS, EDIT, END, FAST, FKEY, HELP, IS, KEYBOARD, LIST, LOAD, MOD, MOD#, MONITOR, NEW, OPERATORS, OR, PROTOTYPE, RECURSION.LIMIT, REM, REMOVE, SAVE, SCRIPT, SLOW, SORT, START, SWITCHES, TEST, VERSION, WIN, WRITER\r\n\r\nMODULE COMMANDS\r\nERROR, ESCAPE, FUNCTION, HALT, INLINE, LINK, MODULE, MODULES, PIPE, STOP, SUB, THREAD, THREADS, USE\r\n\r\nFLOW CONTROL\r\nAFTER, BREAK, CALL, CASE, CONTINUE, DO, ELSE, ELSE.IF, EVERY, EXIT, FOR, GOSUB, GOTO, IF, LOOP, MAIN.TASK, ON, PART, PROFILER, REPEAT, RESTART, SELECT, THEN, THREAD.PLAN, TRY, UNTIL, WAIT, WHILE\r\n\r\nSTACK COMMANDS\r\nCOMMIT, DATA, DROP, FLUSH, OVER, PUSH, READ, REFER, SHIFT, SHIFTBACK, STACK\r\n\r\nDEFINITIONS\r\nAUTO_ARRAYS, BINARY, BUFFER, CLASS, CONST, DECLARE, DEF, DIM, DOCUMENT, ENUM, ENUMERATION, EVENT, GLOBAL, GROUP, INVENTORY, LAMBDA, LET, LOCAL, LONG, METHOD, PROPERTY, SET, STATIC, STOCK, SUPERCLASS, SWAP, WITH\r\n\r\nDOCUMENTS\r\nAPPEND.DOC, EDIT.DOC, FIND, INSERT, LOAD.DOC, MERGE.DOC, OVERWRITE, SAVE.DOC, SORT(DOCUMENT), WORDS\r\n\r\nFILE OPERATIONS\r\nBITMAPS, CLOSE, DRAWINGS, FILES, GET, LINE INPUT, MOVIES, NAME, OPEN, PUT, SEEK, SOUNDS, WRITE\r\n\r\nCONSOLE COMMANDS\r\nBACK, BACKGROUND, BOLD, CHARSET, CLS, CURSOR, DESKTOP, DOUBLE, FIELD, FONT, FORM, FRAME, GRADIENT, GREEK, HIDE, HOLD, ICON, ITALIC, LATIN, LAYER, LEGEND, LINESPACE, LOCALE, MARK, MODE, MOTION, MOTION.W, NORMAL, PEN, REFRESH, RELEASE, REPORT, SCROLL, SHOW, WINDOW\r\n\r\nSCREEN AND FILES\r\n?, HEX, INPUT, PRINT\r\n\r\nOPERATORS IN PRINT\r\n$(, @(, ~(\r\n\r\nTARGET AND MENU\r\nCHANGE, MENU, SCAN, TARGET, TARGETS\r\n\r\nDRAWING 2D\r\nCIRCLE, COLOR, CURVE, DRAW, FILL, FLOODFILL, MOVE, POLYGON, PSET, SMOOTH, STEP, WIDTH\r\n\r\nBITMAP COMMANDS\r\nCOPY, IMAGE, PLAYER, SPRITE\r\n\r\nDATABASES\r\nAPPEND, BASE, COMPRESS, DB.PROVIDER, DB.USER, DELETE, EXECUTE, ORDER, RETRIEVE, RETURN, SEARCH, STRUCTURE, TABLE, VIEW\r\n\r\nSOUNDS AND MOVIES\r\nBEEP, CHOOSE.ORGAN, MOVIE, MEDIA, MUSIC, PLAY, SCORE, SOUND, SPEECH, TONE, TUNE, VOLUME\r\n\r\nMOUSE COMMANDS\r\nJOYPAD, MOUSE.ICON\r\n\r\nBROWSER COMMANDS\r\nBROWSER, TEXT, HTML\r\n\r\nCOMMON DIALOGUES\r\nCHOOSE.COLOR, CHOOSE.FONT, DIR, OPEN.FILE, OPEN.IMAGE, SAVE.AS, SETTINGS, SUBDIR, TITLE\r\n\r\nARITHMETIC FUNCTIONS\r\n#EVAL(, #FILTER(, #FOLD(, #MAP(, #MAX(, #MIN(, #POS(, #REV(, #SLICE(, #SORT(, #SUM(, #VAL(, ABS(, ARRAY(, ASC(, ASK(, ATN(, BACKWARD(, BANK(, BINARY.ADD(, BINARY.AND(, BINARY.NEG(, BINARY.NOT(, BINARY.OR(, BINARY.ROTATE(, BINARY.SHIFT(, BINARY.XOR(, BUFFER(, CAR(, CDATE(, CDR(, CEIL(, CHRCODE(, COLLIDE(, COLOR(, COMPARE(, CONS(, COS(, CTIME(, DATE(, DIMENSION(, DOC.LEN(, DOC.PAR(, DOC.UNIQUE.WORDS(, DOC.WORDS(, DRIVE.SERIAL(, EACH(, EOF(, EVAL(, EXIST(, EXIST.DIR(, FILE.STAMP(, FILELEN(, FLOOR(, FORWARD(, FRAC(, FREQUENCY(, FUNCTION(, GROUP(, GROUP.COUNT(, HIGHWORD(, HILOWWORD(, HSL(, IF(, IMAGE(, IMAGE.X(, IMAGE.X.PIXELS(, IMAGE.Y(, IMAGE.Y.PIXELS(, INKEY(, INSTR(, INT(, JOYPAD(, JOYPAD.ANALOG.X(, JOYPAD.ANALOG.Y(, JOYPAD.DIRECTION(, KEYPRESS(, LEN(, LEN.DISP(, LN(, LOCALE(, LOG(, LOWWORD(, MATCH(, MAX(, MAX.DATA(, MDB(, MIN(, MIN.DATA(, MODULE(, NOT, NOT_2, ORDER(, PARAGRAPH(, PARAGRAPH.INDEX(, PARAM(, POINT(, POINTER(, PROPERTY(, RANDOM(, READY(, RECORDS(, RINSTR(, ROUND(, SEEK(, SGN(, SIN(, SINT(, SIZE.X(, SIZE.Y(, SQRT(, STACK(, STACKITEM(, TAB(, TAN(, TEST(, TIME(, UINT(, USGN(, VAL(, VALID(, WRITABLE(\r\n\r\nSTRING FUNCTIONS\r\n#EVAL$(, #FOLD$(, #MAX$(, #MIN$(, #VAL$(, ADD.LICENSE$(, ARRAY$(, ASK$(, BMP$(, CHR$(, CHRCODE$(, DATE$(, DRIVE$(, DRW$(, ENVELOPE$(, EVAL$(, FIELD$(, FILE$(, FILE.APP$(, FILE.NAME$(, FILE.NAME.ONLY$(, FILE.PATH$(, FILE.TITLE$(, FILE.TYPE$(, FILTER$(, FORMAT$(, FUNCTION$(, GROUP$(, HEX$(, HIDE$(, IF$(, INPUT$(, JPG$(, LAZY$(, LCASE$(, LEFT$(, LEFTPART$(, LOCALE$(, LTRIM$(, MAX.DATA$(, MEMBER$(, MEMBER.TYPE$(, MENU$(, MID$(, MIN.DATA$(, PARAGRAPH$(, PARAM$(, PATH$(, PIECE$(, PIPENAME$(, PROPERTY$(, QUOTE$(, REPLACE$(, RIGHT$(, RIGHTPART$(, RTRIM$(, SHORTDIR$(, SHOW$(, SND$(, SPEECH$(, STACK$(, STACKITEM$(, STACKTYPE$(, STR$(, STRING$(, STRREV$(, TIME$(, TITLE$(, TRIM$(, TYPE$(, UCASE$(, UNION.DATA$(, WEAK$(\r\n\r\nVARS READ ONLY\r\nABOUT$, APPDIR$, BROWSER$, CLIPBOARD$, CLIPBOARD.IMAGE$, CODEPAGE, COLORS, COMMAND$, COMPUTER$, CONTROL$, DIR$, DURATION, EMPTY, ERROR$, FIELD_as variable, FONTNAME$, GRABFRAME$, GREEK_variable, HEIGHT, HWND, INKEY$, INTERNET, INTERNET$, ISLET, ISNUM, KEY$, LAN$, LETTER$, MEMORY, MENU.VISIBLE, MENU_as variable, MENUITEMS, MODE_variable, MODULE$, MODULE.NAME$, MONITOR.STACK, MONITOR.STACK.SIZE, MOTION.WX, MOTION.WY, MOTION.X, MOTION.XW, MOTION.Y, MOTION.YW, MOUSE, MOUSE.KEY, MOUSE.X, MOUSE.Y, MOUSEA.X, MOUSEA.Y, MOVIE.COUNTER, MOVIE.DEVICE$, MOVIE.ERROR$, MOVIE.STATUS$, MOVIE_as variable, MUSIC.COUNTER, NOW, NUMBER, OS$, OSBIT, PARAMETERS$, PEN_variable, PLATFORM$, PLAYSCORE, POINT, POS, POS.X, POS.Y, PRINTERNAME$, PROPERTIES$, REPORTLINES, RND, ROW, SCALE.X, SCALE.Y, SPEECH as variable, SPRITE$, STACK.SIZE, TAB, TEMPNAME$, TEMPORARY$, THIS, THREADS$, TICK, TIMECOUNT, TODAY, TWIPSX, TWIPSY, USER.NAME$, VOLUME_as variable, WIDTH_as variable, X.TWIPS, Y.TWIPS\r\n\r\nCONSTANTS\r\nASCENDING, BINARY_const, BOOLEAN, BYTE, CURRENCY, DATEFIELD, DESCENDING, DOUBLE_as constant, FALSE, FALSE _2, FORMATTING_ANY TYPE, FORMATTING_DATE AND TIME, FORMATTING_NUMBERS, FORMATTING_STRINGS, INFINITY, INTEGER, ISWINE, LONG_TYPE, MEMO, PI, SINGLE, TEXT_as constant, TRUE, TRUE _2, VERSION_as constant\r\n\r\nPRINTINGS\r\nPAGE, PRINTER, PRINTING, PROPERTIES\r\n\r\n
GR:ΟΜΑΔΑ\r\n1) just a simple group, we can place a value for a variable (is optional) in group definition\r\n      group alfa {a,b,c=4,d$,Long i}\r\n      input \"a:\", alfa.a\r\n2) A group with a function and a static variable\r\ngroup beta {\r\n      b=1, k\r\n      name$\r\n      function c {\r\n            read a\r\n            .b++   \\\\ or this.b++\r\n           .k<=a   \\\\ use <= to change group's variable\r\n            =a*.b  \\\\  or =a*this.b\r\n      }\r\n}\r\nprint beta.b\r\nprint beta.c(5), beta.b\r\nprint beta.c(5), beta.b\r\nprint beta.c(5), beta.b\r\n      1\r\n     10        2\r\n     15        3\r\n     20        4\r\n3) Pass a group to  a module...add this code to group beta from (2). So now we can pass not only variables, but functions too to a module.\r\nmodule any {\r\n      read &mygroup\r\n      ? mygroup.c(5), mygroup.b\r\n   }   \r\nany &beta\r\n      25        5\r\n      \r\n4) A more complicated example. Introducing to local variables and functions. These functions are local to the module that we create the group. We can use this group in other modules but not the local variables, arrays or and functions and modules. Main scope for local definition is to do manipulations on data only for creator (module or function). We use this to address variables, functions and modules. But we can't use \"this\" for any local in any other call to a reference to group from any other module or function.\r\nHere we use <= to asign a value without define a new variable (if we use this.many = a then we create a new this.many. So we use this.many<=a so interpreter search for it...in the group). Original name for many is delta.many\r\n\r\n  group delta {\r\n      dim ar(1)\r\n      local many=1\r\n      local module redim {\r\n            read a\r\n            if this.many>=a then exit\r\n            this.many<=a\r\n            dim this.ar(a)\r\n      }\r\n      Local function Integrity {\r\n      try ok {\r\n           if this.many=dimension(this.ar(),1) then {\r\n                  = true\r\n            }  else {\r\n                  = false\r\n            }\r\n      }\r\n      If not ok then =false\r\n      }\r\n}\r\ndelta.redim 10\r\ndelta.ar(5)=10\r\nprint delta.integrity()\r\nmodule testme {\r\n      read &mDelta\r\n      try ok {\r\n      mDelta.redim 50\r\n      }\r\n      ' we can redim ar() because is not local using straight redim\r\n      dim mDelta.ar(100)\r\n}\r\ntestme &delta\r\nprint delta.integrity()\r\ndelta.many=100\r\nprint delta.integrity()\r\n\r\n5) Using prototype\r\nT$={A,B, C$}\r\ngroup a type t$\r\ngroup b type t$\r\ngroup c type t$\r\n\r\n6) adding members and using  group.count, member$() and member.type$()\r\nt$={a, b, c$}\r\ngroup a type t$\r\ngroup a {\r\n      a=100     'this in not added because exist\r\n      d=20\r\n      function alfa {\r\n      =this.a*this.d\r\n      }\r\n      dim a(20)=20\r\n      long k\r\n}\r\nfor i=1 to group.count(a) {\r\nprint member$(a, i), @(20), member.type$(a, i)\r\n}\r\nprint a.alfa()\r\n\r\n7) There is two labels Private: and Public: for making some items private.\r\n\r\n\r\nGENERAL INFO\r\nWe can make group of variables, arrays, events, lambdas, inventories and buffers and groups. \r\nScope ot the group is to make a set of variables and relative functions and modules to be passed in a module by reference. Groups are not objects. \r\nGroups are like objects but  is a collection (we say a group) of variables that exist, in the execution state, in a module or function and when module or function ends the execution, those variables and the group are erased . Passing a group by reference to a module or function we pass all variables in group by reference. We can pass one variable of group by reference only too.\r\nIn any group we can add members, but we can delete them, they are deleted with all members, with group as we saw that before. A reference to a group can add members too but that members are not members of the original group. So the reference group to a group is an other object, not just a reference, although the variables, members, in the group are references. Members are variables in the list of the module or function. We can use LIST to display variables.  We can look if a member exist using VALID() function.\r\n\r\n\r\n\r\n\r\nSIMPLE EXAMPLE \r\ngroup a_name {\r\n      Long a, b, c\r\n      Dim a%(20)=6\r\n      a%(3)=10\r\n      d$=\"Something\"\r\n      b$  ' no value\r\n      function inc {\r\n            this.a++\r\n            =this.a\r\n      }\r\n}\r\n\r\nprint a_name.inc(), a_name.inc(), a_name.inc()\r\nprint a_name.d$\r\na_name.A%(4)=1,2,3,4,5\r\nfor i=1 to 10 {\r\nprint a_name.a%(i)\r\n}\r\n\r\nUSING PROTOTYPE\r\nThe same example but we use  a string as a definition of the group\r\nprototype$ = {\r\n      Long a, b, c\r\n      Dim a%(20)=6\r\n      a%(3)=10\r\n      d$=\"Something\"\r\n      b$  ' no value yet\r\n      function inc {\r\n            this.a++\r\n            =this.a\r\n      }\r\n}\r\ngroup a_name type prototype$\r\ngroup b_name type prototype$\r\ngroup c_name type prototype$\r\n\r\nprint a_name.inc(), a_name.inc(), a_name.inc()\r\nprint a_name.d$\r\na_name.A%(4)=1,2,3,4,5\r\nfor i=1 to 10 {\r\n      print a_name.a%(i), b_name.a%(i)\r\n}\r\n\r\n\r\n\\* Here we can see how we can display the members of the group (except locals)\r\n\\* Also the use of THIS to read variables from group.\r\nform 80,48\r\nflush\r\ngroup a {\r\n      a=4\r\n      group bb {\r\n            c=34\r\n            c1$=\"George\"\r\n            group dd {\r\n                  d=45\r\n                  e=13      \r\n                  group chaos {\r\n                        a=1\r\n                        b=2\r\n                        c=3\r\n                        }\r\n            }\r\n            module other {\r\n            print \"Hello\"\r\n            print this.c1$, \"YES\"\r\n            }\r\n            function mine$ {\r\n                  read a$\r\n                  =a$ + \" \"+.c1$\r\n            }\r\n      }\r\nb=5\r\nc=6\r\ndim a(20)=10\r\ndocument aa$=\"ok\"\r\n}\r\n\r\nfunction count_member {\r\nread &a\r\nread from a;\r\n=stack.size\r\n}\r\nread from a,  a1,Group2 ,,, Group3, , ,Group4\r\nlist  \\\\ give a list of variables/arrays/objects\r\ngroup Group3 {\r\n      K=67\r\n      L=54\r\n}\r\npush &Group3\r\nread &all\r\nprint group.count(A),  count_member(&a)\r\nprint group.count(all), count_member(&all)\r\nfor i=1 to group.count(A) {\r\nprint member$(a,i), @(20),member.type$(a,i)\r\n}\r\n' These 4 variables are one (a.bb.dd.chaos.c)\r\ngroup4.c=1000\r\nprint group3.chaos.c\r\nprint group2.dd.chaos.c\r\nprint a.bb.dd.chaos.c\r\nprint group3.k  , valid(a.bb.dd.k)\r\n\\* in Group3 we make 2 more members local\r\nmodule TestMe {\r\n      read &mygroup\r\n      print mygroup.mine$(\"Hello\")\r\n      mygroup.other\r\n\r\n}\r\na.bb.other\r\nTestMe &Group2\r\n****************************************************************************\r\nBig Example ( copy all lines until the end of text here to a module)\r\n****************************************************************************\r\nrem 1) use of private/public/for/read ?/valid()\r\ngroup alfa {\r\nprivate:\r\n      x, y\r\npublic:\r\n      \\\\ ? in read means optional\r\n      module setXY { read ? .x, .y}\r\n      function getX {=.x}\r\n      function getY {=.y}\r\n}\r\nprint valid(alfa.x)   \\\\ 0 false, we can't read alfa.x\r\nalfa.setXY 10, 40\r\nprint alfa.getX()  \\\\ 10\r\nfor alfa {\r\n      print .getX(), .getY()\r\n}\r\nalfa.setXY ,20\r\nfor alfa {\r\n      print .getX(), .getY()\r\n}\r\nalfa.setXY 5\r\nfor alfa {\r\n      print .getX(), .getY()\r\n}\r\n\r\nrem 2) use by reference\r\nmodule CheckMe {\r\n      \\\\ a new group prepared with all items reference to actual items\r\n      \\\\ modules and functions are just copies to new group\r\n      \\\\ special local items in actual item never referenced (we don't have here)\r\n      read &byref\r\n      for byref {\r\n            print \"old value X:\";.getX()\r\n            .setXY 100\r\n            print \"new value X:\";.getX()\r\n      }\r\n}\r\nCheckMe &alfa\r\nPrint \"alfa value:\";alfa.getX()\r\nrem 3) use byref a function only from group\r\nmodule CheckFunc {\r\n      read what$, &func()\r\n      Print what$;func()\r\n}\r\nCheckFunc \"value for x is \", &alfa.getX()\r\nCheckFunc \"value for y is \", &alfa.getY()\r\n\r\nrem 4) using weak reference\r\nweakref$=weak$(alfa)\r\n\\\\ we have to use function() to resolve weak reference for functions\r\nprint function(weakref$.getX())\r\nmodule CheckMe2 {\r\n      \\\\ always here read actual group\r\n      read weakref$\r\n      print \"inside CheckMe2 \";function(weakref$.getX())\r\n      weakref$.setXY 1,1\r\n}\r\nCheckMe2 &alfa    \\\\ &alfa is a weakref  and *read* inside module decide what to do\r\nfor alfa {\r\n      print .getX(), .getY()\r\n}\r\n\r\nrem 5) we can add some item too.\r\ngroup alfa {\r\n      module printXY {\r\n            print .x,.y\r\n      }\r\n}\r\nalfa.printXY\r\n\r\nrem 6) Overide a module, on a reference of a group\r\nModule CheckReplace {\r\n      read &rep\r\n      group rep {\r\n            module printXY {\r\n                  print \">>>\", .x,.y\r\n            }\r\n      }\r\n      rep.printXY\r\n}\r\nCheckReplace &alfa\r\nalfa.printXY\r\n\r\nrem 7) Find if a group is by reference or not\r\n\\\\ using a group local variable\r\ngroup alfa { \r\n      local stamp\r\n}\r\n\\\\ and a global function using weak reference (is not a reference)\r\nfunction global IsRef { read a$ : =not valid(eval(a$.stamp)) }\r\nprint IsRef(&alfa)   \\\\ 0 false is not reference\r\nmodule CheckDeep {\r\n      read &any\r\n      print IsRef(&any)  \\\\ -1 is a reference\r\n}\r\nCheckDeep &alfa\r\nrem 8) Make an array of same group\r\nalfa.setXY 100, 200\r\n\r\ndim MyAr(10)=alfa\r\n\\\\ using =alfa, all modules and functions are common for all items\r\nMyAr(0).printXY   \\\\ 100, 200\r\nMyAr(2).setXY 2,4\r\nMyAr(2).printXY\r\nPrint valid(MyAr(2).stamp)  \\\\ it is valid\r\nFor MyAr(2) {\r\n      print IsRef(&this)   \\\\ no\r\n      CheckDeep &this    \\\\ yes\r\n}\r\n\\\\ this is a copy\r\nMyAr(0)=MyAr(2)\r\nMyAr(0).printXY   \\\\ 2,4\r\nrem 9) redim array preserving values, and instatiate new items\r\ndim MyAr(20)\r\n\\\\ if we use =alfa then all items restore to aa values\r\n\\\\ so we use stock to sweep 10 items from item 10 (11th, 0 is the first item)\r\nstock MyAr(10) sweep 10, alfa\r\nMyAr(dimension(MyAr(), 1)-1).printXY   \\\\ 100, 200\r\nMyAr(0).printXY  \\\\ 2, 4 preserved\r\nFor MyAr(1) {\r\n      group this {\r\n            module printXY {\r\n                  print \">>>\", .x,.y\r\n            }\r\n      }\r\n      this.printXY\r\n}\r\n\\\\ no change out of For obj { }\r\nMyAr(1).printXY   \\\\ 0 to 9 use common modules/functions\r\nFor MyAr(19) {\r\n      group this {\r\n            module printXY {\r\n                  print \">>>\", .x,.y\r\n            }\r\n      }\r\n      this.printXY\r\n}\r\n\\\\ change happen for good\r\nMyAr(19).printXY  \\\\ 11 to 19 use own modules/functions\r\n\\\\ so now we can make a temporary array of alfa\r\n\\\\ we do a copy one by one item\r\n\\\\ and a copy back for all to MyAr()\r\n\\\\ Ma() erased automatic after For This { }\r\nfor this {\r\n      Dim Ma(20)=alfa\r\n\\\\      for i=0 to 19 { Ma(i)=MyAr(i)}\r\n\\\\      same as above\r\n      stock ma(0) keep 20, MyAr(0)\r\n      MyAr()=Ma()\r\n}\r\n\\\\ now modules are equal\r\nMyAr(1).printXY\r\nMyAr(19).printXY\r\nFor MyAr(19) {\r\n      \\\\ temporary change\r\n      group this {\r\n            module printXY {\r\n                  print \">>>\", .x,.y\r\n            }\r\n      }\r\n      this.printXY\r\n}\r\n\\\\ no change happen, all items have common modules/functions.\r\nMyAr(19).printXY \r\n\r\n\r\nExample with operators for groups\r\n\r\nGroup alfa {\r\n\\\\Private:\r\n      x, y\r\n\\\\Public:\r\n      Module GetXY { Read  ? .X, .Y }\r\n      Operator \"++\" {\r\n            .X++\r\n            .Y++\r\n      }\r\n      Operator \"=\" {\r\n           Read N\r\n           push .X=N.X and .Y=N.Y\r\n      }\r\n      Operator \">\" {\r\n           Read N\r\n           push .X>N.X and .Y>N.Y\r\n      }\r\n      Operator \"+=\" {\r\n            Read N\r\n            .X+=N\r\n            .Y+=N\r\n      }\r\n      Operator \"+\" {\r\n             Read M\r\n            .X+=M.X\r\n            .Y+=M.Y\r\n      }\r\n      Operator \"*\" {\r\n             Read M\r\n            .X*=M.X\r\n            .Y*=M.Y\r\n      }\r\n}\r\nalfa.GetXY 100,300\r\nDim A(10)=alfa\r\na(1).GetXY 1,30\r\nfor a(1) {This+=5}\r\nPrint a(1).x\r\na(2)=a(1)\r\nPrint a(1).x,a(2).x\r\nPrint a(1).x*(a(1).x+a(2).x),$(3),\"6*(6+6)\"  \\\\ $(3) for right justfication \r\na(4)=a(1)*(a(1)+a(2))\r\na(5)=a(1)*(a(2)+a(1))\r\nPrint $(0), A(4)>A(5)  \\\\\\ $(0) return to normal\r\nPrint A(4)=A(5)\r\nPrint A(4).x, A(5).x\r\nprint type$(a(2))\r\nPrint a(2).X, a(2).Y\r\na(2)+=100\r\nPrint a(2).X, a(2).Y\r\n\r\nsee example for operatrors in Class\r\n\r\n
GR:ΟΜΑΔΑ$(\r\nClass alfa$ {\r\nPrivate:\r\n      Name$\r\nPublic:\r\n      value {\r\n            =.Name$\r\n      }\r\n      Property Length {Value}=0\r\nClass:\r\n      Module alfa {\r\n            Read .Name$\r\n            .[Length]<=Len(.Name$)\r\n      }\r\n}\r\n\r\na$=alfa$(\"Hello\")\r\nPrint a.length, a$, type$(a$), type$(a)\r\nb$=Group$(a$)\r\nPrint b.length, b$, type$(b$), type$(b)\r\nc$=a$\r\nPrint type$(c$), c$
GR:ΟΜΑΔΑ(\r\nGroup Alfa {\r\nPrivate:\r\n      x=0\r\nPublic:\r\n      Value {\r\n            =.x\r\n            .x++\r\n      }\r\n}\r\n\r\nPrint Alfa, Alfa, Alfa\r\nBeta=Alfa\r\nPrint Beta , Beta, Beta  ' 3   3   3  is a double\r\nPrint Type$(Beta)\r\nDelta=Group(Alfa)\r\nPrint Delta, Delta, Delta ' 4, 5, 6\r\nPrint Alfa, Alfa, Alfa' 4, 5, 6\r\n
GR:ΟΜΑΔΑ.ΣΥΝΟΛΟ(\r\n\r\nReturn number of members in a group\r\nSee example\r\n\r\nGroup Alfa {\r\nPrivate:\r\n      x=100\r\nPublic:\r\n      a=10\r\n      b=20\r\n      Dim K(20)=50\r\n      Module beta {\r\n            Print .a, .b, .a*.b, .x, .K()\r\n      }\r\n}\r\nAlfa.Beta\r\nPrint Group.Count(Alfa)  \\\\ 3 only variables and arrays\r\nFlush ' empty stack\r\nFor i=1 to Group.Count(Alfa)\r\n      Print \"Weak Reference: \"; Member$(alfa, i), Member.type$(alfa, i)\r\n      Push Filter$(Member$(alfa, i),\"(\")  ' remove ( from array\r\nNext i\r\nStack  ' look the stack now\r\nRead &K1(), &B1, &A1\r\nTry ok {\r\n    Read &x1  ' it is private so no reference exist!\r\n}\r\nIf not ok then Print Error$\r\nPrint K1(3), B1, A1\r\nB1+=100\r\nPrint Alfa.b\r\n\r\n\\\\ this is a way to get references (not by using weak references), including private variables\r\nRead From Alfa, x2, a2, b2, M()\r\nPrint x2, a2, b2, M()\r\na2+=1000\r\nx2*=500\r\nalfa.beta
GR:ΟΜΑΛΑ\r\n\r\nSMOOTH ON\r\nSMOOTH OFF\r\nEnable GDI+ for lines, bezier courves, polygons and circles.\r\n
GR:ΟΝΟΜΑ\r\n\r\nNAME filename1 AS filename2\r\nrename files in current directory  DIR$\r\n
GR:ΟΝΟΜΑ.ΑΡΧΕΙΟΥ$(\r\nReturn name and type of a full path plus name and type (if there are parameters after name then these excluded also)\r\nPrint File.Name$(\"c:\\name1\\name2.exe -help\")\r\nname2.exe\r\n\r\n
GR:ΟΝΟΜΑ.ΑΡΧΕΙΟΥ.ΜΟΝΟ$(\r\n\r\nMenu \\\\ clear Menu list\r\nFiles + \"*\"  \\\\ feed Menu list with filenames\r\nMenu ! \\\\ open Menu\r\nIf Menu>0 Then Print Menu$(Menu), File.Name.Only$(Menu$(Menu))\r\nPrint File.Name.Only$(\"c:\\alfa beta\\delta.klm\")  \\\\ no check if file exist \r\n\\\\ automatic remove of any parameters after name\r\nPrint File.Name.Only$(\"c:\\alfa beta.bin\\delta.klm  -help fileother.txt\")  \\\\ no check if exist file\r\n\\\\ can work with spaces\r\nPrint File.Name.Only$(\"c:\\alfa beta\\delta one.klm\")  \\\\ no check if exist file\r\n\\\\ remove any parameters after name,\r\nPrint File.Name.Only$(\"c:\\alfa beta.bin\\delta one.klm  -help fileother.txt\")  \\\\ no check if exist file\r\n\r\n
GR:ΟΝΟΜΑ.ΤΜΗΜΑΤΟΣ$\r\nmodule beta {\r\n\tPrint module$\r\n\t\\\\ processing the module$\r\n\t\\\\ to retrieve the displayed name\r\n\tPrint module.name$\r\n}\r\ncall beta
GR:ΟΝΟΜΑ.ΧΡΗΣΤΗ$\r\n? USER.NAME$\r\nwe can have many users in m2000. Each of them have a user folder and can write only there. Except the supervisor that can write anywhere. \r\nif we change dir then we can return to user folder using this:\r\nDIR USER \r\n\r\nwe can make new users  or select if exist with  \r\nUSER name\r\n\r\nSupervisor has a phantom name. We can create a user with supervisor name but this will be another user, not the supervisor. So we can't change, by using USER, to the supervisor (it is another command that you have to read help carefully to found).\r\n\r\nin a user mode commands WIN and DOS not run.
GR:ΟΡΙΟ.ΑΝΑΔΡΟΜΗΣ\r\nBy default limit  for subroutines is 10000 calls\r\nRecursion.limit 1000\r\nRecursion.limit 0   \\\\ this means no limit\r\nsee examples below\r\nSubs have own stack, not system. Methods and Functions use the system stack.\r\n\r\nFor system stack:\r\ncheck stack limit and known paths with Monitor command.\r\nswitches \"-REC\"  \r\nchange limit to safe stack size 300\r\nswitches \"+REC\"\r\nchange limit to default stack size 3375\r\nonly limit change not actual stack size. \r\n\r\nexample 1:\r\n\\\\ this is end to 9999\r\na(1)\r\n\r\nsub a(x)\r\n      print x\r\n      x++\r\n      if x<10000 then a(x)\r\nend sub\r\nexample 2:\r\n\\\\ this is not end to 9999 because  we use { } and this use stack space.\r\na(1)\r\n\r\nsub a(x)\r\n      print x\r\n      x++\r\n      if x<10000 then { a(x)}\r\nend sub
GR:ΟΡΙΣΕ\r\nDeclare MessageBox Lib \"user32.MessageBoxW\" {long alfa, lptext$, lpcaption$, long type}\r\nPrint MessageBox(Hwnd, \"HELLO THERE\", \"GEORGE\", 2)\r\nRemove \"user32\"\r\n(if we call MessageBox() again then new reload happen)\r\nAll libraries removed when we finish the run of m2000.exe\r\nDeclare timeGetTime Lib \"winmm.timeGetTime\" {}\r\n\r\nwhile MessageBox(Hwnd, \"HELLO THERE \"+str$( timeGetTime()),\"GEORGE\",2)=4 {\r\nPrint \"one time again\" \r\nRefresh\r\n}\r\n\r\nExample for passing string by reference\r\nDeclare PathAddBackslash Lib \"Shlwapi.PathAddBackslashW\" { &Path$ }\r\nP$ = \"C:\"+String$(Chr$(0), 250)\r\nA= PathAddBackslash( &P$ )\r\nPrint LeftPart$(P$,0)\r\n\\* LeftPart$ is a new function and is like this Mid$(P$,1,Instr(P$,Chr$(0))-1)\r\n\r\nExample of using an object inside a function using declare to create/destroy\r\nFunction MsgBox {\r\n      Read Prompt$, Buttons, mTitle$\r\n      declare Alfa \"WScript.Shell\"\r\n      method Alfa, \"Popup\", Prompt$, 0, mTitle$, Buttons as msgbox_result\r\n      declare Alfa nothing\r\n      =msgbox_result\r\n}\r\na=MsgBox({aaaaaa\r\nбезопасность\r\ncccccccccccc\r\ndddddddddddddd \r\n},1024+64+3,\"безопасность\")\r\n\r\n? a\r\n\r\n\r\nExample 2:\r\n\r\nClear\r\nDeclare vs \"MSScriptControl.ScriptControl\"\r\nDeclare Alfa Module\r\nPrint Type$(Alfa)\r\nWith vs, \"Language\",\"Jscript\", \"AllowUI\", true\r\nMethod vs, \"Reset\"\r\nPrint Type$(Alfa)\r\nMethod vs, \"AddObject\", \"M2000\",  Alfa\r\nMethod vs, \"ExecuteStatement\", {\r\n               \r\n            M2000.AddExecCode(\"Function BB {=1234 **number} : k=2\");\r\n            M=M2000.ExecuteStatement(\"Print 1234, BB(k)\");\r\n            M2000.AddExecCode(\"aa$=key$\");\r\n}\r\nMethod vs, \"eval\", {\"hello there\"} as X$\r\nPrint X$\r\nMethod vs, \"eval\", {\"hello there too\"} as X$\r\nPrint X$\r\nList\r\nDeclare vs Nothing\r\n\r\n\r\n\r\nmybuf$=String$(Chr$(0), 1000)\r\n\\\\ This is for global use. You can declare local without using Global\r\nDeclare Global MyPrint Lib C \"msvcrt.swprintf\" { &sBuf$,  sFmt$, ... } \r\n\\\\  ... means any number  and kind\r\n\\\\  & means by reference\r\n\\\\  ! before a numeric expression to pass it as Long\r\nA=MyPrint(&myBuf$, \"Γειά P1=%s, P2=%d, P3=%.4f, P4=%s\", \"ABC\", !123456, 1.23456, \"xyz\")\r\nPrint Left$(myBuf$,A)\r\n\r\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\big example\\\\\\\\\\\\\\\\\r\nDeclare form1 form\r\nWith form1, \"visible\" as visible\r\nwith form1, \"Title\", \"Download Example\"\r\nlayer form1 {\r\n\twindow 12, 12000,6000\r\n\tcls #333333\r\n\tcursor 0,2\r\n\treport 2,\"close form to exit download\"\r\n}\r\nMethod form1, \"show\"\r\ncls,0\r\nreport 2, \"Download 3 Files using Download object\"\r\ncls, 10\r\ndeclare withevents d(2) download\r\nw=0\r\nm=row\r\nFunction d_Start(new con, host$,port) {\r\n\tcursor 0,m\r\n\tPrint Part con, host$, port\r\n\tPrint under\r\n\tm=row\r\n\tw++\r\n}\r\nFunction d_DownloadProgress(new con, many, total) {\r\n\tcursor 0,3+con\r\n\tPrint over $(4,10), con,  many;\"/\";total\r\n\t\\\\ do not use Refresh here\r\n\tcursor 0, m\r\n\tlayer form1 {\r\n\t\tcursor 0,3+con\r\n\t\tPrint over $(4,10), con,  many;\"/\";total\t\t\r\n\t}\r\n}\r\nFunction d_DownloadError(new con) {\r\n\tcursor 0,m\r\n\tPrint \"DownLoad Error\"\r\n\tPrint  con, number, letter$\r\n\tm=row\r\n\tlayer form1 {\r\n\t\tcursor 0,3+con\r\n\t\tPrint over $(4,10), con,  \"failed\"\r\n\t}\r\n\tw--\r\n}\r\nFunction d_DownloadComplete(new who, a$) {\r\n\tcursor 0,3+who\r\n\tprint over a$+\" - complete\"\r\n\tlayer form1 {\r\n\t\tcursor 0,3+who\r\n\t\tprint over a$+\" - complete\"\t\t\r\n\t}\r\n\tw--\t\r\n}\r\ndeclare d() over   ' one more withevents\r\n\\\\ GetUrl$() function used if we wish the property url to connect on the fly, and disposed\r\n\\\\ because object is naked (not in a mHandler carrier), can't used as value\r\n\\\\ so we have to pass it by reference\r\n\\\\ M2000 pass array items by reference using a second variable, which pass by reference\r\n\\\\ and at the exit get the value from the variable and try to store it back to array to proper item\r\n\\\\ no error happen if array has no item with specific item number\r\n\\\\ this method is like copy in copy out\r\n\\\\ VB6 lock arrays if we pass an array item by reference. M2000 never lock arrays.\r\nFunction GetUrl$(&where) {\r\n\tWith where, \"url\" as url$\r\n\t=url$\r\n}\r\nDim url$(3)\r\nfor i=0 to len(d())-1\r\n\tWith d(i), \"url\" as url$(i)  \\\\ connect property url of d(i) to url$(i)\r\nnext i\r\nMethod d(0), \"DownloadFile\", \"http://www.vbforums.com/showthread.php?818583-Binary-Code-Thunk-Experiment\", dir$+\"vbforums.html\"\r\nMethod d(2), \"DownloadFile\", \"http://www.cs.virginia.edu/~evans/cs216/guides/x86.html\", dir$+\"x86.html\"\r\nMethod d(1), \"DownloadFile\",\"http://rosettacode.org/wiki/Rosetta_Code\", dir$+\"rossetacode.html\"\r\ncursor 0, m\r\n\r\nfor i=0 to len(d())-1\r\n\tPrint Part \"Read Property Url for\"+str$(i)+\":\";~(11); url$(i)  ' GetUrl$(&d(i)) \r\n\tPrint Under\r\nNext\r\nPrint \"press left mouse to exit\"\r\nrefresh\r\nm=row\r\ncls,m\r\nkk=0\r\nthread {\r\n\tcursor 0, m\r\n\tprint kk\r\n\tkk++\r\n\tm=row\r\n} as mm interval 10\r\nWhile w\r\n\tcursor 0,2\r\n\tprint over $(4),\"live connections:\";w, visible\r\n\tif keypress(2)  or not visible then exit\r\n\tbb$=inkey$\r\n\t\\\\ wait 0\r\n\t\\\\ threads need a wait or a Key$, or Inkey$ or a Main.Task or a Every, or a Modal form to be opened.\r\n\t\\\\ com events no need this.\r\nEnd While\r\nthreads erase\r\nwait 100\r\ncursor 0,2\r\nprint over $(4),\"live connections:\";w\r\ncursor 0,m\r\nprint \"done\"\r\ndeclare d() nothing\r\ndeclare form1 nothing\r\n\r\n\r\n
GR:ΟΡΙΣΜΟΙ\r\nDEFINITIONS\r\nAUTO_ARRAYS, BINARY, BUFFER, CLASS, CONST, DECLARE, DEF, DIM, DOCUMENT, ENUM, ENUMERATION, EVENT, GLOBAL, GROUP, INVENTORY, LAMBDA, LET, LOCAL, LONG, METHOD, PROPERTY, SET, STATIC, STOCK, SUPERCLASS, SWAP, WITH\r\n\r\n
GR:ΟΡΟΦ(\r\n\r\nround to next integer value
GR:ΟΧΙ\r\nPrint Not True   ' 0  means false\r\nPrint Not False ' -1 means true
GR:ΠΑΙΖΕΙΦΩΝΗ\r\nPrint PLAYSCORE\r\n\r\nif any score thread exist then playscore return true\r\n
GR:ΠΑΙΚΤΗΣ\r\n\r\nAbove main screen there are 32 Layer acting as Players. Those players are \"hardware\" sprites, because the system draw them with GPU.\r\n\r\n1) Player 0\r\nFlush all players\r\n2)  player 1, 2000,3000 use AA$, 1, 0,angle size 1.4\r\n2.1)  player 1, 2000,3000 use AA$, MASK$, 0,angle size 1.4\r\nFirst number is priority number. 1 for lowest and 32 for higher (32 player is top of all)\r\nPosition 2000,3000 relative to window (see Window)\r\nAA$ is a string containing a DIB. Color for transparency, 0 to 15 and negatives for RGB (use Color(0..255, 0..255,0..255) to define color. We can give an intensity  so we can make transparent colors in a bigger region. With  -1 in intensity we cancel transparency. And finally we have the size, 1 for 100%\r\n\r\n\r\n3)  Player 1 show\r\n     A player  can change invisible. So we must show to be displayed on screen\r\n4)  Player 1 hide\r\n     The opposite. Player going to standby.\r\n5)   Player 1 swap 4\r\n       We can change priorities. We use variables as handlers so we can change what the handlers show to us. Look Collision\r\n6) Player 1, 5000,6000\r\n     Moving Player to new position.\r\n\r\nWe can handle Players with command Layer as screen. So we can put targets, graphics, scrolling numbers and formatted text, images.\r\n\r\n\r\nExample\r\n-----------------------------------------\r\nIn a module A copy this:\r\n      Background {\r\n            Gradient 1,5\r\n      }\r\n      Form 20,40  \r\n      Move 0,0\r\n      clear AA$\r\n      Cls 0,0  :  Pen 15  \r\n      Print \"aaaaaaaaaa\"  :  Print \"{ {  } }\"    \\\\ a simple image\r\n      Copy 3000,1000 To AA$\r\n      SZ=1  \\\\first size...1 in player means 100%\r\n      Player 1, 2000,2000 Use AA$,  15, 0 size  SZ \r\n      Player 1 Show    \r\n      Wait 10               \r\n      Cls   4, 3\r\n      Move 0,0\r\n      TRY {  \\\\ we use try { } yo catch Break or Escape\r\n      EVERY 30 {\r\n            XX=MOUSEA.X\r\n            YY=MOUSEA.Y\r\n            Draw To Mouse.X, Mouse.Y\r\n            Background {\r\n                  Draw To Mouse.X, Mouse.Y\r\n            }\r\n            Player 1,XX-3000*sz/2, YY-1000*sz/2\r\n            a$=Inkey$\r\n            If A$<>\"\" Then {\r\n                  Select Case A$\r\n                  Case \"1\"\r\n                        If SZ>.6 Then SZ=SZ/1.2\r\n                  Case \"2\"\r\n                        If SZ<5 Then SZ=SZ*1.2\r\n                  Else\r\n                        BREAK\r\n                  End Select\r\n                  \\\\ change hot spot from middle to bottom right corner\r\n                  Player 1, mouseA.x-3000*sz/2, mouseA.y-1000*sz/2 Use AA$,15, 0 size SZ\r\n                  A$=\"\"\r\n            } \r\n      } \r\n      }\r\n      Player 1 Hide\r\n      Player 0 ' clear all\r\n
GR:ΠΑΙΞΕ\r\n\r\nScore 1, 500, \"c@2dc @2ef\"\r\nPlay 1, 19\r\n\r\nSee Choose.organ and Score\r\n\r\nPlay scorenumber and instrument (organ)\r\nWe have 16 voices/scores that can play synchronous\r\nIf we execute a play command to same scorenumber that was played then we execute one score over the other. That happen because for each score a thread is open and the play command just say to start and use an organ (instrument). So any thread when the time is up send a change to next note or pause to same to a voice with same number as the score have. So two or more threads can send changes to same voice if they have the same scorenumber.\r\n\r\nThreads in M2000 are lived in a module and died with that. But those threads that send notes and pauses to synthesizer are not died. We can close the synthesizer with PLAY 0\r\n\r\n\\\\ Keyboard - can play two or more notes at once\r\n\\\\ some keybards can play max 6 notes, some other max 4\r\ndim note1$(10,3), note2$(10,3)\r\nFillArray()\r\nForm 60,30\r\nPen 14\r\nCls 5\r\nDouble\r\nReport 2, \"Keyboard 005\"   \r\nNormal\r\nReport 2,{Menu\r\n1-Exit  3-Xylophone 4-Piano 5-Saxophone  8-Show Keys/Notes 9-Rythm Yes 0-Rythm No\r\n\r\nSpace bar - set higher the volume for each note\r\n-- George Karras --\r\n\r\n}\r\nThread.Plan Sequential\r\nPlay 0 \\\\ clear music threads\r\nGlobal kb$=\" \", tempo=300, org=5, f=0, vol$=\"V90\", voi(18), use(17) ' 0 ..17,\r\nn=1\r\nFor i=1 to 16 { use(i)=True }\r\nuse(10)= false \\\\ For drum machine\r\n\\\\ compute virtual clavie position\r\nmm=2*(scale.x div 14)\r\nmm2= mm div 2\r\nkk=row/height*scale.y\r\nkk1=scale.y/height*8\r\ngram=scale.y/height*1.5\r\nCls , row+9\r\nModule ClKey {\r\n      Read a$, press, sel\r\n      If press Then {\r\n      If Instr(kb$,a$+\"-\")>0 Then Exit\r\n      Next()\r\n      voi(sel)=f\r\n      Print a$, f\r\n      Score f, tempo, a$+vol$ : kb$<=kb$+a$+\"-\": Play f, org\r\n      } else {\r\n            kb$<=Replace$(a$+\"-\",\"\", kb$)\r\n            If voi(sel)>0 Then {\r\n             Play voi(sel), 0 \r\n             use(voi(sel))~\r\n             voi(sel)=0\r\n             }\r\n      }\r\n      Sub Next()\r\n      Local i\r\n      For i=1 to 16 {\r\n            If use(i) Then Exit\r\n      }\r\n      If i<17 Then { f<=i : use(i)~ } else f<=1: use(1)=True : Print \"!!!!!!!!\"\r\n      End Sub\r\n}\r\n\\\\ 10 for drum machine\r\nThread { Score 10,400,\"CV90CC  ab Cd eCC\" : Play 10,1 } as L Interval 60\r\nThread {\r\n      ClKey \"A#2\", KeyPress(asc(\"A\")), 1\r\n      ClKey \"B2\", KeyPress(asc(\"Z\")), 2\r\n      ClKey \"C3\", KeyPress(asc(\"X\")), 3\r\n      ClKey \"C#3\", KeyPress(asc(\"D\")), 4\r\n      ClKey \"D3\", KeyPress(asc(\"C\")), 5\r\n      ClKey \"D#3\", KeyPress(asc(\"F\")), 6\r\n      ClKey \"E3\", KeyPress(asc(\"V\")), 7\r\n      ClKey \"F3\", KeyPress(asc(\"B\")), 8\r\n      ClKey \"F#3\", KeyPress(asc(\"H\")), 9\r\n      ClKey \"G3\", KeyPress(asc(\"N\")), 10\r\n      ClKey \"G#3\", KeyPress(asc(\"J\")), 11\r\n      ClKey \"A3\", KeyPress(asc(\"M\")), 12\r\n      ClKey \"A#3\", KeyPress(asc(\"K\")), 13\r\n      \\\\ https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx\r\n      ClKey \"B3\", KeyPress(0xBC), 14 \\\\ VK_OEM_COMMA\r\n      ClKey \"C4\", KeyPress(0xBE), 15 \\\\ VK_OEM_PERIOD\r\n      ClKey \"C#4\", KeyPress(0xBA), 16 \\\\ VK_OEM_1\r\n      ClKey \"D4\", KeyPress(0xBF), 17 \\\\VK_OEM_2  \r\n} as al Interval 50\r\nPrint \"οκ\"\r\nThreads\r\nThread L Interval 6000\r\nMain.Task 100 {\r\n      Display(mm, kk, mm2, kk1)\r\n      Refresh 1000\r\n      If KeyPress(asc(\"1\")) Then Exit\r\n      If KeyPress(asc(\"3\")) Then org<=14 : tempo<=100 \r\n      If KeyPress(asc(\"4\")) Then org<=5 : tempo<=300\r\n      If KeyPress(asc(\"5\")) Then org<=65 : tempo<=5000\r\n      If KeyPress(asc(\"8\")) Then n=1-n\r\n      If KeyPress(asc(\"9\")) Then Thread L Restart\r\n      If KeyPress(asc(\"0\")) Then Thread L Hold\r\n      If KeyPress(32) Then { vol$ <= \"V127\"  } else vol$ <= \"V90\"\r\n      Print \"--------\"\r\n}\r\nThreads Erase\r\nPrint \"END\"\r\nSub Display(p0,y0, p1, y1)\r\n      Clavie(p0, y0, p1, y1, 0, &note1$())\r\n      Clavie(p0-p1/2,y0,p1,y1*2/3, -1, &note2$())\r\n      Refresh 1000\r\nEnd Sub\r\nSub Clavie(p0, y0,p1, y1, p3, &n$())\r\n      Link n$() to n()\r\n      p3-!\r\n      Local k=-1, i\r\n      For i=p0 to 9*p1+p0 step p1\r\n      k++\r\n      If n$(k,0)<>\"\" Then {\r\n            Move i+p3*p1/6, y0\r\n            If p3 Then {\r\n                  Fill p1-p3*p1/3-15,y1-15, 7* (1-(voi(n(k,2))>0))+1, 0,1\r\n            } else {\r\n                  Fill p1-15,y1-15,15,7* (1-(voi(n(k,2))=0))+1,1\r\n            }\r\n            Move i+p3*p1/6, y0\r\n            Fill @ p1-p3*p1/3,y1,2,1\r\n            Move i+p3*p1/6, y0+y1-gram\r\n            Pen p3*15 { Fill @ p1-p3*p1/3,gram,5,n$(k,n)}\r\n      }\r\n      Next i\r\nEnd Sub\r\nSub FillArray()\r\nLocal n,p, n$, k$, no\r\nStack New {\r\n      Data \"A#2\", \"A\", 1, 1, 2\r\n      Data \"B2\", \"Z\", 2, 1, 1\r\n      Data \"C3\", \"X\", 3, 2, 1\r\n      Data \"C#3\", \"D\", 4, 3, 2\r\n      Data \"D3\", \"C\", 5, 3, 1\r\n      Data \"D#3\", \"F\", 6, 4, 2\r\n      Data \"E3\", \"V\", 7, 4, 1\r\n      Data \"F3\", \"B\", 8, 5, 1\r\n      Data \"F#3\", \"H\", 9, 6, 2\r\n      Data \"G3\", \"N\", 10, 6, 1\r\n      Data \"G#3\", \"J\", 11, 7, 2\r\n      Data \"A3\", \"M\", 12, 7, 1\r\n      Data \"A#3\", \"K\", 13, 8, 2\r\n      Data \"B3\", \",\", 14, 8, 1\r\n      Data \"C4\", \".\", 15, 9, 1\r\n      Data \"C#4\",\";\", 16 , 10, 2\r\n      Data \"D4\", \"/\", 17, 10, 1 \r\n      While Not Empty {\r\n      Read n$, k$, no, n, p\r\n            If p=1 Then {\r\n                note1$(n-1,0):= n$, k$, no\r\n            } else {\r\n                  note2$(n-1,0):= n$, k$, no\r\n            }\r\n      }\r\n}\r\nEnd Sub\r\n\r\n\r\n\r\n
GR:ΠΑΝΩ\r\n\r\n1) OVER 5\r\n2) OVER\r\n3) OVER 5,5\r\nCopy over the top the item in 5th position in the stack (if we have less items then an error occur)\r\nThe second case is equal with OVER 1 and this duplicate the top item (same item in position 1 and 2)\r\nThe third make double the 5 top elements of stack.\r\n\r\nLook SHIFT, OVER, DROP, STACKITEM(), STACKITEM$(), \r\n      NUMBER, LETTER$, ISNUM, ISLET, EMPTY, FLUSH, STACK\r\n      \r\n
GR:ΠΑΝΩΜΙΣΟ(\r\n' a is a double\r\na=0xFFFF0000\r\nPrint HighWord(a)  ' 65535\r\n\r\nLowWord(), HiLowWord(), Hex$()\r\nHex\r\n
GR:ΠΑΡΑΓΡΑΦΟΣ$(\r\nParagraph$() copy paragraph from document, or copy paragraph and remove it from document\r\n\r\nDocument Alfa$={First Paragraph\r\n                              Second Paragraph\r\n                              Third Paragraph\r\n                              }\r\nFor i=3 to 1 {\r\n      Report Paragraph$(Alfa$, i)\r\n}\r\noldparagraph$=Paragraph$(Alfa$, 2, -1)\r\nInsert to 2 Alfa$=oldparagraph$+{\r\n      some other paragraph\r\n      and another one\r\n      }\r\nCenter=2\r\nReport Center, Alfa$
GR:ΠΑΡΑΓΡΑΦΟΣ(\r\n\r\nClear\r\nDocument a$\r\nFor i=1 to 9 {\r\n      a$=\"aaaaaaaaaaaaaa\"+str$(i)+{\r\n      }\r\n}\r\na$=\"aaaaaaaaaaaaaa\"+str$(i)\r\nFor i=10  to 1 step 2 {\r\n      \\\\ delete\r\n      d$=Paragraph$(a$, i, -1)\r\n}\r\n\r\nm=Paragraph(a$, 1-1)   ' 1 but -1 to start\r\nd=Forward(a$, m)\r\nWhile m {\r\n      Print Paragraph.Index(a$,m), m\r\n      Report Paragraph$(a$, (m))\r\n}
GR:ΠΑΡΑΘΕΣΗ$(\r\nhere I use ? for PRINT\r\n? QUOTE$(\"alfa\")\r\nprint \"alfa\"\r\n\r\nin a string we can pass one \" as chr$(34).\r\n\r\nA$={\"alfa\"}   is ok in a module (not in command line interpreter)\r\nA$={\r\n\"}\"\r\n} is ok because \"}\" is a string...\r\nA$={ \"\"\"} isn't ok because one \" is missing\r\none way we have to print the ascii code of \"...by using this\r\n? asc(quote$(\"\"))\r\n\r\nso quote$(\"\") isn't empty string but two chars \"\"\r\n\r\nprint quote$(2*4,3+1,\"aaa\"+\"bbb\")\r\n8,4,\"aaabbb\"\r\nwe can use \r\n\r\nflush  ' flush the stack\r\nINLINE \"DATA \"+quote$(2*4,3+1,\"aaa\"+\"bbb\")\r\nread  A, B , C$\r\nwe can make a string  before we found inline, so we can put the result(S) to a string and then we give that string to INLINE\r\nINLINE \"DATA \"+a$\r\n
GR:ΠΑΡΑΘΥΡΟ\r\n\\\\\r\n1) Define size of font (the mode type) , width and height and by using \";\" we center it \r\nWindow modetype, widthTwips, heightTwips;\r\n2) Define size of font (the mode type) , width and height - Window is at the left top corner\r\nWindow modetype, widthTwips, heightTwips\r\n3) Define size of font (the mode type)  and width  (height  produced automatic)\r\nWindow modetype, widthTwips\r\n4) Restore the maximum width and height\r\nWindow modetype, 0  ' we choose monitor 0\r\nWindow modetype, 1  ' we choose monitor 1 if 2nd monitor exist\r\nPrint Window  ' We get the monitor number (from 0) for current layer\r\n\r\nWindow change the screen inside and the background  behind. Background have the wdth and height in pixels. but foreground, the \"screen\", has equal or less size depended from the modetype (the size of the fonts) and the linespacing we use. That extra space can be cut or restored with the FORM command.\r\n\r\nWINDOW also defines the size and font size for Layers, without affect screen or background. Maybe our text not fit exactly to the size we define. We can use FORM after the WINDOW to redefine the modetype accordingly to the character resolution we provide in Form.\r\n\r\n\r\nLook the example . Describe many aspect of M2000 programming model.\r\n\r\n With these simple commands we make a window with a title bar that we can drag to other position and  at the right top corner we can close  (exit from the application). As we drag the window in a new position two threads are running and produce some data on the screen. Threats here can run without using EVERY or MAIN.TASK or WAIT. We use a FIELD command to input some text. So during that input threads running in the background.\r\n\r\nAlso we see how to create TARGET. We give a command (as a SET command) , so MM is a SET MM so we have to place it before TR module, in the first level (In M2000 we can make modules inside modules). We scan targets with scan command. We can have loops in targets but because here we use SCAN in a thread, and a thread is a time based loop, a loop with long duration will stop all threads.\r\n\r\nModule MM {\r\n      set mx=mouse.x\r\n      set my=mouse.y  \r\n      set  startdrag=1\r\n}\r\nModule TR {\r\n      ' we use SET to make some global variables\r\n      set  startdrag=0\r\n      set mx=mouse.x\r\n      set my=mouse.y\r\n      window 6, 0\r\n      Set c = True\r\n      Window Random(7,12) , Scale.X*.7, Scale.Y*.7;\r\n      show\r\n      Cls 15,0\r\n      Gradient 0,15\r\n      Move 0,0\r\n      Fill Scale.X,Scale.Y/Height-25,1,6,0\r\n      Pen 7\r\n      ' We can move the window using the mouse on the title\r\n      Target A,\"MM\",Width-1,1,,,5,\"M2000 EXAMPLES USING THREAD\"\r\n      Print @(Width-1,0);\r\n      Pen 0\r\n      ' We close clicking top and left\r\n      Target B, \"set c = false\" ,1,1,6,,5,\"X\" \r\n      Pen 15\r\n      Modules  ' just print list of modules in memory and in current directory\r\n      AA$=Field$(\"\",10)\r\n      kkk=0\r\n      Pen 0\r\n      CLS ,20\r\n      www=0\r\n      Thread {\r\n            if startdrag=1 then {\r\n                  Motion.W Motion.Xw-MX+Mouse.X,Motion.Yw-MY+Mouse.Y     \r\n            }  else {\r\n                  scan 0.001      ' only this command process the targets\r\n            }             \r\n            if mouse=0 then  set  startdrag=0                  \r\n                  kkk++\r\n      } as AA\r\n      ' thread variables are common to the module that we create them.\r\n      Thread {\r\n            www++\r\n            cls :  pen 0 \r\n            print www, mx, my, mouse, kkk\r\n            ' we can end the program from this thread\r\n            If not C Then Set End\r\n      }  As BB\r\n      Thread AA Interval 50  ' we give some time here\r\n      Thread BB Interval 200 ' some more time here that isn't 50+200 but 200 all or maybe more..\r\n      ' Threads need something to delay so then can run\r\n      ' So we use here a FIELD command\r\n      ' We can type, and we can move the window before the end of the typing... \r\n       Field 10,10,10 As AA$     \r\n}\r\nTR : End\r\n
GR:ΠΑΡΑΘΥΡΟ (HWND)\r\nPrint hWND\r\nreturn window handler\r\n
GR:ΠΑΡΑΜ$(\r\nParam$() get a string of literals (numbers and stings) and place data inline. First item must be a String\r\nUse Param() if first item is number\r\n\r\na$={10,30,\"alfa\",40}\r\na=(param(a$))\r\nPrint a\r\n' first is a string\r\na$={\"hello\", 10,30,\"alfa\",40}\r\na=(param$(a$))\r\nPrint a
GR:ΠΑΡΑΜ(\r\n1) Feed from a string a list of values by place them inline code.\r\n\\\\ compute parameters\r\na=10\r\nb=40\r\n\\\\ and fill results in a string using Quote$()\r\ns$=Quote$(a*b, a/b)\r\n\\\\ funtion Param() with a string merge results inline\r\nPrint Param(s$)\r\nModule LookHere (x,y) { Print x, y }\r\nLookHere Param(s$)\r\nLookHere a*b, a/b\r\n\r\n\r\n\r\n2) param(object) return an inventory list with properties and methods for an object\r\n\r\n\r\n\\\\ to get this GUID we need to perform a LIST COM TO A\r\n\\\\ where A is a module (run this in M2000 command line)\r\n\\\\ We can't create any object (some need special license)\r\nDeclare Worksheet \"{00020820-0000-0000-C000-000000000046}\"\r\n\\\\ we make an inventory\r\n\\\\ we can write: Inventory alfa\r\n\\\\ but param() with an object return an inventory\r\n\\\\ keys are all names in capitals, and items are the definitions (a simple form)\r\n\\\\ for properties and functions\r\nalfa=param(Worksheet)\r\nReport Type$(Worksheet) ' Workbook\r\nIF LEN(ALFA)>1 THEN {\r\nFor i=0 to len(alfa)-1\r\nReport 3, alfa$(i!) ' use index, not key\r\nNext i\r\n}\r\n\\\\ we can write here Declare Worksheet Nothing\r\n\\\\ But at the end all objects (ActiveX) erased
GR:ΠΑΡΑΜΕΤΡΟΙ$\r\nReturn parameters (in a string) with - or + as first char. These parametets was in command line before we start a name.gsb program in M2000.\r\nWe can call another program from a M2000 program, using USE and passing values, or using Win command and passing parameters \r\nWe can use first parameters known for \"Switches\" command\r\n\r\n\r\nOpen a file \"Hello.gsb\" using Edit \"Hello.Gsb\" and copy this:\r\nMODULE HELLO {\r\n      form 40\r\n      Show\r\n      Print \"Example 1, Hello\"\r\n      If instr(parameters$, \"-OK\")>0 Then {\r\n            Print \"You call me from Shell\",,\"    with parameter -OK\"  \\\\ double ,, means next line\r\n      } else {\r\n            L$=Envelope$()\r\n            If LEN(L$)>0 Then {\r\n                  Print \"You call me with USE and \";len(L$);\" parameters\"\r\n                  stack\r\n            } else {\r\n                  Print \"You just call me\"\r\n            }\r\n      }\r\n      Print \"So Hello Again\"\r\n      fkey 1, \"end\"\r\n      fkey 2, \"h1\"\r\n      fkey 3, \"h2\"\r\n      Print \"Choose a Function Key\"\r\n      fkey\r\n}\r\nMODULE H1 {\r\n      WIN Appdir$+\"m2000.exe \"+quote$(Dir$+\"HELLO.GSB -OK\") \r\n}\r\nMODULE H2 {\r\n      use hello.gsb 1, \"aaaa\", 3\r\n      wait 3000\r\n}\r\nHello
GR:ΠΑΡΕ\r\n\r\nFile handling look OPEN, CLOSE, PUT\r\nGET  variable_as_file_handle, variable_field$, record_position\r\nGET  variable_as_file_handle, array_field$(index), record_position\r\n\r\nExample\r\nRecords are specific length strings of bytes, so you define record length when you OPEN the file.\r\n' Read last record, records have no fields separators, and can be anything, not only text.\r\n\r\nhere=RECORDS(fhandler)\r\nGet fhandler, buffer$, here\r\n\r\nif we use WIDE for open the file then that file must be created as unicode by the same statement.\r\n\r\n\r\n
GR:ΠΑΡΕΚΑΡΕ$\r\n\r\na$=GRABFRAME$\r\nThis variable is internal a function that grab a frame in an open video in m2000. We have to put in a string.\r\n
GR:ΠΑΡΕΜΒΟΛΗ\r\nINSERT\r\n\r\nfor strings (or string array elements)\r\na$=\"123456\"\r\nPrint Len(a$)\r\ninsert 3 a$=\"**\" \r\nPrint a$, len(a$)  \\\\12**3456\r\na$=\"123456\"\r\nPrint Len(a$)\r\ninsert 3,2 a$=\"**\" \r\nPrint a$, len(a$)   \\\\12**56\r\na$=\"123456\"\r\nPrint Len(a$)\r\ninsert 3,2 a$=\"\" \r\nPrint a$, len(a$)    \\\\ 1256\r\n\r\n\r\nfor Documents\r\nDocument a$, b$\r\na$={aaaaaaaaaaa\r\n      12345678901234567890\r\n      }\r\nb$=a$\r\n' 2 is the 2nd character\r\ninsert to 2, 10 a$={Hello\r\n      two paragraphs\r\n      }\r\nReport b$\r\nReport a$\r\nClear a$\r\nDocument a$=b$\r\n' 2 is the order number of paragraph\r\n' 10 is the 10th character in the paragraph\r\ninsert to 2, 10 a$=\"Hello\"  ' we can use a third parameter to delete characters before the insertion.\r\nReport b$\r\nReport a$\r\nClear a$\r\na$=b$\r\nOverwrite 2,10 a$=\"Hello\"\r\nReport b$\r\nReport a$\r\nClear a$\r\na$=b$\r\nOverwrite 2 a$=\"Hello\"  \\\\ replace line\r\nReport b$\r\nReport a$
GR:ΠΑΤΗΜΕΝΟ(\r\nFunction Keypress(number) get the virtual key and perform an GetAsyncKeyState, only when M2000 environment are the foreground window\r\n\r\nAll keys in keyboard and all keys in mouse can be tested.\r\n\r\nA=1\r\nRepeat {\r\n      Print A\r\n      A++\r\n} Until Keypress(1)  \\\\ 1 is left mouse button\r\n\r\nsee https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx\r\nfor virtual codes
GR:ΠΑΧΟΣ\r\nDefine a block of code where commands for graphics use a specific line width\r\nWidth  lineWidth [, line style] {\r\n      block of code\r\n}\r\n      We can print text with outline setting with Width {}.\r\nFor GDI line style from 2 to 5 works only for width 1 pixel\r\nFor GDI+ works for every width.\r\n\r\n
GR:ΠΕΔΙΟ\r\n\r\nScreen in M2000 Environment is used for many reason. One of them is to read character input. The basic console has rows an columns for characters.  We can make input forms with fields that read non proportional text and one by one (to validate each stage of input).\r\nWe can prepare string variables with FIELD$() function\r\nEach FIELD command exit by using up down arrows or ESC.\r\n\r\nA$=FIELD$(\"123\", 10)\r\nFIELD x, y, lengthOfInput as A$\r\n\r\nWe get the reason for exit in a variable FIELD, as -1 up arrow, 1 down arrow or enter, 99 for Escape. We can validate the result and provide feedback with FIELD NEW  (push 0 to FIELD read only variable)\r\n\r\nSpecial Field is the Password field\r\nFIELD PASSWORD 1,1, 10 AS PW$\r\n\r\nwe can't copy or cut from a FIELD , but we can paste.\r\nIn Field we can use INSERT keyboard key to change from insert text to overwrite.\r\nIf we ask for width of a string and we don't have in the screen then automatic open a dialog to get the input.\r\n\r\nNew numbers for exit:\r\n-20 Home\r\n20 End\r\n-10 pageup\r\n10 pagedown\r\n1 Tab\r\n-1 Shift Tab\r\n
GR:ΠΕΔΙΟ$(\r\n\r\nA$=FIELD$(\"Content text\",40)\r\nPlace the Content text in A$ and fill spaces to make it 40 chars long.\r\n\r\nIf len is smaller than Content text then a cut perform in the Content text.\r\n
GR:ΠΕΔΙΟ_μεταβλητή\r\n\r\nSee FIELD\r\nRead only variable FIELD return the status of last FIELD input. So we know if user press ESC or Arrows to leave the input.\r\n-1 previus\r\n1 next (EXIT DOWN OR ENTER OR TAB)\r\n99 Esc\r\n-20 Home\r\n20 End\r\n-10 pageup\r\n10 pagedown\r\n1 Tab\r\n-1 Shift Tab
GR:ΠΕΖ$(\r\nreturn the upper case using the system locale\r\nLcase$(string expression)   ' return lower case\r\n\r\nLcase$(string_expression, locale_number)    ' local_number apply a filter on string_expression when string has numbers on ANSI range (otherwise we get ?). The encoding is Utf-16Le in Input  and  Output string.\r\n\r\n\r\n\r\n
GR:ΠΕΝΑ\r\nPen colorindex\r\ncolorindex can be:\r\n1) QBasic Colors: 0 to 15\r\n2) Windows Colors: &H8000000F& in vb6 ...must convert to 0x8000000F for M2000\r\n3) 0 to -16777215  (negative numbers) for RGB values\r\n\r\nWe can use function  Color(redvalue, greenvalue, bluevalue), or we can open color selector with Choose.Color with parameter or not, and get the color from stack.\r\nAlso we can read the color value (as negative number) from a point in screen, with POINT, so MOVE 3000,3000 : A=POINT\r\nThe color selector get hex value or we can scroll up/down to find a color with the help of the rotating plane (b g r, g r b, r b g) who can change by clicking on headline \"B | G | R\".\r\n\r\nWe can Print Pen so we get the negative value or if matched with one of QBasic color, then that positive number return.\r\n\r\n
GR:ΠΕΝΑ_μεταβλητή\r\n\r\nPrint Pen\r\nPrint a negative number if is an RGB  value (0...-(256*256*256-1)) or one of 15 colors from 1 to 15 from default  list of windows colors.\r\nWe can change PEN with PEN command\r\nPen 5\r\n? Pen\r\n                  5\r\nPen color(255,255,255)\r\n? Pen\r\n                15\r\n\\* Because color 15 is color(255,255,255)\r\nPen color(255,250,255)\r\n? Pen\r\n -16775935      \r\n\\* this isn't from default list of windows colors
GR:ΠΕΡΙ\r\n1) Help form for application\r\nAbout your_title$, text_for_help$\r\n2)\r\nAbout your_title$, width_in_twips,  text_for_help$\r\n3)\r\nAbout your_title$, width_in_twips,  height_in_twips, text_for_help$\r\n4)\r\nAbout\r\nClose help form by code\r\n5)\r\nAbout  ! your_title$, width_in_twips,  height_in_twips, text_for_help$\r\nwait ctrl+f1 (from console)\r\nor use About Show from an event About from controls in a form (and form has this event too)\r\n6)\r\nAbout ! \"\"\r\nclear help\r\n7) Using About Call {} (run as a global function), we can click in words, or some words in [ ], and automatic call the About call function and with some about commands we can change page and title too. From forms and About event we can call this function with About Show \"topic one\" and about$ now return \"topic one\". Only one About call function may exist anywhere. A second one replace the old one. This function can't called like any other function. We can't call anything but global modules/functions\r\nFor console applications we have to prepare About Call {} with a About !..... so in an Input command we have early the about form prepared\r\nFor a form application we don't have to prepare about, we have events. So one way is to use About in each event, or if we want a \"book\" of help, we can make an About Call { }  function and from each event we use About Show \"topic\". Also in Unload event we use About to close help form. Help form also closed when a messagebox apear.\r\n\r\nAbout ! tile$, widthinTwips,HeightinTwios, Text$ \r\nuse in brackets [ ] text for hypertext by using the about call { }\r\n \r\n   \r\nadvance  example\r\nabout ! \"Title\", 8000,6000,\"that [is] easy\"\r\nabout call { \r\nselect case about$ \r\ncase \"is\"\r\nabout  \"Title: IS\", 8000,6000,\"that [is] easy [too]\"\r\nelse\r\nabout  \"Title: too\", 8000,6000,\"that [is] easy\"\r\nend select\r\n}\r\n\\* use ctrl+f1 to open About...\r\ninput \"name:\",a$
GR:ΠΕΡΙ$\r\nA$=ABOUT$\r\nread the feedback from About command.\r\n In user help the clickable strings are in brackets [ ]\r\n\r\n\r\nabout ! \"Title\", 8000,6000,\"that [is] easy\"\r\nabout call { \r\n      select case about$ \r\n      case \"is\"\r\n      about  \"Title: IS\", 8000,6000,\"that [is] easy [too]\"\r\n      else\r\n      about  \"Title: too\", 8000,6000,\"that [is] easy\"\r\n      end select\r\n}\r\n\\* use ctrl+f1 to open About...\r\n\\*You can check help form as you input a string.\r\ninput \"name:\",a$\r\n\\* we can use About with no parameters to clear help system\r\n\r\n
GR:ΠΕΡΙΘΩΡΙΟ\r\nsee BACK
GR:ΠΕΡΙΘΩΡΙΟ _\r\n\r\nBackground layer is the layer that all other layer are top of it and moved together with it.\r\nBackground layer can be filled with DESKTOP command and can cutting by FORM command\r\nWe can move it by using MOTION.W and we can define it using size of font and width and height in twips with WINDOW command\r\nWe can make all window transparent using DESKTOP command, or a color of it.\r\nWe can redefine the size of font used in background as we send commands\r\nWe can use BACKGROUND or BACK as equal commands\r\n\r\n1)\r\nBACK {\r\n      ' any command to screen going to background\r\n      Gradient 1,5\r\n}\r\n\r\n2)\r\n      BACK 20 {\r\n      Print \"20pt Chars\"\r\n}\r\n
GR:ΠΕΤΑ\r\n\r\nDROP 4\r\ndrop 4 items from stack,\r\nif STACK.SIZE<4 then an error happen\r\n\r\nDROP 0\r\n\r\ndrop nothing, no error\r\n\r\nIf we give a negative number then we get an error\r\n\r\n\r\nwe can use  Drop, Stack.Size and Stackitem() and Stackitem$() to read a frame of parameters. Only a variable needed to mark the frame: S=Stack.Size, then we can do anything to the stack and we can return to parameter frame using DROP stack.size-s\r\nIf we get a negative number then we miss some parameters from frame.\r\nWe can check the type of stack items using Envelope$(). If we try to read a string using STACKITEM() then an error occur. So a frame must be a set of known items and types. If we have 4 modules that need the same parameter we can place it in stack and we can call each module without passing each time a variable  (so no need to read variable, copy to stack, read to a local variable)
GR:ΠΙ\r\n? pi\r\n            3.1415926535897932384626433832\r\n            Global pi=3.14159~
GR:ΠΙΝΑΚΑΣ\r\nDIM is a statement to dimension arrays\r\n\r\nadditions in ver 8\r\nWe can push arrays in stack and we can get a copy. We can return a copy of array from a funcrion. New Stock command. New class attach to arrays. New free style, we can make any item any class.\r\nFunction GetArray {\r\n      read items\r\n      dim a(items) : for i=0 to items-1 {a(i)=i+1}\r\n      =a()\r\n}\r\ndim K()\r\nK()=GetArray(10)\r\nfor i=0 to 9 {print k(i)}\r\n\r\n\r\nArrays in M2000 can have up to 10 dimensions. By default start from 0 in each dimension. We can change this using BASE 1 command. Each array hold inside the state of base for private use, so we can mix arrays with base 0 and base 1.\r\n\r\nFrom 6.1 version an array can redim without loosing items. \r\n1) Dim A(10)=0, a$(30)=\"\",A%(10,10)=1\r\n    Dim Base 1, A(), B(10,20)  \\\\ change only for these arrays\r\n    Dim A(30)  \\\\ A(1) to A(30)  this is a redim. Interpreter knows A() base.\r\n    Dim Base 0, N(10)  \\\\ N(0) to N(9)   \\\\ Base [0 or 1 but not expression]\r\n    Dim Base 1 to N()  \\\\ change base to 1\r\n    Print dimension(N(),0) \\\\ 1 return base\r\n    Dim New N()  ' make a new one and shadow any old one\r\n    (use New in a  For This { } or in Subs, where all new are for temporary use)\r\n    A()=N()  \\\\ now A() change base because A() is a copy of N()\r\n    Group Alfa {\r\n          Dim Base 0, M(10)=1\r\n          Module GetItem {\r\n                Read .M(number)\r\n          }\r\n          Module PrintItem {\r\n                Read subscription\r\n                Print .M(subscription)\r\n          }\r\n    }\r\n    Print Alfa.M(9)  \\\\ 1\r\n    Alfa.GetItem 0, 30\r\n    Alfa.PrintItem 0  \\\\ 30\r\n2) Global A(10) ' this is a global array\r\n3) Local A(10) ' this is a local array (in ver.8) It is optional because all new variables and arrays are local by default in modules ans functions. Using For This {  } we can make local variables. But any module level arrays and variables are accessible unless we hide them making local  with local instruction.\r\n\r\n\r\nWe can initialize any array in the DIM statement (optional). Names as  A, A$ and A% allowed together.\r\nWe can pass arrays by reference through stack. Arrays live in the module or function where we create them. At the end of creation module or function those arrays are disposed. We can use arrays from other modules if we use global setting or by reference passing. We can redimension an array in a module other than the creation module. We have way to ask for dimensions and upper index limit. Arrays can change number of dimensions without loosing values (but we can have moving values, values that change indexes). We can use an array of strings as an array of numbers, and the reverse, when we assign a reference to the array. \r\n\r\n4) DIM A(2,2), A$(20,5)\r\n      A(0,0)=1,2,3,4\r\n       \\\\Only for Sting Arrays\r\n       \\\\ we can't read from stack in the following statement  (so A(3,0):=number can't work, because temporary the stack change with an empty one)\r\n       A$(3,0) :=\"Name\",1,2,3*100,\"Name too\"  'we put a record in an array (numbers converted to strings)\r\n\r\n' We say that this is a module a\r\n     \r\n      ' array a() erased when module a end.\r\n      set dim a(20)\r\n      a(10)=34\r\n      module that {\r\n            print a(10)  \r\n      }\r\n      that     ' we call module that and inside that a() has a global reference so it exist\r\n      \r\n      dim c%(10)    ' name of c% is a.c%()  but a. can omit in this module\r\n      c%(2)=5.5  ' only integer part written to C%(2)\r\n      \r\n      module thattoo {\r\n            ' a is name of parent module\r\n            print a.c%(2)       ' we can use a.c% to find a \"friend\" array\r\n            a.that  ' or a friend module\r\n      }\r\n      thattoo   ' we call thattoo\r\n      a(10)=600\r\n      module byref {\r\n            read &two%(), &th()   ' Only Read statement can assign a name to a pointer\r\n            print two%(2), th(10)\r\n            list\r\n      }\r\n      ' we can reference  global a() and local c%() using &\r\n      ' we send pointers to stack\r\n      byref &c%(), &a()\r\n      \r\n \r\n' namespace\r\nin a module a write\r\nmodule b {\r\nmodule c {\r\na=10\r\nset b=20\r\nlist\r\n}\r\nc\r\n}\r\nb      \r\n      \r\nwe see from command list\r\nC.A = 10,  B = 20\r\nbecause any variable written as modulename.varname except global variables that not have modulename\r\n\r\n' Let say that we have another module b\r\na=300\r\nset b=1000\r\na\r\n\r\nWe call b and from b we call a that make a new module b that make a new module c and then show us the list of variables\r\nB.A = 300, B = 20, C.A=10\r\n\r\nNow we can insert a A=500 in module b in module a before we call c\r\nwe will see\r\nB.A = 500, B = 20, C.A=10\r\n\r\nbecause B.A. exist for the first B so exist for the second they have common namespace\r\n\r\nIn a gsb file we can place some global definitions for vars and arrays. (before the instruction to call first module, the starting module)\r\n\r\n\r\nAbout names  see ABOUT MODULES\r\ndim a(10)\r\nfunction a {\r\n      read X\r\n      =10*X\r\n}\r\na(2)=5, 1000\r\nprint a(3), array(\"a\",3), a(4), array(\"a\",2)\r\nprint function(\"a\",3), a(* 3)\r\n\r\nin CLI\r\nDIM A$(10)\r\n\r\nin a module\r\n ' erase global array (without removing the name) from module\r\n ' no comments in a SET line\r\nSET DIM A$(0)\r\n ' redim array (without removing the name)\r\nSET DIM A$(20)\r\n 'push a reference\r\nSET PUSH &A$()\r\n 'pop and create a new array name who reference the global array\r\nREAD &A$()  '  we can choose the same name...is a local name.\r\n ' so now we use global array as local\r\nDOCUMENT A$(10)={1st line\r\nsecond line.}  ' Only item 10 is a document var.\r\nA$(10)={Hello Again\r\n}\r\nDIM A$(30 )   'redim without using SET\r\nREPORT A$(10)\r\nLIST   ' give a list of variables and arrays\r\n\r\n\\\\ Version 9\r\nGroup N {\r\n      dim base 1, x()\r\n      value {\r\n            =.X()\r\n      }\r\n      set {\r\n                 Print dimension(.x(),0)                 \r\n                 read .x()\r\n                 dim base 1 to .x()\r\n                 Print dimension(.x(),0)\r\n            }\r\n}\r\nN=(1,2,3,4,5)\r\nPrint N\r\nPrint N.x(5)
GR:ΠΙΝΑΚΑΣ$(\r\nDim A$(2,5,2)=\"ok\"\r\nPrint ARRAY$(\"A$\",1,4,1)\r\nPrint A$(1,4,1)\r\n\\\\ array by pointer (or tuple)\r\nA=(1,2,3,\"word\")\r\nA+=20\r\nPrint A\r\nPrint Array$(A, 4)
GR:ΠΙΝΑΚΑΣ(\r\n\r\nDim a(5,5)=1\r\nPrint Array(\"a\",1,3)\r\nPrint a(1,3)\r\n\r\n\\\\ look array$() \r\n\r\nDim a(10)\r\nFunction a {\r\n      Read  a\r\n      =a*2\r\n}\r\na(5)=3\r\nPrint a(5), array(\"a\",5)  \\\\ 3 3\r\nPrint a(* 5)   ' 10   (use * to indicate that a() is a function)\r\n\r\n\r\na=(1,2,3,\"text\",5)\r\nPrint  Array(a, 0)  ' 1\r\nReturn a, 0:=1000, 4:=\"text b\"\r\nPrint a, Array(a,0), Array$(a,4)\r\nAppend a, (6,7,8,9)\r\nPrint Array(a, 8)\r\nPrint Len(a)\r\nLink a to a$()\r\nPrint a$(4)\r\nPrint array(a$(), 1)\r\n\r\n\r\n
GR:ΠΙΣΩ(\r\n\r\nDocument a$={aaaaaaa\r\nbbbbbbbbb\r\nccccccc\r\n}\r\nm=Paragraph(a$, doc.par(a$)) \r\nIf backward(a$,m) then {\r\n      While m {\r\n            Print Paragraph$(a$,(m))\r\n      }\r\n}
GR:ΠΛΑΓΙΑ\r\n\r\nITALIC : PRINT \"THIS IS LETTERS\" : ITALIC\r\n\r\nor we can use\r\nITALIC 1    ' on\r\nITALIC 0    ' off\r\n\r\n
GR:ΠΛΑΙΣΙΟ\r\nWe can draw frames from the graphic cursor to any other point, using a background color and or a border color.\r\n1) Frame widthInChars, heightInChars, color, border color\r\n2)  Frame @  cornerabsoluteposX, cornerabsoluteposY, type, 1stParameter, 2ndOptionalParameter    \r\n3) Frame @  (widthInChars), (heightInChars), type, 1stParameter, 2ndOptionalParameter    \r\n\r\nLook FILL to read type for read made constructions  (using OS specific routines)  \r\n  \r\nExample\r\n--------------------  \r\nform 30,20\r\nframe @ (30),(20),4,3\r\nwidth 10 {\r\n      cursor 1,1\r\n      frame 13,8,2,5\r\n      Print \"Top Left\"\r\n      cursor 16,1\r\n      frame 13,8,2,5\r\n      Print \"Top Right\"\r\n      cursor 1, 11\r\n      frame 13,8,2,5\r\n      Print \"Bottom Left\"\r\n      }\r\ncursor 16,11\r\n'frame @ 13+pos,8+row-1,4,1   is the same as frame @ (13),(8),4,1  \r\n'frame @ 29,18,4,1   we can make the additions easy because we have in Cursor the right pos and row\r\nframe @ (13),(8),4,1     ' so this form isn't compatible with old versions but is easy to follow as is the same as the first form of FRAME\r\npen 0\r\nPrint \"3D frame\"\r\npen 14
GR:ΠΛΑΤΟΣ\r\nreturn width as chars for current layer
GR:ΠΛΑΤΟΣ.ΣΗΜΕΙΟΥ\r\nTWIPSX\r\ntwips per pixel for screen only\r\nso we can use multiplies of twipsx  for drawing pixels.\r\nwe can draw 10 pixel left\r\ndraw twipsx*10, 0\r\n\r\nwe can display the pixels width of our display form\r\nPrint scale.x/twipsx
GR:ΠΛΑΤΦΟΡΜΑ$\r\n\r\n? PLATFORM$\r\nreturn the platform description  (like WINDOWS NT)
GR:ΠΛΗΚΤΡΟΛΟΓΙΟ\r\nKeyboard !  \r\nOpen OSK (on screen keyboard)\r\nKeyboard StrExpression$\r\nPlace characters to keyboard.\r\nKeyboard 65,\")\"\r\nKeyboard \"This is like we press this keys\"+chr$(13)\r\nInput A$\r\nPrint A$\r\n\r\n
GR:ΠΟΛΥΓΩΝΟ\r\n\r\n1. Using a fill color and relative coordinates (you can add points if you like):\r\n\r\na) POLYGON 4, 1000,0,0,1000,-1000,0,0,-1000\r\n\r\nLast point is moving the cursor\r\n\r\nb) POLYGON 4, 1000,0,0,1000,-1000,0,1000,-1000\r\n\r\na and b is the same drawing but leave cursor in other point.\r\n\r\n2. Polar coordinates\r\nMOVE 5000,2000\r\nPOLYGON 4, ANGLE PI/4,3000,-PI/4,3000,PI/4,-3000,-PI/4,-3000\r\n\r\nif we don't want to fill it, we can with path {} ori color {}  (is the same structure\r\nPATH { POLYGON 4, ANGLE PI/4,3000,-PI/4,3000,PI/4,-3000,-PI/4,-3000 } \r\nWe can strip the color (and other things width path or color (is the same structure)\r\n\r\ncurve get the line color, but polygon get the fill color and always close the line to perform the filling (or width color|path has a transparent filling)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
GR:ΠΡΟΣ\r\n\r\nGoto label\r\nGoto Number  (5 digits most, no Zero in leftmost position)\r\n\r\nLabels must end with symbol \":\"\r\nAfter labels you can insert commands\r\nyou can't jump out of block code\r\n\r\n\r\nI = 0 \r\nRepeat {\r\nagain:\r\n       i++\r\n            A$=Inkey$\r\n            If A$=\"\" Then Goto again\r\n            If A$=\" \" Then exit\r\n            Print i\r\n}  Until i=1000         \r\n\r\nYou can use here Continue instead of Goto label. But if you want a different entry then Goto is here to do right this.\r\n\r\nLook On var GOTO label1, label2...\r\n\r\nJump allowed backward and forward in a block of code in curly brackets { }\r\n\r\nModule a {\r\ni=1\r\nagain:\r\ni++\r\nif i=10 then exit\r\nbreak\r\ngoto again\r\n}\r\ncall a\r\n\r\nUsing a block inside you can forget the goto, but goto is used to have an entry other than the start of a block or to skip some code. If you put code in curly brackets then an Exit is same as a jump to end of block.\r\nModule a {\r\ni=1\r\n{ i++\r\n      if i=10 then exit\r\n      print i\r\n      loop\r\n      }\r\n}\r\ncall a\r\n\r\n\r\nYou can write numbers like that:\r\n\r\n100 print \"ok\"\r\n200 if mouse>0 then exit\r\n       ' this line has no number...numbers in right most position is only labels, not needed for commands\r\n300 goto 100\r\n\r\n\r\nif a goto is for the first line of block then you can swap with the Restart command (no need to search for label, just restart the block).\r\nin a module or a block of code:\r\nprint \"ok\"\r\nif mouse=0 then restart\r\nprint \"End\"\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
GR:ΠΡΟΣΘΕΣΕ.ΕΓΓΡΑΦΟ\r\nAPPEND.DOC DOCNAME$ [, DOCTYPE]\r\nappend a document  to an exist file using default (Utf-8) or specific type.\r\n\r\nIn a module write this:\r\n\r\nform 80,32\r\ndim a$(4) : a$(0)=\"UTF-16LE\",\"UTF-16BE\",\"UTF-8\",\"ANSI\"\r\nPrint over $(6),\"Example of saving and append text in four types\"\r\nfor i=0 to 3\r\n      clear testthis$\r\n      document testthis$ = {1st line\r\n                              2nd line\r\n                              3rd line\r\n                              }\r\n      testthis$={4th line\r\n                              }  \r\n      print under \"Save one time and append one time more:\"  : print \r\n      \\\\ 10 chars left indent - we have to reset it after\r\n      print @(10), : report testthis$ : print @(0),   \\\\ return cusror to far left\r\n      save.doc  testthis$, \"alfa1.txt\", i     \\\\ we use user dir\r\n      append.doc testthis$, \"alfa1.txt\", i\r\n      print part format$({Length for file \"{0}\" in bytes {1} type {2}, total characters {3}}, \"alfa1.txt\", filelen(\"alfa1.txt\"), a$(i), doc.len(testthis$)*2)\r\n      \\\\      edit \"alfa1.txt\"\r\nnext i\r\nprint under\r\n
GR:ΠΡΟΣΘΗΚΗ\r\n\r\n1) for tables in databases\r\nAPPEND nameofbase$, nameoftable$, fieldvalue1, fieldvalue2$, ....fieldvalueN\r\n\r\nAll fieldvalues are one of two general types, number or string. So a memo is a string.\r\n\r\nExamples\r\nAppend Base$, \"Record\", Result, Str$(now, \"SHORT DATE\"), Code, Amount\r\nAppend Base$, \"Person\", CodePerson, Results, Val(Trim(Amount$))\r\n\r\n2)Append work for Inventories and pointer to arrays\r\na=(1,2,3,4)\r\nAppend a,(5,6,7,8), (9,10,11,12)   \\\\ , ...\r\nPrint a\r\nInventory b=1,2,3,4:=300,5\r\nAppend b, 100:=500, \"hello\":=1000, \"ok\":=\"all right\"\r\nPrint b$(\"ok\"), b(4)\r\nPrint b
GR:ΠΡΟΣΩΡΙΝΟ$\r\n\r\nPrint Temporary$\r\nreturn directory for temporary files\r\nSee tempname$
GR:ΠΡΟΧΕΙΡΟ\r\nClipboard A$\r\nWe copy A$ to clipboard. If a$ contain image then that image is copied. We can load from clipboard using Clipboard$ for text and Clipboard.image$ for image.\r\nmove 0,0 \r\nclear A$ \r\ncopy scale.x, scale.y to A$  \\\\ copy to A$\r\nclipboard A$     \\\\ screen copy as DIB in clipboard.image
GR:ΠΡΟΧΕΙΡΟ$\r\nPrint Clipboard$\r\nClipboard \"This is a text for clipboard\"\r\n\r\nuse clipboard.image$ to get a picture from clipboard
GR:ΠΡΟΧΕΙΡΟ.ΕΙΚΟΝΑ$\r\na$=CLIPBOARD.IMAGE$\r\nwe copy the clipboard image (if any) in a$
GR:ΠΡΩΤΟ(\r\n\r\na=((1,2), (3,4), (5, 6))\r\nb=Car(a)\r\nPrint Car(b)  ' 1\r\nPrint Car(Car(a))   ' 1\r\nPrint Cdr(Car(Cdr(Cdr(a))))  ' 6\r\n
GR:ΠΡΩΤΟΤΥΠΟ\r\n\r\nprototype {\r\n      Print \"ok\"\r\n} as alfa$\r\nPrint len(alfa$)\r\nInline alfa$\r\n\r\n\r\n\r\n
GR:ΡΙΖΑ(\r\nreturn square root of a positive number
GR:ΡΟΗ ΠΡΟΓΡΑΜΜΑΤΟΣ\r\nFLOW CONTROL\r\nAFTER, BREAK, CALL, CASE, CONTINUE, DO, ELSE, ELSE.IF, EVERY, EXIT, FOR, GOSUB, GOTO, IF, LOOP, MAIN.TASK, ON, PART, PROFILER, REPEAT, RESTART, SELECT, THEN, THREAD.PLAN, TRY, UNTIL, WAIT, WHILE\r\n\r\n
GR:ΡΟΥΤΙΝΑ\r\nSUB ALFA(X)\r\n\\\\ commands\r\nEND SUB\r\n\r\nSubs are written at the end of modules and functions. We can pass by reference (use &) or by value anything like modules, but subs are not modules, they stay at module's (or function's) namespace and  have the same ability to erase any new item that we make on their space (except threads). So a Sub see anything in a module, except we declare it as Local, also parameters in parameter list are local too. We can exit with Exit Sub. We can use a module variable as static but we must define before we gosub to sub. We call subs with Gosub (also Gosub call simple routine by name or by number without parameters). We have recursion (we use Recursion.Limit 1000 times to limit it, but we can change it). Interpreter search from bottom to find a sub, and record it for second call. When in execution interpreter find Sub then this is like an exit\r\nSo in a module we can write:\r\n\r\ny=100\r\nk=30    \\\\ use it as static\r\nGosub Alfa(3)\r\nAlfa(13)  \\\\ Gosub is optional for subs except there is an array with same name\r\nAlfa(5)\r\nPrint y\r\n\r\nSub Alfa(x)\r\n      Local y=10\r\n      If X>10 Then Exit Sub\r\n      Print x*y, k\r\nEnd Sub\r\n\r\nCalling a sub without Gosub,  may cause problem if an array exist with same name. Interpreter first check for arrays. A global array with same name may broke the code. So it is better for safety to use Gosub in call.
GR:ΡΥΘΜΙΣΕΙΣ\r\n\r\nSettings\r\nOpen a form to make settings like font, name and size and bold on/off, pen color and screen color, case sensitive or not for file names.\r\n\r\n\r\n\r\n\r\n\r\n
GR:ΡΩΤΑ$(\r\n\r\nPRINT ASK$(\"this is a messagebox\")\r\nIF ASK$(\"Info\",\"Title\",\"okTitle\", \"CancelTitle\", Bitmap$) =\"okTitle\" then print \"ok\"\r\n\r\n1. There is ASK() also with same parameters but return number (1 for ok or 2 for cancel)\r\n2. We can use it for input string (maximum 100 chars) \r\nIF ASK$(\"Info\",\"Title\",\"okTitle\", \"CancelTitle\", Bitmap$, \"string to input\") =\"okTitle\" then print \"ok\" : read A$\r\nnow A$ hold the response from ASK. If Ask return 2 (cancel) then no string pushing in stack, so we can't read from stack.\r\n3.  Bitmap$ is a string that we can load a bitmap, or a filename to a picture (internal use vb6 LoadPicture)\r\n\r\nAll parameters are optional except the first one.\r\n\r\n6 parameters\r\nText to Ask\r\nTitle\r\nText for Ok, use \"*\"  as first character to make it default control, use only \"*\" to make it default control with default caption\r\nText for Cancel use \"*\"  as first character to make it default control, use \"*\" only as the one before, and \"\" to not show\r\nString for path or bitmap data\r\nString for make Message box an InputBox.\r\n
GR:ΡΩΤΑ(\r\n\r\nPRINT ASK(\"this is a messagebox\")\r\nIF ASK(\"Info\",\"Title\",\"okTitle\", \"CancelTitle\", Bitmap$) =1 then print \"ok\"\r\n\r\n1. There is ASK$() also with same parameters but return string (ok or cancel title)\r\n2. We can use it for input string (maximum 100 chars) \r\nIF ASK(\"Info\",\"Title\",\"okTitle\", \"CancelTitle\", Bitmap$, \"string to input\") =1 then print \"ok\" : read A$\r\nnow A$ hold the response from ASK. If Ask return 2 (cancel) then no string pushing in stack, so we can't read from stack.\r\n3.  Bitmap$ is a string that we can load a bitmap, or a filename to a picture (internal use vb6 LoadPicture)\r\n\r\nAll parameters are optional except the first one.\r\n\r\n6 parameters\r\nText to Ask\r\nTitle\r\nText for Ok, use \"*\"  as first character to make it default control, use only \"*\" to make it default control with default caption\r\nText for Cancel use \"*\"  as first character to make it default control, use \"*\" only as the one before, and \"\" to not show\r\nString for path or bitmap data\r\nString for make Message box an InputBox.\r\n
GR:ΣΑΡΩΣΕ\r\n\r\nscan\r\n       scan targets waiting for a press on target  see TARGET\r\nscan  .5\r\n      scan targets waiting 0.5 second for a mouse press on target  see TARGET\r\n
GR:ΣΒΗΣΕ\r\n\r\nHIDE\r\nWe hide the screen (not the background). We can hide all  (including the background) if we minimized from the task bar - we can control the title in task bar and if we want to show or hide, and so if we can minimized or close the application from there.\r\n\r\nLayers also can be hide using the PLAYER command (layers are also players, forms that act like hardware sprites). Screen can have 32 layers. Screen and Layers also can move and change dimensions.\r\n\r\nSee SHOW, LAYER, PLAYER\r\n
GR:ΣΕΙΡΑ\r\nWe can import DATA lines of numbers and strings\r\nThat data can be loaded from a module by loading and after the execution we send the data to stack\r\nSo data put to the stack items. We can push items to the top of stack  or we can use DATA to append items to the bottom of stack\r\nSo DATA 1,2 leave 2 to the bottom and a second DATA 3, 4 leave 4 to the bottom\r\nStack is using to hold values. We can use the stack to pass a reference, a reference is creates as a string. \r\n\r\n\r\nFLUSH ' clear the stack\r\nPUSH 2, 1 \r\nDATA 3, 4\r\nnow we have top item 1 and after that 2 and after that 3 and the last one...4\r\n\r\nWhy I use flush to clear the stack? Because if some items are in the stack then  the DATA write values behind that so we take from read the wrong values.\r\nWhen we call a function then new stack created. All modules have common stack if are exist in the same thread. We can call a module from a module and we can pass values to stack. That values are in priority, at the top and place by internal use of DATA and then merged all other items. When a module end, maybe can leave some items in the stack. Threads use common namespace with modules but have own stack. So we can deliver data using stack but we can use variables and arrays.\r\n\r\nExample using stack as FIFO (First in First Out)\r\nFlush\r\nDATA 1,2,3,4\r\nDATA 5,6,7,4+4\r\n\r\nFor i = 1 to 8 {\r\n      read a\r\n      print a\r\n}\r\nDATA 1,3,4  ' The last item in that list become the last item in the stack  (we can say that this is the bottom item)\r\nSee PUSH
GR:ΣΕΙΡΙΑΚΟΣ.ΔΙΣΚΟΥ(\r\nGet an integer as drive serial, maybe a negative number\r\nUse uint() to  make it as an unsign integer (with same bits)\r\n\r\nPrint  hex$(hiword(uint(drive.serial(\"c:\"))),2) + \"-\" + hex$(loword(uint(drive.serial(\"c:\"))),2)\r\n\r\nHex Uint(Drive.serial(\"c:\"))
GR:ΣΕΛΙΔΑ\r\nPAGE\r\nSending what we have print until now to the printer and open a new page\r\n\r\nPAGE 1 ' we send the last and we make a new with portrait orientation\r\n\r\nPAGE 0 ' as before but with landscape orientation\r\n
GR:ΣΕΝΑΡΙΟ\r\nScript modulename\r\nScript commands_in_string$\r\nThis command can run in CLI, or by using Set command in program interpreter\r\n\r\n\\\\ global modules for temporary use \r\nModule Global [001] {\r\n      const n=5, z=50\r\n      Function Hello$ {\r\n            =\"Hello There 1\"\r\n      }\r\n}\r\nModule Global [002] {\r\n      \\\\ any definition here is global\r\n      const n=55, z=550\r\n      Function Hello$ {\r\n            =\"Hello There 2\"\r\n      }\r\n}\r\n\\\\ script can call only global modules\r\n\\\\ and is a special call, which permanent use of modules definitions\r\nSet Script [001]\r\nStart()\r\nClear  \\\\ clears only variables, we need this for erasing constants too\r\nPush \"[002]\"\r\n\\\\ Script can execute Script again\r\nSet Script \"Script \"+letter$\r\nStart()\r\n\r\n\r\nSub Start()\r\n      Print n, z, Hello$()\r\nEnd Sub
GR:ΣΗΜ\r\n\r\nREM : PRINT \"THIS LINE NOT EXECUTED BUT HAS SYNTAX COLOR\"\r\n\r\nREM {\r\n\tPRINT \"THIS BLOCK NOT EXECUTED AND HAS NO SYNTAX COLOR\"\r\n\t\\\\ IT IS A MULTILINE REMARK\r\n}
GR:ΣΗΜ(\r\nPrint Sgn(10),Sgn(0),Sgn(-1)\r\ngive  1      0      -1\r\nA=-5\r\nPrint Sgn(A)\r\n      -1\r\n      
GR:ΣΗΜΑΔΙ\r\n\r\nWe can display a mark like a circle or ellipse.\r\n\r\nMARK widthInChars, HeightInChars, Color, circleOrellipse\r\n\r\nWith last parameter 1 we print circle always, but with 0 maybe we print circle if width and height are equal.\r\nCursor isn't changed so we can use it also as a background style,\r\n
GR:ΣΗΜΕΙΟ\r\n\r\nReturn color of point in current graphic cursor\r\n\r\n(using Layer {} we can change current layer so we can get point from anywhere - Forms also use Layer, but we can't get point from controls on form, only from form's Layer)
GR:ΣΗΜΕΙΟ(\r\n' number in pixels. A$ must have an image inside\r\nPrint Point(a$, 10,10)\r\n\r\noldpoint=Point(a$, 10,10, Color(255, 0, 128))\r\n\r\nTo manipulate images we can use a Hidden Layer, and print image there, so we can use twips and Point to get color, or we can cut any part of image, and place it in another layer or another layer.\r\nHidden layer is any layer without a SHOW command (also SHOW as variable return -1 if layer is visible )\r\n\r\n
GR:ΣΗΜΕΡΑ\r\nreturn date for today\r\nPrint Date$(today)\r\nPrint Str$(today, \"LONG DATE\")
GR:ΣΤΑΘΕΡΕΣ\r\nCONSTANTS\r\nASCENDING, BINARY_const, BOOLEAN, BYTE, CURRENCY, DATEFIELD, DESCENDING, DOUBLE_as constant, FALSE, FALSE _2, FORMATTING_ANY TYPE, FORMATTING_DATE AND TIME, FORMATTING_NUMBERS, FORMATTING_STRINGS, INFINITY, INTEGER, ISWINE, LONG_TYPE, MEMO, PI, SINGLE, TEXT_as constant, TRUE, TRUE _2, VERSION_as constant\r\n\r\n
GR:ΣΤΑΘΕΡΗ\r\nVariables for reading only\r\n1) \r\n      const a=10, b%=12, c$=\"ok\"\r\n2)\r\n      global const a=10\r\n3)\r\n      global const a\r\n4)\r\n      const a      \r\nAny global variable can be shadow from a local one\r\nso we use 3 and 4 in a module to get a global const inside module\r\nwe can use global without this way, but if we assign a value then a new local variable shadow the global one, so we set a copy of constant in a new variable using const a (for global const a). \r\n\r\nWhen we list the variables with List command, we see constants with values in [ ]\r\n\r\n
GR:ΣΤΑΤΙΚΗ\r\nstatic variables in modules and functions, and threads\r\nstatic variables are stored in a collection in execution object. So if we have a global module, and we call from different execution objects, then for each object  we have different collection. \r\nSubs can't have own static variables because run on execution object of module or function, but they can see static variables.\r\nWe can't have static in a thread/module with same name as local variable in module.\r\nWe can't have objects as static variables, except objects using pointers assign to variables.\r\nWe can't pass by reference static variables (except by value pointer to object)\r\nstatic variables clear with clear command (clear every variable, including static variables) \r\n\r\n\r\n\r\nWrite this example in a file using Edit \"st.gsb\" press Esc and load it using Load st\r\n\r\nModule A {\r\n      if match(\"N\") then Drop : Clear\r\n      Module Global M {\r\n            STATIC A=0, B=10, Z=(1,2,3,4,5)\r\n            Z+=20\r\n            Print Z\r\n      }\r\n      Module test1 {\r\n            M\r\n            M\r\n            M\r\n      }\r\n      Print \"three times call M from test1\"\r\n      test1\r\n      Print \"two times call M from this Module \";Module$\r\n      M\r\n      M\r\n      Print \"three times call M from test1\"\r\n      test1\r\n}\r\nModule B {\r\n      K=100\r\n      a 1  ' so now we clear but static variables are for b Module only\r\n      Print K\r\n}\r\nA\r\nB\r\n\r\n\r\nMore advance example:\r\n\r\nClear\r\nZ=100\r\nModule Localmodule {\r\n      Print \"This module can called from parent only\"\r\n}\r\nLocalmodule\r\nModule Global test1 {\r\n      Static M=10\r\n      M++\r\n      Print M\r\n}\r\n\\\\ this is not a ordinary function\r\n\\\\ but a part of this module\r\nFunction fake (&feedback) {\r\n      Z++\r\n      feedback=Z\r\n      test1\r\n      Localmodule\r\n}\r\n\r\nModule Delta {\r\n      Read &func()\r\n      \\\\ we run a part of parent module\r\n      N=0\r\n      Call func(&N)\r\n      Print N\r\n      Call func(&N)\r\n      Print N\r\n      \\ \\  call test1 from Delta\r\n      test1\r\n      test1\r\n}\r\ntest1\r\ntest1\r\n\\\\ we pass a part of this module\r\nDelta Lazy$(&fake())\r\ntest1
GR:ΣΤΗ\r\nLET x=20, y=30, z$=\"ok\"\r\n\r\nWithout LET, in an assignment,  a left hand expression is always in priority, so for A(b+10)=a+10 array is searching, if found then evaluate b+10 and we get array item and then interpreter evaluate  a+10. In a Let command  first evaluate a+10 and then interpreter find array and then evaluate b+10. Also a Let command never hide a global if we give same name with \"=\". So we don't need here to use \"<=\" to make the assignment for global variable. \r\n
GR:ΣΤΗΛΗ\r\nReturn width of column (for print)\r\nPrint @(tab*3), \"ok\"\r\nPrint @(Tab(3)), \"ok\"\r\n\r\nlook Tab(), $()
GR:ΣΤΗΛΗ(\r\nPrint Tab(3)\r\nPrint @(tab(2)),100,@(tab(1)),400\r\n                        400            100\r\nPrint tab*3=tab(3)\r\n\r\nPrint $(,10), tab=10\r\n\r\nlook Tab, $()
GR:ΣΤΟΚ\r\nAny array can be used as stock for values\r\n   1) STOCK arrayname(index)  in  value1, value2, value$...\r\n         copy values from index\r\n   2) STOCK arrayname(index)  out  Var1, Var2, Var$...\r\n         copy to variables from index\r\n3.1) STOCK arrayname(index)  keep 20,  arrayname(index+100) \r\n        Relocate 20 items from inde\r\n3.2) STOCK arrayname(index)  keep 20,  arrayname2(index+100) \r\n         Store in other array from index to 100+index\r\n4.1) STOCK arrayname(index)  sweep 100\r\n         Make Empty all items\r\n4.2) STOCK arrayname(index)  sweep 100,  class1()\r\n         Put class1() from index to index+100-1\r\n\r\n\r\ndim a(200), a$(3)\r\ndim ov$(5)=\"OK\"\r\n\r\nstock a(0) in 1,2,\"George\", ov$()\r\nstock a(0) out a,b, a$(1) , kl$()\r\n\r\nkl$(1)=kl$(0)+\"George\"\r\nprint a,b,a$(1), kl$(1)\r\nprint\r\nstock a(3) out kl2$()\r\nprint kl2$(1)\r\nstock a(3) in kl$()\r\nstock a(3) out kl2$()\r\nprint kl2$(1)\r\nstock a(0) sweep 200\r\n? type$(a(13))\r\nstock a(0) sweep 200, \"1234\"\r\n? type$(a(13)), a(13)   'but is string...\"\r\nstock a(0) in 1,2,3\r\n? a(2)\r\nstock a(0) keep 3, a(100)\r\n? a(101)
GR:ΣΤΟΧΟΙ\r\nTARGETS NEW\r\nclear memory for targets. Same can be done with Mode and Window commands, but we clear layer also.\r\n
GR:ΣΤΟΧΟΙ ΚΑΙ ΕΠΙΛΟΓΗ\r\nTARGET AND MENU\r\nCHANGE, MENU, SCAN, TARGET, TARGETS\r\n\r\n
GR:ΣΤΟΧΟΣ\r\nWe can make targets, visible or not.  Targets are frames on layers to be used by clicking on it, when Scan command used)\r\nCursor left1, top1 \r\nTARGET  handlervariable, \"Beep\",  tWidth, tHeight, FrameColor, OutlineColor, LabelPositionId, \"label\"\r\n\r\nWe can use Change to set some properties\r\nPosition Number (LabelPositionid)\r\n1 2 3\r\n4 5 6 \r\n7 8 9\r\nWe have to use one number, so number 5 means in the center of frame\r\nIf we add 10 to this number if we want the command to interpret as keys.\r\nWe can give a module name for command (in place of Beep command). This module has to be global. So when we click on a target we can call that module (threads can be run in the background). That module can set up a thread after some time to start. So in the exit of a target click we have code that start once with no specific module, but the global one. We can erase threads with THREADS ERASE\r\nTarget handlervariable, 0  we make individual target to not respond\r\nTarget handlervariable, 1 we enter target to list for scanning and we redarw it\r\nMode command erase all targets from specific layer\r\nA cls  erase the visual part of targets, not the scanning process. \r\nTargets New  erase all targets, from all layers.\r\nWe can use targets in background, basic layer and 32 layers above.\r\nA very simple system for scanning targets with irregular shape is to make a hidden layer and insert there a picture with painting areas so you can search similar coordinates for the color (and so color became a new handler). \r\n
GR:ΣΤΡΟΓΓ(\r\n\r\n1. Print Round(12.11211212, 3)\r\nround to 3rd decimal\r\n2. Print Round(12.121312313123123123)\r\n print using  round to 13 decimal\r\n
GR:ΣΥΓΓΡΑΦΕΑΣ\r\nDisplay writer name
GR:ΣΥΓΓΡΑΦΗ\r\n\r\nOpen internal editor and create/modify/rename modules and functions\r\n\r\nEDIT modulename\r\nEDIT functionname(\r\nEDIT functionname%(\r\nEDIT functionname$(\r\nEDIT something, position in text\r\nEDIT this as that\r\n(you can remove last module/function with REMOVE command)\r\n\r\nWe can edit UTF-8, UTF-16 (LE & BE) and ANSI. Internal all changed to unicode UTF-16 LE.\r\nEDIT \"app.gsb\"\r\nWe can open a disk file to edit with \"gsb\" type (george small basic...was the first name of M2000)\r\nEDIT \"file.txt\" \r\nWe can edit text . We discard the changes by using popup menu or Shift-12.\r\n\r\nEDIT ! 4\r\nset 4 char for indentation and tab character for edit\r\nEDIT\r\nOpen the list of commands that recorded in command line screen. So line editor has no arrow movements bat with up and down we can find something we have wrote or we can open the list and we can write any new line, them we go back with esc and use up aor down arrow (same job for both), and find the command you want.\r\n\r\nFor putting text in a variable at run time we can use INPUT,  uses this text editor.\r\nSEE INPUT \r\n\r\n
GR:ΣΥΓΚΡΙΝΕ(\r\na=10\r\nb=11\r\n'' need variable or array item for each place\r\nDim Base 1, A(2)\r\nA(1)=4, 5\r\nPrint Compare(a,b)\r\nPrint Compare(a(1),a(2))\r\nWork with Strings Variables and Array Items (with binary compare only)\r\n\r\nFor expressions use spaceship operator\r\nPrint 10+2<=>10+2, \"aaa\"<=>\"bb\"\r\n
GR:ΣΥΓΚΡΟΥΣΗ(\r\n\r\nPrint Collide(2,100)\r\n\r\nreturn true player 2 touch player 1,  100 means 100% the size of player 2 used for collision detection. So we can touch but we need more to raise the collision. Player 1 is in the lowest priority and so never collides with any player. Player 32 is the front most.\r\nWe can calculate the collision of a player (including 1)  if it touch to a percentage of the size it have to a parallelogram defined by two points (absolute coordinates)\r\n\r\nPrint Collide(2,100,10000,1800,12000,3800)\r\n \r\nwe can use the player as a layer. The second is a way to print on the player as a screen. see LAYER command.\r\n
GR:ΣΥΓΧΩΝΕΥΣΕ.ΕΓΓΡΑΦΟ\r\nMERGE.DOC  document$, filename$\r\nmerge document from a file to document$\r\n\r\n\\\\write something press esc\r\nEdit \"alfa1.txt\"\r\n\\\\write something press esc\r\nEdit \"alfa2.txt\"\r\nDocument alfa$\r\nLoad.doc alfa$, \"alfa1.txt\"\r\nMerge.doc alfa$,\"alfa2.txt\"\r\nReport alfa$
GR:ΣΥΜΠΙΕΣΗ\r\n\r\nCompress base$+\".mdb\"\r\n\r\nerase previously \"deleted\" records\r\n\r\nuse CLOSE BASE dir$+base$+\".mdb\"\r\nbefore make the compress call, to close any open connection to that base\r\n
GR:ΣΥΝ(\r\nReturn cosine of an angle in degrees
GR:ΣΥΝΑΡΤΗΣΗ\r\nΙ) Normal Functions\r\nFunctions are like modules, they have a name with a hidden prefix, from module's or function's name which is the parent of it.\r\nThere are functions in groups, functions without name, and functions in a variable as lambda (and these functions can be included in array items, and inventory lists). \r\nA function after execution erase anything that defined inside (like modules). We can call the same function again, as an argument to function (see DEF description later). Functions have recursion (about 3300 calls only).\r\n\r\nWe can make A(), A%() and A$() as three functions which return double, integer (is an Int(double) as a return), String\r\nAlso functions can return arrays, groups, lambdas, inventories, events, or an array of all of these.\r\nSee Lambda for more help\r\n\r\nTo define a function we can use one line definition with DEF command, or Function name { }  like modules. \r\n1) One Line definition using DEF\r\nDef Alfa(X)=X**2\r\nPrint Alfa(10), Alfa(Alfa(Alfa(2)))\r\n2) Using anonymous call  ( a function in a string use \"{     }\" to place the code (and multiline too), and for return a = as command is used.\r\nPrint Function(\"{=number**2}\", 10)\r\n3) Using anonumous call but give the same name as the module which lazy$() function prepare the function\r\nM=5\r\nPrint Function(lazy$(number**2+M), 10)\r\n4) As 3 but for multiline functions. We can pass back an array of values.\r\nLet K=100, N=1000\r\nM=2   \\\\ M is local too\r\nFunction fake {\r\n      Read New M\r\n      \\\\ in normal functions we can't read K because is out of scope\r\n      Local N=500  \\\\ without Local we change modules N\r\n      =M**2+K, 2*M, 3*K+N\r\n      K++\r\n}\r\nDim A()\r\nA()=Function(lazy$(&fake()),10)\r\nPrint A(0), A(1), A(2)\r\nPrint M  \\\\ 2 but if we delete New in Read statement we get 10\r\nPrint K\r\n5) Lambda is a special construction (is an object inside). We can define variables to hold a state. Using lambda in groups we can move data and functionality from/to groups.\r\n\r\nA=lambda X=3 -> {=X : X++}\r\nPrint A(), A()\r\nB=A       \\\\ not only we have a copy of function but a copy of internal state variables\r\nPrint A(), A(), B()\r\nC=lambda->number**2\r\nPrint C(2)\r\nDim A(10)\r\nA(0)=A, B, C  \\\\ assign values from 0\r\nPrint A(0)(),A(1)(),A(2)(3)   \\\\ 7 6 9\r\nInventory Alfa=1000:=C, \"square\":=C, \"counter\":=B\r\nPrint Alfa(1000)(5), Alfa(\"square\")(3), Alfa(\"counter\")()  \\\\ 25 9 6\r\n\r\n6) Using Function name {}\r\nNo parameter signature needed. We can Read parameters like Module. But while Modules call Modules passing own stack, Functions always have own stack (except if we call them by Call statement, as modules)\r\n\r\nFunction Name1 {\r\n\\\\ multi number return as array\r\n      Print Module$  \\\\ print the real name of Function/module\r\n      =1111,2222,3333\r\n}\r\nDim z(), k()\r\nz()=name1()\r\nPrint z(2)\r\nFunction Name2 {\r\n\\\\ multi object return to array\r\n      group A {X=1,Y=3}\r\n      B=A\r\n      A.X++\r\n      A.Y--\r\n      =A,B\r\n}\r\n\\\\ array defined with Dim before: Dim K()\r\nK()=Name2()\r\nPrint K(0).X, K(1).X  \\\\ 2  1\r\n\r\n\\\\ Example 1:\r\n\\\\ optional parameters\r\nFunction A {\r\n      Y=100\r\n      Read ? X, Y \r\n      =X*Y\r\n}\r\nPrint  A(), A(3), A(2,4)  \\\\ 0, 300, 8\r\n\r\n\\\\ use default value\r\nFunction BB {\r\n      Y=10\r\n      Read X, Y\r\n      =X*Y\r\n}\r\nPrint BB(3,?) \\\\ 30  \r\n\r\nPush &A()   \\\\ push as anonymous  Function\r\nFor This {\r\n      \\\\ use it for temporary definitιons\r\n      Read &AB() \\\\ Read Function and give a name\r\n      Print AB(2,4)  \\\\ 8\r\n}\r\n\r\n\\\\Example 2:\r\n\r\nGroup A {\r\nPrivate:\r\n      k=10\r\nPublic:\r\n      counter\r\n      Module SetK {Read .k}\r\n      Module IncK {.k++}\r\n      Function  GetK {=.k : .counter++}\r\n}\r\nPrint A.GetK()  \\\\ 10   (counter=1)\r\nPush &A.GetK()  \\\\ this is a reference to A.GetK() function\r\nRead &AK()  \\\\ this is a new function which is the same as A.GetK() and has a special reference to group A\r\nA.SetK 55\r\nPrint AK()  \\\\55 (counter=2)\r\nPush &AK()\r\nA.IncK\r\nModule DeepA {\r\n      \\\\ this is the defition only\r\n      Read &AK()   \\\\ here the special reference to group A is tied with function.\r\n      Print AK()  \\\\56 (counter=3)\r\n}\r\nDeepA &A.GetK()  \\\\ this is the call to DeepA\r\nPrint A.counter  \\\\3\r\n\r\n\r\n\\\\Example 3:\r\n\\\\ use Function like subroutine (but without a subroutine call)\r\n\\\\ if you wish to read parameters then use Read NEW (not Read only)\r\nKK=1234\r\nFunction Name3 {\r\n      Print KK\r\n      Print module$  \\\\ B (module$ isn'r Name3(), change to module, so KK is known)\r\n}\r\nCall Local Name3()\r\n\r\n\\\\ Example 4:\r\nFunction Name4 {\r\n      Read A()\r\n      Print A(0).X   \\\\ 2\r\n      Print A(1).X  \\\\ 1\r\n}\r\n\\\\ K() prepared in example 1\r\nCall Name4(K())\r\nCall Function Name4, K()\r\n\r\nFunction FuncAsModule {\r\n      Read A,B\r\n      Push A, B\r\n}\r\n\\\\ STACK NOT ERASED AFTER CALL\r\nCall FuncAsModule(10,1)\r\nPrint Number, Number\r\n\r\n\r\n\\\\QuickSort Example:\r\nFunction partition  {\r\n         Read New &A(), p, r\r\n         x = A(r)\r\n         i = p-1\r\n         for j=p to r-1 {\r\n             if A(j) <= x then {\r\n                       i = i+1\r\n                    Swap A(i),A(j)\r\n                 }\r\n          }\r\n          Swap A(i+1),A(r)\r\n         = i+1\r\n      }\r\nFunction quicksort {    \r\n     Read New &A(), p, r\r\n     if p < r Then {\r\n       q = partition(&A(), p, r)      \r\n       call local quicksort(&A(), p, q - 1)\r\n       call local quicksort(&A(), q + 1, r)\r\n    }\r\n}\r\n\r\nDim  arr(10), old()\r\narr(0)=23,21,1,4,2,3,102,54,26,9\r\nold()=arr()\r\nCall local quicksort(&arr(), 0, 9)\r\nFor i=0 to 9\r\n      Print arr(i), old(i)\r\nnext i\r\n\r\n\\\\ Example check current base\r\nFunction Base {\r\n      Dim a(1)\r\n      =valid(a(0))\r\n}\r\nBase 1\r\nPrint Base()\r\n\r\nII) Simple Functions\r\nFunctions like subs,  staticaly written to a module or a function.\r\nA simple Function  has these differences\r\n1) Use of the caller stack of values\r\n2) Use of the caller name space\r\n3) We have to use Local to define local variables (same for Subs)\r\n4) We can't place them by reference\r\n5) We can't use them as members of Groups\r\n6) We can't use CALL to call simple functions like subs\r\n\r\nAbout them:\r\n1) They have less resources, so we can call 10% more simple functions from normal functions in expression\r\n2) Don't use the same simple function name as a sub name, in same scope.\r\n3) Code of a simple function maybe not in the code of a caller, but in the code where the caller's code taken the first time.\r\n\r\n\\\\ This is a module name, execution of Module statement create the module in the module's/function's list.\r\nModule ModuleName {\r\n\t\\\\ This is a normal function (a definition in one line)\r\n\t\\\\ the same as Function Hello$(x) {=String$(\"H\", x)}\r\n\tDef Hello$(x)=String$(\"H\", x)\r\n\t\r\n\t\\\\ Hello$() exist in modules/functions list\r\n\t\\\\ @Hello$() are static in the code names.\r\n\t\\\\ first time the posiiton searched from the end,\r\n\t\\\\ second time the position is known.\r\n\t\\\\ if an array exist with same name as the Hello$() then\r\n\t\\\\ the @Hello$() call the simple function\r\n\t\\\\ and we need to call Hello$(*10)  with asterisk to use the norma function above.\r\n\tPrint @Hello$(10), Hello$(10)\r\n\t\r\n\tInternalUse()    ' Gosub is optional unlees an Array exist with same name\r\n\tGosub InternalUse()\r\n\t\r\n\t\\\\ this is a simple function\r\n\tFunction Hello$(x)\r\n\t\t=String$(\"Hello\", x)\r\n\tEnd Function\r\n\t\\\\ this is a subroutine\r\n\tSub InternalUse()\r\n\t\tPrint @Hello$(5)\r\n\tEnd Sub\r\n}\r\nModuleName\r\n\\\\ Function Hello$() exist in the same original code\r\nPrint @Hello$(3)\r\n\r\n\r\nAbout Names:\r\n(Only for names in Modules/Functions List and Variables/Arrays list)\r\nWhen two things have the same name\r\nArray preffered from Functions from interpreter\r\nAny local of same kind preffered from a global one.\r\n\r\nFor subs and simple functions: we have to use different names for subs and simple functions.\r\n\r\nSo the problem may happen if we have a Global array, and then we make a Global function with same name\r\nTo indicate the function from the array we have to use Alfa(* )  where asterisk indicate that it is a function.\r\nTo create libraries, forget Global functions, or you have to use asterisk to be sure about any conflict.\r\n\r\n\r\n\\\\ A global array exist before module defined\r\n\\\\ Problems may exist if we define a global function after global array with same name\r\n\\\\  If we use a Function Global Alfa(x) {=x/100} in place of Global Alfa(1 to 10)=4\r\n\\\\ In all Inner definitions the internal Alfa(x) always executed.\r\nGlobal Alfa(1 to 10)=4\r\nPrint Alfa(1)=4\r\nModule Inner {\r\n\tFunction Global Alfa(x) {\r\n\t\t=x**2\r\n\t}\r\n\tPrint Alfa(10)=4\r\n\tPrint @Alfa(10)=100\r\n}\r\nInner\r\nModule Inner {\r\n\tFunction Global Alfa(x) {\r\n\t\t=x**2\r\n\t}\r\n\tPrint Alfa(10)=4, Alfa(*10)=100, @Alfa(10)=30\r\n\tFunction Alfa(x)\r\n\t\t=x*3\r\n\tEnd Function\r\n}\r\nInner\r\nModule Inner {\r\n\tFunction Alfa(x) {\r\n\t\t=x**2\r\n\t}\r\n\tPrint Alfa(10)=100, @Alfa(10)=100\r\n}\r\nInner\r\nModule Inner {\r\n\tFunction Alfa(x) {\r\n\t\t=x**2\r\n\t}\r\n\tPrint Alfa(10)=100, @Alfa(10)=30\r\n\tFunction Alfa(x)\r\n\t\t=x*3\r\n\tEnd Function\r\n}\r\nInner
GR:ΣΥΝΑΡΤΗΣΗ$(\r\nPrint Function$(\"name_of_function$\",1,4,5)\r\nPrint name_of_function$(1,4,5)\r\nPrint Function$(\"{=Mid$({1234567890},number,number)}\", 3, 4)\r\nFunction Alfa$ (x){\r\n      If x>100 then {\r\n            =\"Big\"+str$(x)\r\n      } else =\"Small\"+str$(x)\r\n}\r\na$=&Alfa$()\r\nPrint Function$(a$,200), Function$(a$,50)\r\n
GR:ΣΥΝΑΡΤΗΣΗ(\r\nPrint Function(\"name_of_function\",1,4,5)\r\nPrint name_of_function(1,4,5)\r\n\r\nFunction Alfa (x){\r\n      If x>100 Then {\r\n            =x*500\r\n      } Else =x\r\n}\r\na$=&Alfa()\r\nPrint Function(a$,200), Function(a$,50)
GR:ΣΥΝΕΧΙΣΕ\r\n\r\n1) In a SELECT  CASE continue the Break state.\r\na=5\r\nb=10\r\nselect case  A\r\ncase 1, 5 to 20\r\n      { print \"ok\"\r\n             if b=10 then  break\r\n      }\r\ncase 2,4\r\n      {print \"an ok\"\r\n            continue\r\n      }\r\ncase 3\r\n      { print \"that\"\r\n            print \"and that\"\r\n      }\r\nelse\r\n      print \"??\"\r\nend select\r\n\r\n\r\n2) In a loop continue exit block but not the loop.\r\nfor i = 1 to 1000 {\r\n      if i> 10 then exit\r\n      print i 'print until 10\r\n}\r\nprint i  ' 11\r\n\r\nfor i = 1 to 1000 {\r\n      if i> 10 then continue\r\n      print i  ' print until 10\r\n}\r\nprint i  ' 1001\r\n\r\nfor i=1 to 1000 \r\n      if i>10 then next i : goto 1000\r\n      print i\r\nnext i\r\n1000 print  i
GR:ΣΥΣΚΕΥΗ.ΠΡΟΒΟΛΗΣ$\r\n\r\n? MOVIE.DEVICE$\r\nwe get device name\r\n
GR:ΣΥΣΤΗΜΑ\r\n\r\nWIN \"CALC\"\r\nWIN DIR$\r\nWIN \"WORDPAD\"\r\nWIN \"WORDPAD\",\"COMMAND LINE\"\r\nTo run another gsb file (M2000 script) use the USE command (look also to PIPE command)\r\n
GR:ΣΥΧΝΟΤΗΤΑ(\r\n\r\nReturn frequency for octave and note number
GR:ΣΧΔ$(\r\n\r\nreturn full path with name and type of a wmf file if exist else return empty string\r\n
GR:ΣΧΕΔΙΑ\r\nDIR \"C:\"\r\nDRAWINGS\r\nFILES \"wmf\"\r\n\r\nprint on screen names of wmf files in directory DIR$\r\n\r\nDRAWINGS                ' SORTED BY DATE & TIME\r\nDRAWINGS !              ' SORTED BY NAME\r\nFILES \"wmf\"          ' AS DRAWINGS\r\nFILES \"wmf\"       ' AS DRAWINGS !  \r\nFILES \"wmf\"     ' SORTED BY DATE AND TIME  AND STORED AS MENU ITEMS\r\nFILES +  \"wmf\"  ' SORTED BY NAME AND STORED  AS MENU ITEMS\r\nuse MENU ! to open menu\r\n
GR:ΣΧΕΔΙΟ.ΝΗΜΑΤΩΝ\r\n1) Thread.plan Concurrent\r\nMake each thread to execute one command and pass the execution to other thread. Any block executed as one command. Use If inside block because there is a problem if we have ELSE after THEN (the split is perfect but not for IF)\r\n2) Thread.plan Sequential   \\\\ by default\r\nNo two threads execute commands at the same time.\r\nWe can't change plan if threading pool have threads \r\nIn this example using concurrent plan we can stop \"for next\" changing m variable because thread L can be run when task.main thread run also. If we use sequential plan, m is changed by any thread in turn of execution. Using For k=1 to 100 { } we not allow other thread to run concurrent.\r\n\r\n\r\nthread.plan concurrent\r\n\\\\ thread.plan  sequential\r\nm=0\r\nthread {print \"ok\" : m=50 } as L interval 10\r\nmain.task 100 {\r\nm=0\r\nfor k=1 to 100\r\nprint k\r\nif m>0 then keyboard \" \" : exit for\r\nnext k\r\nif inkey$=\" \" then exit\r\n}\r\n
GR:ΣΩΡΟΣ\r\nAbout  stack\r\nM2000 has a stack system to place by value items without names but in an order.  We can place numbers or strings. There is a system to place a reference to a variable but this reference is a string item  and only a READ command can understand that this was for reference and not for value.\r\nAny function and thread has own stack, but modules in same thread have a common stack. \r\nEvery line of code run in a module (or by SET command as from command line interpreter), use that module as namespace, and can push or pop values to a stack without name or can define variables and arrays with name.\r\nReturn form database commands placed on the stack. We can use stack to send information using pipes.\r\nHere we can see how to use these major stacks with temporary stacks in strings\r\n\r\n1) STACK\r\nprint to output (background, screen, printer or layer) the stack items \r\nWe can see the stack in the Control Form (used to trace a running program) using TEST command or ctrl & I (also any non using combination open the Control Form)\r\n2)  STACK A$\r\nWe can prepare stacks in string variables, with STACK$() function, and here we can dump the string to the stack\r\nWe can use array item as temporary stack.  We can execute one by one command in command line interpreter or we can write all  of this example to a module using edit a and copy from this help screen (with some clicks cursor become alive..)\r\n                  dim a$(10)\r\n                  a$(2)=stack$(1,2,\"ok\")\r\n                  stack a$(2)\r\n                  stack\r\n                  ? len(a$(2))\r\n3)  STACK A$, \"NN\"\r\nWe send only the top two numbers of string A$ who act as a stack in a variable. We can use S for String Item\r\nWe can read the kind of items in a temporary string stack by using ENVELOPE$()   with parameter\r\nSo ENVELOPE$(STACK$(2, 20.5)) is equal to \"NN\"\r\n4) STACK string expression\r\nin 2 and 3 the variables looses content\r\nWe can use string expression but if interpreter find that result is a stack. So we can add variables ready with stack content.\r\n5) STACK NEW {}\r\n      FLUSH\r\n      DATA 1,2,3,4\r\n      STACK NEW {   \\\\ REPLACE STACK WITH A NEW ONE\r\n            PUSH 10,20\r\n            DATA 1,2\r\n            STACK\r\n      }  \\\\ NOW OLD STACK RETURN \r\n      STACK\r\n6) STACK VARIABLES (AS OBJECTS)\r\n    a=Stack\r\n    a=Stack:=1,2,3  ' we can put  (stack:=1,2,3) as a value too\r\n    b=Stack Up a, 2  ' 1,2 to b and leave 3 to a\r\n    a=Stack:=1,2,3\r\n    b=Stack Down a, 2  ' 2,3 to b and leave 1 to a\r\n    Print b ' 2,3\r\n    a=Stack:=!a,!b\r\n    Print a   ' 1,2,3\r\n\r\n     \\\\ use ! before a stack object as argument to pass stack items as arguments\r\n     Function b (x,y) {\r\n            =X**Y\r\n      }\r\n      s=stack:=3,2\r\n      s1=stack:=100,2\r\n      Print b(2,4), b(!s) , b(!stack(s1))\r\n      Print len(s), len(s1)\r\n      \r\n      \r\n      \r\n      \\\\Create one    \r\n      A=Stack  ' Empty\r\n      A=Stack:=1,2,3  ' three items, top is 1\r\n      Print A  \\\\ show items\r\n      Stack A  \\\\  place items to modules stack, at the bottom, A is empty\r\n      A=[]  \\\\ get modules stack. Module stack is empty now use [ ] without space between\r\n      Print Len(A), StackItem(A), StackItem(A,1)\r\n      Stack A {\r\n            Over 2  ' get a copy of 2nd as a new top\r\n            Drop 2 ' drop 2 from top\r\n            Read A, B  ' read means, pop item\r\n            Push A, B ' now top is value of B - before was value of A\r\n            Shift 2 ' now top is value of A\r\n            ShiftBack 2 ' now top is value of B\r\n      }\r\n      Stack Stack(A, 3)  ' pass a copy of 3 first items of A to bottom of module stack\r\n      B=Stack:=100,\"string\", 200\r\n      Stack B {\r\n            \\\\ place B as module stack\r\n            Stack Stack(A, -3)  ' pass a copy of last 3 items of A to bottom of module stack\r\n            \\\\ now at the close, old module stack restored.\r\n      }\r\nExample:\r\n      Flush\r\n      Data 1,2,3,4\r\n      a=Stack:=20,10,1,2\r\n      Stack a {\r\n            Stack\r\n            Drop 2\r\n            Stack\r\n      }\r\n      Stack\r\n      Print StackItem(a), Len(a)  \\\\ 1   2\r\n      Stack a {\r\n            Read x, y\r\n            For This {  \\\\ block for temporary use - all new names erased at the end of blockl\r\n                  Dim m(10)=5\r\n                  Push m()\r\n            }\r\n      }\r\n      n=Stack(a)  \\\\ Get a copy of stack a\r\n      Stack n {\r\n            For This {\r\n                  Read k  \\\\ we get array in a variable (arrays have two interfaces for M2000)\r\n                  k+=100  \\\\ this interface has some operators\r\n                  Push k  \\\\ we can push it back.\r\n                  Print k  \\\\ all array items 105\r\n                  Stack a {\r\n                        Read m()\r\n                        Print m()   \\\\ all array items 5\r\n                  }\r\n                  Print Len(a)  \\\\ 0\r\n            }\r\n      }\r\n      a=Stack:=\"Alpha\",\"Beta\", 100  \\\\ := is a Data command for stack, it is optional\r\n      Print Len(a), Len(n)  \\\\ 3 & 1\r\n      n=Stack(a,n)  \\\\ Here we get a new stack with items from both, but from 'a' first\r\n      Stack n {\r\n            Stack    \\\\  just show stack item\r\n      }\r\n      Stack a {\r\n            Stack\r\n      }\r\n      a=Stack(a,-3)  \\\\ reverse 3 last (a has 3 all, so reverse the order of items in a)\r\n      Stack a {\r\n            Stack   \\\\ show stack items\r\n      }\r\n      Stack Stack(a,-2) {  \\\\ Stack() return always a new object)\r\n      \\\\ last two items in reverse\r\n      \\\\ a isn't change\r\n            Stack\r\n      }\r\n      Stack a {Drop} \\\\ drop top item\r\n      a=Stack(a,-Len(a))\r\n      nn=Each(a)\r\n      While nn {\r\n            Print StackItem$(nn)\r\n      }\r\n      \r\n\r\n\r\n\r\nExample (old examples here)\r\n---------------------\r\nMODULE A {FLUSH\r\nA$=QUOTE$(\"AAAAAAA\",1,\"BBBBBBB\", 2)\r\nB$=STACK$(\"AAAAAAA\",1,\"BBBBBBB\", 2)\r\nPRINT A$\r\nPRINT B$\r\nTRY K {\r\nINLINE \"DATA \"+A$\r\nREAD P$,Q,R$,T\r\nPRINT P$, Q,  R$, T\r\n}\r\nIF K THEN PRINT \"OK\"\r\nSTACK\r\nQ$={PRINT \"OK\"\r\nPRINT 1*2\r\nTONE 1000, 100\r\n}\r\nINLINE Q$\r\n}\r\n\r\nSEE FLUSH, ENVELOPE$, LETTER$, NUMBER, ISNUM, ISLET, EMPTY, DROP
GR:ΣΩΡΟΣ$(\r\n\r\na$={line 1\r\n      line2\r\n      }\r\n\\\\ we can't pass objects to stack$(), we can use object type stack for this (like a)\r\nb$=stack$(10, a$, 300)\r\nPrint envelope$(b$) ' NSN  (number string number)\r\na=Stack\r\nStack a {\r\n      \\\\ feed stack from string\r\n      Rem : Stack b$  ' for all\r\n      Stack b$,\"NS\"\r\n}\r\n\r\nReport StackItem$(a, 2)\r\nStack b$\r\nRead K\r\nPrint K\r\n
GR:ΣΩΡΟΣ(\r\na=Stack:=1,2,\"alfa\",4,5\r\nb=Stack:=6,7,8,9\r\nb=stack(a,b,a)\r\nPrint a\r\nPrint b\r\n\r\n\r\n
GR:ΣΩΡΟΥΤΥΠΟΣ$(\r\n\r\nb=(1,2,3,4)    \\\\ pointer to  mArray object\r\nDim b1(10)=1   \\\\ mArray object\r\n\\\\ in stack we place pointer to arrays (mArray object)\r\na=Stack:=1,\"hello\", b, b1()\r\nStack a {\r\n      \\\\  Stack object_type_stack {}\r\n      \\\\ make object_type_stack as current stack, and old stack as pointer saved\r\n      \\\\ and place back the old stack at the exit\r\n      Print Envelope$()   ' NSAA letters in English\r\n      Print Match(\"NSAA\")   \\\\ English Letters\r\n      Print Match(\"ΑΓΠΠ\")  \\\\ Greek Letters\r\n}\r\n\r\nd=Each(a)  \\\\ Iterator for a\r\nWhile d {\r\n      Print StackType$(d)   \\\\  Number, String, mArray, mArray\r\n}\r\nPrint StackType$(a, 2)\r\nPrint StackItem(a,1), StackItem(a)\r\nPrint StackItem$(a, 2)\r\nPrint StackItem(a, 3) ' 1 2 3 4\r\nPrint Array(StackItem(a, 3), 3)   ' 4\r\nPrint StackItem(a, 4) ' 1 1 1 1 1 1 1 1 1 1\r\n\r\n
GR:ΣΩΣΕ\r\nSAVE LOCAL means that all top modules/functions can be loaded as local\r\nSAVE without LOCAL means that all top modules/functions loaded only as global\r\n \r\n  \r\n1) SAVE \"name with spaces\"\r\n    SAVE name\r\n2) SAVE name, modulename2run\r\n3) SAVE \"name\" @, modulename2run    \\\\ this hide code\r\n    SAVE \"name\" @\r\n4) SAVE \"name\" @ @ \"special code\"\r\n    need the special code with load command.
GR:ΣΩΣΕ.ΕΓΓΡΑΦΟ\r\nSAVE.DOC document$, filename$, type\r\ntype for save document (if document loaded form file then type is keeping as number, the document internal format is UTF-16LE)\r\n0 UTF-16LE\r\n1 UTF-16BE\r\n2 UTF-8 \r\n3 ANSI\r\nBy default: Utf-8\r\n\r\n\r\nDocument α$={One paragraph\r\n}\r\n\r\nSave.Doc a$,\"name1.txt\"\r\n\r\nDocument b$={Another paragraph\r\n}\r\n\r\nIf Exist(\"name1.txt\") Then {\r\n      Append.Doc b$,\"name1.txt\"\r\n} Else {\r\n      Save.Doc b$,\"name1.txt\"\r\n}\r\n\r\nDocument k$\r\nLoad.Doc k$, \"name1.txt\"\r\nReport k$\r\n\r\n\r\n
GR:ΤΑΙΝΙΑ\r\nMOVIE or MEDIA can play avi files\r\n\r\n3 way to play movies\r\n\r\n1) Play one by one\r\n\r\nMovie file1,file2  'play file1 then file2\r\nMovie                     ' stop movie\r\n\r\n2) Play  file(s) and when finish resume the command execution\r\n\r\nMovie  file1,file2;\r\n\r\n3) Advance Use\r\n\r\nMOVIE LOAD \"SECOND\"  ' load movie but not run\r\nMOVIE TO 2                          ' move to 2 second (it is a single)\r\nMOVIE 1000+motion.x,1000+motion.y             '  set the movie window position\r\nMOVIE SHOW                      ' Show the paused movie (we show a static frame)\r\nA$=GRABFRAME$             ' Grab the frame in A$ as image\r\nCOPY 1000,1000 USE A$ ' We can put that frame behind movie (movie has own window, we can't copy there)\r\nMOVIE HIDE                         ' We can hide the movie window\r\n                                                 '(but we can't see that because we see the copying frame)\r\nMOVIE TO 3                         ' change to 3 second of the movie\r\nMOVIE 5000+motion.x,1000+motion.y             ' we move the movie window, we can change width and height also\r\nMOVIE SHOW                     ' we show the frame\r\nA$=GRABFRAME$            ' we take it \r\nCOPY 5000,1000 USE A$ ' and we print it\r\nMOVIE     ' we close the movie\r\n\r\nsummary of advance commands\r\nMOVIE LOAD \"FILENAME OR PATH AND FILENAME\"\r\nMOVIE PLAY\r\nMOVIE PAUSE\r\nMOVIE HIDE\r\nMOVIE SHOW\r\nMOVIE RESTART\r\nMOVIE TO 0.01\r\nMOVIE left, top\r\nMOVIE left, top, width      \r\nMOVIE left, top, width, height\r\n\r\nWe can use 1 and 2 as\r\nMOVIE left, top, file1$  [,fileN$]\r\nMOVIE left, top, width , file1$  [,fileN$]\r\nMOVIE left, top, width, height, file1$ [,fileN$]\r\nwithout position the movie is centered to the screen (the basic layer of the environment)\r\nMovie 1.2  same as  Movie to 1.2\r\nMovie 0 same as Movie Restart \r\nMovie -1 same as Movie Pause\r\nFeedback:\r\nWe can read Duration (a read only variable)\r\nMovie is also a read only variable. It is true if a movie play.\r\nMovie.Counter or Media.Counter or Music.Counter is the same read only variable.\r\nThis counter is -1 if nothing is loaded.\r\n\r\n\r\n\r\n\r\n
GR:ΤΑΙΝΙΑ.ΜΕΤΡΗΤΗΣ\r\nsame as Music.Counter\r\nreturn -1 if nothing played\r\nreturn for current tune the time of play in msec from start.\r\nLook Duration  (to get duration of tune)\r\n
GR:ΤΑΙΝΙΑ_μεταβλητή\r\nReturn True if something (video or music from internal media player still executed)\r\nSAME AS MEDIA, MUSIC
GR:ΤΑΙΝΙΕΣ\r\n\r\nDIR \"C:\"\r\nMOVIES\r\nFILES \"avi\"\r\n\r\nshowing movies files in directory DIR$\r\n\r\nuse win dir$  to open an explorer and to put some avi files if you wish to use with your programs.\r\n\r\nMOVIES                ' SORTED BY DATE & TIME\r\nMOVIES !              ' SORTED BY NAME\r\nFILES \"avi\"          ' AS MOVIES\r\nFILES  ! \"avi\"       ' AS MOVIES !  \r\nFILES  + \"avi\"     ' SORTED BY DATE AND TIME  AND STORED AS MENU ITEMS\r\nFILES  ! +  \"avi\"  ' SORTED BY NAME AND STORED  AS MENU ITEMS\r\nuse MENU ! to open menu\r\n
GR:ΤΑΞΗ\r\n\r\nYou can set the order for simple reading using DESCENDING or ASCENDING\r\nORDER \"mine\", \"firstTable\", \"title1\", ascending   [, \"title2\", way]
GR:ΤΑΞΗ(\r\n\r\nPrint Order(\"ALFA1232\",\"ALFA800\")\r\n\r\nfind the order of two strings,  by searching names as names and numbers as numbers.  This function used internal for Inventories when we choose: sort |ascending|descending| inv_name as numbers.\r\n
GR:ΤΑΞΙΝΟΜΗΣΗ\r\nSORT [descending] document$ [, start, end[, from_position]]\r\nFor Documents see 1 and 2,  for Inventories see 3, 4, for arrays see 5 and 6\r\n\r\n\r\n1)\r\n\\\\ use key to see next lines. Report going to wait mode, when display lots of lines.\r\nDocument alfa$ ={one\r\n      two\r\n      three\r\n      four\r\n      five\r\n      six\r\n      seven\r\n      eight\r\n      nine\r\n      ten\r\n      } \r\nSort alfa$, 1, 10\r\nReport alfa$\r\nPrint \"***************\"\r\nSort descending alfa$, 1, 10\r\nReport alfa$\r\nPrint \"***************\"\r\nSort alfa$, 1, 5\r\nReport alfa$\r\n\r\nWe can use Methods of Document to change the compare function\r\nMethods are SetTextCompare (default), SetBinaryCompare, SetDatabaseCompare (I can't figure if it works)\r\nand SetLocaleCompare with or without parameter. (without use stored locale id in document)\r\n(we can store explicity locale id using With a$, \"Lcid\", 1033 or  using a variable for input/output: With a$, \"Lcid\" as aName : aName=1033)\r\n\r\nDocument a$={péché\r\n            sin\r\n            peach\r\n            pêche\r\n            }\r\n\r\nMethod a$, \"SetLocaleCompare\", 1036\r\nSort ascending a$, 1,4\r\nReport a$\r\nMethod a$, \"SetLocaleCompare\", 1033\r\nSort ascending a$, 1,4\r\nReport a$\r\n\r\n\r\n2) We can set the position from where we run compare\r\nso we can put data for specific width and keys for any length\r\ndocument a$={1234beta\r\n      4567alfa\r\n      1212zeta\r\n      9921epsilon\r\n      }\r\nSort descending a$, 1,4, 5\r\nReport A$\r\n\r\n3) \r\nSort ascending  inventory1 as number\r\nSort  inventory1 as number, 1\r\nSort descending  inventory1 as number\r\nSort  inventory1 as number, 0\r\nSort ascending  inventory1 as text\r\nSort  inventory1 as text 1\r\nSort descending  inventory1 as text\r\nSort  inventory1 as text, 0\r\n\r\nSort ascending  inventory1 as text, way\r\nSort descending  inventory1 as text, way\r\nway can be \r\n0 Binary Compare\r\n1 Text Compare  (default)\r\n2 Database Compare\r\n1033 or 0x800 or any other Locale Id\r\nInventories have never equal keys (binary compared), except for Inventory queue which is not sortable.\r\nInventoried can accept only keys (and later we can attach somthing to any key)\r\n\"Print a\" normaly show items of Inventory, but if a key has no item, then key presented\r\n\r\nInventory  a=\"sin\",\"pêche\",\"péché\",\"peach\"\r\nsort a as text, 1\r\nPrint a, \"standard ascending\"\r\nsort a as text, 0\r\nPrint a, \"standard descending\"\r\nsort ascending a as text, 1036\r\nPrint a, 1036\r\nsort ascending a as text, 1033\r\nPrint a, 1033\r\n\r\n4) Using Columns in Keys in Inventories (using chr$(1) between columns of key)\r\ninventory queue alfa\r\nwith alfa, \"Stable\", false ' so we use quicksort  and not insertion sort (default in inventory queue)\r\n\\\\ 0 means ascending text\r\n\\\\ 1 means descending text\r\n\\\\ 2 means ascending numeric\r\n\\\\ 3 means descending numeric\r\n\\\\ keys have to place a chr$(1) to handle it with columns. \r\ndef d$(a$, n)=a$+chr$(1)+str$(n,\"\")\r\nAppend alfa, d$(\"a1\",1):=1,\"c1\",d$(\"a1\",2):=2\r\nAppend alfa ,\"b1\",d$(\"a1\",3):=3,\"z1\", d$(\"a1\",4):=4,\"c2\",d$(\"a1\",5):=5,\"b5\",d$(\"a1\",100):=100,\"z1\", \"sin\",\"pêche\",\"péché\",\"peach\"\r\nPrint \"without sort\"\r\nPrint alfa\r\nPrint \"sort first part of key ascending as text (chr$(1) used to break parts), second part ascending as number\"\r\nSort alfa, 0,2\r\nPrint alfa\r\nPrint \"same as previous but use 1036 for clid for text\"\r\nSort ascending alfa, 1036, 0,2\r\nPrint alfa\r\nPrint \"sort key ascending with automatic number recognition\"\r\nSort ascending alfa as number \r\nPrint alfa\r\nPrint \"sort key ascending as text, 1036\"\r\nSort ascending alfa as text , 1036\r\nPrint alfa\r\nprint  \"done\"\r\n\r\n\r\n\r\n
GR:ΤΑΞΙΝΟΜΗΣΗ(ΕΓΓΡΑΦΟΥ)\r\nSee SORT\r\n
GR:ΤΑΥΤΙΣΗ(\r\n\r\npush 3, \"alfa\",1,2\r\nwe can check the types in stack\r\nPrint match(\"nn\")\r\n\r\nPrint match(\"nns\")\r\n\r\nPrint envelope$()    \\\\ envelope return one of NSAG for each element in stack\r\nNNSN\r\n\r\nTypes:\r\n[N]umber, [G]roup, [E]vent, [B]uffer, [I]nventory, [A]rray, [F]unction, [S]tring, Sta[C]k\r\nF is for Lambda functions (they have object inside)\r\n\r\n\\\\Example\r\nFlush \\\\ flush stack\r\nDim A(10)\r\nInventory Alpha=1,2,3\r\nBuffer Clear Beta as Long*10\r\nGroup Delta {X=10}\r\nL=Lambda->100\r\nFunction Zeta {=100}\r\nEvent K {Read X}\r\nA=Stack:=1,2,\"οκ\",3\r\nPush \"οκ\", L ,A(), Alpha, Beta,K, Delta, Zeta(), Stack(A)\r\nPrint Stack.Size\r\nStack\r\nPrint Envelope$(), Match(\"CNGEBIAFS\"), Match(\"ΣΑΟΕΔΚΠΛΓ\")  \\\\ also Greek letters can be used\r\nCNGEBIAFS            -1            -1\r\n\\\\ Envelope$() always return English Letters.\r\n\r\n\r\n
GR:ΤΕΛΕΣΤΕΣ\r\nFor objects only\r\npointer Is pointer, pointer is nothing\r\npointer can be any object handled with pointer\r\ngroup_pointer is group_pointer,  group_pointer is group\r\n(group is group not work)\r\n\r\n\r\n\r\nArithmetic Operators\r\n-3^2 gives 9, 0-3^2 gives -9\r\n+ - = /\r\n^ ** for power\r\nDiv\r\nDiv# (euklidean)\r\nMod\r\nMod# (euklidean)\r\n< > <> <= >= = ==  \r\n<=> (spaceship operator)\r\nOr And Xor Not\r\n(,) empty array\r\n(1,) one item array\r\n(1,2) two item array\r\n\r\nOperators for arithmetic variables (eg A++ as a statement)\r\nFor group properties (not variables) we have to define operators\r\n+=\r\n-=\r\n*=\r\n/= \r\n-!  change sign\r\n~ \\\\ false <-> true\r\n++\r\n--\r\n\r\nOperators for Strings\r\n+\r\n< > <> <= >= =\r\n~ ( like Like in VB6)\r\n<=> (spaceship operator)\r\n\r\n
GR:ΤΕΛΟΣ\r\n\r\nEnd used to end program – and close environment. This can be used in level 0 (CLI). We can use SET END in a module or function. Using END without SET in a module or function is same as BREAK.\r\nThere are two variants for specific use: [END SELECT] and [END SUB]
GR:ΤΕΛΟΣ(\r\nWhile Not Eof(#N) {\r\n    '  do something\r\n}\r\n\r\nReturn true if file cursor pass end of file (E_nd O_f F_ile)
GR:ΤΙΚ\r\nReturn tick for threads. If tick=0 then no thread run\r\ntick advanced from M2000 Task Manager\r\n\r\nuse this for rimer\r\nDECLARE timeGetTime LIB \"winmm.timeGetTime\" {}\r\nfor i=1 to 10 {\r\nPrint  timeGetTime()\r\n}\r\n
GR:ΤΙΜΗ\r\nPick a number from stack, from top of stack, if stack has a number at top or we get an error\r\nUsing Number we use info for one time only, no need for a variable to store before\r\n\r\nDef A()=Number**Number\r\nPrint A(2,4)\r\n\r\nUse Array to get array\r\nPush (1,2,3,4)\r\nPrint Array\r\n\r\nuse Group to get a group\r\nGroup k {\r\n      Value {\r\n            =100\r\n      }\r\n}\r\nPush group(k)\r\nDim a(10)\r\na(1)=Group\r\nPrint a(1)  ' 100\r\n\r\nFor Inventories and stacks we have to use variable or we can get using StackItem() and use Drop to drop from top\r\na=Stack:=1,2,3,4\r\nPrint StackItem()\r\nDrop\r\n\r\nWe can read top item on stack without droping. But this can read objects too\r\nPush (1,2,3,4,5)\r\nPrint StackItem()\r\nor\r\nPrint StackItem(1)\r\n\r\n\r\nUse Match(), StackType$(), Envelope$() to check for types before reading\r\n
GR:ΤΙΜΗ(\r\n1) First Parameter is a String Expression\r\nPrint Val(\"123\")\r\nPrint Val(\"1 2 3\")=123\r\nPrint Val(\"123.233\")\r\nPrint Val(\"123,233\", \",\")\r\nPrint Val(\"123-233\", \"-\")\r\nPrint Val(\"123,233\", 0)\r\nPrint Val(\"123,233\", 1032)\r\nPrint Val(\"123.233\", 1033)\r\n2) First Parameter is a Number Expression\r\n\\\\ use it for type conversions\r\nDef TypeOfExpression$(Ν)=Type$(Ν)\r\nPrint TypeOfExpression$(10)    ' Double\r\nPrint TypeOfExpression$(Val(10->0@))    ' Decimal\r\nPrint TypeOfExpression$(Val(10->0#))    ' Currency\r\nPrint TypeOfExpression$(Val(10->0&))    ' Long\r\nPrint TypeOfExpression$(Val(10@))    ' Double\r\nPrint TypeOfExpression$(Val(10#))    ' Double\r\nPrint TypeOfExpression$(Val(10&))    ' Double\r\nPrint TypeOfExpression$(Val(10#->0@))    ' Decimal\r\nPrint TypeOfExpression$(Val(10&->0@))    ' Decimal\r\nPrint TypeOfExpression$(Val(10@->0#))    ' Currency\r\nPrint TypeOfExpression$(Val(10&->0#))    ' Currency\r\nPrint TypeOfExpression$(Val(10@->0&))    ' Long\r\nPrint TypeOfExpression$(Val(10#->0&))    ' Long\r\n\r\nWe can use names instead  zero+symbol\r\nDecimal, Currency, Double, Single, Long, Boolean\r\nA=Val(B->Boolean)\r\n\r\n3) Return in a third parameter the length of valid numeric characters, from beginning of string, or -1 if not  number not exist\r\nFunction IsNumeric(a$) {\r\n      def m\r\n      =val(false->boolean)\r\n      Try {\r\n            if islet then {\r\n                  z=val(a$,letter$, m)\r\n            } else.if isnum then {\r\n                  z=val(a$,number, m)\r\n            } else z=val(a$,\"\", m)\r\n            =m>len(a$)\r\n      }\r\n}\r\nFunction IsIntegerNumeric(a$) {\r\n      def m\r\n      =val(false->boolean)\r\n      Try {\r\n            z=val(a$,\"Int\", m)\r\n            =m>len(a$)\r\n      }\r\n}\r\nPrint IsIntegerNumeric(\"1221213123213\")=true\r\nPrint IsIntegerNumeric(\"1221213.123213\")=false\r\nPrint isNumeric(\"123131232131231231.23123123\")=true\r\nPrint isNumeric(\"-123131232131231231.23123123e112\")=true\r\nPrint isNumeric(\"-123131232131231231.23123123e112\", \",\")=false\r\nPrint isNumeric(\"-123131232131231231.23123123e112\", 1036)=false\r\nPrint isNumeric(\"-123131232131231231.23123123e112\", 1033)=true\r\nPrint val(\"233.44sec\", 1033)=233.44\r\na$=\"233.44sec\"\r\nm=0\r\nPrint val(a$, 1033, m)=233.44\r\nif m>0 then Print Mid$(a$, m)=\"sec\"\r\n\\\\ any string for decimal point with len >1 cut decimals\r\nPrint val(a$, \"??\", m)=233\r\nif m>0 then Print Mid$(a$, m)=\".44sec\"
GR:ΤΙΜΗΣΩΡΟΥ$(\r\n\r\npush \"alfa\", \"beta\"\r\nprint stackitem$(), stackitem$(2)\r\nbeta      alfa\r\n\r\nstackitem$() is same as stackitem$(1) and is the TOP item on stack.\r\nif we give a wrong position (that isn't exist) we get an error\r\nIf at postition we want to get a string aren't  a string value we get an error.\r\n\r\nUsing Stackitem$() for stack objects\r\na=stack\r\nStack a {\r\n      Data \"alfa\", \"beta\"\r\n}\r\nPrint stackitem$(a), stackitem$(a,2)\r\n\\\\ old stack deleted and variable a point to new stack\r\na=stack:=\"alfa1\", \"beta1\"\r\nPrint stackitem$(a), stackitem$(a,2)\r\nFlush  \\\\ flush current stack\r\nData \"alfa2\", \"beta2\"\r\na=[]   \\\\ a get current stack, and current stack now is empty (use [ ] without space between])\r\nPrint Empty  \\\\ -1 means true\r\nPrint stackitem$(a), stackitem$(a,2)\r\nData \"one more\"  \\\\ to current stack\r\nStack a     \\\\ now a is empty, all data of a pushed  to end of current stack\r\nPrint Len(a)  ' 0\r\nPrint Stack.size ' 3\r\nStack\r\nRead a1$, a2$, a3$\r\nPrint Empty  \\\\ -1 means true\r\na=Stack:=a1$, a2$, a3$\r\nPrint len(a)  ' 3\r\n
GR:ΤΙΜΗΣΩΡΟΥ(\r\n\r\nPush 1,2,3\r\nPrint stackitem(2), stackitem()\r\n2      3\r\n\r\nstackitem(1) is the top item in stack - same as stackitem()\r\nif no value exist at index or no index (index greater than size)  then an error occur\r\n\r\nuse it with DROP and STACK.SIZE  and STACKITEM$()  - for strings- to make frames of parameters on stack.\r\n
GR:ΤΙΤΛΟΣ\r\n\r\nTITLE \"a label for taskbar\",  1 or 0\r\n\r\nby default without second parameter is 1 (showing the form of program)\r\nWith 0 Form is minimized in taskbar.\r\n\r\nTITLE  with no parameters erase the presence in taskbar.\r\n\r\nThe taskbar label is useful because you can utilize Alt Tab, to switch to M2000, and you can perform by the context menu minimize or restore to original size, the form of M2000, without stopping the running of any application.\r\nYou can run a M2000 program without showing UI, because all programs start with minimized option, as a hidden UI, and when they execute a SHOW or need the input of a user then can open the hidden UI (user interface). Dialogues can  open without showing the main form. There is a msgbox for asking for a OK or Cancel, see ASK( and look for Dialogues to see what else you can open, without showing ui.\r\n\r\n\r\nAdditional commands\r\nwith ICON you change the icon of program that showing in taskbar.\r\n\r\n\r\n\r\n\r\n\r\n
GR:ΤΙΤΛΟΣ$(\r\nPrint Title$(\"george karras\")\r\nGeorge Karras
GR:ΤΙΤΛΟΣ.ΑΡΧΕΙΟΥ$(\r\nPRINT  FILE.TITLE$(\"TXT\")
GR:ΤΜΗΜΑ\r\nA module is a basic programming block of commands that can be called by name. Like module we have Functions. Functions are modules that return a value to an expression. So function we can say (but not restricted to that)  called from expressions and modules from line of code or form command line (from console).\r\n\r\nModules have a name with on letter at least. We can put dots.\r\nTo create a module in command line we have to write EDIT nameofmodule\r\nWe can exit from editor with ESC, or Shift+F12 if editor get mad (sometimes using ctrl+z/c/v need to get back the original code, by canceling changes)\r\nWe can create modules in modules.\r\nModules are saved with SAVE command and loaded with LOAD command. Each time we have to give a name. That name is a file name, not a module name.  We can use ctrl+A to save again in same name as the last save. This keystroke has to be deployed in M2000 command line.\r\nWe run a module just using the name of it\r\n\r\nIMPORTANT: A module rule say that everything that created in a module, erased at the end of execution of module.\r\n\r\nSo if we load modules from disk in a module, then those modules erased at the exit from that module.\r\nEvery module can create modules, functions, threads and can store values to variables, arrays and in the special stack.\r\n\r\nModule Decoration\r\nWe can call a module decorated, which means to pass a new definition for an inner module inside module.\r\n\\\\ Decorated modules\r\nGroup a {\r\n      x=100\r\n      module finish (a) {\r\n            .x+=a\r\n            print \"My good finish\", .x\r\n      }\r\n}\r\nmodule beta {\r\n      print \"beta\"\r\n}\r\nmodule alpha (b){\r\n      module finish (x){\r\n            print \"standard finish\", x\r\n      }\r\n      module delta {\r\n            print \"internal delta\"\r\n      }\r\n      print \"ok\", b\r\n      delta\r\n      finish 50\r\n}\r\nprint a.x\r\nalpha 100 ; delta as beta, finish as a.finish\r\nprint a.x\r\nalpha 200\r\nModules ?\r\n\r\nA module use the parent stack always. A function start with own stack. A thread is a part of a module that read same values but has own stack. Stack can hold numbers and strings and for bit of time references to arrays and variables. Variables and Arrays erased as first law says, but not the stack. The top parent is the command line interpreter CLI, as it run in the main thread. Other parents are all other threads and the functions. A recursive function create a new stack in every level of recursion.\r\n\r\nWe can use recursive call in a module using the CALL statement\r\n\r\nA module name is as a namespace for named creations (threads use numbers in variables, so they have no names but handlers). We can change this name for the time of execution only. But when we do that all creations from the old name cannot founded except we use the old name as a prefix.\r\nModule a {\r\n      b=10    ' we create the a.b numeric variable\r\n      module c    ' here we change the name space\r\n      b=20\r\n      print b, a.b  ' we use prefix a as qulifier for the old b value\r\n      b++    ' add one to b\r\n      a.b++  ' add one to a.b\r\n      print b, a.b\r\n      list  ' we see the list of variables\r\n      module a\r\n      list ' we can see the list of variables is the same             \r\n}\r\nNow list print  A.B=11,  A.C=21\r\n\r\nAnother example using weak reference in a string. Inside module C we call A$.B so we know that a B module is calling, but we can change the prefix (but with that prefix a module B must be loaded in the list of modules before). Functions can be called as modules to and can be passed by reference without needing to be loaded, they load in the Read statement.\r\nModule B {\r\n      Read A, B\r\n      Print A*2, B**2\r\n}\r\nModule C {\r\n      Read A$\r\n      A$.B 20\r\n}\r\nC Module$, 20\r\n\r\nHere is a more advanced example\r\nWe use two threads to call the same module so we want to use per thread namespace.\r\nWe pass values to modules writing to Stack. We can write it before we call a module or we can set a frame of values after the name. Those values are written on top of stack but the first become the top of stack.\r\nIn b \"AA\", k we write on top the string \"AA\" and next the value of k. Stack holds values only (we can place references to variables as values too, see the next example)\r\nWe can get the values from stack by using READ but that mean that the variables have a prefix at that time. So We can read the stack by using Letter$ for string and number for number (there is function to ask for what we have, because if we use letter$ and no string is on top of stack then an error happen)\r\nIn b module we only make a variable C and then we print the list of variables (from all modules)\r\n\r\nmodule a {\r\n      module b {\r\n            module letter$\r\n            read c\r\n            list\r\n      }\r\n      k=1\r\n      thread {\r\n            k++\r\n            b \"AA\", k\r\n      } as aa  interval 10\r\n      o=100\r\n      thread {\r\n            o++\r\n            b \"BB\",  o\r\n      } as bb interval 10\r\n      main.task 20 {\r\n            if inkey$<>\"\" then exit\r\n            print o, k\r\n            refresh  ' need that to refresh the screen....\r\n      }\r\n}\r\n\r\n\r\nExample of By Reference Passing to module\r\nWe can place it in a module or in a module in a module\r\n\r\na=10\r\nmodule b {\r\n      read &a\r\n      a++\r\n}\r\nb &a\r\nprint a\r\n\r\n' module in a module\r\nmodule k {\r\n      a=10\r\n      module b {\r\n            read &a\r\n            a++\r\n      }\r\n      b &a\r\n      print a\r\n}\r\nk\r\n\r\n  \r\n  
GR:ΤΜΗΜΑ$\r\n? module$\r\nwe print the module's name (or function) that run in that moment (perhaps we are in a thread...so we now that because we write this code in a thread...)\r\n\r\n 
GR:ΤΜΗΜΑ(\r\nPrint Module(A)\r\nreturn -1 if module A exist
GR:ΤΜΗΜΑΤΑ\r\nMODULES\r\n      print all the modules in memory and in current directory\r\nMODULES !\r\n      print all the modules in memory and then sort by name and print the modules in current directory \r\nMODULES ?\r\n      print all the modules in memory\r\nMODULES ? \"alfa\"\r\n      print all the modules in memory with name start from alfa\r\nMODULES ? \"*alfa\"\r\n      print all the modules in memory with name having alfa\r\nMODULES ? \"\",\"DIM \"\r\n      print all the modules in memory who have DIM in the code\r\nMODULES ? \"*alfa\",\"DIM \"\r\n      print all the modules in memory with name having alfa and have DIM in the code\r\n\r\n\\\\ For searching files we use FILES\r\nFILES \"GSB\", \"PRINT|DIM\"  ' return all files *.gsb with the two words PRINT and DIM\r\n \r\nYou can use any folder to save and load a module. One folder is the USER and by default this is the first folder when we open m2000 without using an execution after we provide a gsb file. When we have call M2000 loading a module from disk, by clicking a gsb, file then the current folder is the folder of that file. So if we have some modules as libraries (we can load when a program run) we have to change to USER directory (it is the directory that open for a user, so in the same computer but another user we have other USER folder)\r\n\r\nUse this to change to the user directory\r\nDIR USER  \r\nUse this to open the user directory  with explorer\r\nWIN DIR$\r\nSo you can move or delete modules by using explorer. 
GR:ΤΟΝΟΣ\r\n\r\nNot for simulator, but in a real Windows Machine.\r\n1) Tone     play 1khz for 1/10 of a second\r\n2) Tone 200 play 1khz for 0,2 of a seconf\r\n3) Tone 200, 5000 play 5khz for 0,2 of a second\r\nTone is generated from hardware and Windows Kernel stop any service for threads in M2000.\r\nSo this command aren't suitable for thread programming\r\n\r\n\r\nModule A {Module AA {\r\nFor i=1 To 10 {\r\nTone 50, 150\r\nTone 25, 300\r\n}\r\n}\r\nFor i=1 To 5 {\r\nAA\r\nWait 200\r\nAA\r\nWait 800\r\n}\r\n}\r\nModule B {For i = 1 To 10 {\r\nTUNE \"cac \"\r\nWait 200\r\n}\r\n} \r\nModule C {For i=100 To 8000 Step 20 {\r\nTone 2,i   'play \r\n}\r\n}\r\n\r\n\r\n\r\nCheck a thread (copy to a module)\r\nI=0\r\nTHREAD {\r\nPRINT I\r\nI=I+1\r\n} AS L INTERVAL 40\r\nWAIT 1000\r\nTONE 1000,3000\r\nWAIT 1000\r\n
GR:ΤΟΞ.ΕΦ(\r\n\r\nPrint Tan(45)\r\nPrint Atn(1)  ' degrees\r\n
GR:ΤΟΠΙΚΗ\r\n1) Local make new variables always. In a block of code For This { } any new definitions lost after the end of block execution, so local variables with same name using Local used to shadow old values. \r\n\r\nExample:\r\nLet X=4, Y=5\r\nFor This {\r\n      Local X=10, Y=30\r\n      a()\r\n}\r\na()\r\nEnd\r\nSub a()\r\n      Print X, Y\r\nEnd Sub\r\n\r\n\\Example 2 - We can define arrays too\r\nLocal a(10)=1  \\\\ in group defintions Local is added to command, so there we use Local Dim a(10)=1\r\nPrint a(3)\r\n\r\n2) In a group local do something else. Look example\r\n\\\\ we don't need to use a Class function to make a Group. We can do this with Group command\r\n\\\\ We can make Local arrays, modules and functions. This command is interpreted in Group definitions only\r\n\\\\ A class definition is a group defintion, in a function which return a group.\r\nGroup Alfa {\r\n      Local X=10\r\n      Local Dim M(3)=1\r\n      Z=3\r\n}\r\nAlfa.M(2)=1000\r\nAlfa.X++\r\nPrint Alfa.X, Alfa.M(2)  \\\\ 11  1000\r\nPush &Alfa   \\\\ send weak reference to stack\r\nRead &Beta  \\\\ make Beta a reference to Alfa but excluding Local variables and arrays (or functions and modules)\r\nPrint Valid(Beta.X), Valid(Beta.M(2))  \\\\ local variables are not included in a reference\r\n\\\\ but using a weak reference we can\r\nA$=weak$(Alfa.X)\r\nPrint Eval(A$.)  \\\\ this is an evaluation of a weak reference - see dot after $\r\n\\\\ using weak reference we ca use group like it is a global\r\nModule Inside {\r\n      Read A$\r\n      Print format$(\"Inside {0}\",Eval(A$.X))\r\n}\r\nInside weak$(Alfa)\r\nTheta=Alfa  \\\\ local variables included in a copy, but with start values\r\nPrint valid(Theta.X), Theta.X, Theta.M(2)\r\nDim A(10)\r\nA(0)=Alfa \\\\ local variables are immutable in array items\r\nAlfa.X+=20\r\nPrint Alfa.X   \\\\ 31\r\nA(0).X+=20   \\\\ can change only in the opening of float group in A(0)\r\nPrint A(0).X   \\\\ 10\r\nFor A(0) {\r\n      .X+=20\r\n      Print .X  \\\\ 30 because A(0) is in opening state\r\n      Inside &This  \\\\ we call Inside wih weak reference of this, which is the open group from A(0)\r\n}  \\\\ now open group is closed to A(0), so X next time gets the default value 10\r\nPrint A(0).X  \\\\ every time we open A(0) X get the original value
GR:ΤΟΠΙΚΟ\r\nLocale localeID\r\nLocal \";\\Y\\e\\s;\\N\\o\"   ' set boolean values\r\nLocal \"\" ' reset boolean values to original values.\r\nthis is a setting for some functions, not for the screen or file or the system locale.\r\nchr$() can give us the unicode code from any ANSI code based on locale.\r\n\r\nWe can set a global Locale ID or we can use in place: Print chr$(249,1037) \r\n\r\nThis global setting affect \r\nAll of this functions return strings\r\nThese return the unicode representation\r\n      CHR$(ansi number) , CHR$(ansistring, 0),  Ucase$(ansistring,0),  Lcase$(ansistring, 0)\r\nThis make an ansistring  (one ANSI char per 2 bytes)\r\n      STR$(string to convert, 0)\r\nWe can convert to 1 byte char (so in any 2 bytes we have 2 ansi chars) by using STR$(string) and we do the reverse by using CHR$(string). \r\nBut  these commands work with system locale. So we need to make first an ansistring and then we can compact it to a real ansi string with str$(). So this A$=Str$(Str$(\"Ελληνικά\", 1032)) make an Ansi string that we can do the reverse in any system locale by using this:\r\n? chr$(chr$(A$), 1032)\r\nthe inner CHR$() make the 4 chars 8 chars with chars with values below 256. The outer take the ansi code and replace with the UTF16LE code (as used by Windows).\r\nIf we want to feed an open file using an other locale, say 1049, and we wish to use the ansi version of OPEN command, we can prepare each string with STR$(string2put, 1049)  as export$, and the system do a hidden Str$(export$). When we read from file a hidden Chr$(import$) give as a value and we have to do a CHR$(export$,1049) to get the right string.\r\nIf we wish we can use WIDE in the OPEN command and then we can write and read mix chars from any set, as Unicode UTF-16LE.\r\nThis is an example of how to print a charset from a locale\r\nlocale 1055\r\nfor i=33 to 255 {\r\nprint chr$(i);\r\n}\r\nprint\r\n\r\n' or we can use directly the locale id\r\nfor i=33 to 255 {\r\nprint chr$(i,1037);\r\n}\r\nprint
GR:ΤΟΠΙΚΟ$(\r\nForm 60, 30\r\nDouble\r\nPrint \"Example 1.0\"\r\nNormal\r\nScroll Split 2  ' or use Cls, 2  to clear screen too\r\nLocale 1033 ' use 1032 for Greek\r\nFor i=0 to 255 {\r\n      If Locale$(i)<>\"\" then {\r\n            \\\\ report stop after 3/4 of screen lines printed (lines from low part of split screen)\r\n            Report format$(\"{0::-3}. Locale$(0x{1})={2}\", i, hex$(i,1),Quote$(Locale$(i)))\r\n      }\r\n}
GR:ΤΟΠΙΚΟ(\r\n1) Get language id from  letters\r\nPrint Locale(\"ΓΑΒ\")\r\n      1032\r\n2) Check against an id\r\nPrint Locale(\"ΓΑΒ\",1032)\r\n      -1\r\nPrint Locale(\"ΓΑΒ\",1033)\r\n      0\r\n
GR:ΤΟΠΟΣ$(\r\n\\\\ Return path from special folders in Windows\r\nGlobal Const CSIDL_ADMINTOOLS  = 0x30\r\nGlobal Const  CSIDL_ALTSTARTUP  = 0x1D\r\nGlobal Const  CSIDL_APPDATA  = 0x1A\r\nGlobal Const  CSIDL_BITBUCKET  = 0xA\r\nGlobal Const  CSIDL_COMMON_ADMINTOOLS  = 0x2F\r\nGlobal Const  CSIDL_COMMON_ALTSTARTUP  = 0x1E\r\nGlobal Const  CSIDL_COMMON_APPDATA  = 0x23\r\nGlobal Const  CSIDL_COMMON_DESKTOPDIRECTORY  = 0x19\r\nGlobal Const  CSIDL_COMMON_DOCUMENTS  = 0x2E\r\nGlobal Const  CSIDL_COMMON_FAVORITES  = 0x1F\r\nGlobal Const  CSIDL_COMMON_PROGRAMS  = 0x17\r\nGlobal Const  CSIDL_COMMON_STARTMENU  = 0x16\r\nGlobal Const  CSIDL_COMMON_STARTUP  = 0x18\r\nGlobal Const  CSIDL_COMMON_TEMPLATES  = 0x2D\r\nGlobal Const  CSIDL_CONNECTIONS  = 0x31\r\nGlobal Const  CSIDL_CONTROLS  = 0x3\r\nGlobal Const  CSIDL_COOKIES  = 0x21\r\nGlobal Const  CSIDL_DESKTOP  = 0x0\r\nGlobal Const  CSIDL_DESKTOPDIRECTORY  = 0x10\r\nGlobal Const  CSIDL_DRIVES  = 0x11\r\nGlobal Const  CSIDL_FAVORITES  = 0x6\r\nGlobal Const  CSIDL_FONTS  = 0x14\r\nGlobal Const  CSIDL_HISTORY  = 0x22\r\nGlobal Const  CSIDL_INTERNET  = 0x1\r\nGlobal Const  CSIDL_INTERNET_CACHE  = 0x20\r\nGlobal Const  CSIDL_LOCAL_APPDATA  = 0x1C\r\nGlobal Const  CSIDL_MYPICTURES  = 0x27\r\nGlobal Const  CSIDL_NETHOOD  = 0x13\r\nGlobal Const  CSIDL_NETWORK  = 0x12\r\nGlobal Const  CSIDL_PERSONAL  = 0x5   ' My Documents\r\nGlobal Const  CSIDL_MY_DOCUMENTS  = 0x5\r\nGlobal Const  CSIDL_PRINTERS  = 0x4\r\nGlobal Const  CSIDL_PRINTHOOD  = 0x1B\r\nGlobal Const  CSIDL_PROFILE  = 0x28\r\nGlobal Const  CSIDL_PROGRAM_FILES  = 0x26\r\nGlobal Const  CSIDL_PROGRAM_FILES_COMMON  = 0x2B\r\nGlobal Const  CSIDL_PROGRAM_FILES_COMMONX86  = 0x2C\r\nGlobal Const  CSIDL_PROGRAM_FILESX86  = 0x2A\r\nGlobal Const  CSIDL_PROGRAMS  = 0x2\r\nGlobal Const  CSIDL_RECENT  = 0x8\r\nGlobal Const  CSIDL_SENDTO  = 0x9\r\nGlobal Const  CSIDL_STARTMENU  = 0xB\r\nGlobal Const  CSIDL_STARTUP  = 0x7\r\nGlobal Const  CSIDL_SYSTEM  = 0x25\r\nGlobal Const  CSIDL_SYSTEMX86  = 0x29\r\nGlobal Const  CSIDL_TEMPLATES  = 0x15\r\nGlobal Const  CSIDL_WINDOWS  = 0x24\r\nList\r\nPrint Path$(CSIDL_PROGRAM_FILES)\r\n\r\n\r\n
GR:ΤΟΠΟΣ.ΑΡΧΕΙΟΥ$(\r\nReturn path only from full path plus name plus type extension and maybe some switches after.\r\n
GR:ΤΟΤΕ\r\n\r\n\r\nLook If
GR:ΤΡΑΠ(\r\nBanker's Rounding Same as Round() in Vb6
GR:ΤΥΠΟΣ\r\n 1) MODE sizeofFont, screenwidth, screenheight\r\n 2) MODE sizeofFont, screenwidth\r\n 3) MODE sizeofFont\r\n\r\nUse scale.x and scale.y to read the screen size (also you can read printer, background and layers dimensions using proper structure, see BACKGROUND, PRINTER and LAYER)\r\nYou can use FORM to automatic adjust char resolution. Only type 3 can be used in Layers (the other must be used with WINDOW command.\r\nAs we see there are 3  commands for alter the screen.\r\nMODE  ' change font size, and in screen set the screen inside background\r\nWINDOW ' change background font size and window size. For layers also change the size, and the font size\r\nFORM ' this is a command that alter automatic the font size to the resolution we choose.\r\n\r\nMode suspend the TARGETS system (see TARGET), but not erase them. Use TARGETS NEW or START to clear TARGETS.\r\n\r\n
GR:ΤΥΠΟΣ$(\r\n\r\na=10\r\nb=(1,2,3,4)\r\nPrint Type$(a), Type$(b)   ' double  mArray
GR:ΤΥΠΟΣ.ΑΡΧΕΙΟΥ$(\r\n\r\nreturn extension letters from a file (remove path and name and maybe some parameters after)\r\n
GR:ΤΥΠΟΣ_μεταβλητή\r\n\r\nReturn Mode (height of frame of a line of text) in pt  (12 pt is 1/72 of logical inch, a logical inch is 1440 twips, so 1440/72 twips are 12pt)\r\nso 12 pt is equal to 1440/72*12=240 twips
GR:ΤΥΠΩΣΕ\r\n1) use ? for PRINT\r\nPRINT  1,2 3\r\nwe can print numbers, strings or results form expressions\r\nprint $(0,6)    ' 6 CHAR COLUMN \r\na=5\r\nc=100\r\nb$=\"A\"\r\nprint a=5 and c>2, 100, \"a\">b$\r\n      -1      100      -1\r\n2)A special PRINT is HEX to convert decimal to hex (negative values show ???, only unsigned)\r\nHEX 1,2,3 \r\nwe can write 0xFFFF as a hex number\r\nHEX 0xAA + 0xFF\r\n            0x01A9\r\n3) Print to open file\r\n      Using filename \"\" in Open for Output we send output to screen\r\n      included no separation spaces so we can place ,\" \", or any other char\r\n      PRINT #F, A, B$\r\n      Insert Newline : (2 chars)\r\n      Print #F \r\n      \r\n      use WRITE #F to write strings in \"\" and  insert \",\" after each print item except last\r\n      we can use INPUT #F to get from WRITE #F\r\n      and LINE INPUT #F to get from PRINT #F\r\n4) Print to a Layer\r\n      LAYER 1 {\r\n            PRINT \"alfa\"\r\n      }\r\n5) Print to Background\r\n      BACKGROUND {\r\n                  print \"alfa\"\r\n            }\r\n6) Print to Printer\r\n            PRINTER {\r\n                  print \"alfa\"\r\n            }\r\n7) Use @() internal operator\r\n      Print @(10,10), \"Print at 10,10\"\r\n      print @(10,10,18,11), \"Hello there\"\r\n      @( has a lot of functions. Used to prepare the background for specific item. Print prints transparent. So if we need background or because we need to overwrite, then we use  @( . Also we can put bitmaps with that function in a place defined by character positions.\r\n@(X,Y)\r\n@(X,Y, XlowerRightCorner,YlowerRightCorner, BackColor)\r\n@(X,Y, XlowerRightCorner,YlowerRightCorner, BackColor, Outlinecolor)  'we can make boxes with printing data\r\n@(X,Y, XlowerRightCorner,YlowerRightCorner, BitmapOrFilename$)   ' fill width an image...stretching it to fill the area\r\n@(X,Y, XlowerRightCorner,YlowerRightCorner, BitmapOrFilename$,  1)  ' last parameter says \"keep aspect ratio of image\"\r\n\r\n8) Use $() internal operator to format item and to the output way ( with or withoit proportional text, and the justification, left, right, center or spread to other column). For proportional text we can use REPORT which have left and right justification and can calculate lines before actually print, and print starting form any line,  the lines we want. So Print can be used for multi column printing of items, but for items that didn't need multi lines.\r\n$(ColumnSJustifyID) \r\n$(ColumnSJustifyID, ColumnSWidth)\r\n$(StringWay2format$)\r\n$(StringWay2format$ , ColumnSWidth) \r\n\r\nmodes from 0 to 8\r\nFor numbers and logic expressions \r\n0 = right, 1 = left, 2 = center, 3 = right  - All of these using  one character width for all letters\r\n4 = right, 5 = left, 6 = center, 7,8 = left  - All of these using  each character own width and kerning\r\n\r\nFor strings\r\n0 = right, 1 = right, 2 = center, 3 = left  -  All of these using  one character width for all letters  \r\n4 = right, 5 = right, 6 = center, 7 = left , 8 =  left and right  both -  All of these using  each character own width and kerning\r\nFor 0 and 4 strings can overwrite next column(s) and advance the cursor to the next one\r\n\r\n\r\n? $(\"00000\",5),1,2,34,5  ' we can print code numbers\r\n00001000020003400005\r\n\r\nSpecial chars for StringWay2format$, f      or strings\r\n      1)@   \r\n      char from item to print or space - justify right\r\n      2)&\r\n      char form item or nothing\r\n      3)<\r\n      lcase (using system locale)\r\n      4)>\r\n      ucase (using system locale)\r\n      5)!\r\n      justify left\r\n      print $(\"@@@@@\"),\"aa\";$(\"!@@@@@@@@@ok\"),\"George\";     ' need ; to use that mode\r\n? $(0) return to normal   \r\nFor numbers   \r\n      1)0\r\n            0 or number\r\n      2)#\r\n           number or nothing \r\n      3).\r\n          dot position\r\n      4)%\r\n           multiply by 100 and writing with a % at the end\r\n      5),\r\n            thousands delimiter\r\n      6) E- E+ e- e+\r\n          using in scientific notation (we can write numbers with scientific notation)\r\n          \r\n          For date - time\r\n                  1):\r\n                   for time\r\n                  2)/\r\n                  for day \r\n                  3)c\r\n                  give the natural writing date and time\r\n                  ? $(\"c\"), today\r\n                  ? $(\"c\"), now\r\n                  4)d\r\n                  day only without space in the left (1 - 31)\r\n                  5)dd\r\n                  as 4 but with 0 in the left  (01 - 31)\r\n                  6)ddd\r\n                  3 letters of day\r\n                  7)dddd\r\n                  name of day  (using system locale)\r\n                  8)ddddd\r\n                  full day description\r\n                  9)w\r\n                  print number of day, 1 for Sunday\r\n                  10)ww\r\n                  week number (1-54)\r\n                  11)m\r\n                  month number  (1 -12)\r\n                  12)mm\r\n                  as 11 but with 0 if needed  (01-12)\r\n                  13)mmm\r\n                  name of the month, three letters\r\n                  14)mmmm\r\n                  name of the month      \r\n                  15)q\r\n                  quorter of the year  (1-4)\r\n                  16)y\r\n                  day of the year as number (1-366)\r\n                  17)yy\r\n                  2 digits for year (00-99)\r\n                  18)yyyy\r\n                  number of year (100 -99990\r\n                  19)h\r\n                  hour without left space (0 - 23)\r\n                  20)hh\r\n                  like 19 but with 0 left (00 - 23)\r\n                  21)n\r\n                  minutes with space left (0 - 59)\r\n                  22)nn\r\n                  like 21 but with 0 as left char, if needed(00 - 59)\r\n                  23)s\r\n                  Seconds with no space left (0 - 59)\r\n                  24)ss\r\n                  As 23 but with zero at left if needed (00 - 59)\r\n                  25)ttttt\r\n                  Time full description\r\n                  26)AM/PM\r\n                   12 hour time (ucase)\r\n                  27)am/pm\r\n                  12 hour time (lcase)\r\n                  28)A/P\r\n                  like 26 but one letter only\r\n                  29)AMPM\r\n                  using defaul values for time format  from Windows\r\n\r\n9) Scrolling\r\nIf we print in the bottom line then scrolling happen, except we use Print Part and Print Under (one row before).\r\nWe can use SCROLL UP,  SCROLL DOWN and SCROLL SPLIT number. The first two used to scroll up or down without printing, and the last one to define an upper part of screen that can not scroll. This is the same as CLS 1,number without clearing the screen as CLS does.\r\n\r\n10) Moving the cursor.\r\nCursor is hidden. But we can use @() to move it as we print or we can use CURSOR command\r\n\r\n11) Break line\r\n      11.1)  without parameter is a New Line\r\n            Print \r\n      11.2) two comma is a new line, three is two new lines, four is three....\r\n            Print ,,,   we give 2 new lines\r\n            Print 1,2,,3,4  we print\r\n                  1      2\r\n                  3      4\r\n      11.3) Print without using tab stop\r\nPrint \"alfa\";\"beta\"    \r\nalfabeta     \r\n12) Using ; as last thing in the print to hold the new line.\r\n          print \"X=\";\r\n\r\nNew additions in version 8\r\n13) Print Over  $(6),\"Center proportional text\"   \\\\ clear background in all width, set one column only, leave a thin line under, \r\n                                                                                         \\\\ no new line, no column wrap\r\n14) Print Part \"ok\", 1         \\\\ no new line, no column wrap\r\n15) Print Under     \"Under a line\"     \\\\ draw a horizontal line in current row, change row and do as Print Part.\r\n16) Print ~(#FFAA33), \"Color\"            \\\\New internal operator ~() \r\n17) Print Back 1,2,3  \\\\ Clear background for this line, and maybe more if needed\r\n18) Print #-2, format$(\"Hello\\n\\there\\t100\\t500\\6000\")\r\nOpen \"\" For Output as #F    ' F turn to -2\r\nPrint  #F, format$(\"Hello\\n\\there\\t100\\t500\\6000\")\r\nClose #F\r\n     \r\nExample  #1   \r\n     \r\ndim bb(20)\r\nl$={multi line string\r\n      this is other \"paragraph\"\r\n      this is { inside multiline string}\r\n}\r\nprint l$ ' wrong way\r\nreport l$ ' this is nice\r\nk$={print dimension(\"bb\"), dimension(bb()      )}\r\n      print k$\r\n      print dimension(\"bb\"), dimension(bb())\r\n      dim bb(10,1)\r\n      i= dimension(\"bb\")\r\n      oldtab= tab\r\n      print \"bb() dimensions=\";i\r\nfor j=1 to i {\r\n      print $(3,7),j,$(1,1), \".\",$(3,8), dimension(bb(),j)  ' $(3,7) justify right non proportional printing 7 chars column, next 1 char column,  next 8 char column...\r\n}\r\nprint $(0,oldtab)\r\n\r\n\r\nExample #2\r\nFlush\r\nj=3  \\\\ from version 8 we have 4 chars minimum column\r\nForm 80,32\r\nRepeat {\r\n      j=j+1\r\n      Cls\r\n      Print \"Example for types of Print, Column:\";j;\" charcters\";\r\n      Cursor 0,Row+1\r\n      Data 0,1,2,3,4,5,6,7, 8\r\n      Repeat  {\r\n            Read i\r\n            Print $(I,j),145355,\"George Karras\", \"The Best\",\r\n            Cursor 0,Row+1\r\n      } Until Empty\r\n      Cursor 0,Row+1\r\n      Print $(0);\"press any key\"\r\n      a$=Key$\r\n} Until j=25\r\nPrint
GR:ΤΥΧΑΙΟΣ\r\n\r\nPrint Rnd  \\\\ return a number >=0 and <1
GR:ΤΥΧΑΙΟΣ(\r\nPrint Random(1,10)  \\\\ a number >=1 and  <=10\r\nPrint Rnd   \\\\ a number <1 and >=0\r\nX=Random(!12345) \\\\ set generator to specific point and push old seed in one level stack\r\n\r\nExample\r\nForm 60,40\r\n\\\\ first we see 6 random numbers from specific seed\r\nx=random(!1234)\r\nPrint rnd, rnd, rnd\r\nPrint rnd, rnd, rnd  \\\\ look second line\r\n\\\\ now we reset the seed\r\nx=random(!1234) \\\\ push seed  - only one level for pushing seed\r\nPush rnd, rnd, rnd  \r\nDrop 3  \\\\ drop three values from stack\r\n\\\\ now we break the seed using a new one\r\nx=random(!2341) \\\\ push seed  \r\nPrint rnd, rnd, rnd\r\nx=random(!)  \\\\ pop old seed \r\nPrint rnd, rnd, rnd  \\\\ here are the same as second line
GR:ΤΩΡΑ\r\nPrint Time$(NOW)\r\nPrint Str$(Now, \"hh:mm AMPM\")\r\na=Now+Today ' (time is the fraction, and date is the integer part)
GR:Υ.ΣΗΜΕΙΑ\r\nReturn Layer/Main/Background width size in twips\r\nsame as Scale.Y
GR:ΥΠΑΡΧΕΙ(\r\n1) Using a string expression as parameter\r\nIF EXIST(\"C:\\AUTOEXEC.BAT\") THEN PRINT \"OK\"\r\n\r\n2) Using an object as first parameter, search an inventory using hash table\r\nInventory alfa=1, 2:=200,\"beta\":=1000, \"100\":=\"ok\"\r\nPrint alfa\r\nIf Exist(alfa, 2) Then Print Eval$(alfa), Eval(alfa)\r\nIf Exist(alfa, 1) Then Print Eval$(alfa)\r\nIf Exist(alfa, 100) Then Print Eval$(alfa)\r\nIf Exist(alfa, \"100\") Then Print Eval$(alfa)\r\n\r\nWithout search maybe we get error\r\nPrint alfa$(\"100\") ' ok\r\nPrint alfa(500) ' error\r\n\r\n3)using third parameter to find same keys (for queue type of inventory)\r\na=queue:=1,2:=\"2A\",2:=\"2B\",3,4:=\"4A\",4:=\"4B\",5, 2:=\"3B\"\r\nm=each(a)\r\n\\\\ $(4) for using proportional printing\r\nPrint $(4),\"value as string\", @(tab(2)),\"position - 0 based\", @(tab(4)),\"key as string in quote\"\r\nPrint $(0),\r\n\r\nWhile m {\r\n      Print eval$(m), @(tab(2)), eval(m!),@(tab(4)),quote$(eval$(m, m^))\r\n}\r\n\\\\ new optional parameter for Exist() function\r\n\\\\ with parameter 0 we get the number of items with same key\r\nPrint exist(a,2, 0)=3 ' true\r\n\\\\ using positive we get the 1st for 1\r\nIf exist(a,2,1) Then Print eval$(a)=\"2A\"  ' true\r\n\\\\ using negative we get last for -1\r\nIf exist(a,2,-3) Then Print eval$(a)=\"2A\"  ' true\r\n\r\nPrint exist(a,4,0)=2\r\n\\\\ we can iterate same keys using a for loop, and the exist with the third parameter\r\nfor i=-exist(a,4,0) to -1 \r\n      if exist(a,4, i) then Print eval$(a),  ' we get 4A 4B\r\nnext i\r\nPrint\r\n\r\n
GR:ΥΠΑΡΧΕΙ.ΚΑΤΑΛΟΓΟΣ(\r\nPrint Exist.Dir(\"d:\")\r\n0 if we don't have a CD on d:\r\n-1 if we have.\r\nLook Drive$()\r\n\r\n\r\n
GR:ΥΠΕΡΚΛΑΣΗ\r\nA Superclass can bind to any object, but any object (group)can hold one reference for Superclass.\r\nBecause a group may have any number of groups inside, we can give superclass for each. See the second example\r\n\r\nSuperclass Alpha {\r\n      Unique:\r\n            x, y\r\n            Dim A(20)\r\n      Public:\r\n      \\\\ k created for superclass and for object (two different things, two differnet values)\r\n            k=10\r\n            Module DisplayInfo {\r\n                  For Superclass, This {\r\n                        .k++\r\n                        \\\\ in one prin we can handle k from superclass and k from object.\r\n                        Print .k, ..k\r\n                        \\\\  .x and .y are unique here\r\n                        .x++\r\n                        Print .x, .y\r\n                         \\\\ Here we print arrays (only from Superclass, because we deFine it in Unique part)\r\n                        Print .A()\r\n                  }\r\n            }\r\n}\r\n\\\\ there is no Alpha.DisplayInfo, or other value. Alpha is closed, only can create/merge other objects (groups)\r\nk=Alpha\r\nk.DisplayInfo\r\nClass Delta {\r\n      Property ReadOnly {Value} = 1234321\r\n      Module Delta (This) {}\r\n}\r\nm=Delta(Alpha)\r\nm.DisplayInfo\r\nPrint m.ReadOnly\r\n\\\\ here Array A() has a special holder for all items (are groups), for code only.\r\n\\\\ because all Delta() get Alpha as SuperClass (merged to This in constructor)\r\n\\\\ all have SuperClass common variables/arrays through a dedicated pointer\r\n\\\\ so we can export this array, and return from this block (maybe a module)\r\n\\\\ and Alpha erased, but not data if there are objects who hold pointer to them\r\nDim A(100)=Delta(Alpha)\r\nA(4).DisplayInfo\r\n\r\nThis is the second example.\r\n\r\nSuperclass Kappa1 {\r\n      x=10\r\n      Module Display {\r\n            For Superclass {\r\n                  .x++\r\n                  Print .x, This.x\r\n            }\r\n      }\r\n}\r\nSuperclass Kappa2 {\r\n      x=50\r\n            Module Display {\r\n            For Superclass {\r\n                  .x++\r\n                  Print .x, This.x\r\n            }\r\n      }\r\n}\r\n\\\\ we can create groups using Group command\r\nGroup Alfa {\r\n      Group Beta {\r\n            \\\\ no definitions yet we get from superclass\r\n      }\r\n}\r\n\\\\ first we bind superclass for each group.\r\nAlfa.Beta=Kappa2\r\nAlfa=Kappa1\r\n\\\\ now we have two superclass, one for outer group, and one for inner group\r\nAlfa.Display            \\\\ 11 10\r\nAlfa.Beta.Display   \\\\ 51 50\r\n\r\nZ=Alfa\r\n\r\nZ.Display                 \\\\ 12 10\r\nZ.Beta.Display        \\\\ 52 50\r\nAlfa.Display            \\\\ 13 10\r\nAlfa.Beta.Display   \\\\ 53 50\r\n\r\nDim A(10)\r\nA(3)=Z\r\nA(3).Display           \\\\ 14 10\r\nA(3).Beta.Display  \\\\ 54 50\r\n\r\nInventory Inv1 = 100:=Z\r\n\\\\ keys for inventories are strings, but we can handle like numbers if they are like numbers\r\nInv1(\"100\").Display      \\\\ 15 10\r\nInv1(100).Beta.Display  \\\\ 55 50
GR:ΥΠΜΕΡ(\r\na_day_as_number=cdate(a_day_as_number, +-years, +-months, +-days)\r\n\r\nA=today\r\nPrint date$(cdate(A, 0,4,0))  \\\\ 4 months later\r\nPrint date$(cdate(A, 0,0,100))  \\\\ 100 days later\r\nPrint date$(cdate(A, 0,0,-1))  \\\\ yesterday
GR:ΥΠΟΚΑΤΑΛΟΓΟΣ\r\nTry {\r\n      SUBDIR ALFA\r\n}\r\nDIR  ALFA\r\n\r\nCreate ALFA if not exist, and then  we set ALFA as current Directory.\r\n
GR:ΥΠΟΛ\r\nPrint 13 mod 3\r\n1\r\nPrint 13.5 mod 3\r\n1.5
GR:ΥΠΟΛ#\r\nEuclidean modulo\r\n\r\na=-20\r\nb=6\r\n\\\\ Euclidean\r\nc=a div# b\r\nd=a mod# b\r\nPrint c, d  ' -4   4\r\nPrint a=b*c+d\r\n\\\\ normal\r\nc=a div b\r\nd=a mod b\r\nPrint c, d ' -3  -2\r\nPrint a=b*c+d
GR:ΥΠΟΛΟΓΙΣΤΗΣ$\r\n\r\nPrint Computer$\r\n\r\nprints Computer Name\r\n
GR:ΥΠΟΜΝΗΜΑ\r\nused in TABLE command
GR:ΥΠΩΡΑ(\r\na=now+today\r\nb1=CTIME(a,0,100,0)  ' 100 minutes later\r\nb2=CTIME(a,100,0,0)  ' 100 hours later\r\nPrint Str$(a,\"yyyy-mm-dd hh:nn:ss\")\r\nPrint Str$(b1,\"yyyy-mm-dd hh:nn:ss\")\r\nPrint Str$(b2,\"yyyy-mm-dd hh:nn:ss\")
GR:ΥΨΟΣ\r\nReturn number of rows in a layer, or in console's form, or in background form\r\n
GR:ΥΨΟΣ.ΣΗΜΕΙΟΥ\r\nTWIPSY\r\ntwips per pixel for screen only\r\nso we can use multiplies of twipsY  for drawing pixels.\r\nwe can draw 10 pixel UP\r\ndraw 0, -twipsY*10\r\n\r\nwe can display the pixels height of our display form\r\nPrint scale.y/twipsy
GR:ΦΑΚΕΛΟΣ$(\r\n\r\n1) print envelope$()\r\nprint a string with stack items as N or S depends of type of each. \r\n\r\nLetters can be [N]umber, [G]roup, [E]vent, [B]uffer, [I]nventory, [A]rray, [F]unction, [S]tring, Sta[C]k\r\n\r\n      - a variable reference is a string that hold the variable expanded name \r\n            chek this:\r\n                  a=10 : push &a, &a\r\n                  read expanded_name$, &b\r\n                  print expanded_name$, b\r\n\r\n2) print envelope$(a$)\r\n\\\\  flush the stack to see example\r\nflush \r\na$=stack$(1,2,5-3,\"alfa\", str$(123,\"\"),  str$(123), str$(today,\"dddd YYYY MMMM\")\r\nprint envelope$(a$)\r\n\\\\ now we place 2 numbers from a$ to stack \r\nstack a$, \"NN\"\r\nprint envelope$(a$)\r\nprint envelope$()\r\nstack\r\n\r\nTo find types on a stack object we have to make it  temporary as  the current stack\r\na=stack:=1,2,3,4\r\nStack a {\r\n      Print Envelope$()\r\n}\r\n 
GR:ΦΑΝΕΡΟ$(\r\nReturn a hidden message produced from Hide$()\r\nUse a string, a key as string and a value \r\n\r\nLook HIDE$()
GR:ΦΑΡΔΙΑ\r\nWe can use BOLD for output to Screen / Layers, Background and Printer\r\n1)\r\nBOLD : PRINT \"BOLD TYPE\" : BOLD\r\n\r\n2)\r\nBOLD 1\r\n' any print type as bold\r\nBOLD 0
GR:ΦΕΡΕ\r\n\r\n1) SHIFT 5\r\n2) SHIFT\r\n3) SHIFT N, M\r\n\r\nshift 5th stack item (1st is in position 1, this is the top item)\r\n2nd variation is same as SHIFT STACK.SIZE\r\n3rd from N, M items\r\n4\r\nFLUSH\r\n\\*  we use in this example the FIFO (all items make a stack that join to the bottom of the stack, but now stack is empty)\r\nDATA 1,2,3,4,5   \r\nSHIFT 3\r\n\\* we use stack to display the stack\r\nSTACK \r\n      3 1 2 4 5\r\n\r\n\\* use SHIFTBACK 3 to place the top item to the third place\r\nSHIFTBACK 3\r\nSTACK\r\n\r\n\\* In this example we push some items (we can push numbers or letters -strings-)\r\n\\* and we change the value of third item\r\nflush\r\npush 1, \"alfa\", 3,\"beta\"\r\nstack\r\nshift 3 : push number+2: shiftback 3\r\nprint stackitem(3)\r\n\r\n\\\\Simple example\r\ndata 1,2,3,4,5\r\nstack\r\nshift 3,3\r\nstack\r\nshiftback 3,3\r\nstack\r\nflush\r\n\r\n\r\nA module in a module has same stack so we can make \"stack commands\" as modules\r\nuse DROP OVER SHIFT SHIFTBACK\r\n\r\nmodule swaptop {\r\n      shift 2\r\n}\r\nmodule Dup {\r\n      over\r\n}\r\nmodule Dup2 {\r\n      over 2 : over 2\r\n}\r\nModule DupN {\r\n      read N\r\n      for i=1 to N { over N}\r\n}
GR:ΦΕΡΕΠΙΣΩ\r\n\r\n1) SHIFTBACK 5\r\n2) SHIFTBACK\r\n3) SHIFTBACK N, M\r\nShift top to 5th position in the stack (if we have less items then an error occur)\r\nThe second case is equal with SHIFTBACK STACK.SIZE and make top item as bottom item\r\nThird case: Shift from top M items to N\r\nLook SHIFT, OVER, DROP, STACKITEM(), STACKITEM$(), \r\n      NUMBER, LETTER$, ISNUM, ISLET, EMPTY, FLUSH, STACK\r\n      \r\n
GR:ΦΘΙΝΟΥΣΑ\r\nused in ORDER and SORT commands\r\n
GR:ΦΙΛΤΡΟ$(\r\n? FILTER$(\"ABCDEFGH\", \"BCF\")\r\nADEGH\r\n\r\nExclude chars in second string from first string.\r\n\r\n\r\nlook REPLACE$( for replace text no chars only)\r\nThe example above as series of relaces$()\r\na$=\"ABCDEFGH\"\r\na$=REPLACE$(\"ABCDEFGH\", \"B\")\r\na$=REPLACE$(\"ABCDEFGH\", \"C\")\r\na$=REPLACE$(\"ABCDEFGH\", \"F\")
GR:ΦΟΝΤΟ\r\n\r\nGRADIENT 1  ' fill the output with one color (CLS clear the split screen...but GRADIENT  paint entire screen)\r\nGRADIENT 1,2 ' fill from color 1 to color 2 (we can use 0 to 16 standard colors or Color() function (RGB model) or HSL() function (convert to rgb), or system colors using 0x prefix)\r\nGRADIENT 1,3,0  ' from left to right\r\n\r\nPrint and Report command type letters without clear first the place to type. Only in a Field input and the Query of command line (using the same routine as FIELD)  clear always the background  (the FIELD command clear from start, the \"Query\" clear as we type).\r\nFor this reason if we want to print in a cursor location many times a value then we have to use FRAME command or the print operator  @() which can alter the background of a frame with color or image.\r\n\r\nExample\r\n-------------------\r\nModule A {\r\n      Mode 12, 8000\r\n      Background {\r\n            Desktop\r\n            path ! {Gradient 1,2}\r\n      }\r\n}\r\n\r\n
GR:ΦΟΡΜΑ\r\nAbout screen\r\nExcept from WINDOW and MODE we have a way to found the size of font to use by declare the width in characters or width and height. Also we can show or hide the non character display area around the screen. This non using area is cutting from background. We say that area as Border (but is part of background layer)All the layers exist on background. All layers and background are movable and can alter size, font size, colors, can display images, text, and drawings. When background move...all other layers move together.\r\n\r\nAlso we can use Printer as a screen to (without refreshing). But for printer we can't use Form command (nothing happen) only the MODE command or by using PRINTER command we can define the size for font as the basic size to print.\r\nM2000 Environment has a background and a screen on it, and 32 layers that can be using as screens or sprites (with transparent parts).  \r\n\r\nFrom 6.7 rev 21 we have line spacing (as twips using it as top and bottom border for each line). We can change using LINESPACE 0 or any positive value until 1000 twips.  We can read that number using LINESPACE as read only variable.\r\n\r\nWe have 5 variants for FORM command\r\n\r\n1) FORM 80 \r\nusing the LINESPACE define a display mode with 80 chars width,  and as many lines as it can.\r\nwe can alter the linespace but see the 2 variant\r\nThis command can be used to printer (we can set only the char width automatic), and for layers\r\n2) FORM 80, 25 \r\nIf the background has height as screen then this command alter LINESPACE to use as many space form screen can be used\r\nIf not then maybe some part above and below screen are showing bacgkround\r\nThis can be used for Layers but without auto line spacing adjustment.\r\n3) FORM\r\nThe border is cutting so now we know what variant 2 doing\r\n4) FORM ;\r\nThe border  is back again\r\n5) FORM 80, 25;\r\nNow we have a force creation of the text resolution we want. This is the best\r\nUsing ! after Form we make the internal algorithm to give more space around text frame (used as safe area for TV monitors)\r\nTry Form ! 60,40 and Form 60,40 to see what happen\r\n\r\nWe can use the cutting process more than one time, so we can make three lines of text and we can move to top side of screen, so we can make applications for a part of the screen, using exactly the resolution we want (without  we define a font size..that will be defined automatic).\r\n\r\nExample\r\nMake a column of 20 chars and 40 lines in the top left corner\r\nform ;          '  pop  the border if is cutting\r\nform 20,60  ' centered using maximum linespace (Automatic) to fill as possible the screen height\r\nform             '  cutting the border\r\nmotion.w 0, 0  ' move background  to the left (so all the layers moved together)\r\nform 20,40  ' we cut some lines - linespace not alter - 10 lines up and 10 lines down are cutting and showing the black background\r\nmotion 0,0  ' move form to top  - so now 20 lines are black lower the screen\r\nform  ' cutting border , now 20 lines are gone...\r\nSo with one command and the variants we can make any screen type.\r\n\r\n
GR:ΦΟΡΜΑ$\r\nPRINT CONTROL$\r\nReturn the active form name if is one of the AVI, MAIN, HELP, or a User Form. If a user form is part of an array of forms then we get name with parenthesis and index number inside.\r\nWe can use this feedback if we need to know what part of environment is in focus. If environment is minimized or has lost focus then this is an empty string\r\n\r\n\r\n\r\n
GR:ΦΟΡΜΑΡΙΣΜΑ_ΑΛΦΑΡΙΘΜΗΤΙΚΩΝ\r\nFor Str$() an d internal function in Print $(\r\n1)@\r\nspace or a char from string\r\n2)&\r\na char from string  or nothing\r\n3)<\r\nlcase the following letters\r\n4)>\r\nUcase the following letters\r\n5)!\r\nchange print direction\r\n
GR:ΦΟΡΜΑΡΙΣΜΑ_ΑΡΙΘΜΩΝ\r\nFor Str$() and for $() in Print  command\r\n1)0\r\ndigit or zero\r\n2)#\r\ndigit or nothing\r\n3).\r\ndecimal point\r\n4)%\r\npercent (number times 100 plus % as char)\r\n5),\r\nthousands separator\r\n6) E- E+ e- e+\r\nscientific notation for numbers
GR:ΦΟΡΜΑΡΙΣΜΑ_ΓΙΑ ΚΑΘΕ ΤΥΠΟ\r\n\r\nUsed in Str$() and in $() for formatting purposes\r\nexcluded a, c, d, h, m, n, p , q, s, t ,w, y, / and :
GR:ΦΟΡΜΑΡΙΣΜΑ_ΗΜΕΡΟΜΗΝΙΩΝ ΚΑΙ ΩΡΑΣ\r\n1):\r\ntime separator\r\n2)/\r\nday separator\r\n3)c\r\nfull date or full time\r\n4)d\r\nday as number with no lead zero (1 - 31)\r\n5)dd\r\nlike d but can use leading zero\r\n6)ddd\r\nday with 3 letters\r\n7)dddd\r\nday by name\r\n8)ddddd\r\nfull day \r\n9)w\r\nnumber for day  (1 for Sunday and 7 for Saturday)\r\n10)ww\r\nPrint number of week of year (1-54)\r\n11)m\r\nmonth number without leading zero(1 -12)\r\n12)mm\r\nmonth number including leading zero if needed (01-12)\r\n13)mmm\r\nmonth name with 3 letters\r\n14)mmmm\r\nname of month\r\n15)q\r\nnumber of quarter of year (1-4)\r\n16)y\r\nNumber of day of year (1-366)\r\n17)yy\r\nnumber of year as last two digits\r\n18)yyyy\r\nnumber of year (100 -9999)\r\n19)h\r\nhour without leading zero (0 - 23)\r\n20)hh\r\nhour including leading zero if needed (00 - 23)\r\n21)n\r\nminutes without leading zero (0 - 59)\r\n22)nn\r\nminutes  including leading zero if needed  (00 - 59)\r\n23)s\r\nseconds without leading zero (0 - 59)\r\n24)ss\r\nseconds including leading zero (00 - 59)\r\n25)ttttt\r\ntime full form\r\n26)AM/PM\r\ntime indicator day/night using upper case letters\r\n27)am/pm\r\ntime indicator day/night using lower case letters\r\n28)A/P\r\ntime indicator with one letter A or P\r\n29)AMPM\r\nUsing system letters for time indicator\r\n
GR:ΦΟΡΤΟΣ\r\nProfiler ' set profiler on\r\nFor i=1 to 10000 {x=10}\r\nPrint Timecount  ' measure time in msec (as a double)\r\n\r\n
GR:ΦΟΡΤΩΣΕ\r\nfrom version 9 there is a cache for loadings, so next time we use the store in memory, not the file. If we want the file, then we use Load New command.\r\n\r\nLoad Modules  ...  (for loading modules/functions without executing calls to modules, using cache)\r\nLoad New Modules ...(for loading modules/functions without executing calls to modules, refreshing cache)\r\n\r\nLoad name\r\n------Load name.gsb from Dir$  current directory (m2000 user directory) and execute\r\nLoad name, \"password\"\r\n------As previous but you save it before with user password\r\n\r\nLoad \"name with spaces\"  && \"this name with spaces\"\r\n------Load one and merge with second and then execute\r\nLoad \"name with spaces\", pass$  && \"this name with spaces\", pass$\r\n\r\nAnything you load after termination of current level of run, erased. But this can be change if we load code in a module when we call it with special Call! command. Because anything local can be stay alive we have to ensure that the loading happen once. So in next call! we have all variables, modules, classes, functions as static. We can use For This {} to make a block where all erased at exit.\r\n\r\n\r\n
GR:ΦΟΡΤΩΣΕ.ΕΓΓΡΑΦΟ\r\nLOAD.DOC document_name$, filename$\r\nCan open UTF-16LE, UTF-16BE, ANSI and UTF-8\r\nInternal the text converted to UTF-16\r\nInside document a property used to hold the type of file\r\nSo when we do Save.Doc  we use that type, or explicit we can use a type for that save only.\r\nText command save in temporary folder for logging purposes.\r\ng$=\"George\"\r\nText utf-8 alfa.txt { lines of text\r\n                  This is a variable \"##g$##\"\r\n                  second line\r\n                  }\r\n\r\nDocument a$\r\nLoad.doc a$, Temporary$+\"alfa.txt\"\r\nReport a$
GR:ΦΩΝΗ\r\n\r\n SCORE 3, 1000, \"C5F#@2B@2C5F#@2B\"\r\n     SCORE 1, 1000, \"D@2E@2C#3 @2D5@2V90 @3F#4V127\"\r\n                    '/ C C# D D# E F F# G G# A# B\r\n                    '/\r\n     PLAY   1, 19, 3, 22  ' VOICE, INSTRUMENT\r\n     for score 3 we have  1000 miliseconds period for a note, so we can use @2 for 1000/2 until @6 for 1000/32 as periods\r\n     C5 is C in 5th octave\r\n     V is for volume V1 to V127\r\n     We can place a space for pause and we can give a time period for that as for notes.\r\n     Each score is copied to a bank so a new copy can change the bank\r\n     When a bank is in use each reading is droping from bank. When bank is empty that voice is stopped.\r\n     We can change the bank before the reading is over. We can't read the bank, only we can write it.\r\n     PLAY 0 for erasing synthesizer threads, and empty all the banks.\r\n     Use VOLUME for total volume control, CHOOSE.ORGAN to find an instrument\r\n     \r\n     \r\n     \r\n     \r\n     
GR:ΦΩΤΟ$(\r\nreturn full path with name and type of a jpg file if existe else return empty string
GR:Χ.ΣΗΜΕΙΑ\r\nReturn Layer/Main/Background width size in twips\r\nsame as scale.x\r\n
GR:ΧΑΡ$(\r\n?  chr$(240)\r\nif LATIN selected then this print the ascii code of the system locale else print the GREEK one\r\nwe can use a second parameter\r\n? chr$(240, 1036)   prints the french letter in the 240 position in a French codepage\r\n? chr$(\"convert me to french\",1036)\r\nlook CHRCODE$() and CHRCODE()\r\n\r\n\r\n\\\\ we can use Locale to set  locale id fro Ansi conversion\r\na$=Str$(\"Hello\")\r\n\\\\ a$ has a string as ansi string\r\nPrint len(a$)=2.5\r\nPrint \"Bytes:\"=Len(a$)*2  ' 5 bytes\r\nPrint Len(chr$(a$))=5\r\nPrint a$\r\n\r\n\r\n\r\n  \\* Using locale ID\r\nFORM 60,32\r\nSET FAST !\r\nshowchars  = true\r\nMODULE SHOWME {\r\n      READ  showletters, any_locale\r\n      FOR I = 33 TO 255 {\r\n            if showletters then {\r\n                  PRINT CHR$(I,any_locale);\r\n            } else {\r\n                  PRINT CHRCODE(CHR$(I,any_locale)),\r\n            }\r\n      }\r\n      PRINT\r\n      PRINT\r\n      REFRESH\r\n}\r\n\r\n\\* print the unicode number from ansi using system\r\nPrint \"SYSTEM\"\r\n      SHOWME showchars, 0\r\n\\* print the unicode number from ansi using Greek\r\nPrint \"GREEK\"\r\n      SHOWME showchars, 1032\r\n\\* print the unicode number from ansi using Hebrew \r\nPRINT \"HEBREW\"\r\n      SHOWME showchars, 1037\r\nPRINT \"FINLAND\"\r\n\\* print the unicode number from ansi using Finland \r\n      SHOWME showchars, 2077\r\n\\* print the unicode number from ansi using Turkish\r\n      PRINT \"TURKISH\"\r\n      SHOWME showchars, 1055\r\nSET FAST\r\n\r\n\r\n\r\n
GR:ΧΑΡΑΚΤΗΡΕΣ\r\nWe can define charset for LAYERS, BACKGROUND and PRINTER.\r\nFor greek\r\nCHARSET 161 \r\nThis is equal to GREEK command (from SETTINGS we can define the startup charset)\r\nCHARSET 0\r\nfor default charset\r\nPRINT CHARSET\r\n\r\nWe have another point that we can declare code page (like charset, but not the same values). That is for a Database, as we using the BASE command to make a new one. We can use UNICODE only in long binary fields (we declare that as OLE in the TABLE command). Using codepage we can sort the tables accordingly to that.\r\n\r\n
GR:ΧΑΡΑΞΕ\r\n      \r\n1) DRAW RelativePosXTwips, RelativePosYTwips [, color]\r\n      color can be 0 to 15 basic colors, or an rgb value (negative numbers for M2000), or system colors like 0x80000001\r\n      You can use COLOR(rValue, gValue, bValue)  values from 0 to 255 \r\n      You can use hexadecimal form with minus sign -0xAA00FF \r\n      (M2000 reads hexadecimal as unsign long, but sign is -1* so -0xAA00FF is an arithmetic expression of -1 * 0xAA00FF). Better you can use Html color hex #FF00AA  (always 6 hex digits else we get an error)\r\n2) DRAW ANGLE rad, distanceTwips [,color]\r\n3) DRAW TO absolutePosXTwips, absolutePosYTwips [,color]\r\n      If you want to change line width use WIDTH { } structure\r\n      Drawing can perform inside closed paths, see PATH {} structure, so anything drawing outside the path surface stay unchanged.\r\n\r\nsee FILL and FLOODFILL\r\nalso see POLYGON, CIRCLE, CURVE\r\n\r\n\r\n\r\n\r\n
GR:ΧΑΡΚΩΔ$(\r\nPrint chrcode$(0x0645)\r\nreturn 16bit UTF8LE  chars or surrogates (2*16bit)\r\n
GR:ΧΑΡΚΩΔ(\r\nPrint Chrcode(Chrcode$(0x0645))\r\n\r\nreturn the 16bit from  first char in a string
GR:ΧΕΙΡΙΣΜΟΣ ΑΡΧΕΙΩΝ\r\nFILE OPERATIONS\r\nBITMAPS, CLOSE, DRAWINGS, FILES, GET, LINE INPUT, MOVIES, NAME, OPEN, PUT, SEEK, SOUNDS, WRITE\r\n\r\n
GR:ΧΕΙΡΙΣΜΟΣ ΤΜΗΜΑΤΩΝ\r\nMODULE COMMANDS\r\nERROR, ESCAPE, FUNCTION, HALT, INLINE, LINK, MODULE, MODULES, PIPE, STOP, SUB, THREAD, THREADS, USE\r\n\r\n
GR:ΧΕΙΡΙΣΤΕΣ ΤΗΣ ΤΥΠΩΣΕ\r\nOPERATORS IN PRINT\r\n$(, @(, ~(\r\n\r\n
GR:ΧΚΦ(\r\nPen HSL(60,100,50)   ' hue 60 deg, Saturation 100%, Lightness 50%\r\n\r\n
GR:ΧΡΗΣΗ\r\n1) Use \"Hello.Gsb\"  1, \"alfa\", 2\r\n2) Use \"Hello\"  1, \"alfa\", 2\r\n3) a$=\"HELLO\" : Use a$ 1,\"alfa\", 3\r\n4) USE TRG.GSB 1,\"hello again\",3 TO K$ AS L\r\n   THREAD L INTERVAL 200\r\n   ' execute trg.gsb  send 3 items and prepare L thread to listen a pipe and put the result to string K$ as an stack variable ...see Envelope$()\r\n5) USE PIPE TO K$ AS L : THREAD L INTEVAL 200\r\n   ' make a pipe for input to K$ using a thread with handler L\r\n\r\n\r\nexample 1  \r\n\r\nMODULE HELLO {\r\n      Form 40\r\n      Show\r\n      Print \"Example 1, Hello\"\r\n      If Instr(parameters$, \"-OK\")>0 Then {\r\n            Print \"You call me from Shell\",,\"    with parameter -OK\"\r\n      } else {\r\n            L$=Envelope$()\r\n            If Len(L$)>0 Then {\r\n                  Print \"You call me with USE and \";len(L$);\" parameters\"\r\n                  stack\r\n            } else {\r\n                  Print \"You just call me\"\r\n            }\r\n      }\r\n      Print \"So Hello Again\"\r\n      Fkey 1, \"end\"\r\n      Fkey 2, \"h1\"\r\n      Fkey 3, \"h2\"\r\n      Print \"Choose a Function Key\"\r\n      Fkey\r\n}\r\nMODULE H1 {WIN DIR$+\"HELLO.GSB -OK\"\r\n      }\r\nMODULE H2 {use hello.gsb 1, \"aaaa\", 3\r\n      wait 2000\r\n}\r\nHELLO\r\n\r\nexample 2\r\n' this is the BASE.GSB and below is the TRG.GSB\r\n' Base open Trg and Trg can send data to Base and can stop it.\r\n' Base open TRG and give a pipe to it. Anyone can write to that pipe if knows the name.\r\n' So we can make one base and we can execute many TRG. So the BASE can handle input from every TRG\r\n' We can define in each TRG a new pipe for input and we can send the pipe name to Base\r\n' So the Base can sen back to a specific TRG.\r\n' So with that use we can have one SERVER and many CLIENTS. We can use pipes with computer names in front. So we can comunicate. But we can start a Base in one computer and run a Trg  in any other. \r\n' What we can do is to make a standard \"listening\" pipe, in a known computer, and in all Trg programs we can setup that name for access to base. Then Base can known from a message from a Trg about how to transfer to the Trg data, just with the name of the pipe from computer who runs the Trg.\r\n\r\nMODULE B {WINDOW 12, 8000,6000\r\nFORM 32, 25\r\nFORM\r\nSHOW\r\nMOTION.W 500,2000\r\nPRINT \"THIS IS THE BASE\"\r\nUSE TRG.GSB 1,\"hello again\",3 TO K$ AS L\r\nTHREAD L INTERVAL 200\r\nC=0\r\nPAR$=\"\"\r\nNM$=\"\"\r\nGETOUT=FALSE\r\nEVERY 200 {\r\n                        C=C+1\r\n                        PRINT C\r\n                        IF INKEY$=\" \" THEN EXIT\r\n                        IF C=1000 THEN EXIT\r\n                        IF K$<>\"\" THEN {\r\n                                          STACK K$\r\n                                          STACK  ' SHOW ONLY\r\n                                          READ NM$, PAR$\r\n                                          FLUSH\r\n                                          IF PAR$=\"N\" THEN GETOUT =TRUE\r\n                                          C=0\r\n                        }\r\n                        IF GETOUT THEN EXIT \r\n                  }\r\nPRINT \"FINISH\"\r\n}\r\n\r\nlook to PIPE to find the TRG.GSB\r\n\r\nMODULE SERVER {\\\\ Server - Client in one module\r\n\\\\ USER DEFINED FUNCTION IN ONE LINE\r\nFUNCTION CONSUME$ { READ &A$ : =A$ : A$=\"\" }\r\n\\\\ A new special thread prepare here with id 30123\r\n\\\\ If pipe can be used then ALFA$ has the full pipe name.\r\nUSE PIPE TO ALFA$ AS 30123\r\n IF ALFA$=\"\" THEN PRINT \"Ooops\" : EXIT\r\n\\\\ Here is the client part...\r\n\\\\ we have to clear ALFA$ (ALFA$ is in server side)\r\n\\\\  Pipe name can be calculated by this function PIPENAME$(\"S30123\")\r\nPIPE CONSUME$(&ALFA$),\"George\",2,3\r\nWHILE ALFA$=\"\" {\r\n      IF MOUSE THEN BREAK   \\\\EXIT FROM MODULE\r\n      WAIT 10\r\n      PRINT \"Wait...\"\r\n}\r\n\\\\ WE GET pipename$ (one that we clear), a match string \"SNN\" of what items follow.\r\n\\\\ and finally the items\r\n\\\\ So we can dump these to stack\r\nSTACK ALFA$    : DROP 2  \\\\ drop pipe name and match string\r\nREAD A$, A, B\r\nPRINT A$, A, B\r\nTHREAD 30123 ERASE\r\nTHREADS\r\n\r\n\r\n}\r\nMODULE B {FUNCTION CONSUME$ { READ &A$ : =A$ : A$=\"\" }\r\nK$=\"13232\"\r\nM$=CONSUME$(&K$)\r\nPRINT LEN(K$), M$\r\n}\r\nMODULE SERVER1 {\\\\ Server - Client in one module\r\n\\\\ Setup of a pipe thread to link to a buffer$\r\n\\\\ Syntax USE PIPE TO BUFFER$\r\n\\\\ We can erase pipe thread by erasing all threads THREAD ERASE\r\n\\\\ Or by using ID(A$) user function to find thread id from pipe name.\r\n\\\\ First Buffer$ has the full pipe name. We have to erase to start fill it\r\n\\\\ So we use a user function with more than one command Comsume$()\r\n\r\n\\\\ USER DEFINED FUNCTION IN ONE LINE \r\nFUNCTION CONSUME$ { READ &A$ : =A$ : A$=\"\" }\r\n\r\n\\\\ As old basic (FN is an optional prefix in function name )\r\nDEF ID(A$)=VAL(REPLACE$(PIPENAME$(\"M\"),\"\", A$))\r\n\r\nUSE PIPE TO ALFA$\r\nIF ALFA$=\"\" THEN PRINT \"Ooops\" : EXIT\r\nL=ID(ALFA$)\r\nPIPE CONSUME$(&ALFA$),\"George\",2,3\r\nWHILE ALFA$=\"\" {\r\n      IF MOUSE THEN BREAK   \\\\EXIT FROM MODULE\r\n      WAIT 10\r\n      PRINT \"Wait...\"\r\n}\r\n\\\\ WE GET pipename$ (one that we clear), a match string \"SNN\" of what items follow.\r\n\\\\ and finally the items\r\nSTACK ALFA$    : DROP 2  \\\\ drop pipe name and match string\r\nREAD A$, A, B\r\nPRINT A$, A, B\r\nTHREAD L ERASE\r\nTHREADS\r\n\r\n\r\n}\r\nMODULE SERVER2 {\\\\ Server - Client in one module\r\n\\\\ The easy way. ALFA$ is cleared\r\n\\\\ L=12345   \\\\ here we use an auto thread number.\r\nUSE PIPE TO ALFA$ AS L\r\nPIPE PIPENAME$(L),\"George\",2,3\r\nWHILE ALFA$=\"\" {\r\n      IF MOUSE THEN BREAK   \\\\EXIT FROM MODULE\r\n      WAIT 10\r\n      PRINT \"Wait...\"\r\n}\r\nSTACK ALFA$    : DROP 2  \\\\ drop pipe name and match string\r\nREAD A$, A, B\r\nPRINT A$, A, B\r\nTHREAD L ERASE\r\nTHREADS\r\n\r\n\r\n}\r\n\r\n\r\n
GR:ΧΡΟΝΟΣ$(\r\nA=Now\r\nPrint Time$(A), Str$(A, \"hh:nn\") \r\nPrint time$(now,)\r\nPrint time$(now,1033)\r\nPrint ucase$(time$(now,1033, \"hh:mm:ss tt\"))\r\nPrint ucase$(time$(now,1032, \"hh:mm:ss tt\"))\r\nPrint ucase$(time$(now,1033, \"Long Time\"))\r\nPrint ucase$(time$(now,1033, \"Short Time\"))\r\nPrint Time$()   ' return the time zone string used by Windows\r\nPrint Time(Time$())  ' return the difference from UTC (without using the Daylight bias)\r\nPrint Time$(Time(\"UTC\"))  ' return UTC time for now\r\n\r\nLook Time()
GR:ΧΡΟΝΟΣ(\r\nreturn time as double from a string representing time\r\nPrint Time$(Time(\"10:20\"))
GR:ΧΡΩΜΑ\r\nDefine color/path in a block of code. There are four variations for color or path structure\r\n\r\n1) COLOR fillcolorNu [, fill style] {\r\n      block of code\r\n      }\r\n      All graphics inside structure has this color as fillcolor\r\n2) COLOR ! fillcolorNum [, fill style] {\r\n      block of code\r\n      }\r\n      All graphics inside structure has this color as fillcolor  AND DRAWING with Xor type of blend\r\n      So second time the graphics erased and the screen restored\r\n      There are also other ways to restore the screen...such as HOLD  (the bitmap) and then RELEASE (the bitmap) of screen.\r\n3) COLOR {\r\n      block of code\r\n      }\r\n      No fill color. Only drawing lines with pen color. See an example in POLYGON\r\n4) COLOR {\r\n      block of code\r\n      };      \r\n      Look the semi colon after the ending of block\r\n      All the area defining in block code, from a polygon, a circle, anything, creates path for exclusive printing inside.\r\n      If you like you can call it PATH (because it is a path, as in windows terminology, but for M2000 is a color manipulator, so is a part of color structure)\r\n      You can reset the path with these commands\r\n                  Move 0,0\r\n                  Path {POLYGON 0, x.twips, 0,0,y.twips,-x.twips,0,0,-y.twips};\r\n                  ' first 0 is the color, so first point is x.twips,0 the top line or you reset it with CLS (clear screen)\r\n                  or better Path {};  clear path\r\n                  or CLS \r\n\r\n\r\n\r\n
GR:ΧΡΩΜΑ(\r\n\r\nPEN COLOR(100,50,255)\r\n\r\npen color(0,0,0)   ' black\r\npen color(255,255,255) 'White\r\n\r\nThis function gives a negative number or zero\r\n\r\nPen (and all graphic commands) use negative number for RGB values, positive for basic colors and >=0X80000001 for system colors.\r\n\r\nColor Constant like html using #\r\nprint color(0x020c3d),color(\"3d0c02\"), color(#3d0c02), #3d0c02,color(61, 12, 2)\r\n      -134205     -134205      -134205      -134205      -134205\r\nprint #af, 12  \\\\ af is a file handler\r\nprint #afafaf, 112 \\\\ is a color number RGB\r\ncls 0X80000001  \\\\ this is a system color DESKTOP\r\ncls 1   \\\\ this is QBcolor 1\r\ncls color(61,12,2)  \\\\ this is Black Bean color look here: http://encycolorpedia.com/3d0c02\r\ncls #3d0c02         \\\\ this is Black Bean color\r\ncls 0x020c3d        \\\\ this is Black Bean color (as BGR)  \r\n\r\nif number is 0 to 15 then we have QBcolor and converted to rgb (as negative number)\r\nif number >=0X80000000 then this is a system color and converted to rgb (as negative number)\r\nif number>0 and (number and OxFF000000) =0 then this is an RGB color and we change sign to minus (so we have a negative as rgb)\r\nif number<0 and (number and OxFF000000) =0 then we have a ready Rgb color\r\nif we have 3 numbers Color(rvalue positive, gvalue positive, bvalue positive) we get an Rgb value.\r\nSo if we wand #000005 we can use the #mapped or Color(0,0,5).\r\nOx05 and 5 give the QBasic color 5
GR:ΧΡΩΜΑΤΑ\r\nPRINT COLORS\r\nprints the number of colors that screen can show\r\n\r\n\r\n\r\n
GR:ΧΡΩΜΑΤΙΣΕ\r\nPSET\r\nPSET 15\r\nPSET COLOR(100,100,500)\r\n\r\nPSET 15, 6000,6000 'graphic cursor not affected\r\nPSET COLOR(100,100,500), 6000,6000
GR:ΨΕΥΔΕΣ\r\nEqual to 0
GR:ΨΕΥΔΗΣ\r\nequal to 0
GR:ΨΗΦΙΟ\r\n\r\nused in command TABLE and in command Structure and in object BUFFER, also used for buffers, in Return command and in Eval()
\#ΑΘΡ(!19
\#ΑΝΑΠ(!19
\#ΑΝΤ(!19
\#ΕΚΦΡ$(!20
\#ΕΚΦΡ(!19
\#ΘΕΣΗ(!19
\#ΜΕΓ$(!20
\#ΜΕΓ(!19
\#ΜΕΡΟΣ(!19
\#ΜΙΚ$(!20
\#ΜΙΚ(!19
\#ΠΑΚ$(!20
\#ΠΑΚ(!19
\#ΤΑΞΙΝΟΜΗΣΗ(!19
\#ΤΙΜΗ$(!20
\#ΤΙΜΗ(!19
\#ΦΙΛΤΡΟ(!19
\ΑΔΕΙΑΣΕ!9
\ΑΚ(!19
\ΑΚΕΡΑΙΟ.ΔΥΑΔΙΚΟ(!19
\ΑΚΕΡΑΙΟΣ!23
\ΑΛΗΘΕΣ!23
\ΑΛΗΘΗΣ!23
\ΑΛΛΑΓΗ!13
\ΑΛΛΑΓΗ$(!20
\ΑΛΛΑΞΕ!7
\ΑΛΛΙΩΣ!3
\ΑΛΛΙΩΣ.ΑΝ!3
\ΑΛΤ!15
\ΑΛΦΑΡΙΘΜΗΤΙΚΑ!22
\ΑΝ!3
\ΑΝ$(!20
\ΑΝ(!19
\ΑΝΑΖΗΤΗΣΗ!2
\ΑΝΑΘΕΣΕ!9
\ΑΝΑΚΤΗΣΗ!2
\ΑΝΑΛΟΓΙΟ!10
\ΑΝΑΛΟΓΙΟ$!21
\ΑΝΑΛΥΤΗΣ!3
\ΑΝΑΜΟΝΗ!3
\ΑΝΑΝΕΩΣΗ!8
\ΑΝΑΠ$(!20
\ΑΝΑΦΟΡΑ!8
\ΑΝΑΨΕ!8
\ΑΝΟΙΓΜΑ.ΑΡΧΕΙΟΥ!12
\ΑΝΟΙΓΜΑ.ΕΙΚΟΝΑΣ!12
\ΑΝΟΙΞΕ!11
\ΑΝΤΙΓΡΑΨΕ!4
\ΑΠΑΡ!7
\ΑΠΑΡΙΘΜΗΣΗ!7
\ΑΠΕΔΩΣΕ!9
\ΑΠΕΙΡΟ!23
\ΑΠΛΟΣ!23
\ΑΠΟ!3
\ΑΠΟΘΗΚΕΥΣΗ.ΩΣ!12
\ΑΠΟΚ$(!20
\ΑΠΟΚ.ΑΡ$(!20
\ΑΠΟΚ.ΔΕ$(!20
\ΑΠΟΛ(!19
\ΑΡΓΑ!14
\ΑΡΙΘΜΗΤΙΚΑ!22
\ΑΡΙΘΜΟΣ.ΠΑΡΑΓΡΑΦΟΥ(!19
\ΑΡΙΣ$(!20
\ΑΡΙΣΤΕΡΟΜΕΡΟΣ$(!20
\ΑΡΧΕΙΑ!11
\ΑΡΧΕΙΟ!2
\ΑΡΧΕΙΟ$(!20
\ΑΡΧΕΙΟΥ.ΜΗΚΟΣ(!19
\ΑΡΧΕΙΟΥ.ΣΤΑΜΠΑ(!19
\ΑΡΧΗ!14
\ΑΥΛΟΣ!15
\ΑΥΛΟΣ$(!20
\ΑΥΞΟΥΣΑ!23
\ΑΥΤΟ!21
\ΑΥΤΟΜΑΤΟΙ_ΠΙΝΑΚΕΣ!7
\ΑΦΑΙΡΕΣΗ!2
\ΑΦΗΣΕ!8
\ΒΑΛΕ!9
\ΒΑΛΕ.ΑΔΕΙΑ$(!20
\ΒΑΣΕΙΣ ΔΕΔΟΜΕΝΩΝ!22
\ΒΑΣΗ!2
\ΒΑΣΗ(!19
\ΒΑΣΗ.ΠΑΡΟΧΟΣ!2
\ΒΑΣΗ.ΧΡΗΣΤΗΣ!2
\ΒΑΨΕ!1
\ΒΗΜΑ!1
\ΒΟΗΘΕΙΑ!14
\ΓΕΓΟΝΟΣ!7
\ΓΕΜΙΣΕ!1
\ΓΕΝΙΚΗ!7
\ΓΙΑ!3
\ΓΡΑΜΜΑ$!21
\ΓΡΑΜΜΑΤΟΣΕΙΡΑ!8
\ΓΡΑΜΜΑΤΟΣΕΙΡΑ$!21
\ΓΡΑΜΜΕΣΑΝΑΦΟΡΑΣ!21
\ΓΡΑΜΜΗ!21
\ΓΡΑΜΜΗ ΕΙΣΑΓΩΓΗΣ!11
\ΓΡΑΦΗ$(!20
\ΓΡΑΦΙΚΑ 2Δ!22
\ΓΡΑΨΕ!11
\ΓΡΗΓΟΡΑ!14
\ΔΑΠΕΔ(!19
\ΔΕΙΚΤΗ.ΜΟΡΦΗ!6
\ΔΕΙΚΤΗΣ!21
\ΔΕΙΚΤΗΣ(!19
\ΔΕΙΚΤΗΣ.ΚΟΜ!21
\ΔΕΙΚΤΗΣ.Υ!21
\ΔΕΙΚΤΗΣ.Χ!21
\ΔΕΙΚΤΗΣΑ.Υ!21
\ΔΕΙΚΤΗΣΑ.Χ!21
\ΔΕΙΞΕ!2
\ΔΕΚ(!19
\ΔΕΚΑΕΞ!16
\ΔΕΚΑΕΞ$(!20
\ΔΕΝ!19
\ΔΕΞΙ$(!20
\ΔΕΞΙΜΕΡΟΣ$(!20
\ΔΕΣ!3
\ΔΙΑ!14
\ΔΙΑ#!14
\ΔΙΑΒΑΣΕ!9
\ΔΙΑΓΡΑΦΗ!14
\ΔΙΑΔΙΚΤΥΟ!21
\ΔΙΑΔΙΚΤΥΟ$!21
\ΔΙΑΚΟΠΗ!15
\ΔΙΑΚΟΠΤΕΣ!14
\ΔΙΑΜΕΣΟΥ!3
\ΔΙΑΡΘΡΩΣΗ!7
\ΔΙΑΡΘΡΩΣΗ(!19
\ΔΙΑΡΚΕΙΑ!21
\ΔΙΑΣΤΑΣΗ(!19
\ΔΙΑΣΤΙΧΟ!8
\ΔΙΑΦΑΝΕΙΑ$!21
\ΔΙΑΦΑΝΟ!4
\ΔΙΑΦΥΓΗ!15
\ΔΙΕΚΟΨΕ!3
\ΔΙΕΡΜΗΝΕΥΤΗΣ!22
\ΔΙΚΤΥΟ$!21
\ΔΙΟΡΘΩΣΕ!25
\ΔΙΠΛΑ!8
\ΔΙΠΛΟΣ!23
\ΔΟΚΙΜΗ!14
\ΔΟΚΙΜΗ(!19
\ΔΟΜΗ!2
\ΔΡΟΜΕΑΣ!8
\ΔΥΑΔΙΚΗ.ΠΕΡΙΣΤΡΟΦΗ(!19
\ΔΥΑΔΙΚΟ!7
\ΔΥΑΔΙΚΟ(!19
\ΔΥΑΔΙΚΟ.ΑΚΕΡΑΙΟ(!19
\ΔΥΑΔΙΚΟ.ΑΝΤΙ(!19
\ΔΥΑΔΙΚΟ.ΑΠΟ(!19
\ΔΥΑΔΙΚΟ.Η(!19
\ΔΥΑΔΙΚΟ.ΚΑΙ(!19
\ΔΥΑΔΙΚΟ.ΟΛΙΣΘΗΣΗ(!19
\ΔΥΑΔΙΚΟ.ΟΧΙ(!19
\ΔΥΑΔΙΚΟ.ΠΡΟΣΘΕΣΗ(!19
\ΔΥΑΔΙΚΟ_σταθ!23
\ΔΥΟΜΙΣΑ(!19
\ΔΩΣΕ!11
\ΕΓΓΡΑΦΑ!22
\ΕΓΓΡΑΦΕΣ(!19
\ΕΓΓΡΑΦΟ!7
\ΕΓΓΡΑΦΟΥ.ΛΕΞΕΙΣ(!19
\ΕΓΓΡΑΦΟΥ.ΜΗΚΟΣ(!19
\ΕΓΓΡΑΦΟΥ.ΜΟΝΑΔΙΚΕΣ.ΛΕΞΕΙΣ(!19
\ΕΓΓΡΑΦΟΥ.ΠΑΡ(!19
\ΕΓΓΡΑΨΙΜΟ(!19
\ΕΓΚΥΡΟ(!19
\ΕΙΚ$(!20
\ΕΙΚΟΝΑ!4
\ΕΙΚΟΝΑ(!19
\ΕΙΚΟΝΑ.Υ(!19
\ΕΙΚΟΝΑ.Υ.ΣΗΜΕΙΑ(!19
\ΕΙΚΟΝΑ.Χ(!19
\ΕΙΚΟΝΑ.Χ.ΣΗΜΕΙΑ(!19
\ΕΙΚΟΝΕΣ!11
\ΕΙΚΟΝΙΔΙΟ!8
\ΕΙΝΑΙ!14
\ΕΙΝΑΡ!21
\ΕΙΝΓΡ!21
\ΕΙΣΑΓΩΓΗ!16
\ΕΙΣΑΓΩΓΗ$(!20
\ΕΚΔΟΣΗ!14
\ΕΚΔΟΣΗ_σταθερά!23
\ΕΚΤΕΛΕΣΗ!2
\ΕΚΤΥΠΩΣΕΙΣ!22
\ΕΚΤΥΠΩΣΗ!17
\ΕΚΤΥΠΩΤΗΣ!17
\ΕΚΤΥΠΩΤΗΣ$!21
\ΕΚΦΡ$(!20
\ΕΚΦΡ(!19
\ΕΛ ISWINE!23
\ΕΛ OSBIT!21
\ΕΛ$!24
\ΕΛ?!16
\ΕΛ@!24
\ΕΛ~!24
\ΕΛΕΓΧΟΣ!14
\ΕΛΕΓΧΟΣ.ΜΕΓΕΘΟΣ.ΣΩΡΟΥ!21
\ΕΛΕΓΧΟΣ.ΣΩΡΟΥ!21
\ΕΛΛΗΝΙΚΑ!8
\ΕΛΛΗΝΙΚΑ_μεταβλητή!21
\ΕΝΑΟΝΟΜΑ$!21
\ΕΝΘΕΣΗ!15
\ΕΝΚΟΜ$!21
\ΕΝΚΟΜ(!19
\ΕΝΤΑΣΗ!5
\ΕΝΤΑΣΗ_μεταβλητή!21
\ΕΝΤΟΛΕΣ ΔΕΙΚΤΗ!22
\ΕΝΤΟΛΕΣ ΕΙΚΟΝΩΝ!22
\ΕΝΤΟΛΕΣ ΙΣΤΟΥ!22
\ΕΝΤΟΛΕΣ ΚΟΝΣΟΛΑΣ!22
\ΕΝΤΟΛΕΣ ΣΩΡΟΥ!22
\ΕΝΤΟΛΗ$!21
\ΕΝΩ!3
\ΕΝΩΣΕ!15
\ΕΝΩΣΗ(!19
\ΕΝΩΣΗ.ΣΕΙΡΑΣ$(!20
\ΕΞΟΔΟΣ!3
\ΕΠΑΝ$(!20
\ΕΠΑΝΑΛΑΒΕ!3
\ΕΠΑΝΕΛΑΒΕ!3
\ΕΠΙΓΡΑΦΗ!8
\ΕΠΙΛΕΞΕ!3
\ΕΠΙΛΕΞΕ.ΓΡΑΜΜΑΤΟΣΕΙΡΑ!12
\ΕΠΙΛΕΞΕ.ΟΡΓΑΝΟ!5
\ΕΠΙΛΕΞΕ.ΧΡΩΜΑ!12
\ΕΠΙΛΟΓΕΣ!21
\ΕΠΙΛΟΓΕΣ.ΦΑΝΕΡΕΣ!21
\ΕΠΙΛΟΓΗ!13
\ΕΠΙΛΟΓΗ$(!20
\ΕΠΙΛΟΓΗ_μεταβλητή!21
\ΕΠΙΠΕΔΟ!8
\ΕΠΙΣΤΡΟΦΗ!2
\ΕΠΙΦΑΝΕΙΑ!8
\ΕΠΟΜΕΝΑ(!19
\ΕΤΟΙΜΟ(!19
\ΕΥΡΕΣΗ!25
\ΕΦΑΠ(!19
\ΕΦΑΡΜΟΓΗ.ΑΡΧΕΙΟΥ$(!20
\ΕΦΑΡΜΟΓΗ.ΚΑΤ$!21
\Η!14
\ΗΜ(!19
\ΗΜΕΡΑ$(!20
\ΗΜΕΡΑ(!19
\ΗΜΕΡΟΜΗΝΙΑ!23
\ΗΧΟ$(!20
\ΗΧΟΙ!11
\ΗΧΟΙ ΚΑΙ ΤΑΙΝΙΕΣ!22
\ΗΧΟΣ!5
\ΘΕΣΕ!7
\ΘΕΣΗ!1
\ΘΕΣΗ(!19
\ΘΕΣΗ.Υ!21
\ΘΕΣΗ.Χ!21
\ΘΕΣΗ_μεταβλητή!21
\ΘΕΣΗΔΕΞΙΑ(!19
\ΙΔΙΟΤΗΤΑ!7
\ΙΔΙΟΤΗΤΑ$(!20
\ΙΔΙΟΤΗΤΑ(!19
\ΙΔΙΟΤΗΤΕΣ!17
\ΙΔΙΟΤΗΤΕΣ$!21
\ΙΣΧΝΗ$(!20
\ΚΑΘΑΡΟ!14
\ΚΑΘΕ!3
\ΚΑΘΕ(!19
\ΚΑΙ!14
\ΚΑΛΕΣΕ!3
\ΚΑΜΠΥΛΗ!1
\ΚΑΝΕ!7
\ΚΑΝΟΝΙΚΑ!8
\ΚΑΤ$!21
\ΚΑΤΑΛΟΓΟΣ!12
\ΚΑΤΑΣΤΑΣΗ!7
\ΚΑΤΑΣΤΑΣΗ.ΤΑΙΝΙΑΣ$!21
\ΚΑΤΑΧΩΡΗΣΗ!25
\ΚΑΤΩΜΙΣΟ(!19
\ΚΕΙΜΕΝΟ!10
\ΚΕΙΜΕΝΟ_σταθερά!23
\ΚΕΝΟ!21
\ΚΕΦ$(!20
\ΚΙΝΗΣΗ!8
\ΚΙΝΗΣΗ.Π!8
\ΚΙΝΗΣΗ.ΠΥ!21
\ΚΙΝΗΣΗ.ΠΧ!21
\ΚΙΝΗΣΗ.Υ!21
\ΚΙΝΗΣΗ.ΥΠ!21
\ΚΙΝΗΣΗ.Χ!21
\ΚΙΝΗΣΗ.ΧΠ!21
\ΚΛΑΣΗ!7
\ΚΛΕΙΔΙ!14
\ΚΛΕΙΣΕ!11
\ΚΛΙΜΑΞ.Υ!21
\ΚΛΙΜΑΞ.Χ!21
\ΚΟΙΝΕΣ ΦΟΡΜΕΣ!22
\ΚΟΜ$!21
\ΚΟΝΣΟΛΑ!14
\ΚΡΑΤΗΣΕ!8
\ΚΡΥΦΟ$(!20
\ΚΥΚΛΙΚΑ!3
\ΚΥΚΛΟΣ!1
\ΚΥΛΙΣΗ!8
\ΚΥΡΙΟ.ΕΡΓΟ!3
\ΚΩΔ(!19
\ΚΩΔΙΚΟΣΕΛΙΔΑ!21
\ΛΑΒΗ!6
\ΛΑΒΗ(!19
\ΛΑΒΗ.ΑΝΑΛΟΓΙΚΟ.Υ(!19
\ΛΑΒΗ.ΑΝΑΛΟΓΙΚΟ.Χ(!19
\ΛΑΒΗ.ΚΑΤΕΥΘΥΝΣΗ(!19
\ΛΑΘΟΣ!15
\ΛΑΘΟΣ$!21
\ΛΑΘΟΣ.ΤΑΙΝΙΑΣ$!21
\ΛΑΜΔΑ!7
\ΛΑΤΙΝΙΚΑ!8
\ΛΕΞΕΙΣ!25
\ΛΙΣΤΑ!14
\ΛΟΓ(!19
\ΛΟΓΙΚΟΣ!23
\ΛΟΓΙΣΤΙΚΟ!23
\ΛΟΓΟΣ!5
\ΛΟΓΟΣ ως μεταβλητή!21
\ΛΟΓΟΣ$(!20
\ΛΣ$!21
\ΛΦ(!19
\ΜΑΚΡΥΣ!7
\ΜΑΚΡΥΣ_ΤΥΠΟΣ!23
\ΜΕ!3
\ΜΕ_Αντικείμενο!7
\ΜΕΓΑΛΟ(!19
\ΜΕΓΑΛΟ.ΣΕΙΡΑΣ$(!20
\ΜΕΓΑΛΟ.ΣΕΙΡΑΣ(!19
\ΜΕΓΕΘΟΣ.ΣΩΡΟΥ!21
\ΜΕΓΕΘΟΣ.Υ(!19
\ΜΕΓΕΘΟΣ.Χ(!19
\ΜΕΘΟΔΟΣ!7
\ΜΕΛΟΣ$(!20
\ΜΕΛΟΥΣ.ΤΥΠΟΣ$(!20
\ΜΕΛΩΔΙΑ!5
\ΜΕΡΟΣ!3
\ΜΕΡΟΣ$(!20
\ΜΕΣ$(!20
\ΜΕΤΑ!3
\ΜΕΤΑΒΛΗΤΕΣ ΣΥΣΤΗΜΑΤΟΣ!22
\ΜΕΤΑΘΕΣΗ!11
\ΜΕΤΑΘΕΣΗ(!19
\ΜΕΧΡΙ!3
\ΜΗΚΟΣ(!19
\ΜΗΚΟΣ.ΕΜΦ(!19
\ΜΙΚΡΟ(!19
\ΜΙΚΡΟ.ΣΕΙΡΑΣ$(!20
\ΜΙΚΡΟ.ΣΕΙΡΑΣ(!19
\ΜΙΚΡΟΣ.ΚΑΤΑΛΟΓΟΣ$(!20
\ΜΝΗΜΗ!21
\ΜΟΡΦΗ$(!20
\ΜΟΥΣΙΚΗ!5
\ΜΟΥΣΙΚΗ.ΜΕΤΡΗΤΗΣ!21
\ΜΠΙΠ!5
\ΜΠΡΟΣΤΑ(!19
\ΝΕΟ!14
\ΝΗΜΑ!15
\ΝΗΜΑΤΑ!15
\ΝΗΜΑΤΑ$!21
\ΞΕΚΙΝΑ!3
\ΟΔΗΓΟΣ$(!20
\ΟΘΟΝΗ!8
\ΟΘΟΝΗ ΚΑΙ ΑΡΧΕΙΑ!22
\ΟΚΝ$(!20
\ΟΛΑ!22
\ΟΜΑΔΑ!7
\ΟΜΑΔΑ$(!20
\ΟΜΑΔΑ(!19
\ΟΜΑΔΑ.ΣΥΝΟΛΟ(!19
\ΟΜΑΛΑ!1
\ΟΝΟΜΑ!11
\ΟΝΟΜΑ.ΑΡΧΕΙΟΥ$(!20
\ΟΝΟΜΑ.ΑΡΧΕΙΟΥ.ΜΟΝΟ$(!20
\ΟΝΟΜΑ.ΤΜΗΜΑΤΟΣ$!21
\ΟΝΟΜΑ.ΧΡΗΣΤΗ$!21
\ΟΡΙΟ.ΑΝΑΔΡΟΜΗΣ!14
\ΟΡΙΣΕ!7
\ΟΡΙΣΜΟΙ!22
\ΟΡΟΦ(!19
\ΟΧΙ!19
\ΠΑΙΖΕΙΦΩΝΗ!21
\ΠΑΙΚΤΗΣ!4
\ΠΑΙΞΕ!5
\ΠΑΝΩ!9
\ΠΑΝΩΜΙΣΟ(!19
\ΠΑΡΑΓΡΑΦΟΣ$(!20
\ΠΑΡΑΓΡΑΦΟΣ(!19
\ΠΑΡΑΘΕΣΗ$(!20
\ΠΑΡΑΘΥΡΟ!8
\ΠΑΡΑΘΥΡΟ (HWND)!21
\ΠΑΡΑΜ$(!20
\ΠΑΡΑΜ(!19
\ΠΑΡΑΜΕΤΡΟΙ$!21
\ΠΑΡΕ!11
\ΠΑΡΕΚΑΡΕ$!21
\ΠΑΡΕΜΒΟΛΗ!25
\ΠΑΤΗΜΕΝΟ(!19
\ΠΑΧΟΣ!1
\ΠΕΔΙΟ!8
\ΠΕΔΙΟ$(!20
\ΠΕΔΙΟ_μεταβλητή!21
\ΠΕΖ$(!20
\ΠΕΝΑ!8
\ΠΕΝΑ_μεταβλητή!21
\ΠΕΡΙ!14
\ΠΕΡΙ$!21
\ΠΕΡΙΘΩΡΙΟ!8
\ΠΕΡΙΘΩΡΙΟ _!8
\ΠΕΤΑ!9
\ΠΙ!23
\ΠΙΝΑΚΑΣ!7
\ΠΙΝΑΚΑΣ$(!20
\ΠΙΝΑΚΑΣ(!19
\ΠΙΣΩ(!19
\ΠΛΑΓΙΑ!8
\ΠΛΑΙΣΙΟ!8
\ΠΛΑΤΟΣ!21
\ΠΛΑΤΟΣ.ΣΗΜΕΙΟΥ!21
\ΠΛΑΤΦΟΡΜΑ$!21
\ΠΛΗΚΤΡΟΛΟΓΙΟ!14
\ΠΟΛΥΓΩΝΟ!1
\ΠΡΟΣ!3
\ΠΡΟΣΘΕΣΕ.ΕΓΓΡΑΦΟ!25
\ΠΡΟΣΘΗΚΗ!2
\ΠΡΟΣΩΡΙΝΟ$!21
\ΠΡΟΧΕΙΡΟ!14
\ΠΡΟΧΕΙΡΟ$!21
\ΠΡΟΧΕΙΡΟ.ΕΙΚΟΝΑ$!21
\ΠΡΩΤΟ(!19
\ΠΡΩΤΟΤΥΠΟ!14
\ΡΙΖΑ(!19
\ΡΟΗ ΠΡΟΓΡΑΜΜΑΤΟΣ!22
\ΡΟΥΤΙΝΑ!15
\ΡΥΘΜΙΣΕΙΣ!12
\ΡΩΤΑ$(!20
\ΡΩΤΑ(!19
\ΣΑΡΩΣΕ!13
\ΣΒΗΣΕ!8
\ΣΕΙΡΑ!9
\ΣΕΙΡΙΑΚΟΣ.ΔΙΣΚΟΥ(!19
\ΣΕΛΙΔΑ!17
\ΣΕΝΑΡΙΟ!14
\ΣΗΜ!14
\ΣΗΜ(!19
\ΣΗΜΑΔΙ!8
\ΣΗΜΕΙΟ!21
\ΣΗΜΕΙΟ(!19
\ΣΗΜΕΡΑ!21
\ΣΤΑΘΕΡΕΣ!22
\ΣΤΑΘΕΡΗ!7
\ΣΤΑΤΙΚΗ!7
\ΣΤΗ!7
\ΣΤΗΛΗ!21
\ΣΤΗΛΗ(!19
\ΣΤΟΚ!7
\ΣΤΟΧΟΙ!13
\ΣΤΟΧΟΙ ΚΑΙ ΕΠΙΛΟΓΗ!22
\ΣΤΟΧΟΣ!13
\ΣΤΡΟΓΓ(!19
\ΣΥΓΓΡΑΦΕΑΣ!14
\ΣΥΓΓΡΑΦΗ!14
\ΣΥΓΚΡΙΝΕ(!19
\ΣΥΓΚΡΟΥΣΗ(!19
\ΣΥΓΧΩΝΕΥΣΕ.ΕΓΓΡΑΦΟ!25
\ΣΥΜΠΙΕΣΗ!2
\ΣΥΝ(!19
\ΣΥΝΑΡΤΗΣΗ!15
\ΣΥΝΑΡΤΗΣΗ$(!20
\ΣΥΝΑΡΤΗΣΗ(!19
\ΣΥΝΕΧΙΣΕ!3
\ΣΥΣΚΕΥΗ.ΠΡΟΒΟΛΗΣ$!21
\ΣΥΣΤΗΜΑ!14
\ΣΥΧΝΟΤΗΤΑ(!19
\ΣΧΔ$(!20
\ΣΧΕΔΙΑ!11
\ΣΧΕΔΙΟ.ΝΗΜΑΤΩΝ!3
\ΣΩΡΟΣ!9
\ΣΩΡΟΣ$(!20
\ΣΩΡΟΣ(!19
\ΣΩΡΟΥΤΥΠΟΣ$(!20
\ΣΩΣΕ!14
\ΣΩΣΕ.ΕΓΓΡΑΦΟ!25
\ΤΑΙΝΙΑ!5
\ΤΑΙΝΙΑ.ΜΕΤΡΗΤΗΣ!21
\ΤΑΙΝΙΑ_μεταβλητή!21
\ΤΑΙΝΙΕΣ!11
\ΤΑΞΗ!2
\ΤΑΞΗ(!19
\ΤΑΞΙΝΟΜΗΣΗ!14
\ΤΑΞΙΝΟΜΗΣΗ(ΕΓΓΡΑΦΟΥ)!25
\ΤΑΥΤΙΣΗ(!19
\ΤΕΛΕΣΤΕΣ!14
\ΤΕΛΟΣ!14
\ΤΕΛΟΣ(!19
\ΤΙΚ!21
\ΤΙΜΗ!21
\ΤΙΜΗ(!19
\ΤΙΜΗΣΩΡΟΥ$(!20
\ΤΙΜΗΣΩΡΟΥ(!19
\ΤΙΤΛΟΣ!12
\ΤΙΤΛΟΣ$(!20
\ΤΙΤΛΟΣ.ΑΡΧΕΙΟΥ$(!20
\ΤΜΗΜΑ!15
\ΤΜΗΜΑ$!21
\ΤΜΗΜΑ(!19
\ΤΜΗΜΑΤΑ!15
\ΤΟΝΟΣ!5
\ΤΟΞ.ΕΦ(!19
\ΤΟΠΙΚΗ!7
\ΤΟΠΙΚΟ!8
\ΤΟΠΙΚΟ$(!20
\ΤΟΠΙΚΟ(!19
\ΤΟΠΟΣ$(!20
\ΤΟΠΟΣ.ΑΡΧΕΙΟΥ$(!20
\ΤΟΤΕ!3
\ΤΡΑΠ(!19
\ΤΥΠΟΣ!8
\ΤΥΠΟΣ$(!20
\ΤΥΠΟΣ.ΑΡΧΕΙΟΥ$(!20
\ΤΥΠΟΣ_μεταβλητή!21
\ΤΥΠΩΣΕ!16
\ΤΥΧΑΙΟΣ!21
\ΤΥΧΑΙΟΣ(!19
\ΤΩΡΑ!21
\Υ.ΣΗΜΕΙΑ!21
\ΥΠΑΡΧΕΙ(!19
\ΥΠΑΡΧΕΙ.ΚΑΤΑΛΟΓΟΣ(!19
\ΥΠΕΡΚΛΑΣΗ!7
\ΥΠΜΕΡ(!19
\ΥΠΟΚΑΤΑΛΟΓΟΣ!12
\ΥΠΟΛ!14
\ΥΠΟΛ#!14
\ΥΠΟΛΟΓΙΣΤΗΣ$!21
\ΥΠΟΜΝΗΜΑ!23
\ΥΠΩΡΑ(!19
\ΥΨΟΣ!21
\ΥΨΟΣ.ΣΗΜΕΙΟΥ!21
\ΦΑΚΕΛΟΣ$(!20
\ΦΑΝΕΡΟ$(!20
\ΦΑΡΔΙΑ!8
\ΦΕΡΕ!9
\ΦΕΡΕΠΙΣΩ!9
\ΦΘΙΝΟΥΣΑ!23
\ΦΙΛΤΡΟ$(!20
\ΦΟΝΤΟ!8
\ΦΟΡΜΑ!8
\ΦΟΡΜΑ$!21
\ΦΟΡΜΑΡΙΣΜΑ_ΑΛΦΑΡΙΘΜΗΤΙΚΩΝ!23
\ΦΟΡΜΑΡΙΣΜΑ_ΑΡΙΘΜΩΝ!23
\ΦΟΡΜΑΡΙΣΜΑ_ΓΙΑ ΚΑΘΕ ΤΥΠΟ!23
\ΦΟΡΜΑΡΙΣΜΑ_ΗΜΕΡΟΜΗΝΙΩΝ ΚΑΙ ΩΡΑΣ!23
\ΦΟΡΤΟΣ!21
\ΦΟΡΤΩΣΕ!14
\ΦΟΡΤΩΣΕ.ΕΓΓΡΑΦΟ!25
\ΦΩΝΗ!5
\ΦΩΤΟ$(!20
\Χ.ΣΗΜΕΙΑ!21
\ΧΑΡ$(!20
\ΧΑΡΑΚΤΗΡΕΣ!8
\ΧΑΡΑΞΕ!1
\ΧΑΡΚΩΔ$(!20
\ΧΑΡΚΩΔ(!19
\ΧΕΙΡΙΣΜΟΣ ΑΡΧΕΙΩΝ!22
\ΧΕΙΡΙΣΜΟΣ ΤΜΗΜΑΤΩΝ!22
\ΧΕΙΡΙΣΤΕΣ ΤΗΣ ΤΥΠΩΣΕ!22
\ΧΚΦ(!19
\ΧΡΗΣΗ!15
\ΧΡΟΝΟΣ$(!20
\ΧΡΟΝΟΣ(!19
\ΧΡΩΜΑ!1
\ΧΡΩΜΑ(!19
\ΧΡΩΜΑΤΑ!21
\ΧΡΩΜΑΤΙΣΕ!1
\ΨΕΥΔΕΣ!23
\ΨΕΥΔΗΣ!23
\ΨΗΦΙΟ!23
\#EVAL$(!20- 4
\#EVAL(!19- 5
\#FILTER(!19- 17
\#FOLD$(!20- 12
\#FOLD(!19- 13
\#MAP(!19- 3
\#MAX$(!20- 7
\#MAX(!19- 8
\#MIN$(!20- 10
\#MIN(!19- 11
\#POS(!19- 6
\#REV(!19- 2
\#SLICE(!19- 9
\#SORT(!19- 14
\#SUM(!19- 1
\#VAL$(!20- 15
\#VAL(!19- 16
\$(!24- 194
\?!16- 195
\@(!24- 196
\ABOUT!14- 409
\ABOUT$!21- 410
\ABS(!19- 59
\ADD.LICENSE$(!20- 79
\AFTER!3- 343
\ALL!22- 369
\AND!14- 267
\APPDIR$!21- 241
\APPEND!2- 428
\APPEND.DOC!25- 427
\ARITHMETIC FUNCTIONS!22- 61
\ARRAY$(!20- 416
\ARRAY(!19- 417
\ASC(!19- 304
\ASCENDING!23- 73
\ASK$(!20- 439
\ASK(!19- 440
\ATN(!19- 512
\AUTO_ARRAYS!7- 75
\BACK!8- 412
\BACKGROUND!8- 411
\BACKWARD(!19- 418
\BANK(!19- 520
\BASE!2- 81
\BEEP!5- 358
\BINARY!7- 147
\BINARY.ADD(!19- 156
\BINARY.AND(!19- 153
\BINARY.NEG(!19- 150
\BINARY.NOT(!19- 155
\BINARY.OR(!19- 152
\BINARY.ROTATE(!19- 146
\BINARY.SHIFT(!19- 154
\BINARY.XOR(!19- 151
\BINARY_const!23- 157
\BITMAPS!11- 176
\BITMAP COMMANDS!22- 210
\BMP$(!20- 169
\BOLD!8- 544
\BOOLEAN!23- 319
\BREAK!3- 136
\BROWSER!10- 37
\BROWSER$!21- 38
\BROWSER COMMANDS!22- 211
\BUFFER!7- 128
\BUFFER(!19- 129
\BYTE!23- 580
\CALL!3- 268
\CAR(!19- 433
\CASE!3- 328
\CDATE(!19- 533
\CDR(!19- 236
\CEIL(!19- 383
\CHANGE!13- 24
\CHARSET!8- 563
\CHOOSE.COLOR!12- 227
\CHOOSE.FONT!12- 225
\CHOOSE.ORGAN!5- 226
\CHR$(!20- 562
\CHRCODE$(!20- 565
\CHRCODE(!19- 566
\CIRCLE!1- 301
\CLASS!7- 290
\CLEAR!14- 264
\CLIPBOARD!14- 430
\CLIPBOARD$!21- 431
\CLIPBOARD.IMAGE$!21- 432
\CLOSE!11- 292
\CLS!8- 366
\CODEPAGE!21- 305
\COLLIDE(!19- 467
\COLOR!1- 574
\COLOR(!19- 575
\COLORS!21- 576
\COMMAND$!21- 214
\COMMIT!9- 35
\COMMON DIALOGUES!22- 295
\COMPARE(!19- 466
\COMPRESS!2- 469
\COMPUTER$!21- 537
\CONS(!19- 217
\CONSOLE COMMANDS!22- 212
\CONST!7- 454
\CONSTANTS!22- 453
\CONTINUE!3- 474
\CONTROL$!21- 551
\COPY!4- 48
\COS(!19- 470
\CTIME(!19- 539
\CURRENCY!23- 320
\CURSOR!8- 145
\CURVE!1- 269
\DATA!9- 443
\DATABASES!22- 80
\DATE$(!20- 244
\DATE(!19- 245
\DATEFIELD!23- 246
\DB.PROVIDER!2- 83
\DB.USER!2- 84
\DECLARE!7- 381
\DEF!7- 270
\DEFINITIONS!22- 382
\DELETE!2- 76
\DESCENDING!23- 547
\DESKTOP!8- 235
\DIM!7- 415
\DIMENSION(!19- 131
\DIR!12- 273
\DIR$!21- 272
\DIV!14- 119
\DIV#!14- 120
\DO!3- 222
\DOC.LEN(!19- 164
\DOC.PAR(!19- 166
\DOC.UNIQUE.WORDS(!19- 165
\DOC.WORDS(!19- 163
\DOCUMENT!7- 162
\DOCUMENTS!22- 160
\DOS!14- 297
\DOUBLE!8- 140
\DOUBLE_as constant!23- 141
\DRAW!1- 564
\DRAWINGS!11- 479
\DRAWING 2D!22- 99
\DRIVE$(!20- 365
\DRIVE.SERIAL(!19- 444
\DROP!9- 413
\DRW$(!20- 478
\DURATION!21- 130
\EACH(!19- 266
\EDIT!14- 465
\EDIT.DOC!25- 139
\ELSE!3- 27
\ELSE.IF!3- 28
\EMPTY!21- 280
\END!14- 497
\ENUM!7- 49
\ENUMERATION!7- 50
\ENVELOPE$(!20- 542
\EOF(!19- 498
\ERROR!15- 311
\ERROR$!21- 312
\ESCAPE!15- 135
\EVAL$(!20- 190
\EVAL(!19- 191
\EVENT!7- 88
\EVERY!3- 265
\EXECUTE!2- 185
\EXIST(!19- 530
\EXIST.DIR(!19- 531
\EXIT!3- 219
\FALSE _2!23- 578
\FALSE!23- 579
\FAST!14- 101
\FIELD!8- 403
\FIELD$(!20- 404
\FIELD_as variable!21- 405
\FILE$(!20- 67
\FILE.APP$(!20- 240
\FILE.NAME$(!20- 376
\FILE.NAME.ONLY$(!20- 377
\FILE.PATH$(!20- 518
\FILE.STAMP(!19- 69
\FILE.TITLE$(!20- 506
\FILE.TYPE$(!20- 523
\FILELEN(!19- 68
\FILES!11- 65
\FILE OPERATIONS!22- 567
\FILL!1- 85
\FILTER$(!20- 548
\FIND!25- 238
\FKEY!14- 291
\FLOODFILL!1- 89
\FLOOR(!19- 102
\FLOW CONTROL!22- 436
\FLUSH!9- 18
\FONT!8- 93
\FONTNAME$!21- 94
\FOR!3- 91
\FORM!8- 550
\FORMAT$(!20- 355
\FORMATTING_ANY TYPE!23- 554
\FORMATTING_DATE AND TIME!23- 555
\FORMATTING_NUMBERS!23- 553
\FORMATTING_STRINGS!23- 552
\FORWARD(!19- 359
\FRAC(!19- 112
\FRAME!8- 420
\FREQUENCY(!19- 477
\FUNCTION!15- 471
\FUNCTION$(!20- 472
\FUNCTION(!19- 473
\GET!11- 398
\GLOBAL!7- 90
\GOSUB!3- 127
\GOTO!3- 426
\GRABFRAME$!21- 399
\GRADIENT!8- 549
\GREEK!8- 201
\GREEK_variable!21- 202
\GROUP!7- 370
\GROUP$(!20- 371
\GROUP(!19- 372
\GROUP.COUNT(!19- 373
\HALT!15- 29
\HEIGHT!21- 540
\HELP!14- 87
\HEX!16- 113
\HEX$(!20- 114
\HIDE!8- 442
\HIDE$(!20- 299
\HIGHWORD(!19- 389
\HILOWWORD(!19- 158
\HOLD!8- 298
\HSL(!19- 570
\HWND!21- 394
\ICON!8- 177
\IF!3- 31
\IF$(!20- 32
\IF(!19- 33
\IMAGE!4- 170
\IMAGE(!19- 171
\IMAGE.X(!19- 174
\IMAGE.X.PIXELS(!19- 175
\IMAGE.Y(!19- 172
\IMAGE.Y.PIXELS(!19- 173
\INFINITY!23- 52
\INKEY$!21- 205
\INKEY(!19- 206
\INLINE!15- 204
\INPUT!16- 181
\INPUT$(!20- 182
\INSERT!25- 400
\INSTR(!19- 253
\INT(!19- 19
\INTEGER!23- 21
\INTERNET!21- 123
\INTERNET$!21- 124
\INTERPRETER!22- 137
\INVENTORY!7- 274
\IS!14- 178
\ISLET!21- 180
\ISNUM!21- 179
\ISWINE!23- 192
\ITALIC!8- 419
\JOYPAD!6- 306
\JOYPAD(!19- 307
\JOYPAD.ANALOG.X(!19- 309
\JOYPAD.ANALOG.Y(!19- 308
\JOYPAD.DIRECTION(!19- 310
\JPG$(!20- 560
\KEY$!21- 296
\KEYBOARD!14- 424
\KEYPRESS(!19- 401
\LAMBDA!7- 314
\LAN$!21- 138
\LATIN!8- 315
\LAYER!8- 233
\LAZY$(!20- 368
\LCASE$(!20- 406
\LEFT$(!20- 63
\LEFTPART$(!20- 64
\LEGEND!8- 223
\LEN(!19- 348
\LEN.DISP(!19- 349
\LET!7- 456
\LETTER$!21- 92
\LINE INPUT!11- 97
\LINESPACE!8- 132
\LINK!15- 216
\LIST!14- 317
\LN(!19- 325
\LOAD!14- 557
\LOAD.DOC!25- 558
\LOCAL!7- 513
\LOCALE!8- 514
\LOCALE$(!20- 515
\LOCALE(!19- 516
\LOG(!19- 318
\LONG!7- 326
\LONG_TYPE!23- 327
\LOOP!3- 300
\LOWWORD(!19- 277
\LTRIM$(!20- 57
\MAIN.TASK!3- 303
\MARK!8- 449
\MATCH(!19- 495
\MAX(!19- 330
\MAX.DATA$(!20- 331
\MAX.DATA(!19- 332
\MDB(!19- 82
\MEMBER$(!20- 337
\MEMBER.TYPE$(!20- 338
\MEMO!23- 538
\MEMORY!21- 354
\MENU!13- 230
\MENU$(!20- 231
\MENU.VISIBLE!21- 229
\MENUITEMS!21- 228
\MENU_as variable!21- 232
\MERGE.DOC!25- 468
\METHOD!7- 336
\MID$(!20- 342
\MIN(!19- 350
\MIN.DATA$(!20- 351
\MIN.DATA(!19- 352
\MOD!14- 535
\MOD#!14- 536
\MODE!8- 521
\MODE_variable!21- 524
\MODULE!15- 507
\MODULE$!21- 508
\MODULE(!19- 509
\MODULE.NAME$!21- 378
\MODULES!15- 510
\MODULE COMMANDS!22- 568
\MONITOR!14- 198
\MONITOR.STACK!21- 200
\MONITOR.STACK.SIZE!21- 199
\MOTION!8- 282
\MOTION.W!8- 283
\MOTION.WX!21- 285
\MOTION.WY!21- 284
\MOTION.X!21- 288
\MOTION.XW!21- 289
\MOTION.Y!21- 286
\MOTION.YW!21- 287
\MOUSE!21- 104
\MOUSE.ICON!6- 103
\MOUSE.KEY!21- 106
\MOUSE.X!21- 108
\MOUSE.Y!21- 107
\MOUSEA.X!21- 110
\MOUSEA.Y!21- 109
\MOUSE COMMANDS!22- 209
\MOVE!1- 252
\MOVIE, MEDIA!5- 487
\MOVIE.COUNTER!21- 488
\MOVIE.DEVICE$!21- 475
\MOVIE.ERROR$!21- 313
\MOVIE.STATUS$!21- 275
\MOVIES!11- 490
\MOVIE_as variable!21- 489
\MUSIC!5- 356
\MUSIC.COUNTER!21- 357
\NAME!11- 375
\NEW!14- 360
\NORMAL!8- 271
\NOT!19- 384
\NOT_2!19- 115
\NOW!21- 528
\NUMBER!21- 500
\ON!3- 54
\OPEN!11- 47
\OPEN.FILE!12- 45
\OPEN.IMAGE!12- 46
\OPERATORS!14- 496
\OPERATORS IN PRINT!22- 569
\OR!14- 242
\ORDER!2- 491
\ORDER(!19- 492
\OS$!21- 324
\OSBIT!21- 193
\OVER!9- 388
\OVERWRITE!25- 276
\PAGE!17- 445
\PARAGRAPH$(!20- 390
\PARAGRAPH(!19- 391
\PARAGRAPH.INDEX(!19- 62
\PARAM$(!20- 395
\PARAM(!19- 396
\PARAMETERS$!21- 397
\PART!3- 340
\PATH$(!20- 517
\PEN!8- 407
\PEN_variable!21- 408
\PI!23- 414
\PIECE$(!20- 341
\PIPE!15- 71
\PIPENAME$(!20- 72
\PLATFORM$!21- 423
\PLAY!5- 387
\PLAYER!4- 386
\PLAYSCORE!21- 385
\POINT!21- 450
\POINT(!19- 451
\POINTER(!19- 105
\POLYGON!1- 425
\POS!21- 256
\POS.X!21- 255
\POS.Y!21- 254
\PRINT!16- 525
\PRINTER!17- 188
\PRINTERNAME$!21- 189
\PRINTING!17- 187
\PRINTINGS!22- 186
\PROFILER!3- 39
\PROPERTIES!17- 261
\PROPERTIES$!21- 262
\PROPERTY!7- 258
\PROPERTY$(!20- 259
\PROPERTY(!19- 260
\PROTOTYPE!14- 434
\PSET!1- 577
\PUSH!9- 78
\PUT!11- 159
\QUOTE$(!20- 392
\RANDOM(!19- 527
\READ!9- 121
\READY(!19- 237
\RECORDS(!19- 161
\RECURSION.LIMIT!14- 380
\REFER!9- 51
\REFRESH!8- 41
\RELEASE!8- 77
\REM!14- 447
\REMOVE!14- 122
\REPEAT!3- 221
\REPLACE$(!20- 25
\REPORT!8- 43
\REPORTLINES!21- 95
\RESTART!3- 364
\RETRIEVE!2- 36
\RETURN!2- 234
\RIGHT$(!20- 116
\RIGHTPART$(!20- 117
\RINSTR(!19- 257
\RND!21- 526
\ROUND(!19- 463
\ROW!21- 96
\RTRIM$(!20- 58
\SAVE!14- 485
\SAVE.AS!12- 55
\SAVE.DOC!25- 486
\SCALE.X!21- 294
\SCALE.Y!21- 293
\SCAN!13- 441
\SCORE!5- 559
\SCREEN AND FILES!22- 367
\SCRIPT!14- 446
\SCROLL!8- 302
\SEARCH!2- 34
\SEEK!11- 345
\SEEK(!19- 346
\SELECT!3- 224
\SET!7- 251
\SETTINGS!12- 438
\SGN(!19- 448
\SHIFT!9- 545
\SHIFTBACK!9- 546
\SHORTDIR$(!20- 353
\SHOW!8- 44
\SHOW$(!20- 543
\SIN(!19- 243
\SINGLE!23- 53
\SINT(!19- 20
\SIZE.X(!19- 335
\SIZE.Y(!19- 334
\SLOW!14- 60
\SMOOTH!1- 374
\SND$(!20- 247
\SORT!14- 493
\SORT(DOCUMENT)!25- 494
\SOUND!5- 250
\SOUNDS!11- 248
\SOUNDS AND MOVIES!22- 249
\SPEECH as variable!21- 322
\SPEECH!5- 321
\SPEECH$(!20- 323
\SPRITE!4- 134
\SPRITE$!21- 133
\SQRT(!19- 435
\STACK!9- 481
\STACK$(!20- 482
\STACK(!19- 483
\STACK.SIZE!21- 333
\STACKITEM$(!20- 502
\STACKITEM(!19- 503
\STACKTYPE$(!20- 484
\STACK COMMANDS!22- 213
\START!14- 70
\STATIC!7- 455
\STEP!1- 86
\STOCK!7- 459
\STOP!15- 125
\STR$(!20- 98
\STRING$(!20- 220
\STRING FUNCTIONS!22- 30
\STRREV$(!20- 42
\STRUCTURE!2- 144
\SUB!15- 437
\SUBDIR!12- 534
\SUPERCLASS!7- 532
\SWAP!7- 26
\SWITCHES!14- 126
\TAB!21- 457
\TAB(!19- 458
\TABLE!2- 66
\TAN(!19- 239
\TARGET!13- 462
\TARGETS!13- 460
\TARGET AND MENU!22- 461
\TEMPNAME$!21- 203
\TEMPORARY$!21- 429
\TEST!14- 142
\TEST(!19- 143
\TEXT, HTML!10- 278
\TEXT_as constant!23- 279
\THEN!3- 519
\THIS!21- 74
\THREAD!15- 361
\THREAD.PLAN!3- 480
\THREADS!15- 362
\THREADS$!21- 363
\TICK!21- 499
\TIME$(!20- 572
\TIME(!19- 573
\TIMECOUNT!21- 556
\TITLE!12- 504
\TITLE$(!20- 505
\TODAY!21- 452
\TONE!5- 511
\TRIM$(!20- 56
\TRUE _2!23- 22
\TRUE!23- 23
\TRY!3- 118
\TUNE!5- 339
\TWIPSX!21- 422
\TWIPSY!21- 541
\TYPE$(!20- 522
\UCASE$(!20- 281
\UINT(!19- 149
\UNION.DATA$(!20- 218
\UNTIL!3- 347
\USE!15- 571
\USER.NAME$!21- 379
\USGN(!19- 148
\VAL(!19- 501
\VALID(!19- 168
\VARS READ ONLY!22- 344
\VERSION!14- 183
\VERSION_as constant!23- 184
\VIEW!2- 111
\VOLUME!5- 207
\VOLUME_as variable!21- 208
\WAIT!3- 40
\WEAK$(!20- 263
\WHILE!3- 215
\WIDTH!1- 402
\WIDTH_as variable!21- 421
\WIN!14- 476
\WINDOW!8- 393
\WITH!7- 329
\WORDS!25- 316
\WRITABLE(!19- 167
\WRITE!11- 100
\WRITER!14- 464
\X.TWIPS!21- 561
\Y.TWIPS!21- 529
\~(!24- 197