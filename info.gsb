MODULE A {Superclass alfa {
      Unique:
            counter=1
      Public:
            Value {
                  For SuperClass {
                        =.counter
                        .counter++
                  }
            }
            Module Reset (x){
                  For SuperClass {
                        .counter<=x
                  }                  
            }
}
a=alfa
b=alfa
Print a=1, b=2, a=3, a=4, b=5 ' true true true true true
\\ we have to use group(a) to get the group not the value
\\ we use ( ) to get a copy
z->(group(a))
Print eval(z)=6, a=7, b=8, eval(z)=9 ' true true true true
z=>Reset 100
Print eval(z)=100, a=101, b=102, eval(z)=103 ' true true true true
For z {
      .Reset 10
}
Print eval(z)=10, a=11, b=12, eval(z)=13 ' true true true true
}
MODULE B {\\ m is an auto array (a tuple)
\\ z is an iterator of m
m=(1,2) : Print valid(m^)=false ' bug return valid(m^)=true
z=each(m): Print Valid(z^)=true
}
MODULE C {dim a(), b()
a()=(1,2,3)
b()=(3,2,1)
for i=0 to 2
print max(a(i), b(i)), max(b(i), a(i))
print min(a(i),b(i)), min(b(i), a(i))
print compare(a(i), b(i)), a(i), b(i)
next i


dim a()
a()=(1,2,3)
for i=0 to 2
print max(a(2-i), a(i)), max(a(2-i), a(i))
print min(a(2-i),a(i)), min(a(2-i), a(i))
print compare(a(i), a(2-i)), a(2-i), a(i)
next i
}
MODULE B1 {Module FadeScreen  {
      static Img1, tempo=1, gx=3, gy=5
      ? tempo, gx, gy
}
FadeScreen      
}
MODULE BB {Print "Press Esc to exit"
m=false
Every 100 {
if mouse.key then { m=true } else m=false
print not m
}
}
MODULE BB1 {while not mouse { print mouse ,  not -mouse}
? "ok"
}
MODULE D {\\ Identifiers in Greek language
\\ see DR for the same program with statements in English language

\\ [] return the pointer of last current stack, and leave an empty current stack

Τμήμα Λατινικοί_Αριθμοί {
      Άδειασε
      Διαμέσου Αρχικοποίηση
      Έγγραφο Εγγ$
      Ενώ όχι κενό
            Διάβασε λατ$
            Τύπωσε λατ$;"=";ΤιμήΛατινικού$(λατ$)
            Εγγ$=λατ$+"="+ΤιμήΛατινικού$(λατ$)+{
            }
      Τέλος Ενώ
      Πρόχειρο Εγγ$
      Τέλος
Αρχικοποίηση:
      Συνάρτηση ΤιμήΛατινικού$(λατ$) {
            Άδειασε
             ="άκυρο"           
            Αν Φίλτρο$(λατ$,"MDCLXVI")<>"" Τότε Έξοδος
            \\ θα μπουν ανάποδα, το τελευταίο πρώτο.
            Βάλε "CM", "MD", "Q","CD", "MD","W", "XC", "DL", "E","XL", "X","R", "IX","V","T", "IV","I","Y"
            διπλό_λατινικό=[]
            \\ θα μπουν με το τελευταίο να είναι τελευταίο.
            Σειρά "M", 1000, "Q",900,"D", 500,"W", 400,"C",100,"E",90, "L",50,"R", 40,"X", 10, "T", 9, "V", 5, "Y", 4, "I",1
            απλό_λατινικό=[]
            σύνολο=0
            μια_τιμή=0
            μετρητής=0
            Σωρός διπλό_λατινικό {
                  Αν κενό Τότε Έξοδος
                  Διάβασε απ$, μη_έγγυροι_χαρακτήρες$,χαρακτ$
                  ι=Θέση(λατ$,χαρακτ$)
                  Αν ι >0 Τότε
                        προσωρινή_τιμή$=Μεσ$(λατ$,ι+2)
                        λ=Μήκος(προσωρινή_τιμή$)
                        Αν λ>0 Τότε Αν Μήκος(Φίλτρο$(προσωρινή_τιμή$, μη_έγγυροι_χαρακτήρες$))<>λ Τότε λατ$="A": Έξοδος
                        Αν Θέση(λατ$,Μεσ$(λατ$,ι,1))<ι Τότε λατ$="A": Έξοδος
                        insert ι, 2 λατ$=απ$ '  2 λέμε αλλα δίνουμε 1 χαρακτήρα και ο μεταφραστής θα βάλει ένα διάστημα 
                  Τέλος Αν
                  Κυκλικά
            }
            λατ$=Φίλτρο$(λατ$," ")
            Σωρός απλό_λατινικό {
                  Αν κενό Τότε Έξοδος
                  Διάβασε χαρακτ$, μια_τιμή
                  μετρητής=0
                  Ενώ Αρισ$(λατ$,1)=χαρακτ$
                         Παρεμβολή 1, 1 λατ$=""
                         μετρητής++
                         σύνολο+=μια_τιμή
                  Τέλος Ενώ
                  Αν μετρητής>3 Τότε έξοδος
                  Κυκλικά
            }
            Αν Μήκος(λατ$)>0 ή μετρητής>3 Αλλιώς
            =Γραφή$(σύνολο,1033)
            Τέλος Αν
      }
      Σειρά "MMMCMXCIX", "LXXIIX", "MMXVII", "LXXIX", "CXCIX","MCMXCIX","MMMDCCCLXXXVIII"
      Σειρά "CMXI","M","MCDXLIV","CCCC","IXV", "XLIXL","LXXIIX","IVM"
      Σειρά "XXXIX", "XXXX", "XIXX","IVI", "XLIX","XCIX","XCIV","XLVIII"
      Επιστροφή
}
Λατινικοί_Αριθμοί
}
MODULE DD {class beta {
      structure alfa1 {
            a as long*4
            b as long*4
      }
      structure alfa {
            a as long*4
            b as long*4
            c as alfa1*3
      }
      buffer delta as alfa*3
}
beta=beta()
Print beta.alfa("b")
list
}
MODULE DD1 {local group alfa {
      x=10, y%=50, z$="asdasda"
      dim M(4)=10
      event alfa {read b}
      document a$="100"
      class allo {
            q=4
      }
      Group M {
            k=10
      }
      function delta {
           
      }
      module kappa {
           
      }
}
local group alfa {
      x=10, y%=50,z$="asdasda"
      dim M(4)=10
      event alfa {read b}
      document a$="100"
      class allo {
            q=4
      }
      Group M {
            k=10
      }
      function delta {
           
      }
      module kappa {
           
      }
}

List
Modules ?

}
MODULE DD2 {const b=lambda->100
const b%=lambda->100
const b$=lambda$->"hello"
Print b%()
Print b$()
Try {
      b=lambda->500
}
Print b()
}
MODULE DD3 {\\ this is in a global module A
group alfa {
      x=100
      b=lambda->{
            =.x
            .x++
      }
}
\\ get a copy to alfa
beta=alfa
\\ try to change function with a fake one
function alfa.b {
      =500
}
\\ references for functions are strings with code
\\ we get  {CALL EXTERN 3}A.ALFA. (but is not the actual hard link.
\\ actual code is in lambda object. 3 is the actual "slot" where the object exist.
Print &alfa.b()
\\ we can make a link to f() (only for new identifiers)
Link  alfa.b() to f()
Print f()
\\ this function can be changed because has no "hard link" with lambda
\\ all functions except final in groups can be changed
function f {
      =500
}
Print f()=500
Print alfa.b()
Print  beta.b()
\\ we can test pointers
\\ there is two type of pointers
\\ 1. pointers to float groups (holded in containers or by pointers)
\\ 2. pointer to named groups (using a weak reference)
\\ this type has no use when referenced group get out of scope
\\ but as all pointers can change value later
\\ pointers can be null, using p->0 but they hold just an empty group
\\ so never a pointer in M2000 has a real null value, but an "empty" one.

\\ p->(beta) is the same as this:
p=pointer((beta)) ' a copy of beta
Print p=>b(), p=>b()
Print beta.b()
\\ p->beta is same as this
p=pointer(beta) ' as reference to beta
Print p=>b(), p=>b()
}
MODULE DD4 {n=lambda ->500
a=lambda n (x)->{
      if x<=0 then=0 : exit
      =lambda(x-1)+x+n()
}
Print a(3)=1506
Print a(10)=5055
n=lambda->100
\\ closures are copies, and are like globals for lambda
Print a(3)=1506
\\ closures can be change only from inside
\\ if they are value types (lambda is a value type)
m=lambda->100
a=lambda n, m (x)->{
      if x>5 then n=lambda ->500
      if x<=0 then=0 : n=m : exit
      =lambda(x-1)+x+n()
}

Print a(3)=306
Print a(10)=1055
\\ touple is an array, can have zero items (,)
\\ or one ore more, and it is a reference type
z=(m,)
Link z to Z()
Print Z(0)()=100
a=lambda z (x) -> {
      if x<=0 then=0 : exit
      link z to z()
      =lambda(x-1)+x+z(0)()
}
\\ now we change value in z(0), which is the z
Print a(10)=1055
z(0)=lambda->300
\\ so now lambda change because hold a closure to a reference
Print a(10)=3055
Print eval(z)(0)()=300
\\ without using link we can get the first element in 0 posiiton, and ask for function
\\ this function has a life for the moment of call
\\ interpreter just open the lambda object, invoke, and close again.
a=lambda z (x) -> {
      if x<=0 then=0 : exit
      =lambda(x-1)+x+Eval(z)(0)()
}
Print a(10)=3055
}
MODULE DD5 {class a {
      counter as long
}
b=lambda k=pointer(a()) (x)-> {
      k=>counter+=x
      \\ we can return pointers from groups (if they are float type)
      ->k
}
m=b(30)
Print m=>counter=30
\\ get a pointer and convert it to a named group, and then return  a float group (as is, without pointer)
def copy(x as group)=x
group k=b(300)
z=b(300)
Print z=>counter=630
Print m=>counter=630
Print z is m ' false
z->b(300)
Print z is m 'true
Print z=>counter=930
Print k.counter=330 ' old value
}
MODULE DD6 {group beta {
      x$="1000mm"
      m=100
}
\\  beta copied here
inventory alfa=1:=(list:=1,2,300:=(1,2,3,3,5,beta), 500:="ok")

dim g()
\\  beta copied here
g()=(100,beta,(1, (list:=1:=beta,2,"z":=(1,200,3,alfa), "s":="string"), "Hello there"), 500@, "ok")
g(1).m*=100
Print g(1).m=10000
link g() to g$()
Print type$(g(2), 1)="Inventory"
Print type$(g(2), 1!)="List"   ' show type of inventory (list or queue)
Print type$(g(2), 2)="String", g(2)#val$(2)="Hello there"
Print g$(2)(2)="Hello there"    ' using g$() a reference to g()
Print g$(2)(1)("s")="string"
Print g$(2)(1)("z")(3)(1)(500)="ok"
\\ new this also
Print  g(2)(1)("z")(3)(1)(300)(5).m=100 ' multiple object opening until a group object
\\ new this also. we can get a pointer from inner group
n->g(2)(1)("z")(3)(1)(300)(5)
Print n=>m=100
n=>m++ ' increment one
Print g(2)(1)("z")(3)(1)(300)(5).m=101
Print g(2)(1)("z")(3)(1)(300)(5).x$="1000mm"
n=>x$="2000mm"
Print g(2)(1)("z")(3)(1)(300)(5).x$="2000mm"
m=g() ' we get a pointer to array ' these are not the same as the group's pointers
\\ stacks, inventories and arrays (not those we make with Dim) are pointers
\\ we can use IS operator to check two of them if show same object
z=list:=100, 150:=m, 200
Print z(150)(2)(1)("z")(3)(1)(300)(5).m=101
\\ using g() we pass a copy
\\ but anything which is a pointer (like a list, or a pointer to array) only pointer copied
\\ groups may have or may haven't pointers. Those with no pointers copied when we get an array copy.
\\ Only arrays with names with parenthesis copied. So here we get a copy of g().
z=list:=100, 150:=g(), 200
g(1).m+=100
Print g(1).m=10100
Print z(150)(2)(1)("z")(3)(1)(300)(5).m=101 ' group has a pointer/ also list is the same
Print z(150)(1).m=10000 ' group copied
n=>m++
Print z(150)(2)(1)("z")(3)(1)(300)(5).m=102
Print g(2)(1)("z")(3)(1)(300)(5).m=102
}
MODULE DD7 {module Checkit {
      Stack New {
            Data "foo://example.com:8042/over/there?name=ferret#nose", "urn:example:animal:ferret:nose"
            Data "jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true", "ftp://ftp.is.co.za/rfc/rfc1808.txt"
            Data "http://www.ietf.org/rfc/rfc2396.txt#header1", "ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two"
            Data "mailto:John.Doe@example.com", "news:comp.infosystems.www.servers.unix", "tel:+1-816-555-1212"
            Data "telnet://192.0.2.16:80/", "urn:oasis:names:specification:docbook:dtd:xml:4.1.2", "ssh://alice@example.com"
            Data "https://bob:pass@example.com/place", "http://example.com/?a=1&b=2+2&c=3&c=4&d=%65%6e%63%6F%64%65%64"
            a=Array([])
      }
      function prechar$(a$, b$) {
            if a$<>"" then {=quote$(b$+a$)} else ={""}
      }
      z=each(a)
      document s$="["+{
      }
      While z {
            a$=array$(z)
            s1$={           "uri": }+quote$(a$)+{,
                  "authority": }+ quote$(string$(a$ as URLAuthority))+{,
                  "userInfo": }+ quote$(string$(a$ as URLUserInfo))+{,
                  "scheme": }+quote$(string$(a$ as URLScheme))+{,
                  "hostname": }+quote$(string$(a$ as UrlHost))+{,
                  "Port": }+quote$(string$(a$ as UrlPort))+{,
                  "pathname": }+quote$(string$(a$ as UrlPath))+{,
                  "search": }+prechar$(string$(a$ as URLpart 6),"?")+{,
                  "hash": }+prechar$(string$(a$ as UrlFragment),"#")+{
            }
            s$="     {"+{
            }+s1$+"     }"
            \\ z^ is the iteraror's counter (z is an iterator of a, a touple - array in M2000)
            if z^<len(a)-1 then s$=" ,"   ' append to document
            s$={
            }
      }
      s$="]"
      Print "Press any keyboard key or mouse key to continue scrolling"
      Report s$   
      Clipboard s$
}
Checkit
}
MODULE DD8 {Module Pairs {
      \\ written in version 9.5 rev. 13
      \\ use Gdi+ antialiasing (not work with Wine in Linux, but we get no error)
      smooth on
      Const center=2, right=3, left=1, blue=1, angle=0, dotline=3
      Const size9pt=9, size11pt=11
      Cls ,0 ' use current background color, set split screen from line 0
      Cursor 0,3
      Report center, "Coordinate pairs"
      x = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
      y = (2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0)
      dx=scale.x/2/len(x)
      dy=dx 'ratio 1:1
      graH=dy*len(x)
      Basex=scale.x/4
      Basey=(scale.y+graH)/2
      Move Basex, Basey
      \\ draw use relative coordinates
      Draw 0,-graH
      \\ Step just move graphic cursor
      Step 0, graH
      Draw scale.x/2
      Step -scale.x/2
      \\ scX is 1, not used
      max=Y#max()
      \\ Auto scale for Y, using 0 for start of axis Y
      scY=-graH/((max+5^log(max) ) div 100)/100
      \\ make vertical axis using dots with numbers center per dx
      j=1
      For i=basex+dx to basex+dx*x#max() Step dx
            Move i, basey
            Step 0, twipsy*10
            Legend format$("{0}",array(x,j)), "courier", size9pt, angle, center
            Width 1, dotline { draw 0, -graH-twipsy*10,7}
            j++
      Next i
      \\ the same for horizontal axis
      HalfTextHeight=Size.y("1","courier", size9pt)/2
      For i=basey-dy to basey-dy*x#max() Step dy
            Move basex, i
            Step -twipsx*10
            Width 1, dotline { draw scale.x/2+twipsx*10,,7}
            Move basex-100, i+HalfTextHeight
            Legend format$("{0}",(i-basey)/scY), "courier", size9pt, angle, left
      Next i
      ex=each(x) : ey=each(y)
     \\ start from first point. We use Draw to for absolute coordinates
      Move array(x,0)*dx+Basex, array(y,0)*scy+Basey
      While ex, ey {
            Width 2 {
                  Draw to array(ex)*dx+Basex, array(ey)*scy+Basey, blue
            }
      }
      \\ second pass for marks and labels
      ex=each(x) : ey=each(y)
      While ex, ey {
            Move array(ex)*dx+Basex, array(ey)*scy+Basey
            Step -75, -75
            Pen 12 {draw 150: draw 0,150 : draw -150 : draw 0,-150}
            Pen 13 {
                  Step 200, -200
                  Legend format$("({0}-{1})",array(ex),array(ey) ), "courier bold", size11pt, angle, right
            }
      }
      \\ screenshot to clipboard
      Screenshot$=""
      Move 0,0
      Copy scale.x, scale.y to Screenshot$
      Clipboard Screenshot$
      a$=key$
}
Pairs
}
MODULE DD9 {a=10
Module Checkit {
      if random(10)=1 then Clear ' erase all statics and variables from this level
      Module Checkit {
            flush
            module Checkit {
                  static k=(Queue:=1,2)
                  Try {
                        Read ? k as queue
                  }
                  Print type$(k)
                  Print k
            }
            group alfa {
                  x=10
            }
            z->(alfa)
            Checkit
            Checkit z
            Checkit (Queue:=1,2,3,1,2,3)
            Checkit (List:=1,2,3)
      }
      Checkit
}
Checkit
Print a ' a exist always
}
MODULE F1 {Group alfa {
      private:
            x=10
      public:
      \\ we can use Print as module name
      Module Print {
            Print .x
      }
      Module IncX {
            .x++
      }
}
alfa.print    ' print 10
Print valid(alfa.x)=false
alfa.incX
alfa.print   ' print 11
}
MODULE F2 {module checkit {
      def long counter=0
      class b1 {
            x=10
      }
      \\ b is a pointer to a new group from b1()
      b->b1()
      Try {
            beta()
      }
      Print Error$ ' z not found in scope, we can't use it as pointer
      \\ z is a pointer to a new group from b1()
      z->b1()
      \\ now z exist
      alfa() ' 11 - use of internal pointer to group
      beta() ' 11
      Print b=>x=10 ' true
      alfa(z) ' 12
      alfa(z) '13
      beta() ' 14
      alfa() ' 11  - use of internal pointer to group
      Print b=>x=10 ' true
      alfa(b) '11
      alfa(b) '12
      Print b=>x=12 ' true
      Print z=>x=14
      beta() ' 15
      Print z=>x=15
      Print counter

      Sub alfa()
            \\ we make a local variable b
            \\ we assign a fresh group
            \\ then we read optional a pointer
            local b : b->b1() : Read ? b as pointer
            \\ now we make a second local variable
            \\ we assign a pointer
            local z : z->b
            beta()
      End Sub
      Sub beta()
            \\ increment member x
            z=>x++
            Print z=>x
            \\ subs have same scope as the module from where called
            counter++
      End Sub
}
Checkit
}
MODULE F3 {Module Checkit {
      group alfa {
      x=10
      }
      b->alfa
      checkme(b)
      Print b=>x=10
      Print alfa.x=10
      checkme2(b)
      Print b=>x=11
      Print alfa.x=11
      checkme3(&b)
      Print b=>x=12
      Print alfa.x=12
    
      \\ sub is like End if execution find it
      sub checkme(a as group)
            print type$(a)
            a.x++
            Print a.x
      End sub
      sub checkme2(a as pointer)
            print type$(a)
            a=>x++
            Print a=>x
      End sub
      sub checkme3(&a as pointer)
            print type$(a)
            a=>x++
            Print a=>x
      End sub
}
Checkit
}
MODULE F4 {gosub modules
group alfa {
x=10
}
b->alfa
checkme b
Print b=>x=10
Print alfa.x=10
checkme2 b
Print b=>x=11
Print alfa.x=11
checkme3 &b
Print b=>x=12
Print alfa.x=12
End
modules:
module checkme {
            Read a as group
            print type$(a)
            a.x++
            Print a.x
}
module checkme2 {
            Read a as pointer
            print type$(a)
            a=>x++
            Print a=>x
}
Module  checkme3 {
            Read &a as pointer
            print type$(a)
            a=>x++
            Print a=>x
}
Return
}
MODULE F5 {gosub modules
group alfa {
x=10
}
b->alfa
checkme
checkme b
Print b=>x=10
Print alfa.x=10
checkme2
checkme2 b
Print b=>x=11
Print alfa.x=11
checkme3 &b
Print b=>x=12
Print alfa.x=12
End
modules:
module checkme {
            group a {
                  x=100
            }
            Read ? a as group
            print type$(a)
            a.x++
            Print a.x
}
module checkme2 {
            group a1 {
                  x=100
            }
            a->a1
            Read ? a as pointer
            print type$(a)
            a=>x++
            Print a=>x
}
Module  checkme3 {
            Read &a as pointer
            print type$(a)
            a=>x++
            Print a=>x
}
Return


}
MODULE F6 {Module CheckMe {
      Class alfa {
            x=1000
      }
      Global Enum aaa {a,b,c,d}
      \\ use Clear to clear static from level of modules like Checkit
      Rem : Clear
      Module Checkit {
            \\ we can use stacks, arrays, inventories and pointers to groups
            \\ enumerators
            \\ for stacks
            static z=(stack:=1,2), m=(1,2,3,4), k->alfa()
            static b as aaa=a, cc=(List:="a":=100,"b":=500,"c":=200)
            read ? z
            Print k=>x
            k=>x++
            Print z
            Stack z {
                  if isnum then print number
            }
            Print m
            m++
            Return cc, "a":=cc("a")+1
            If Exist(cc,"a") Then Print Eval(cc)
     
      }
     
      Checkit
      Checkit
      Checkit (stack:=5,6,7)
      Checkit
      Checkit
}
CheckMe
}
MODULE F7 {Module checkit {
      Declare random1 lib "advapi32.SystemFunction036" {long lpbuffer, long length}
      Buffer Clear Alfa as long*2
      Print Eval(Alfa,0)
      Print Eval(Alfa,1)
      call void random1(alfa(0), 8)
      Print Eval(Alfa,0)
      Print Eval(Alfa,1)
}
checkit
}
MODULE F8 {Declare Global CryptAcquireContext Lib "advapi32.CryptAcquireContextW" {Long &hProv, pszContainer$,pszProvider$, long dwProvType, long dwFlags}
Declare Global CryptReleaseContext Lib "advapi32.CryptReleaseContext" {Long hProv, Long dwFlags}
Declare Global CryptGenRandom Lib"advapi32.CryptGenRandom" {Long hProv, Long dwLen, Long &ByRef}
Global Const PROV_RSA_FULL As Long = 1
Global Const VERIFY_CONTEXT As Long = 0xF0000000&
 
Function  Random2 {
      Long Rand=0, hProv=0
      Call void CryptAcquireContext(&hProv, "", "", PROV_RSA_FULL, VERIFY_CONTEXT)
      Call Void CryptGenRandom( hProv, 4&, &Rand)
      Call Void CryptReleaseContext(hProv, 0&)
      =Rand
}
m= Random2()
mUnsigned=uint(m)
Print m
Print mUnsigned
Print hex$(mUnsigned, 4)
Print sint(mUnsigned)=m

Print m=eval("0x"+hex$(mUnsigned, 4)+"&")  ' using & at the end we get the signed long 32 bit
Print type$(mUnsigned)
m1=sint(mUnsigned)
Print type$(m1)
m2=binary.and(m1, 0xFF00FF00)
Print type$(m2)
k=0xFF00FF00
Print type$(k)
k1=Binary.Shift(k,-8)
Print type$(k1)
k2=Binary.Rotate(k,-8)
Print type$(k2)
k3=binary.add(0xFF123456,0xF1234567,0xFFFFFFFF)
Print type$(k3)
}
MODULE URL {Module checkit {
      document doc$
      any=lambda (z$)->{=lambda z$ (a$)->instr(z$,a$)>0}
      one=lambda (z$)->{=lambda z$ (a$)->z$=a$}
      number$="0123456789"

      series=Lambda -> {
                  func=Array([])
                  =lambda func (&line$, &res$)->{
                        if line$="" then exit
                        k=each(func)
                        def p=0,ok as boolean
                        while k {
                              ok=false : p++ : f=array(k)
                              if not f(mid$(line$,p,1)) then exit
                              ok=true
                        }
                        if ok then res$=left$(line$, p) : line$=mid$(line$, p+1)
                        =ok
                  }
      }

      is_any=lambda series, any (c$) ->series(any(c$))
      is_one=lambda series, one (c$) ->series(one(c$))
      Is_Alpha=series(lambda (a$)-> a$ ~ "[a-zA-Z]")
      Is_digit=series(any(number$))
      Is_hex=any(number$+"abcdefABCDEF")

      optionals=Lambda -> {
                  func=Array([])
                  =lambda func (&line$, &res$)->{
                        k=each(func)
                        def ok as boolean
                        while k {
                              f=array(k)
                              if f(&line$,&res$) then ok=true : exit
                        }
                        =ok
                  }
      }
      repeated=Lambda (func)-> {
                  =lambda func (&line$, &res$)->{
                        def ok as boolean, a$
                        res$=""
                        do {
                              sec=len(line$)
                              if not func(&line$,&a$) then exit
                              res$+=a$
                              ok=true
                        } until line$="" or sec=len(line$)
                        =ok
                  }
      }

      oneAndoptional=lambda (func1, func2) -> {
            =lambda func1, func2 (&line$, &res$)->{
                              def ok as boolean, a$
                              res$=""
                              if not func1(&line$,&res$) then exit
                              if func2(&line$,&a$) then res$+=a$
                              =True
                        }      
      }
      many=Lambda -> {
                  func=Array([])
                  =lambda func (&line$, &res$)->{
                        k=each(func)
                        def p=0,ok as boolean, acc$
                        oldline$=line$
                        while k {
                              ok=false
                              res$=""
                              if line$="" then exit
                              f=array(k)
                              if not f(&line$,&res$) then exit
                              acc$+=res$
                              ok=true
                         }
                        if not ok then {line$=oldline$} else res$=acc$
                        =ok
                  }
      }
      is_safe=series(any("$-_@.&"))
      Is_extra=series(any("!*'(),"+chr$(34)))
      Is_Escape=series(any("%"), is_hex, is_hex)
      \\Is_reserved=series(any("=;/#?: "))
      is_xalpha=optionals(Is_Alpha, is_digit, is_safe, is_extra, is_escape)
      is_xalphas=oneAndoptional(is_xalpha,repeated(is_xalpha))
      is_xpalpha=optionals(is_xalpha, is_one("+"))
      is_xpalphas=oneAndoptional(is_xpalpha,repeated(is_xpalpha))
      Is_ialpha=oneAndoptional(Is_Alpha,repeated(is_xpalphas))
      is_fragmentid=lambda is_xalphas (&lines$, &res$) -> {
            =is_xalphas(&lines$, &res$)
      }
      is_search=oneAndoptional(is_xalphas, repeated(many(series(one("+")),is_xalphas)))
      is_void=lambda (f)-> {
            =lambda f (&oldline$, &res$)-> {
                  line$=oldline$
                  if f(&line$, &res$) then {oldline$=line$ } else res$=""
                  =true
            }
      }
      is_scheme=is_ialpha
      is_path=repeated(oneAndoptional(is_void(is_xpalphas), series(one("/"))))
      is_uri=oneAndoptional(many(is_scheme, series(one(":")), is_path), many(series(one("?")),is_search))
      is_fragmentaddress=oneAndoptional(is_uri, many(series(one("#")),is_fragmentid ))

      data "foo://example.com:8042/over/there?name=ferret#nose"
      data "urn:example:animal:ferret:nose"
      data "jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true "
      data "ftp://ftp.is.co.za/rfc/rfc1808.txt"
      data "http://www.ietf.org/rfc/rfc2396.txt#header1"
      data "ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two"
      data "mailto:John.Doe@example.com"
      data "tel:+1-816-555-1212"
      data "telnet://192.0.2.16:80/"
      data "urn:oasis:names:specification:docbook:dtd:xml:4.1.2"

      while not empty {
            read What$
           
            pen 15 {
                  Print(What$)
            }
            a$=""
            If is_scheme(&What$, &a$) Then Print( "Scheme="+a$ ): What$=mid$(What$,2)
            If is_path(&What$, &a$) Then {
                  count=0
                  while left$(a$, 1)="/" { a$=mid$(a$,2): count++}
                  if count>1 then {
                        domain$=leftpart$(a$+"/", "/")
                        a$=rightpart$(a$,"/")
                        if domain$<>"" Then Print( "Domain:"+Domain$)
                        if a$<>"" Then Print("Path:"+a$)
                  } else.if left$(What$,1) =":" then {
                        Print( "path:"+a$+What$): What$=""
                  } Else Print("Data:"+ a$)

            }

            if left$(What$,1) =":" then {
                  is_number=repeated(is_digit)
                  What$=mid$(What$,2): If is_number(&What$, &a$) Then Print("Port:"+a$)
                  if not left$(What$,1)="/" then exit
                  If is_path(&What$, &a$) Then {
                        while left$(a$, 1)="/" { a$=mid$(a$,2)}
                        if a$<>"" Then Print("Path:"+a$)
                  }
            }
            if left$(What$, 1)="?" then {
                        What$=mid$(What$,2)
                        If is_search(&What$, &a$) Then {
                        v$=""
                        if left$(What$, 1)="=" then {
                              What$=mid$(What$,2)
                              If is_search(&What$, &v$) Then Print("Query:"+a$+"="+v$)
                        }  else Print("Query:"+a$)
                        }
            }
            While left$(What$, 1)="#"  {
            What$=mid$(What$,2)
            if not is_xalphas(&What$, &a$) Then exit
            Print( "fragment:"+a$)
            }
            if What$<>"" Then print("Data:"+ What$)
      }
      clipboard doc$
      Sub Print(a$)
            print a$
            doc$=a$+{
            }
      End Sub
}
Checkit
}
MODULE T1 {a=(1,2,3,4,5)
Print a#rev()
Print a#sum()=15
Print a#max()=5, a#min()=1
k=-1
L=-1
Print a#max(K)=5, a#min(L)=1
Print K=4 ' 5th position
Print L=0 ' 1st position
Print a#pos(3)=2 ' 3rd position
Print a#val(4)=5
\\ tuples in tuple
a=((1,2),(3,4))
Print a#val(0)#val(1)=2
Print a#val(1)#val(1)=4
a=(1,2,3,4,5,6,7,8,9)
fold1=lambda ->{
      push number+number
}
Print a#fold(fold1)=a#sum()
Print a#fold(fold1,1)=a#sum()+1
even=lambda (x)->x mod 2=0
b=a#filter(even, (,))
Print b ' 2 4 6 8
Print a#filter(even)#fold(fold1)=20
map1=lambda (a)->{
      push a+100
}
c=b#map(map1)
Print c ' 102,103, 104, 105
numbers=lambda p=1 (x) ->{
      push x+p
      p++
}
oldnumbers=numbers ' we get a copy of numbers with p=1
c=c#map(numbers)
Print c ' 103, 106, 109, 112
zfilter=lambda -> number>106
tostring=lambda -> {
      push chrcode$(number)
}
oneline=lambda -> {
             shift 2 ' get second as first
             push letter$+letter$
}
Line$=c#filter(zfilter)#map(tostring)#fold$(oneline,"")
print Line$="mp", chrcode$(109)+chrcode$(112)
zfilter=lambda -> number>200
Line$=""
Line$=c#filter(zfilter)#map(tostring)#fold$(oneline,"")
\\ lines$ can't change value becuse filter has no items to give
Print Line$=""
\\ if we leave a second parameter without value the we get No Value error
Try {
      Line$=c#filter(zfilter, )#map(tostring)#fold$(oneline,"")
}
Print error$=" No value"
\\ second parameter is the alternative source
Line$=c#filter(zfilter,(109,112))#map(tostring)#fold$(oneline,"")
Print Line$="mp"
c=(1,1,0,1,1,1,1,0,1,1,0)
\\ hard insert
Print c#pos(1,0,1) ' 1  means 2nd position
Print c#pos(3->1,0,1) ' 6  means 7th position
\\ using another tuple
Print c#pos((1,0,1)) ' 1  means 2nd position
Print c#pos(3->(1,0,1)) ' 6  means 7th position
t=(1,0,1)
Print c#pos(t) ' 1  means 2nd position
Print c#pos(3->t) ' 6  means 7th position
}
MODULE R1 {Function DispRev$(a$) {
      i=1: j=Len(a$): if j=0 then ="": exit
      z$=String$(" ",j): j++
      do {
            k$=mid$(a$, i, 1)
            if i<len(a$) then {
            while len.disp(k$+mid$(a$, i+1,1)) =len.disp(k$) {
                  k$+=mid$(a$, i+1,1) : i++ : if i>len(a$) then exit
                  j-- } : j-- : insert j, len(k$) Z$=K$
            } else j-- :Insert j,1 z$=k$
            i++
           
      } until i>len(a$)
       =z$
}
Print DispRev$("abcd")="dcba"
Print DispRev$("")=""
Print DispRev$("s⃝df̅")="f̅ds⃝"
}
MODULE W1 { Module WeaselAlgorithm {
      Print "Evolutionary Algorithm"
      \\ Weasel Algorithm
      \\ Using dynamic array, which expand if no fitness change,
      \\ and reduce to minimum when fitness changed
      \\ Abandon strings when fitness change
      \\ Also lambda function Mutate$ change when topscore=10, to change only one character
      l$="ABCDEFGHIJKLMNOPQRSTUVWXYZ "
      randomstring$=lambda$ l$ ->{
            res$=""
            For i=1 to 28: res$+=Mid$(L$,Random(1,27),1):next i
            =res$
      }
      m$="METHINKS IT IS LIKE A WEASEL"
      lm=len(m$)
      fitness=lambda m$, lm (this$)-> {
            score=0 : For i=1 to lm {score+=If(mid$(m$,i,1)=mid$(this$, i, 1)->1,0)} : =score
      }
      Mutate$=lambda$ l$ (w$)-> {
            a=random(1,28) : insert a, 1 w$=mid$(l$, random(1,27),1)
            If random(3)=1 Then b=a:while b=a {b=random(1,28)} : insert b, 1 w$=mid$(l$, random(1,27),1)
            =w$
      }
      Mutate1$=lambda$ l$ (w$)-> {
            insert random(1,28), 1 w$=mid$(l$, random(1,27),1) : =w$
      }
      f$=randomstring$()
      topscore=0
      last=0
      Pen 11 {Print "Fitness |Target:", @(16),m$, @(47),"|Total Strings"}
      Print Over $(3,8), str$(topscore/28,"##0.0%"),"",$(0),f$, 0
      count=0
      gen=30
      mut=0
      {
            last=0
            Dim a$(1 to gen)<<mutate$(f$)
            mut+=gen
            oldscore=topscore
            For i=1 to gen {
                  topscore=max.data(topscore, fitness(a$(i)))
                  If oldscore<topscore Then last=i:Exit
            }
            If last>0 Then {
                  f$=a$(last) : gen=30 : If topscore=10 Then mutate$=mutate1$
            } Else gen+=50
            Print Over $(3,8), str$(topscore/28,"##0.0%"), "",$(0),f$, mut : refresh
            count+=min(gen,i)
            If topscore<28 Then loop
      }
      Print
      Print "Results"
      Print "I found this:"; a$(i)
      Print "Total strings which evalute fitness:"; count
      Print "Done"
}
WeaselAlgorithm
}
MODULE S1 {Module CheckIt {
      Flush
      Form ! 60, 40    ' use ! to reduce form (for safe area for TV)
      oldback=point  ' read color from 0,0  ' (Mode, Form. and Widow statement reset graphic cursor)
      Cls 0 ' Black
      Gradient 0,1
      Pen 14 ' Yellow
      Set Fast !
      Refresh 500
      Module Sphere (R as long, X0 as long, Y0 as long, fun){
            R2 = R * R
            Def Long X, Y, D2
            Let Scale=twipsx/R*13.5
            For Y = -R To R step twipsx {
            Move X0-R, Y+Y0
            For X = -R To R step twipsy {
                  D2 = X **2 + Y **2
                  IF R2>D2 THEN Pset Fun(Max.Data(Min.Data((Sqrt(R2 - D2) - ( X + Y) / 2 )*Scale ,255),0))
                  Step twipsx
            }
            }
      }
      Blue=lambda (c)->{
            c1=c/4+192
            =Color(c,c,c1)
      }
      Blue1=lambda (c)->{
            c1=c/4+Random(150,192)
            =Color(c,c,c1)
      }
      Mystery=lambda m=1 (c)->{
            c1=c/4+m
            m+=10
            if m>192 then m=1
            =Color(c,c,c1)
      }
      Mystery2=lambda m=1, p=true (c)->{
            c1=c/4+m
           if p then m+=10
           Else m=-10
            if m>192 then m-=10 : p=false
            If m<0 then m+=10: p=true
            =Color(c,c,c1)
      }
      Buffer Alfa as byte*8
      Trans =lambda Alfa (c) -> {
            Return Alfa, 0:=-point as long
            Return Alfa, 4:=-color(c,c, c/4+192) as long
            for i=0 to 2: Return Alfa, i:=(Eval(Alfa, i)+Eval(Alfa, i+4))/2: Next i
            =-Eval(Alfa, 0 as long)
      }
      Sphere 2400, 9000,7000, Blue
      Sphere 800, 6000, 7000, Blue1
      Sphere 1200, 5000,5000, Mystery
      Sphere 1200, 10000,6000, Mystery2
      Sphere 1200, 8000,5000, trans
      \\ set spped to normal  (Fast is normal)
      Set Fast
      Refresh 30
      copy$=""
      move 0,0
      copy scale.x, scale.y to copy$
      clipboard copy$
      Print Part @(0,height),"Press a Key"
      A$=Key$
      Cls oldback
}
Checkit
}
MODULE M1 { Module FilterMapFold {
      Form 80,40
      \\ HasString()
      \\ used to find if an array has strings or numbers
      \\ looking first element
      \\ because a is an iterator of array we have to copy first item
      \\ in a fresh array, which is base 0 by default
      \\ car(a) return first item as an array of one item
      \\ cdr(a) return all others as an array - not used here
      \\ (,) is the empty array - we can use Len() to check this
      HasString=Lambda (&a) ->{
            z=car(a)
            if len(z)=0 then =false :exit
            link z to s()
            =type$(s(0))="String"
      }
      \\ FilterFold$()
      \\ get an array or a pointer to array or an iterator to array
      \\ then optional get filter
      \\ then get the fold function (not optional)
      \\ then get the initial string value - optional
      \\ return string
      FilterFold$=lambda$ HasString (w)-> {
            f=lambda->true
            res$=""
            Read ? f
            Read fold, ? res$
            flush ' empty stack no other arguments allowed
            if not valid(w^) then {m=each(w)} else m=w
            if HasString(&m) then {
                  while m {
                        if not f(array$(m)) then continue
                         Call fold(array$(m), &res$)
                  }
            } else {
                  while m {
                        if not f(array(m)) then continue
                         Call fold(array(m), &res$)
                  }
            }
            =res$
      }
      \\ FilterFold()
      \\ get an array or a pointer to array or an iterator to array
      \\ then optional get filter
      \\ then get the fold function (not optional)
      \\ then get the initial number value - optional
      \\ return number
      FilterFold=lambda HasString (w)-> {
            f=lambda->true
            res=0
            Read ? f
            Read fold, ? res
            flush ' empty stack no other arguments allowed
            if not valid(w^) then {m=each(w)} else m=w
            if HasString(&m) then {
                  while m {
                        if not f(array$(m)) then continue
                         Call fold(array$(m), &res)
                  }
            } else {
                  while m {
                        if not f(array(m)) then continue
                         Call fold(array(m), &res)
                  }      
            }
            =res
      }
      \\ FilterMap()
      \\ get an array or a pointer to array or an iterator to array
      \\ check to see if is an iterator, if not make one
      \\ then optional get filter function
      \\ check if has string or number
      \\ then optional get mapfunction
      \\ return a poinrer to a new array with results
      \\ [ ] get all items from stack and return a stack object
      \\ Array([])  convert stack object to array
      FilterMap=lambda HasString (w)-> {
            if not valid(w^) then {m=each(w)} else m=w
            f=lambda->true
            if HasString(&m) then {
                  map$=lambda$->Letter$
                  Read ? f, map$
                  flush ' empty stack no other arguments allowed
                  while m {
                        if not f(array$(m)) then continue
                        data map$(array$(m))
                  }
            } Else {
                  map=lambda ->Number
                  Read ? f, map
                  flush ' empty stack no other arguments allowed
                  while m {
                        if not f(array(m)) then continue
                        data map(array(m))
                  }
            }
           =Array([])
      }
      \\ we can combine filters using filter()
      \\ we can have any number of lambda functions as parameters
      \\ if any function return false then exit and return falsa
      \\ so return true only if all functions return true
      \\ here we use it with one parameter
      \\ s is a pointer to stack object
      \\ stack(s) is a stack object as copy of s
      \\ ! stack(s)  paste all items to current stack, the lambda stack
      \\ so filter  return a lambda which works for any number and type of arguments
      \\ we use T and F as boolean values - only for print statement
      \\ because True and False are doubles, not boolean, but works nice in boolean expressions
      \\ All comparisons return boolean.
      Function filter {
            Def boolean T=True, F=False
            dim all() : all()=Array([]) : L=len(all())-1
            =lambda all(), L , F, T -> {
                s=[] : =T
                for i=0 to L { if all(i)(!stack(s)) else =F : exit
                }
            }
      }
      \\ example for two parameters
      greater=lambda (x, z)->x>z
      divided=lambda (x, z)->x mod z=0
      myfilter=filter(greater, divided)
      Print myfilter(10,2)=true, myfilter(2,10)=false, myfilter(7,3)=false
    
      \\ combine$()
      \\ take any number of lambda functions, which return string/object result
      \\ combine$() get all parameters to an array and make it  a closure in the returned lambda
      \\ stackitem$() return any type from stack (string or object), without dropping it
      \\ because function's stack always erased at the exit, it make the drop for us.
      Function combine$ {
            dim all$()
            all$()=Array$([])
            L=len(all$())-1
            =lambda$ all$(), L -> {
                for i=0 to L {Push all$(i)(![])} : =StackItem$()
            }
      }
      \\ combine(
      \\ take any number of lambda functions, which return number/object result
      \\ combine() get all parameters to an array and make it  a closure in the returned lambda
      \\ stackitem() return any type from stack (number or object), without dropping it
      \\ because function's stack always erased at the exit, it make the drop for us.
      Function combine {
            dim all()
            all()=Array([])
            L=len(all())-1
            =lambda$ all(), L -> {
                for i=0 to L {Push all(i)(![])} : =StackItem()
            }
      }
      \\ so now we see some example of using these functions
      \\ b is a pointer to array
      b=(1,2,3,4,5,6,7,8)
      \\ just  return a copy of b
      Print FilterMap(b)
      \\ we make a lambda to be used to FilterFold
      \\ second parameter has to be passed by reference
      \\  We can use FilterFolder with String Arrays or Number Arrays
      \\ but we get number  as result (from FilterFolder$ we get string)
      \\ so the reference here must be for a number
      \\ the first parameter here is number because we have number array to fold
      mul=lambda (x, &p) -> {
            p*=x
      }
      \\ using initial value 1  (default is 0, but here 0 isn't good)
      Print FilterFold(b,,mul,1)
      \\ so now we use the same number array but for string result
      \\ we make a text with one to eight starts, like a triangle of stars
      bar$=lambda$ (x, &ret$) ->{
            ret$+=string$("*", x)+{
            }
      }
      \\ Report using 2 center each line, so we get something like a tree
      \\ also report use proportional spacing
      Report 2, FilterFold$(b,,bar$) +"*"
      \\ we can make a new array adding three times b, so now b point to a new array
      b=cons(b,b,b)
      \\ we want the sum of all numbers in b
      Sum=lambda (x, &total)->{
            total+=x
      }
      \\ we leave empty the filter, we place the sum function. Initial value is 0 and this is nice here.
      Print FilterFold(b, ,Sum)
      \\ We want now to get an array of all squares of even numbers in array
      \\ so we want  the Even function as filter (return a boolean)
      \\ and the square function which return squares
      Even=lambda (x)->x mod 2=0
      Square=lambda (x)->x**2
      \\ this is the same
      Square=lambda (x) -> {
            =x**2
      }
      \\ and this is the same too
      Square=lambda -> {
            Read x
            =x**2
      }
      \\ or better , using  Number  which pop a number from lambda's stack
      Square=lambda ->Number**2
      \\ so now we get an array with all values
      Print FilterMap(b, Even, Square)
      \\ We can get the sum too easy:
      Print FilterFold(FilterMap(b, Even, Square), , sum)
      \\ Warning
      \\ Each( )can't work with expression, it need a pointer to array or an array like a()
      \\ so we use c as a pointer to array
      c=FilterMap(Each(b 1 to 8), Even, Square)
      \\ we can see items and length
      Print c, len(c)
      \\ so now we can use each(c,1,2) to get the two first items
      \\ and using FilterFold we get the sum ot those two items
      Print FilterFold(each(c,1,2), , sum)
      \\ We can use two dimensional arrays, or more (maximum ten dimensions)
      \\ we can set different base (low bound) for each dimension
      \\ Dim is always like a "Dim Preserve" in VB6
      Dim z(1 to 4, 1 to 2)
      z(1,1)=1,2,3,4,5,6,7,8
      \\ So now we pass z() to FilterFold, and this check that it has numbers
      \\ and apply the proper code to support the sum function
      Print FilterFold(z(), , sum)
      \\ no it has numbers
      Print HasString(&Z())
      \\ so now we see examples with strings in array
      a=("car","boat","cat","frog")
      \\ check that HasString() works
      Print HasString(&a) ' true
      \\ filters
      \\ check if a$ has a "t" upper or lower case
      HasAt=lambda (a$)->instr(lcase$(a$),"t")>0
      \\ check if a$ has three characters length
      IsThreeLetters=lambda (a$)->len(a$)=3
      \\ maps
      \\ convert to uppercase
      capitalize$=lambda$ (a$)->Ucase$(a$)
      \\ add "123"
      add123$=lambda$ (a$)->a$+"123"
      \\ add brackets
      addbrackets$=lambda$ (a$)->"["+a$+"]"
      \\ Using filterMap with no filter/map, so we get the first two items by each()
      Print filterMap(each(a,1,2))
      \\ now we get all items capitalize
      Print filterMap(a,,capitalize$)
      \\ now we get items with three letters capitalize
      Print filterMap(a,isThreeletters,capitalize$)
      \\  We pass a composite filter using  filter()
      \\ so now we want items with three letters and  have a "t" inside, and map to capitalize
      Print filterMap(a,filter(isThreeletters,HasAt), capitalize$)
      \\  Here we get all items with three letters an apply combine map of two functions
      \\ last function applied last
      Print filterMap(a,isThreeletters, combine$(capitalize$, add123$))
      \\  Here we get all items with three letters an apply combine map
      \\ last applied the addbrackets so we get [CAR123] [CAT123]
      Print filterMap(a,isThreeletters, combine$(capitalize$, add123$, addbrackets$))
      \\ So now we make a folding function
      \\ using string for items and by reference string for accumulator
      appendstring=lambda (x$, &all$)->{
            all$+=x$
      }
      \\ we get all items in a string without spaces
      Print FilterFold$(a,,appendstring)
      \\ we use each with no coma using "to" and Start and End (1 and -1), in reverse
      \\ so we get the items in a string in reverse order
      \\ reverse, we can use each(a, -1, 1)
      Print FilterFold$(each(a End to Start),,appendstring)
      \ like this
      Print FilterFold$(each(a,-1,1),,appendstring)
      \\ we can apply a filter
      Print FilterFold$(a,isThreeletters,appendstring)
      \\ or we can use the FilterMap() as a parameter for FilterFold$()
      Print FilterFold$(FilterMap(a,isThreeletters, combine$(capitalize$, addbrackets$)),,appendstring)
      \\ Another folding function, to get the total length, so we need number,
      \\ so we use FilterFold and not FilterFold$
      GetLength=lambda (x$, &all)-> {
            all+=len(x$)
      }
      \\ Also we can get the maximum length from items
      GetMaxLength=lambda (x$, &max)-> {
            If len(x$)>max then max=len(x$)
      }
      \\ so now we get the length from all items with three letters
      Print FilterFold(a,isThreeletters,GetLength)=6
      \\ and we get the maximum length from all items
      Print FilterFold(a,,GetMaxLength)=4
}
FilterMapFold

}
MODULE H1 { Class HttpStatus {
Events "trace", "err","high","low"
Private:
      myvalue
Public:
      Enum Status { NotFound=404, MethodNotAllowed=405}
      Set {
            read x ' number or enum
            \\ if number not exist in enum list Then we get an error
            Call event "trace", x
            Try ok {
                  .myvalue<=x
            }
            if not ok Then call event "err", format$("value {0} not accepted", x)
      }
      Value {
            =.myvalue
      }
      Operator "++" {
            old=.myvalue
            .myvalue++
            if old=.myvalue Then call event "high"
      }
      Operator "--" {
            old=.myvalue
            .myvalue--
            if old=.myvalue Then call event "low"
      }
      class:
      Module HttpStatus {
      .myvalue<=.NotFound
      }
}
Group WithEvents HttpStatus=HttpStatus()
Function HttpStatus_trace(New a){
      Print ">>>",a
}
Function HttpStatus_err(New a$) {
      Print a$
}
accHigh=0
Function HttpStatus_high {
      Print "high limit"
      accHigh++
}
Function HttpStatus_low {
      Print "low limit"
}
Print HttpStatus.NotFound, HttpStatus.MethodNotAllowed
Print HttpStatus=404
HttpStatus=HttpStatus.MethodNotAllowed
Print HttpStatus=405
HttpStatus=10
Print HttpStatus=405
\\ 404 is ok
HttpStatus=404
Print HttpStatus
HttpStatus--
HttpStatus++
Print HttpStatus=405
HttpStatus++
Print accHigh=1
Print Type$(HttpStatus)="Group"
Def InferType$(x)=Type$(x)
Print InferType$(HttpStatus)="Status"
\\ for enum types Status letter Case have to match the Case in definition
Module Checkit(a as Status) {
      Print type$(a) ' it is a enum type, not a group, so no events happen
      Print a
      a--
      Print a, eval$(a)="NotFound"
     
}
Checkit HttpStatus.NotFound ' 404 404
Checkit HttpStatus ' 405 404
Print Eval$(HttpStatus)="MethodNotAllowed"
Try ok {
      Checkit 405
}
If error or not ok Then Print Error$ ' Wrong type in module A.CHECKIT
Module CheckThis(a as group) {
      Print "ok", a=405
      a++ ' raise high event, add one to acchigh
}
Try ok {
      CheckThis HttpStatus
}
If Error or not ok Then Print Error$ ' Wrong type in module A.CHECKTHIS
\\ we can pass group not value of HttpStatus
CheckThis Group(HttpStatus)
Print acchigh=2
Select Case HttpStatus
Case HttpStatus.NotFound
      Print "Not Found"
Case HttpStatus.MethodNotAllowed
      Print "Method Not Allowed"
End Select
HttpStatus=HttpStatus.NotFound
Module CheckThisToo(&a as group) {
      Print "ok", a=404
      a++ ' raise high event, add one to acchigh
}
\\ pass by reference
CheckThisToo &HttpStatus
Print HttpStatus=HttpStatus.MethodNotAllowed
\\ check a copy of HttpStatus to a
a=HttpStatus
a++
a++ ' we have no events now, a has a new cleared event list
Print a =405
\\ check a pointer to HttpStatus
b->HttpStatus
Print Eval(b), b=>NotFound, Eval$(b=>NotFound)="NotFound"
b++ ' we get event because b is a pointer to HttpStatus
Try {
      \\ b is an object so we get wrongtype
      Checkit b
}
\\ now we can get the value from b
Checkit eval(b)
\\ no used & because  b is actual a reference to HttpStatus
\\ if we use & then we pass the reference of pointer, not the the reference of Httpstatus
CheckThis b
Dim a(2)
\\ this is the second type of pointer, a pointer to a copy of HttpStatus
a(1)->(Group(HttpStatus))
b->a(1)
Print Eval(a(1))=405
a(1)--
Print Eval(a(1))=404
a(1)=405
Print Type$(a(1))="Group", InferType$(Eval(a(1)))="Status"
a(1)++ ' we get high limit, because a(1) has a float group (nameless), and event list inside is the original one.
b++ ' now we get high limit because b and a(1) show the same nameless (or float) group


}
MODULE INF { locale 1033
Module CheckIt {
      Form 66,40
      Cls 5
      Pen 14
      \\ Ensure True/False for Print boolean (else -1/0)
      \\ from m2000 console use statement Switches without Set.
      \\ use Monitor statement to see all switches.
      Set Switches "+SBL"
      IF version<9.8 then exit
      IF version=9.8 and revision<18 then exit
      rem {
            \\ from revision 18 there is a constant infinity
            Function Infinity(positive=True) {
                  buffer clear inf as byte*8
                  m=0x7F
                  if not positive then m+=128
                  return inf, 7:=m, 6:=0xF0
                  =eval(inf, 0 as double)
            }
            K=Infinity(false)
            L=Infinity()
      }
      K=-Infinity
      L=Infinity
      Function TestNegativeInfinity(k) {
            =str$(k, 1033) = "-1.#INF"
      }
      Function TestPositiveInfinity(k) {
            =str$(k, 1033) = "1.#INF"
      }
      Function TestInvalid {
            =str$(Number, 1033) = "-1.#IND"
      }
      Pen 11 {Print "       True       True"}    
      Print TestNegativeInfinity(K), TestPositiveInfinity(L)
      Pen 11 {Print "    -1.#INF     1.#INF    -1.#INF     1.#INF    -1.#INF     1.#INF"}
      Print K, L, K*100, L*100, K+K, L+L
      M=K/L
      Pen 11 {Print "    -1.#IND    -1.#IND       True       True" }
      Print K/L, L/K, TestInvalid(M), TestInvalid(K/L)
      M=K+L
      Pen 11 {Print "    -1.#IND    -1.#IND    -1.#IND       True       True"}
      Print M, K+L, L+K, TestInvalid(M), TestInvalid(K+L)
      Pen 11 {Print "    -1.#INF     1.#INF"}
      Print 1+K+2, 1+L+2
      Pen 11 {Print "    -1.#INF"}
      Print K-L
      Pen 11 {Print "     1.#INF"}
      Print L-K
      Pen 11 {Print "       True       True       True       True"}    
      Print L<>k, 100>K, 100>K+1, L>K
      Pen 11 {Print "       True       True          1          0"}
      Print L+10>100, 100+L>K, L<=>k, L<=>L
}
Checkit
}
MODULE CONV { Module Checkit {
      Conv2dec=lambda (n$, frombase=10, dp$=".") -> {
           neg=left$(n$,1)="-": if neg then n$=mid$(n$,2)
           if instr(n$, dp$)>0 then {
                 n2$=Piece$(n$,dp$,2)
                 n$=Piece$(n$, dp$,1)
           } else n2$=""
           n0=0
           l1=len(n$)+1
           For i=len(n$) to 1
                 dig$=Mid$(n$,l1-i,1)
                 dig=asc(dig$)-48
                 if dig$>"9" then dig-=7
                 if dig>=frombase then error "not in base:"+frombase
                 n0+=dig*frombase^(i-1)
           next i
           if n2$<>"" then {
              For i=1 to len(n2$)
                 dig$=Mid$(n2$,i,1)
                 dig=asc(dig$)-48
                 if dig$>"9" then dig-=7
                 if dig>=frombase then error "not in base:"+frombase
                 n0+=dig/frombase^i
              Next i
           }
           if neg then n0-!
           =n0
      }
      Conv2Any$=Lambda$ (dec, tobase=10, dp$=".", prec=16) -> {
           a$=""
           neg=false
           if dec<0 then neg=true
           dec=abs(dec)
           n2=frac(dec)
           if dec=0 then {
                 a$="0"
           } else {
                 do {
                        n=dec mod tobase
                        if n>=10 then n+=7
                        a$=chr$(n+48)+a$
                        dec=dec div tobase
                  } until dec==0
            }
            if n2<>0 then {
                 a$+=dp$
                 prec--
                 do {
                      prec--
                      dec=n2*tobase
                      n2=frac(dec)
                      dec-=n2
                      n2=round(n2)
                      if dec>=10 then dec+=7
                      a$+=chr$(dec+48)
                 } until n2=0 or prec<0
            }
            if neg then {="-"+a$} else =a$
      }
      Rem : Locale 1033 ' use . for all print out for decimal point
      Print Conv2dec("10111.01011",2); " => ";Conv2Any$(23.34375,2)
      Print Conv2Any$(11.90625, 2); " => "; Conv2dec("1011.11101",2)
      \\ using , for decimal point
      Print Conv2Any$(Conv2dec("1011,11101",2, ","), 10, ",")
      Print 12312321.1212
      clipboard Conv2Any$(12312321.1212, 2)
      \\ using . for 1033 locale
      Print Str$(Conv2Dec(Conv2Any$(12312321.1212, 2), 2), 1033)="12312321.1211853"
      Print Str$(Conv2Dec(Conv2Any$(12312321.1212, 2,,52), 2), 1033) ="12312321.1212"
}
Checkit
}
MODULE RAT {Module RationalNumbers {
      Class Rational {
            numerator as decimal, denominator as decimal
            gcd=lambda->0
            lcm=lambda->0
            operator "+" {
                 Read l
                 denom=.lcm(l.denominator, .denominator)
                 .numerator<=denom/l.denominator*l.numerator+denom/.denominator*.numerator
                 if .numerator==0 then denom=1
                 .denominator<=denom
            }
            Operator Unary {
                  .numerator-!
            }
            Operator "-" {
                  Read l
                  Call Operator "+", -l
            }
            Operator "*" {
                  Read l
                  g1=.gcd(l.numerator,.denominator)
                  g2=.gcd(.numerator, l.denominator)
                  Push l.numerator/g1*.numerator/g2
                  Push l.denominator/g2*.denominator/g1
                  Read .denominator, .numerator

            }
            Function Inverse {
                  if .numerator==0 then Error "Division by zero"
                  ret=This
                  sign=sgn(ret.numerator) : if sign<0 then ret.numerator-!
                  swap ret.numerator, ret.denominator
                  if sign<0 then ret.numerator-!
                  =ret
            }
            Operator "/" {
                  Read l
                  call operator "*", l.inverse()
            }
            Function Power {
                  Read pow as long
                  ret=This
                  ret.numerator<=.numerator^pow
                  ret.denominator<=.denominator^pow
                  =ret
            }
            Operator "=" {
                  Read l
                  Def boolean T=True, F=False
                  if Abs(sgn(l.numerator))+Abs(sgn(.numerator))=0 then Push T: exit
                  if sgn(l.numerator) <>sgn(.numerator) then Push F : exit
                  pcomp=l/this
                  PUSH pcomp.numerator=1 and pcomp.denominator=1
            }
            Operator ">" {
                  Read l
                  Def boolean F
                  if Abs(sgn(l.numerator))+Abs(sgn(.numerator))=0 then Push F: exit
                  if sgn(l.numerator)=0 then {
                        PUSH .numerator>0
                  } Else {
                        pcomp=this/l
                        PUSH pcomp.real>1
                  }
            }
            Operator ">=" {
                  Read l
                  if sgn(l.numerator)=0 then {
                        PUSH .numerator>=0
                  } Else {
                        pcomp=this/l
                        PUSH pcomp.real>=1
                  }
            }      
            Operator "<" {
                  Read l
                  Def boolean F
                  if Abs(sgn(l.numerator))+Abs(sgn(.numerator))=0 then Push F: exit
                  if sgn(l.numerator)=0 then {
                        PUSH .numerator<0
                  } Else {
                        pcomp=this/l
                        PUSH pcomp.real<1
                  }
            }
            Operator "<=" {
                  Read l
                  if sgn(l.numerator)=0 then {
                        PUSH .numerator<=0
                  } Else {
                        pcomp=this/l
                        PUSH pcomp.real<=1
                  }            
            }
            Operator "<>" {
                  Read l
                  if sgn(l.numerator)=0 then {
                        PUSH .numerator<>0
                  } Else {
                        pcomp=this/l
                        PUSH pcomp.real<>1
                  }            
            }
            Group Real {
                  value {
                        link parent numerator, denominator to n, d
                        =n/d
                  }
            }
            Group ToString$ {
                 value {
                        link parent numerator, denominator to n, d
                        =Str$(n)+"/"+Str$(d,"")
                  }      
            }
            class:
            Module Rational (.numerator, .denominator) {
                  if .denominator<=0 then Error "Positive only denominator"
                  gcd1=lambda (a as decimal, b as decimal) -> {
                        if a<b then swap a,b
                        g=a mod b
                        while g {
                              a=b:b=g: g=a mod b
                        }
                              =abs(b)
                  }
                  .gcd<=gcd1
                  .lcm<=lambda gcd=gcd1 (a as decimal, b as decimal) -> {
                        =a/gcd(a,b)*b
                  }
            }
      }
      Print rational(-3,3)<>rational(-3,3)
      M=Rational(10, 150)
      N=Rational(2, 4)
      Z=M+N
      Print Z.numerator, Z.denominator
      Print 10/150@+2/4@
      Print Z.real
      Z=-M+N
      Print Z.numerator, Z.denominator
      Print -10/150@+2/4@
      Print Z.real
      Z=M-N
      Print Z.numerator, Z.denominator
      Print 10/150@-2/4@
      Print Z.real
      Z=M*N
      Print Z.numerator, Z.denominator
      Print (10/150@)*(2/4@)
      Print Z.real
      Z=M/N
      Print Z.numerator, Z.denominator
      Print (10/150@)/(2/4@)
      Print Z.real
      Z=Z.Power(2)
      Print Z.real
      Print Z=Z
      Print Z=N
      Print Z=-Z
      ZZ=-Z
      Print ZZ=ZZ
      Print -Z=-Z
      Print Z.numerator, Z.denominator
      Print Z.real, Z.tostring$
      \\ Array of rational numbers
      Dim K(100)=rational(1,1)
      M=K(4)+K(3)
      Print M.real
      Print K(4).toString$

           pk->(Z)
      Print pk=>toString$
      zzz=pk+pk
      Print zzz.toString$

}
RationalNumbers
}
MODULE TUPLE { Form 80, 60
\\ Tuple of items (as one dimension arrays)
A=(1,2,3,4,5)
B=("George", 10, "Bob", 5)
C=(("George", 10),("Bob", 5))
Print Len(A)=5 ' true
Print Len(B)=4 ' true
Print Len(C)=2 ' true
\\ get reference of A to A1
A1=A
B1=B
C1=C
\\ Get Shallow Copy
Dim A(), B$(), C()
A()=A
B$()=B
C()=C
A(0)=10
Print A ' 1 2 3 4 5
Print A() ' 10 2 3 4 5
Link B$() to B()
B$(0)="Hello George"
B(1)=1000
Print B ' George 10 Bob 5
Print B$() ' Hello George 1000 Bob 5
C()=C
C(0)=("New Name", 500)
Print Array(C,0), Array(C, 1) ' George 10 Bob 5
Print C(0)(), C(1)() ' New Name 500 Bob 5
\\ Test Shallow Copy
\\ we keep pointer to second array but we change values
\\ we need a pointer to C[1]
N=Array(C,1)
\\ So we can use Return to return multiple values
Return N, 0:="New Bob", 1:=5000
\\ So Array(C,1) show us new values
Print Array(C,0), Array(C, 1) ' George 10 New Bob 5000
\\ And because we get shallow copy (pointer only) we get C(1)() array with new values
Print C(0)(), C(1)() ' New Name 500 New Bob 5000
\\ Now C(1) get a new pointer
C(1)=("Another Name", 2000)
Print Array(C,0), Array(C, 1) ' George 10 New Bob 5000
Print C(0)(), C(1)() ' New Name 500 Another Name 2000
\\ we can get a copy of A using Cons() with one argument
NewArray=Cons(A) ' copy of A
Print NewArray
NewArray2=Cons(A, A) ' add A twice
Print NewArray2
\\ Get a copy of C() to a pointer
CopyC=Cons(C())
Print Array(CopyC, 0), Array(CopyC, 1)
Return CopyC, 1:=("Just Another Name", 3000)
Print Array(CopyC, 0), Array(CopyC, 1) ' New Name 500 Just Another Name 3000
Print C(0)(), C(1)() ' New Name 500 Another Name 2000

\\ Pointers for multi dimension arrays
Dim A(2 to 10, 5 to 10)=1
M=A()
Print Len(M) = 54 ' 9X6
Print array(M, 2,5)=1 \\ M point to a 2 dimension Array
\\ Return use one dimension, so 0 is the first element
Return M, 0:=1000, 6:=5000 ' 6 is the 7th item, first in second row (row, columns)
Print array(M, 2,5)=1000, array(M, 3,5)
Dim A(2 to 11, 5 to 10) ' add one row
Print Len(M) = 60 ' 10X6
Print Type$(A(11, 5))="Empty"  ' new raw has Empty as value (in calculations this is same as 0 or empty string)
\\ So now we put a value
For i=5 to 10:A(11,i)=1:Next i
\\ we can alter last item using pointer M
Return M, 59:=9999
Print A(11, 10)=9999
\\ assuming we have defalut base 0
Dim A(10,6) ' redim preserving values
Print A(9, 5)=9999, Len(A())=60
\\ we can use Base 1 or Base 0 to explicit declare base
Dim Base 1, A(10,6) ' redim preserving values
Print A(10, 6)=9999, Len(A())=60
\\ or we can use for each dimension a new base
Dim A(5 to 14, 10 to 15) ' redim preserving values
Print A(14, 15)=9999, Len(A())=60
\\ Get dimensions, width for each dimension, base (min value) for each dimension, max value for each dimension
Print Dimension(A())=2 ' 2 dimension
Print Dimension(A(),0)=5 ' first dimension base is 5
Print Dimension(A(),1)=10 ' 10 items
Print Dimension(A(),2)=6 ' 6 items, so we have 10x6 items
Print Dimension(A(),1,0)=5
Print Dimension(A(),1,1)=14
Print Dimension(A(),2,0)=10
Print Dimension(A(),2,1)=15
\\ Copy all item to stack using pointer to array (not A() but M)
Flush  ' now stack is empty stack
Push ! M ' now get 60 items
Print stack.size=60 ' true
Stack   ' now display all stack items
Flush ' now empty stack
\\ if we use Push ! M we send values in reverse
Data ! M ' now get 60 items
\\ now all item make an array and return a pointer to Z
Z=Array([])
Print stack.size=0
Link Z to Z()
Dim Z(5 to 14, 10 to 15)
Print Z()
Print Z(14,15)=9999
Z++ ' Add 1 to all items
Print Z()
Z(14,15)-- ' Subtract 1 from one item
Print Z(14,15)
}
MODULE TU {Module TestGroup {
      Group A {
            X=10
            Dim K(10)=1
      }
      Dim A(), B()
      A()=(A,)
      B()=A()
      A(0).X++
      A(0).K(0)=1000
      Print A(0).X=11, A(0).K()
      Print B(0).X=10, B(0).K()
}
TestGroup


Module TestGroup2 {
      Group A {
            X=10
            Dim K(10)=1
      }
      Dim A(), B()
      A()=(0,) ' one item
      A(0)->(A) ' now A(0) has a pointer to a copy of  A
      B()=A()
      A(0).X++
      A(0).K(0)=1000
      Print A(0).X=11, A(0).K()
      Print B(0).X=11, B(0).K()
}
TestGroup2
}
MODULE PEND { Module Pendulum {
      back()
      degree=180/pi
      THETA=Pi/2
      SPEED=0
      G=9.81
      L=0.5
      Profiler
      lasttimecount=0
      cc=40 ' 40 ms every draw
      accold=0
      Every cc {
            ACCEL=G*SIN(THETA*degree)/L/50
            SPEED+=ACCEL/cc
            THETA+=SPEED
            Pendulum(THETA)
            if KeyPress(32) Then Exit
      }

      Sub back()
            If not IsWine then Smooth On
            Cls 7,0
            Pen 0
            Move 0, scale.y/4
            Draw scale.x,0
            Step -scale.x/2
            circle fill #AAAAAA, scale.x/50
            Hold ' hold this as background
      End Sub

      Sub Pendulum(x)
            x+=pi/2
            Release ' place stored background to screen
            Width scale.x/2000 {
                  Draw Angle x, scale.y/2.5
                  Width 1 {
                        Circle Fill 14, scale.x/25
                  }
                  Step Angle x, -scale.y/2.5
            }
            Print @(1,1), lasttimecount
            if sgn(accold)<>sgn(ACCEL) then lasttimecount=timecount: Profiler
            accold=ACCEL
            Refresh 1000
      End Sub
}
while inkey$<>"" : end while
Pendulum
keyboard "Info"+chr$(13)
}
MODULE LOGO {smooth off  ' can't use xor with GDI+, so we work with GDI32 (by default)
Form 80, 50
Cursor 0,0
Gradient 11,0
drawframeM()
drawframe2()
drawframe0()
drawframe0()
drawframe0()
cls, 4
Sub drawframeM()
      local i, n=0
      Move !
      Pen 0 {
            Step 100, 100
            For i=1 to 2 {
                  Path n {
                        Polygon 0, 1000, 0, 0,1000, -200,0, 0,-700,-200, 0, 0,700, -200,0, 0,-700,-200, 0, 0,700, -200, 0, 0,-1000
                        Step 200, 300
                  }
                  Step -300, -400
                  n=15-n
            }
      }
      Step 1400,0
      Cursor !
End Sub
Sub drawframe2()
      local i, n=0
      Move !
      Pen 0 {
            Step 100, 100
            For i=1 to 2 {
                  Path n {
                        Polygon 0, 1000, 0, 0,600, -700,0, 0,100,700,0,0,300, -1000,0,0,-600,700,0,0,-100,-700,0,0,-300
                        Step 200, 300
                  }
                  Step -300, -400
                  n=15-n
            }
      }
      Step 1400,0
      Cursor !
End Sub
Sub drawframe0()
      local i, n=0
      Move !
      Pen 0 {
            Step 100, 100
            For i=1 to 2 {
                  Path n {
                        Polygon 0, 1000, 0, 0,1000, -1000,0, 0,-1000
                        Step 200, 300
                        Polygon 0, 600, 0, 0,400, -600,0, 0,-400
                  }
                  Step -300, -400
                  n=15-n
            }
      }
      Step 1400,0
      Cursor !
End Sub
}
MODULE EN {\\ by default Dog=1, Cat=2
\\ we can change it: Dog=0, Cat   ' so now Cat=1
\\ we can change it: Dog=100, Cat=200
\\ we can put a new line in place of comma
\\ or after comma,
\\ we can't leave a comma as last character except new lines, in the enum block.
Enumeration Pets {
      Dog
      Cat
}
a=Dog
Print a=1 ' true
a++
Print Eval$(a)="Cat", a=2
k=Each(Pets)
While k {
      Print Eval$(k), Eval(k)
      a=Eval(k)
      Print a<Cat
      Alfa(a)
}
a=Dog
AlfaByRef(&a)
Print a=Cat

Sub Alfa(b as Pets)
      Print b
End Sub
Sub AlfaByRef(&b as Pets)
      Print b
      b++
End Sub
}
MODULE FS {\\ appdir$ is the application directory. Normally we nevert use it
\\ dir$ is the current dir
\\ see Help "file operations" or Help "file "
\\ Help Files  (or one of this list BITMAPS, CLOSE, DRAWINGS, FILES, GET, LINE INPUT, MOVIES, NAME, OPEN, PUT, SEEK, SOUNDS, WRITE)

Dir user  ' set current directory to M2000 user
userdir$=dir$
Declare fs "Scripting.FileSystemObject"
Method fs, "GetFolder", dir$ as fc
With fc, "SubFolders" set SubFolders
Print type$(SubFolders)
show_members(SubFolders)


With SubFolders, -4& as Folder, "count" as SF.count
Print SF.count
if SF.count>0 then
	Show_Folders(SubFolders)
else
	Try ok {
		SubDir NewFolder1
		wait 100  ' give some time to system
		if exist.dir("..\NewFolder1") then
			Print "Folder Created"
			Dir ..\     ' return
		else
			dir user
		End if
	
	}
	if error or not ok then Print "Error from SubDir:"+Error$
	Print "Total folders="; SF.count
	If SF.count> 0 then Show_Folders(SubFolders)
End If
Win Dir$  ' open explorer in M2000 user directory
Rem Win "explorer", "/select,"+dir$  ' open explorer with selected name the folder dir$
declare fs nothing


sub show_members(obj)
local mm=param(obj), i
IF LEN(mm)>1 THEN {
      For i=0 to len(mm)-1
            Report 3, mm$(i!) ' use index, not key
      Next i
}
end sub
sub Show_Folders(obj)
With obj, -4& as new Folder

	With Folder, "Name" as FolderName$
	
	While Folder {
	      Print FolderName$
	}

end sub
}
MODULE FS1 {Declare fs "Scripting.FileSystemObject"
Method fs, "GetFolder", dir$ as fc
With fc, "files" set files
\\ Produce the TypeLib
mm=param(files)
IF LEN(mm)>1 THEN {
      For i=0 to len(mm)-1
            Report 3, mm$(i!) ' use index, not key
      Next i
}
Print "Press a key ": Print Key$
With files, "count" as count
if count>0 then
      With files, "item" set myfile ("llist1.gsb")
      \\ this is a property -4 which return a IEnumVariant
      With files, -4& as EnumFile
      Print Type$(EnumFile)
      \\ Produce the TypeLib
      m=param(EnumFile)
      IF LEN(m)>1 THEN
            For i=0 to len(m)-1
                  Report 3, m$(i!) ' use index, not key
            Next i
      End If
      Print "Press a key ": Print Key$
      With EnumFile, "Name" as aName$
      While EnumFile
            Print aName$
      End While
End if
Declare fs nothing

}
MODULE GAME {Module Game2048 {
      \\ 10% 4 and 90% 2
      Def GetTlleNumber()=If(Random(10)<2->4, 2)
      \\ tile
      Def Tile$(x)=If$(x=0->"[    ]", format$("[{0::-4}]", x))
      \\ empty board
      BoardTileRight =lambda (x, y)->x+y*4
      BoardTileLeft=lambda (x, y)->3-x+y*4
      BoardTileUp=lambda (x, y)->x*4+y
      BoardTileDown=lambda (x, y)->(3-x)*4+y
      Dim Board(0 to 15)
      Inventory EmptyTiles
      \\ Score is a statement but we can use it as a variable too.
      Score=0
      \\ Win is also a statement but we can use it as a variable too.
      Win=False
      ExitNow=False
      BoardDirection=BoardtileRight
      Process(BoardDirection)
      \\ Split Rem lines to insert start condition to check valid moves
      Rem : board(0)=2
      Rem : board(1)=2, 2, 2 ' place to (1), (2), (3)
            While len(EmptyTiles) {
            NewTile()
            DrawBoard()
            Action=False
            do {
                  a$=key$
                  if len(a$)=2 then {
                        Action=true
                        Select case Asc(mid$(a$,2))
                        Case 72
                        BoardDirection=BoardTileUp
                        Case 75
                        BoardDirection=BoardTileRight
                        Case 77
                        BoardDirection=BoardTileLeft
                        Case 80
                        BoardDirection=BoardTileDown
                        Case 79 ' End key
                              ExitNow=True
                        Else
                        Action=false
                        end select
                  }
            } until Action
            If ExitNow then exit
            Process(BoardDirection)
      }
      If Win then {
            Print "You Win"
      } Else {
            Print "You Loose"
      }
      Refresh 30
      End
      Sub Process(Boardtile)
      Inventory EmptyTiles ' clear inventory
      local where, i, j, k
      For i=0 to 3
            Gravity()
            k=boardtile(0,i)
            For j=1 to 3
                  where=boardtile(j,i)
                  if Board(where)<>0 then {
                        if board(k)=board(where) then {
                               board(k)*=2 : score+=board(where): board(where)=0
                               if board(k)=2048 Then Win=True : ExitNow=true
                        }
                  }
                  k=where
            Next j
            Gravity()
            For j=0 to 3
                  where=boardtile(j,i)
                  if board(where)=0 then Append EmptyTiles, where
            Next j
      Next i
      End Sub
      Sub NewTile()
            local m=EmptyTiles(Random(0, len(EmptyTiles)-1)!)
            Board(m)=GetTlleNumber()
            Delete EmptyTiles, m
      End Sub
      Sub DrawBoard()
            Refresh 2000
            Cls
            Cursor 0, 10
            Local Doc$, line$
            Document Doc$
            Doc$=Format$("Game 2048 Score {0}", score)
            \\ Using Report 2 we use rendering as text, with center justify
            Report 2, Doc$
            Doc$={
            }
            Local i, j
            For i=0 to 3
                  line$=""
                  For j=0 to 3
                        line$+=Tile$(Board(BoardTileRight(j, i)))
                  Next j
                  Print Over $(2), Line$
                  Print
                  Doc$=Line$+{
                  }
            Next i
            Report 2, "Next:Use Arrows | Exit: Press End"
            Refresh
            ClipBoard Doc$
      End Sub
      Sub Gravity()
            k=-1
            for j=0 to 3 {
                  where=boardtile(j,i)
                  if k=-1 then if board(where)=0 then k=j : continue
                  if board(where)=0 then continue
                  if k=-1 then continue
                  board(boardtile(k,i))=board(where)
                  board(where)=0
                  k++
            }  
      End Sub
}
Game2048
}
MODULE FIX1 {Class fixme {
      f=lambda->1
}
fix->fixme()
next_fact=lambda fix (x)->{
     if x<=1 then =1 :exit
     =x*fix=>f(x-1)
}
fix=>f=next_fact
Print next_fact(5)
m=next_fact
Print m(5)
}
MODULE Y {Module Ycombinator {
      \\ factorial
      Print lambda (g, x)->{=g(g, x)}(lambda (g, n)->if(n=0->1, n*g(g, n-1)),10)
       \\ fibonacci
      Print lambda (g, x)->{=g(g, x)}(lambda (g, n)->if(n<=1->n,g(g, n-1)+g(g, n-2)), 10)

      \\ Using closure in y, y() return function
      y=lambda (g)->lambda g (x) -> g(g, x)
    
      fact=y((lambda (g, n)-> if(n=0->1, n*g(g, n-1))))
      Print fact(6), fact(24)
    
      fib=y(lambda (g, n)->if(n<=1->n,g(g, n-1)+g(g, n-2)))
      Print fib(10)
}
Ycombinator
}
MODULE EV {Module CheckEvents {
      \\ we can use standard functions (not lambda functions)
      \\ we can use lambda() so we can use function with different names
      \\ We can define functions inside groups with events
     Group WithEvents Alfa {
           Event "GetIt", "PushIt"
           Function fib(n) {
                  if n<=1 then {
                        =val(n->Decimal)
                  } else {
                        if n<140 then { m=-1@} else m=-1
                        call event "Getit", n, &m
                        if m>-1 then =m : exit
                        \\ m1 may get double if a decimal can write the result
                        \\ if we use m we get overflow error
                        m1=lambda(n-1)+lambda(n-2)
                        call event "Pushit", n, m1
                        =m1
                  }            
            }
      }
      \\ we use an Inventory list to save old values
      Inventory Getit
      \\ event's service functions
      \\ if not event's functions exist, call event skipped
      Function Alfa_Getit {
            Read new key, &m
            if exist(Getit, key) then m=eval(Getit)
      }      
      Function Alfa_Pushit {
            Read new key, m
            Append Getit, key:=m
      }
      Module Inner (&fibonacci()){
            acc=0
            For i=1 to 200 ' until 139 we get decimal type, above it we get double
                  Print fibonacci(i),
            Next i
      }
      Form 80,32
      print $(4,20),	' set: proportional text, 20 characters column width
      Inner &Alfa.fib()
      print $(0,10),	' reset: no proportional text, 10 characters column width

}
CheckEvents
}
MODULE MG {Font "Arial"
Form 60,44
Escape Off
Flush
Flush Garbage
mybg=5
Cls mybg,0 : Pen 11
Bold 1
Report "Console Input Parameters Easy"
Bold 0
Cursor 0,0 : Print Under
Cls , 1

\\  ValidateValue(number, letter$)
\\  return a lambda function with closures And signature lambda(letter$), returning boolean
\\  ValidateValue( number, number)
\\  return a lambda function with closures And signature lambda(number), returning boolean

Function ValidateValue {
      IF match("NN") Then {
            Read X1, Y1
            =lambda X1, Y1 (n) ->{
                  =X1<=n And n<=Y1 ' Or n<Y1
            }
      } Else {
            Read what, x1$
            =lambda x1$, what (n$) ->{
                  IF what=0 Then {
                        =n$ ~ x1$
                  } Else.If what>0 Then {
                         =n$ >= x1$ And len(n$)>what
                  } Else = n$ >= x1$ And len(n$)>-what And n$=filter$(n$, " ")
            }      
      }
}
\\ InpValueClass make a group
\\ We can display labels, values, recording positions
\\ Using ScanRange we can use arrows To move from a range of input values, in Loop
\\ using Esc we get out from Loop
\\ we can give two more parameters
\\ the "Exit" value  And a flag, IF True Then Exit IF value changed
\\  mygroup=InpValueClass(#FF5522)  '' need a color for background
\\
\\  .Record=True  needed for recording
\\  .PrintLabel
\\  .PrintNext
\\  .PrintUp
\\  .UseLastAsList
\\ when we record we make ranges of input/print values And we can use
\\ .RenderView To print labels/values
\\ .ScanRange 
\\
Class InpValueClass {
Private:
      NoKey, LastKey$, UseInteger, drawbg, overridecolors, mybg, overfr, overbg
      Inventory Bag, EditItems
Public:
      Record=True,  item
      Property mywidth {
            Value, 
            Set {
                  IF value>width Then value=width
                  IF value<3 Then value=3
            }
       } = 10
      Property myheight {
            Value,
            Set {
                  IF value>height-1 Then value=height-1
                  IF value<1 Then value=1
            }
      }=1
      Group MaxInputItem {
            Value {
                  Link Parent EditItems To Ed
                  =Len(Ed)
            }
      }
      Group MaxItem {
            Value {
                  Link Parent Bag To Bag
                  =Len(Bag)
            }
      }
      Group ItemValue {
            Value (akey$) {
                  Link Parent Bag To Bag
                  =Bag(akey$+".value")
            }
            Set (akey$) {
                  Read mGroup
                  Link Parent Bag To Bag
                  IF exist(Bag, akey$+".value") Then {
                        Return Bag, akey$+".value":=mGroup
                  }
            }
      }
      Class Info {
            iskey, isbutton, menuitem, isnumeric
            Event CallBack { Read &What }
            ValidValue=Lambda->True
            myvalue$
            stackA=stack
            X, Y, mycolor, boldface
            W=10, H=1
            \\ only for button
            mybg
      Class:
            Module Info {
                  Read .isnumeric, .iskey, .MyValue$
                  Read .X, .Y, .W, .H, .mycolor, .boldface, .ValidValue
            }
      }
       Module PrintNext {
            Cursor 0, Row-1
            .PrintLabel
      }
      Module PrintLabel {
            ticket=False
            IF IsNum Then {
                  ticket=1-.UseInteger 
                  Read N 
                  IF ticket=2 Then { what$=Trim$(Str$(N,"0")) } Else  what$=Trim$(Str$(N))
            } Else Read what$
            Let colour=pen, spaces=0, boldface=0
            Read ?  spaces, colour, boldface
            bold Abs(boldface<>0)
            Pen colour {
                  Print @(spaces),
                  IF .Record Then RecordMe()
                  IF ticket Then  what$=Format$("{0}",N)
                  IF .drawbg Then .drawbg<=False : Print @(Pos,Row,Pos+.mywidth, Row+.myheight, .mybg);
                  IF .myheight>1 Then {
                        Legend ! what$, .mywidth, .myheight
                  } Else {
                        Legend ! what$, .mywidth, 1          
                  }
                  Print
            }
            bold 0
            Sub RecordMe()
                  Local mylambda=lambda->True
                  IF Not empty Then Read myLambda
                  IF  Not .NoKey Then {
                        Append .Bag, what$:=.Info(False, true, what$, Pos, Row, .mywidth, .myheight, colour, Abs(boldface<>0), mylambda)
                        .lastkey$<=what$+".value"
                        \\ using = And Not  <= we get Error in next call
                        \\ becaue = make a Local variable, but .lastkey$ is a group variable.
                  } Else {
                        Try ok {
                              Append .EditItems, len(.Bag)
                             Append .Bag, .lastkey$:=.Info(ticket, False, what$, Pos, Row, .mywidth, .myheight, colour, Abs(boldface<>0), mylambda)
                         }
                         \\ using of Flush Error To clean Error message first
                         IF Error Or Not ok Then Flush Error : Error "You can't record two values in same key"
                  }
            End Sub
      }
      Module PrintButtonNext {
            Cursor 0, Row-1
            .PrintButton
      }
      Module  PrintButton {
            Read .LastKey$, caption$
            Oldmybg=.mybg
            Read ? .mybg
            Push caption$
            .LastKey$<=.LastKey$+".value"
            .NoKey~
            .drawbg~
            .PrintLabel
            .NoKey~
            \\ Bag(key) Or Bag(num!) num from 0 To len(Bag)-1
            Read ? event_copy
            there=Len(.Bag)-1
            
            For .Bag(there!), this {
                 .isbutton<=True
                 .callback<=event_copy
                 .mybg<=..mybg
            }
            swap Oldmybg, .mybg
      }
      Module PrintText (Lines, TextWidth) {
            Cursor 0, Row-1
            .NoKey~
            Let oldw=.mywidth, oldH=.myHeight
             .mywidth<=TextWidth
             .myheight<=Lines
            .PrintLabel 
            swap .mywidth, oldw
            swap .myHeight, oldH
            .NoKey~
      }
      Module  UseLastAsList (ArrayA) {
            Read ? event_copy
            IF  Instr(.lastkey$,".value") Else Exit
            For .Bag(.Lastkey$)  {
                  Stack New {
                        Data !ArrayA
                        .CallBack<=event_copy
                        \\ this [] pass current stack To .StackA, and leave a new empty stack
                        \\ [] is "[" and "]" (these chars can be used in variables names too)
                        .StackA<=[]
                  }
            }
      }
      Module InpList {
            a=Each(.EditItems)
            While a {
                  \\ ! use position (form 0) And no key To walk in .bag()
                  for .bag(eval(a)!) {
                        Print .MyValue$, Len(.stackA)>0, .isbutton, .iskey
                  }
            }
      }
      Group Json$ {
            Value (x) {
                 ' quote$(string$(MyValue$ as json)) 
                 bag$=""
                 nl$={
                 }
                 if x<=0 then nl$="" : x=0
                  space$=string$(" ",x)
                  Link Parent bag To bag
                  a=Each(bag)
                  While a {
                        M= bag(a^!)
                        For M {
                              IF Not .iskey and Not .isbutton Then {
                              if bag$<>"" then bag$=bag$+", "+nl$
                                    bag$=bag$+space$+quote$(Replace$(".value","",Eval$(bag, a^-1)))+" : "+quote$(string$(.MyValue$ as json)) 
                               }
                        }
                  }
                  ="{"+nl$+bag$+nl$+"}"
            }
            Set {
                  Read bag$
                  c$=""""   \\ this is one char 34
                  nl$={
                  }
                  end$=""
                  Link Parent bag To bag
                  safety=len(bag$)
                   Stack New {
                   if left$(trim$(bag$),1)="{" then  {
                         bag$=Trim$(RightPart$(bag$,"{"))
                         end$="]"
                   } else.if left$(trim$(bag$),1)="[" then  { 
                        bag$=Trim$(RightPart$(bag$,"{"))
                        end$="}"
                   }
                        do {
                              While Left$(bag$,2)=nl$ {bag$=Trim$(Mid$(bag$, 3))}
                              bag$=Trim$(RightPart$(bag$, c$))
                              mkey$=LeftPart$(bag$, c$)+".value"
                              bag$=Trim$(RightPart$(bag$, c$))
                              if mkey$="" then exit
                              While Left$(bag$,2)=nl$ {bag$=Trim$(Mid$(bag$, 3))}
                              bag$=Trim$(RightPart$(bag$,":"))
                              While Left$(bag$,2)=nl$ {bag$=Trim$(Mid$(bag$, 3))}
                              bag$=Trim$(RightPart$(bag$, c$))
                              mval$=LeftPart$(bag$, c$)
                              bag$=Trim$(RightPart$(bag$, c$))
                              Group M
                              if exist(bag, mkey$) Then {
                                    M=eval(bag)
                                    M.myvalue$<=format$(mval$)
                                    Return bag, mkey$:=M
                              }
                              If left$(bag$, 1)="," then bag$=Trim$(Mid$(bag$, 2)) : Restart
                              if end$<>"" then if left$(bag$,1)=end$ then exit
                              if safety=len(bag$) then Error "Json parse problem"
                              safety=len(bag$)                              
                        } Until bag$=""
                        
                  }
            }
      }
      Group Serialize$ {
            value {
                  bag$=""
                  Link Parent bag To bag
                  a=Each(bag)
                  While a {
                        M= bag(a^!)
                        For M {
                              IF Not .iskey and Not .isbutton Then {
                                    IF .isnumeric Then {
                                     bag$=bag$+" "+.MyValue$
                                    } else  bag$=bag$+stack$(.MyValue$)
                               }
                        }
                  }
                  =bag$
            }
            Set {
                  Read bag$
                  Stack New {
                        Stack bag$  \\ fill stack with special format string for stack
                        Link Parent bag To bag
                        a=Each(bag)
                        Try ok {
                              While a {
                                    M= bag(a^!)
                                    For M {
                                          IF Not .iskey And Not .isbutton Then {
                                                IF .isnumeric=1 Then {
                                                      Read N
                                                      .MyValue$=Trim$(Str$(N))
                                                } Else.If  .isnumeric=2 Then {
                                                      Read N%
                                                      .MyValue$=Trim$(Str$(N%))
                                                } Else Read .MyValue$
                                           }
                                    }
                              }
                        }
                        If Error Or Not ok Then Flush Error : Error "Serialize Input Not Compatible"
                  }
            }
      }
      Module PrintUp {
            Cursor 0, Row-1
            .NoKey~
            .PrintLabel
            .NoKey~
      }
      Module PrintUpInteger {
            Read N
            Push Val(Str$(N,"0"))
            Cursor 0, Row-1
            .NoKey~
            .UseInteger~
            .PrintLabel
            .UseInteger~
            .NoKey~
      }
      Module RenderThis {
            Read M
            Read ? offsetX, offsetY
            IF .overridecolors Then {
                  mybg= .overbg
            } else {
                  mybg=.mybg
            }
            local inuse, final$
            For M {
                        IF this.overridecolors and .isbutton Then exit
                        offsetX+=.X
                        offsetY+=.Y
                        Cursor offsetX, offsetY
                        IF .isbutton Then mybg=.mybg  \\ from M.mybg
                        Print @(offsetX, offsetY, offsetX+.W, offsetY+.H, mybg);
                        IF this.overridecolors Then {inuse=this.overfr} else inuse=.mycolor
                        Pen inuse {
                              Bold .boldface
                              if .isnumeric then {
                                   final$=format$( "{0}", Val(.MyValue$) )
                              } else final$=.MyValue$
                              IF .H>1 Then {
                                    Legend ! final$, .W, .H
                              } Else Legend ! final$, .W, 1
                              Bold 0
                        }
                  }
      }
      Module RenderView {
            local fromA=1, toB=-1, offsetX, offsetY
            Read ? FromA, toB, offsetX, offsetY, .overridecolors
            IF .overridecolors Then Read .overfr, .overbg
            N=Each(.Bag, FromA, toB)
            While N {
                  .RenderThis .Bag(N^!),offsetX, offsetY
            }
            Print
            .overridecolors<=false
      }
      Module ScanRange {
            Local FromA=1, ToB=.maxitem, vert, curx, cury, mKey$
            IF ToB=0 Then Exit
            Read ? FromA, ToB
            Read ? ExitC, forever
            Local changed
            .item<=FromA
            Field New 1 ' reset To 1 the Field internal variable.
            mybg=.mybg
            {
                  GetAValue(.item, &changed)
                  IF changed Then vert=False
                  IF Field=99 Or Field=121 Then .item<=0 : Exit
                  IF Field=1000 Then Exit
                  IF .item=ExitC And (changed Or Not forever) Then Field New 1000 : Exit
                  IF vert  Then {
                        vert=False
                        IF .item>=ToB  And Field=1 Then Exit
                        IF .item<=FromA  And Field=-1 Then Exit
                        IF Field=1 Then {
                              a=Each(.EditItems, .item+1, ToB)
                        } Else  a=Each(.EditItems, .item, FromA)
                        last=.item
                        Try {
                              While a {
                                    IF Field=1 Then {
                                           for .bag(eval(a)!) {
                                                IF .x>=curx And .y>cury Then last<=a^ :Break
                                         }
                                    } Else {
                                           for .bag(eval(a)!) {
                                          IF .x>=curx And  .y<cury Then {
                                                field new 0 : last<=a^+1 
                                                IF .x>curx   else  Break
                                          }
                                          }
                                    }
                              }
                        }          
                        .item<=last      
                  } 
                  IF Field=1 Then .item++
                  IF Field=-1 Then .item--
                  IF .item<FromA Then .item<=ToB
                  IF .item>ToB Then .item<=FromA
                  CONTHERE:
                  Loop
            }
            Sub CheckOk()
                  Refresh
                  ok=-2
                  {
                        ok=inkey(100)  \\ delay 100ms IF no key pressed (return -1 IF no key pressed in 100ms)
                        IF ok=-1 Then Loop   ' any block can performe once using loop statement
                  }
                  Select Case ok
                  Case 121 ' F10
                        oldfield=121
                  Case 262162
                        oldfield=99
                  Case 38
                        { oldfield=-1 : vert=True }
                  Case 40  ' two Or more statements need a block after Case
                        { oldfield=1 : vert=True}
                  Case 39 ' left
                        oldfield=1 
                  Case 37 ' right
                        oldfield=-1  
                  Case 27, -2
                        {
                              While keypress(27) {} : oldfield=99
                        }
                  End Select
            End Sub
            Sub GetAValue(where, &changed)
                  Local N,N$, posnow=Pos, rownow=Row, StackB, k$, oldfield=Field, ok
                  IF Not Abs(oldfield)=1 Then oldfield=1
                  Try ok {
                        where=val(eval$(.EditItems, where-1))
                  }
                  IF Error Or Not ok Then Exit Sub
                  Try {
                        mKey$=Eval$(.Bag, where)
                  }
                  IF mKey$="" Then Exit Sub
                  IF  Instr(mKey$,".value") Else Exit Sub
                  temp=.Bag(mKey$)
                  For temp {
                        Let curx=.x, cury=.y
                        IF  Len(.stackA)>0 Then {
                              Print @(.X,.Y, .X+.W, .Y+.H, 7),
                              IF Not .isbutton Then  Mark 1,1, 8: Print " ";
                              Pen .myColor {
                                    Bold .boldface
                                    IF .H>1 Then {
                                          Legend ! .MyValue$, .W, .H
                                    }  Else  Legend ! .MyValue$, .W, 1
                                    Bold 0
                              }
                              CheckOk()
                              IF ok=13 Or ok=9 Or ok=32 Then {
                                    ShowMenu()   
                              }
                        } Else.If  .isnumeric Then {
                              Print @(.X,.Y, .X+.W, .Y+.H, 7);
                                          Pen .mycolor {
                                                Bold .boldface
                                                Legend ! Format$("{0}",val(.MyValue$)), .W, 1
                                                Bold 0
                                          }
                                          CheckOk()
                                          IF ok>=96 And ok<=105 Then ok=ok-48
                                          IF ok=13 Or ok=9  Or Chr$(ok) ~ "[0-9]" Then {
                                                N=Val(.MyValue$)
                                                Pen .mycolor {
                                                IF Chr$(ok) ~ "[0-9]" Then {
                                                      IF N=0 Then {N=Val(Chr$(ok))} Else N=Val(.MyValue$+Chr$(ok))
                                                }
                                                    Print @(.X,.Y,.X+.W, .Y+.H, 7);
                                                    IF .isnumeric=2 Then {
                                                            N%=N
                                                            Input ! N%, .W
                                                            N=N%
                                                    } Else Input ! N, .W
                                                }
                                                IF .ValidValue(N) Then {
                                                      changed=Not .MyValue$=Trim$(Str$(N))
                                                      .MyValue$<=Trim$(Str$(N))
                                                }
                              }
                        }  Else {
                                   Print @(.X,.Y,.X+.W, .Y+.H, 7);
                              IF .isbutton Then {
                                   Pen .mycolor {
                                          Bold .boldface
                                          IF .H>1 Then {
                                                Legend ! .MyValue$, .W, .H
                                          }  Else Legend ! .MyValue$, .W, 1
                                          Bold 0
                                    } 
                                    CheckOk()
                                    Field New oldfield
                                    IF  ok=13 Then  Call Event .callback,  &This, Replace$(".value","", mKey$) : changed=True
                                    oldfield=Field
                              } Else { 
                                    N$=.MyValue$
                                    Pen .mycolor {
                                          Bold .boldface
                                          IF .h>1 Then {
                                                Legend ! .MyValue$, .W, .H
                                                CheckOk()
                                                IF ok=13 Or ok=9  Or ok=32 Then  Input ! N$, .w, .h,"Editor"
                                          } Else {
                                                Legend ! .MyValue$, .W, 1
                                                CheckOk()
                                                IF ok=13 Or ok=9 Or ok=32 Then Print @(.X,.Y,.X+.W, .Y+.H, 7); : Input ! N$, .w
                                          }
                                          Bold 0                              
                                    }
                                    IF  .ValidValue(N$)  Then {
                                          changed=Not .MyValue$=N$
                                          .MyValue$<=N$
                                    }
                              }
                        }
                        IF .isbutton Then {
                        Print @(.X,.Y, .X+.W, .Y+.H, .mybg);
                        } Else  Print @(.X,.Y,  .X+.W, .Y+.H, mybg);
                        Pen .mycolor {
                              Bold .boldface
                              IF .H>1 Then {
                                    Legend ! .MyValue$, .W, .H
                              }  Else {
                                    IF .isnumeric Then {
                                      Legend ! Format$("{0}",val(.MyValue$)), .W, 1
                                     } Else  Legend ! .MyValue$, .W, 1 
                                }
                              Bold 0
                          }        
                  }
                  Field New oldfield
                  Cursor posnow, rownow
                 Return  .Bag, mKey$:=temp
            End Sub
            Sub ShowMenu()
                        oldfield=1
                        Print @(.X,.Y+1),
                        IF Not .isbutton Then Print @(.X,.Y), :Mark 1,1, 15 :  Print " ";
                        menu fill 7,7, .mycolor
                        menu frame off
                        menu  \\ erase menu
                        StackB=Each(.stackA)
                        While StackB {
                              Menu  + stackitem$(StackB)
                        }
                        try ok {
                              menu show .MyValue$
                        } 
                       IF Error Or Not ok Then Error flush : Menu !   \\ show menu
                       Menu fill 1  \\ reset fill colors
                       menu frame  \\ reset frame
                       IF menu>0 Then {
                             IF Not .isbutton Then {
                                    changed=Not .MyValue$=menu$(menu)
                                    .MyValue$<=menu$(menu)
                              } Else .menuitem<=menu
                              Field New oldfield
                              Call Event .callback,  &This, Replace$(".value","", mKey$)
                              oldfield=Field
                              IF Abs(oldfield)=1 Then oldfield=0
                        } Else oldfield=0
      End Sub
      }
      Class:
      module  InpValueClass (.mybg) {
            Read ? .mywidth, .myheight
      }
}

LocalVar$="New Title - Module scope variable"
exitthis=False
Function FromEvent {
      Read New &What, mykey$
      Local K
      K=Ask(what.myvalue$, LocalVar$)
}
Function FromEvent2 {
      Read New &What, mkey$
      Local K

      IF what.menuitem>0 Then {
            IF instr(Menu$(what.menuitem),"---")>0 Then Break
            K=Ask(what.myvalue$+" "+Menu$(what.menuitem), "No2")
            IF what.menuitem=2 Then {
                  M=InpValue2.ItemValue("Exit")
                  M.myvalue$="Press me "+Time$(Now)
                  InpValue2.ItemValue("Exit")=M
                  InpValue2.RenderThis M
            }
      } Else {
             K=Ask(what.myvalue$, "No2")
      }
      IF mKey$="File" And what.menuitem=4 Then Field New 99  : exitthis=True : Exit
      Cls, -14
      InpValue2.InpList
}
Function FromEvent3 {
      \\ this is a module's variable
'     exitthis=True
'      Field New 99
      \\ We can use 1000 as default Exit
      Field New 1000
}
Event E1 { Read &A, B$}
E2=E1  ' copy of E1 To E2
FIN=E2 ' copy of E2 To FIN
\\ Using  Lazy$(&FromEvent()) And Not FromEvent() we pass code from module
\\ when run take the module name space, so all modules variables/modules/functions are visible
\\ except subrutines.
Event E1 New Lazy$(&FromEvent())
Event E2 New Lazy$(&FromEvent2())
Event FIN New Lazy$(&FromEvent3())
\\ Now we have
 InpValue=InpValueClass(mybg)
 InpValue2=InpValueClass(mybg)
middlepoint=0
For InpValue {
      .mywidth=6
      .PrintButton "File","File [F10]",,,8,1,,E2
      .UseLastAsList ("Menu1","Menu2","Menu3","Exit")
      .PrintButtonNext "Edit","Edit",,6,8,1,,E2
      .UseLastAsList ("Help","Update","--------","About")
      }
For InpValue2 {      
      .mywidth=10
      .PrintLabel "Element",,15,1
      .PrintLabel "Type", 4
      .PrintUp "Combo", 10, 14
      .UseLastAsList ("ListBox","Combo", "TextBox", "EditBox"), E1
      .PrintLabel "Name", 4
      .PrintUp "Combo1", 10, 14,,ValidateValue(-3, "A")
      .PrintLabel "Text Field",4
      Document AA$={aaaaaaaaaaaaa
                                          bbbbbbbbbbbbb
                                          cccccccccc
                                          }
      .PrintText 3, 30, AA$, 10,14
      middlepoint=.maxitem
      Cursor 0, Row+4
      .PrintLabel "Attributes",,15,1
      .PrintLabel "Title", 4
      .PrintUp "Form1", 10, 14
      .PrintLabel "Top", 4
      .PrintUpInteger 0, 10, 14
      .PrintNext "Left",24
      .PrintUpInteger 0, 30, 14
      .PrintLabel "Width",4
      .PrintUpInteger 4000, 10, 14, ,ValidateValue(3000, 12000)
      .PrintNext "Height",4+20
      .PrintUpInteger 6000, 10+20, 14
      .PrintLabel "Double",4
      .PrintUp pi, 10, 14
      .PrintNext "Double1",24
      .PrintUp 2*pi, 30, 14
      .PrintNext "Double2",44
      .PrintUp 4*pi, 50, 14
      .PrintButton "Exit","For Exit Come Here", 8, 10, 15, 1,,FIN
       Print "Press Esc Key"
      THERE:
     Cls, Row
   \\    .RenderView
}
\\Exit
maxInputitem=InpValue2.maxInputItem
do {
      do {
      InpValue.ScanRange
      } until Field<>121
      IF exitthis Then Exit
      InpValue2.ScanRange 1, maxInputitem, maxInputitem-1, True
} until exitthis Or Field=1000

\\ Part 2
Cls 15, 1
Pen 0
Report "Print to Paper <Demo on Screen>"
\\ export without buttons, black color on white paper
InpValue2.RenderView 1,7, 5, 5, true, 0, 15
\\ -1 is the maxitem in bag
Cursor 0,15
Report "We can move a group by offset X and Y"
\\ using -1 for end mark
\\ 5 chars right, 10 char lines down
InpValue2.RenderView 8, -1, 5, 10, true, 0, 15

Print InpValue2.maxitem
A$=InpValue2.Serialize$
Print A$
InpValue2.Serialize$=A$
A$=key$
cls mybg,1
Pen 15
Report "RenderView"
InpValue2.RenderView 
Report "Json 2 chars indent"
Pen 14
Report InpValue2.Json$(2)
A$=InpValue2.Json$(0)
Pen 15 {
      Report "Json 0 chars indent"
}
Report A$
Pen 15 {
      Report "Len json$ vs Serialize$"
}
Print  Len(A$), Len(InpValue2.Serialize$)  '' 216, 123
InpValue2.Json$=A$
Pen 15 {
      Report {InpValue2.Json$={"Left" : "1000", "Top" : "500"}}
}

InpValue2.Json$={"Left" : "1000", "Top" : "500"}
Report InpValue2.Json$(0)
Escape on
}
MODULE QSORT3 {Module Checkit3 {
      Class Quick {
      Private:
            partition=lambda-> {
                  Read &A(), p, r : i = p-1 : x=A(r)
                  For j=p to r-1 : If .LE(A(j), x) Then i++:Swap A(i),A(j)
                  Next j : Swap A(i+1), A(r) :  Push  i+2, i 
            }
      Public:
            LE=Lambda->Number<=Number
            Module ForStrings {
                  .partition<=lambda-> {
                        Read &A$(), p, r : i = p-1 : x$=A$(r)
                        For j=p to r-1 : If A$(j)<= x$ Then i++ : Swap A$(i),A$(j)
                        Next j : Swap A$(i+1), A$(r) : Push i+2, i
                  }
            }
            Function quicksort {
                  Read ref$
                  do 
                        loop : If Stackitem() >= Stackitem(2) Then 
                        Drop 2  
                        \\ if  empty then Break else continue  
                                           \\ because is hidden  if empty then {Break} else continue
                         \\ but here 
                         if  empty then
                               exit 
                        else
                              continue
                        end if
                        end if
                        over 2,2 : call .partition(ref$) :shift 3 
                  always
            }
      }
      Quick=Quick()
      Dim A(10)<<Random(50, 100)
      Print A()
      Call Quick.quicksort(&A(), 0, Len(A())-1)
      Print A()
      Quick=Quick()
      Function join$(a$()) {
            n=each(a$(), 1, -2)
            k$=""
            while n {
                  overwrite k$, ".", n^:=array$(n)
            }
            =k$
      }
      Stack New {
                  Data "1.3.6.1.4.1.11.2.17.19.3.4.0.4" , "1.3.6.1.4.1.11.2.17.19.3.4.0.1", "1.3.6.1.4.1.11150.3.4.0.1"
                  Data "1.3.6.1.4.1.11.2.17.19.3.4.0.10", "1.3.6.1.4.1.11.2.17.5.2.0.79", "1.3.6.1.4.1.11150.3.4.0"
                  Dim Base 0, arr(Stack.Size)
                  i=0 : While not Empty {Let arr(i)=piece$(letter$+".", ".") : i++ }
      }
      \\ change comparison function
      Quick.LE=lambda (a, b)->{
            Link a, b to a$(), b$()
             def i=-1
             do {
                   i++
             } until a$(i)="" or b$(i)="" or a$(i)<>b$(i)
             If b$(i)="" Then =a$(i)="":Exit
             If a$(i)="" Then =true:Exit
             =val(a$(i))<=val(b$(i))
      }
      Call Quick.quicksort(&arr(), 0, Len(arr())-1)
      For i=0 to len(arr())-1 {
            Print join$(arr(i))
      }
      \\ Fresh load
      Quick=Quick()
      Quick.ForStrings
      Dim A$()
      A$()=("one","two", "three","four", "five")
      Print A$()
      Call Quick.quicksort(&A$(), 0, Len(A$())-1)
      Print A$()
}
Checkit3
}
MODULE CONC {Thread.Plan Concurrent
Module CheckIt {
      Flush  \\ empty stack of values
      Data "Enjoy", "Rosetta", "Code"
      For i=1 to 3 {
            Thread {
                  Print A$
                  Thread This Erase
            } As K
            Read M$
            Thread K Execute Static A$=M$
            Thread K Interval Random(500,1000)
            Threads
      }
      Rem : Wait 3000   ' we can use just a wait loop, or the main.task loop
      \\ main.task exit if all threads erased
      Main.Task 30 {
      }
\\ when module exit all threads from this module get a signal to stop.
\\ we can use Threads Erase to erase all threads.
\\ Also if we press Esc we do the same
}
CheckIt
 
\\ we can define again the module, and now we get three time each name, but not every time three same names.
\\ if we change to Threads.Plan Sequential we get always the three same names
\\ Also in concurrent plan we can use a block to ensure that statements run without other thread executed in parallel.
 
Module CheckIt {
      Flush  \\ empty stack of values
      Data "Enjoy", "Rosetta", "Code"
      For i=1 to 3 {
            Thread {
                  Print A$
                  Print A$
                  Print A$
                  Thread This Erase
            } As K
            Read M$
            Thread K Execute Static A$=M$
            Thread K Interval Random(500,530)
            Threads
      }
      Rem : Wait 3000   ' we can use just a wait loop, or the main.task loop
      \\ main.task exit if all threads erased
      Main.Task 30 {
      }
\\ when module exit all threads from this module get a signal to stop.
\\ we can use Threads Erase to erase all threads.
\\ Also if we press Esc we do the same
}
CheckIt
}
MODULE LISP {Profiler
EntryLevel =0
Module forall {  \\ For all subs - reusable code use Call ! Local forall
      Local MyAcc$
      Document MyAcc$
      Clear Buffer$  \\ delete command - need Clear /  = is For append
      Call Local Parser(level,  &MyAcc$)
}
Module Comm {
      Read proc$
      Call ! Local forall
      Local dummy$=paragraph$(MyAcc$,-1,-1)
      Local a, d, acc
      Long a, d=forward(MyAcc$, a)  \\ there is a  backward() function too
      If d<>0 Then {
      Select Case proc$
      Case "+"
      { While a<>0 { acc+=Val(paragraph$(MyAcc$, (a))) }}
      Case "-"
            {         If a<>0 Then   acc=Val(paragraph$(MyAcc$, (a))) 
                       While a<>0 { acc-=Val(paragraph$(MyAcc$, (a)))  }}
      Case "*"
            { acc=1: While a<>0 { acc*=Val(paragraph$(MyAcc$, (a))) }}
      Else  '  Case "/"
            { acc=1
                  If a<>0 Then  acc=Val(paragraph$(MyAcc$, (a))) 
                  While a<>0 { acc/=Val(paragraph$(MyAcc$, (a))) }}
      End Select    
       Accum$=Format$("{0}", acc)+nl$
      } 
}
Module CommWrite {
      Call ! Local forall
      Print "Lisp:";
      Local i, f=Doc.Par(MyAcc$)
      If f>1 Then {
      f--  : If f>1 Then Print "(";
      For i=1 to f
            Print paragraph$(MyAcc$, i); : If i<f Then  Print " ";
      Next i
      }
      If f>1 Then { Print ")" } Else Print
}
Module LoopLisp {
      Local dummy$ : Clear Buffer$
      cnt++ : Local backhere=cnt
      Local mylevel=level
      {
            Call Local Parser(myLevel, &Accum$)
            dummy$=paragraph$(Accum$,-1,-1)     \\ throw  last nl$
            dummy$= paragraph$(Accum$,-1,-1)
            Accum$=nl$  \\ insert  last nl$
            If dummy$="t" Then Exit
            cnt=backhere
            level=mylevel
            loop   
      }          
}
Module MyList {
      Local MyAcc$
      Document MyAcc$ : Clear Buffer$
      Call Local Parser(level, &MyAcc$)
      Accum$="("+Trim$(Replace$(nl$," ", MyAcc$))+")"+nl$       
}
Module Myif {
      Call ! Local forall
      If paragraph$(MyAcc$, 1)="t" Then {
            Accum$=paragraph$(MyAcc$, 2)+nl$
      } else {
            Accum$=paragraph$(MyAcc$, 3)+nl$
      }
}
Module DefVar {
      Local MyAcc$, Iddoc$
      Document MyAcc$, Iddoc$ : Clear Buffer$
      cnt++
      Call Local Parser(level,  &Iddoc$, True)
      Call Local Parser(level,  &MyAcc$)
      Local id$=paragraph$(Iddoc$, 1,-1)  \\ third parameter If is -1 Then delete the paragraph 
      If id$="" Then Error "No name For variable"
      While Doc.Par(iddoc$)>0 {
            Call Local PrintNewLine "Var :"+id$
            If not exist(Mem,id$) Then {
                  Append Mem, id$:=MyAcc$
            } Else Error "Variable "+id$+" already defined"
           id$=paragraph$(Iddoc$, 1,-1)
      }
}
Module SetVar {
      Local MyAcc$, Iddoc$
      Document MyAcc$, Iddoc$ : Clear Buffer$
      cnt++
      Call Local Parser(level, &Iddoc$, True)
      cnt--
      Call Local Parser(level, &MyAcc$)
      Local id$=paragraph$(Iddoc$, 1,-1)  \\ third parameter If is -1 Then delete the paragraph 
      If id$="" Then Error "No name For variable"
      While Doc.Par(iddoc$)>0 {
            Call Local PrintNewLine "Var :"+id$
            If exist(Mem,id$) Then {
                  Return Mem, id$:=MyAcc$
            } Else Error "No such variable"
           id$=paragraph$(Iddoc$, 1,-1)
      }
}
Module Cons {
      Call ! Local forall
      Accum$=MyAcc$
}
Module Remark {
     while cnt<=tmproof {
           cnt++
           If mid$(a$, cnt,2)=nl$ Then cnt++ : exit
     }
}
Module String {
     Local check=cnt
     Clear Buffer$ : numeric=false
     while cnt<=tmproof {
           cnt++
           If mid$(a$, cnt,1)=qu$ Then exit
     }
     if cnt-check>1 Then { Buffer$=Mid$(a$,check, cnt-check+1)} Else Buffer$={""}
}
Module  PrintBuffer {
      If Doc.Len(Buffer$)>0 Then {
                  If exist(Mem, Buffer$) and not GetQuote Then {
                       Accum$=Mem$(Buffer$)
                  } else   Accum$=Buffer$+nl$
            Call Local PrintNewLine Buffer$
            Clear Buffer$ : prints++
      }
}
Module PrintNewLine {
      Read New What$
     If mess Then Print what$
}
Module StopChar {
      Read New val    
      com = val=1
      level+=val
      If GetQuote And level<=EntryLevel Then Call Local PrintBuffer : GetQuote=false: tmproof=cnt : Exit
      If val<>0 Then Local oldprints=prints : prints=0
      Call Local PrintBuffer
      If profil=1 And val=-1 Then If prints=0 Then If oldprints=prints Then Buffer$="()" : Call Local PrintBuffer
      profil=val
}
Module StopCharZero {
      If GetQuote And level=EntryLevel Then Call Local PrintBuffer:GetQuote=false: tmproof=cnt : Exit
      If com Then Call Local CheckCommand
      If not com Then Call Local PrintBuffer : Exit
}
Module StorePeriod {
      If Doc.Len(Buffer$)=0 Then Call Local StoreNumeric : Exit
      If numeric Else Call Local StoreLabel : Exit  \\ see Else, same as If not numeric Then
      If Instr(Buffer$,".")>0 Then Call Local PrintBuffer
      Call Local StoreNumeric
}
Module StoreSign {
      If Doc.Len(Buffer$)>0 And numeric Then Call Local PrintBuffer : Call Local  StoreNumeric : Exit
      Call Local StoreNumeric  \\ maybe numeric=False so this is like storelabel...
}
Module StoreNumeric {
      If Doc.Len(Buffer$)=0 Then  numeric=True 
      buffer$=one$
}
Module StoreLabel {
      numeric=False
      buffer$=one$
}
Module CheckCommand {
      com=false
      If GetQuote Then Exit
      If numeric Then {
            If Doc.Len(Buffer$)=1 Then If Instr("*/+-",Buffer$)>0 Then Exit
            Exit
      }
      If Exist(commands, Buffer$) Then  push eval$(commands) : Call Local letter$
}
Module Sym {
      Read new w$
      Call ! Local forall
      If Evall(quote$(paragraph$(MyAcc$, 1) )+ w$+ Quote$(paragraph$(MyAcc$, 2) )) Then {
       Accum$=t$  } Else  Accum$=nil$
}
Module Quote {
      Clear Buffer$
      cnt++
      Call Local Parser(level, &Accum$, True)
      cnt--
}
Module Car {
      Call ! Local forall     
      Accum$=paragraph$(MyAcc$, 1)+nl$
}
Module Cdr {
      Call ! Local forall     
      Local drop$=paragraph$(MyAcc$, 1,-1)
      Accum$=MyAcc$
}
Module Eq {
      Call ! Local forall
      If paragraph$(MyAcc$, 1)=paragraph$(MyAcc$, 2) Then {
            Accum$=t$
      } Else  Accum$=nil$
}
Function Parser {
      Read New EntryLevel,  &Back$
      Local GetQuote  
      Read ? GetQuote  \\ this is an optional argument For Parser
      Local tmproof=roof, Accum$
      Document Accum$
      Repeat  {
      If level<EntryLevel Then cnt-- : Back$=Accum$ : Exit
      one$=mid$(a$,cnt,1)
      \\ warning in each Case one command in one line or use { } For multiple commands/lines
      \\ no empty lines allowed. 
      Select Case one$
      Case  qu$
            Call Local String
      Case ";"  \\ remark
            Call Local Remark
      Case "'"  \\ quote
            Call Local Quote
      Case "("
            Call Local StopChar, 1 ''StopChar(1)
      Case ")"
            Call Local StopChar, -1 ''StopChar(-1)
      Case " ", Ch10$, Ch13$  ' white space too
            Call Local StopCharZero
      Case "0" to "9"
            Call Local StoreNumeric
      Case "."
            Call Local StorePeriod
      Case "-", "+"
            Call Local StoreNumeric
      Else Case
            Call Local StoreLabel
      End Select
      cnt++
      } Until cnt>tmproof 
      if cnt>tmproof  then  Back$=Accum$

}
\\ Mini lisp ver 0.01
Clear \\ clear variables
Flush \\ empty stack
Form ! 60,48

Print "MiniLisp Ver 0.01"
Scroll Split  Row  \\ make this row start of scrolling screen
\\ A simple lisp interpreter written in M2000 by George Karras
\\For Documents "=" is For append text. Clear a$, give a new object Document.
Document a$={
                        "hello there this is a string"  ; this is going to result
                        (write 1223345.788)(defvar Hello "M2000")(write Hello)
                        (write 121 "Hello again...")
                        (eq 7 7)(write (list 1 2 4 5))(defvar A (+ 7 9 13 1 5 7) ) (write A  (- A 10) (* A 3) (/ 5 2))
                        (defvar (a b c d) 100)(write a b c d)(setq a (+ a 1))(write '(a =) a)(write (car '(a b c))(cdr '(a b c))) ; remark
                        (write (cons 'a '(b c)))(write George 'Karras)(write (eq a 101))
                        (this is written as result)(write '(This written before results) (+ a 1))
                        (quote (Hello 1 There a b))  '(Hello 2 There a b)(eq 5 5)
                        (loop (write a) (eq a 107) (setq a (+ a 1))) (write (list 1 A (+ A 1) 3 4 5))
                        (write 1 A (+ A 1) 3 4 5)
                        (write (If t 5 6))  (write ok)
                        (write (If nil (list 1 2 3) (list 4 5 6)))
                        (write (If nil 5 6))
                        (write (If t (list 1 2 3) (list 4 5 6)))
                        ; A form which calls the + function with 1,2 and 3 as arguments.
                        ; It returns 6.
                        (write (+ 1 2 3))
                        }                    
Print "Parse:";
Report a$
Print
nl$={
} \\ nl$ is new line
Let level=0, one$="", numeric=False, prints=0, com=False, profil=1, ch10$=chr$(10),ch13$=chr$(13), qu$=chr$(34)
Let mess=false '\\true   \\ For messages
Let cnt=1, roof=len(a$), comlevel=-1 
' no command
Document Buffer$, Result$
\\ Inventory is a hash table.
Inventory commands="+":="Comm {+}",  "-":="Comm {-}" , "*":="Comm {*}", "/":="Comm {/}", "write":="CommWrite", "car":="Car", "cdr":="Cdr", "cons":="Cons",  "defvar":="DefVar", "eq":="Eq", "setq":="SetVar", "quote":="Quote", "loop":="loopLisp",">":="Sym {>}" ,"<":="Sym {<}", ">=":="Sym{>=}","<=":="Sym{<=}", "<>":="Sym{<>}", "list":="MyList","If":="Myif"
Clear t$, nil$
\\ we want a paragraph only - with new line
Inventory mem  \\ For variables
t$="t"+nl$
nil$="nil"+nl$
Append Mem, "t":=t$,"nil":=nil$
Try ok {  Call Local Parser(level,  &Result$)}
If Error or Not Ok Then Print Error$
If level>0 Then Error "more ("
If Not Mess Then {
      Report 2, "Results" 
      Report Replace$(nl$," ", Result$)
}
Print Timecount
}
MODULE P {SET FAST !
PEN #fff9aa
\\ BLOCK ESCAPE KEY
ESCAPE OFF
\\thread.plan sequential \\WE CAN USE THREAD plan sequential also.
THREAD.PLAN CONCURRENT
ox=scale.x*1.2
oy=scale.y*1.2
REFRESH  500 
Layer 1 {
	Window Mode, ox, oy
	CLS 1 ,0   ' COLOR BLUE AND  RESET SPLIT SCREEN SETTING TO TOP LINE
	MOVE 1500,1000
	polygon 13, 1000,-500,300,1000, -2000, -500,0, -1000
	PRINT "This is first line"    ' WE CAN'T SEE THE FOUR PRINTS 
	PRINT "This is second line"   'BECAUSE WE SET A HIGH REFRESH RATE
	PRINT "This is third line"
	PRINT "This is forth line"
	PRINT $(1)  \\ NOT allowed  a PRINT of an item to exceed a column (1,2,3,5,6,7,8,9)
	MOVE 0,0
	A$=""
	COPY 3000,2000 TO A$
	GRADIENT 1, 9   ' CLEAR SCREEN WITH GRADIENT
	PEN 14 {
	FOR i=1 TO 100 {
	      MOVE RANDOM(SCALE.X),RANDOM(SCALE.Y)
	      CIRCLE FILL 14, RANDOM(3)*TWIPSX
	}
	}
	\\COPY 6000,6000 TOP A$, 10, 200
	\\COPY 6000,6000 TOP A$, 45
	\\COPY 2000,2000 USE A$, 45
	h$="	"
	Move 0,0
	copy scale.x, scale.y to h$
}
MOVE 6000,6000
I=1
LET X=MOUSE.X, Y=MOUSE.Y
LET range=6000, ANGLE=0
LET canfire= true, fireX=0, fireY=0, firesize=0
Let sX=SCALE.X/2, sY=SCALE.Y/2
THREAD {
IF abs(fireX-sx)>500 THEN {
      fireX=(fireX*4+SX)/5
      fireY=(fireY*4+SY)/5
} ELSE {
THREAD L HOLD
canfire=true
}
} AS L
e1x=6000 : e1y=6000 : e1z=20
enemy1=true 
THREAD {
      e1z+=5
      IF e1z>180 OR NOT enemy1 THEN enemy1=FALSE : THREAD this HOLD
} AS E1 INTERVAL 30
THREAD {
      e2z+=5
      IF e2z>180 OR NOT  enemy2 THEN enemy2=FALSE : THREAD this HOLD
} AS E2
e2x=SCALE.X*.8 : e2y=6000 : e2z=20
enemy2=FALSE : THREAD e2 HOLD :  THREAD E2 INTERVAL 30
THREAD {
      e3z-=10
      IF e3z<30 OR NOT  enemy3 THEN enemy3=FALSE : THREAD this HOLD
} AS E3
e3x=SCALE.X*.8 : e3y=SCALE.Y: e3z=180
enemy3=FALSE : THREAD e3 HOLD :  THREAD E3 INTERVAL 50

enemy4=FALSE
pp=.02
X=MOUSE.X
Y=MOUSE.Y
\\ simple routine name is case sensitive
GOSUB basicpart
\\MOVE x,y
\\GOSUB ship
SHOW

TASK.MAIN 20 { 
      I++
      IF KEYPRESS(49) THEN EXIT
      ' YOU CAN MAKE THE SECOND ROTATED OBJECT TO HAVE FLICKERING
      ' IF YOU DO THAT:
      ' COMMENT THE LINE BELOW AND PUT REFRESH TO 10 IN THE FIRST LINE
      {
            Move -(scale.x/2-x)/scale.x*300,-(scale.y/2-y)/scale.y*300 : Image h$
            \\ PART USE $(4) (PROPORTIONAL TEXT), AND WRITE ONLY IN ONE LINE WITH NO WRAP
            PRINT PART $(0),@(0,0),"SPACE BAR TO FIRE OR KEY 1 TO QUIT"

            PRINT PART @(0,1),STR$(NOW,"HH:MM:SS"), e1z   \\, $(0),format$("({0},{1})", sX, sY)
            
            GOSUB basicpart
            IF enemy1 THEN {
                  MOVE e1x, e1y
                  STEP sx*e1z/100-SCALE.X/2, sy*e1z/100-SCALE.Y/2
                  SPRITE A$, 1, ANGLE/10, e1z,30+e1z/4
            }
            IF enemy2 THEN {
                  MOVE e2x, e2y
                  STEP sx*e2z/50-SCALE.X/2, sy*e2z/50-SCALE.Y/2
                  SPRITE A$, 1, ANGLE/10, e2z,30+e2z/4
            }
            IF enemy3 THEN {
                  MOVE e3x, e3y
                  STEP -( sx*e2z/100-SCALE.X/2), -(sy*e2z/50-SCALE.Y/2)
                  SPRITE A$, 1, ANGLE/10, e3z,30+e3z/4
            }
            IF enemy4 THEN {
                  MOVE 8000,4000
                  STEP sx-SCALE.X/2, sy-SCALE.Y/2
                  SPRITE A$, -1, I, 100,30
            }
            IF canfire AND KEYPRESS(32) THEN {
                  SCORE 2, 100,"c"  ' SET A MIDI MUSIC SCORE
                  canfire~ : fireX=x : fireY=y
                  firesize= (SQRT((SCALE.X/2)**2+(SCALE.Y/2)**2)-SQRT((x-SCALE.X/2)**2+(y-SCALE.Y/2)**2))/10
                  THREAD L RESTART
                  THREAD L INTERVAL 10
                  PLAY 2, 10  ' PLAY THE SCORE 2 USING ORGAN 10
            } else.if NOT canfire THEN {
                  MOVE fireX, fireY
                  TRY { PEN 4{CIRCLE FILL 4, firesize}}
            }
            MOVE X, Y   
            GOSUB ship
      }
       IF NOT enemy1 and RANDOM(100)>95 THEN GOSUB enshow1
       IF NOT enemy2 and RANDOM(100)>95 THEN GOSUB enshow2
       IF NOT enemy3 and RANDOM(100)>97 THEN GOSUB enshow3
              
      REFRESH 5000   ' DO NOW A SCREEN REFRESH ONLY
      IF MOUSE=1 THEN {
            X=MOUSE.X
            Y=MOUSE.Y
      }     
}
\\ UNBLOCK ESCAPE KEY
ESCAPE ON
REFRESH 30
EXIT
enshow1:
      e1x=6000+RANDOM(2000) : e1y=6000+RANDOM(2000) : e1z=20
      enemy1=true : THREAD E1 RESTART
RETURN
enshow2:
      e2x=SCALE.X*.8-RANDOM(2000) : e2y=6000-RANDOM(2000) : e2z=20
      enemy2=true : THREAD E2 RESTART
RETURN
enshow3:
      e3x=SCALE.X*.8 +RANDOM(2000): e3y=SCALE.Y: e3z=180
      enemy3=true : THREAD E3 RESTART
RETURN
basicpart:
      range = SQRT((x-SCALE.X/2)**2+(y-SCALE.Y/2)**2)
      ANGLE =(360*(SCALE.Y-y)/SCALE.Y/2)*(SCALE.X/2-x)/SCALE.X
      sx=SCALE.X/2-(x-SCALE.X/2)/4
      sy=SCALE.Y/2-(y-SCALE.Y/2)/4
      MOVE sx, sy
      CIRCLE 300
      MOVE 0,SCALE.Y-range/2
      PEN 2 { polygon 2, 0,0,SCALE.X, 0,0, range/2,-SCALE.X,0,0,-range/2 }
      STEP SCALE.X/2,0
      PEN 0 {
            DRAW to SCALE.X/2+(x-SCALE.X/2)/4, SCALE.Y
            IF 1.1-PP<1 THEN {
                  MOVE 0, SCALE.Y-range/2*(1.1-PP)
                  DRAW SCALE.X,0 
            }
            MOVE 0, SCALE.Y-range/1.9*(.9-PP)
            DRAW SCALE.X,0
            MOVE 0, SCALE.Y-range/1.8*(.7-PP)
            DRAW SCALE.X,0
            IF NOT 1.1-PP<1 THEN {
                  MOVE 0, SCALE.Y-range/1.75*(.5-PP)
                  DRAW SCALE.X,0
            }
            pp+=.04
            IF pp>.20 THEN pp=.02
      }
RETURN
ship:
TRY {
      CIRCLE  300 *(12000-range)/5000    
      SPRITE A$, 1, ANGLE, (12000-range)/50, 100-range/200 
}
RETURN
}
MODULE MEDITOR {\\ notepad for M2000 programs (gsb files)
\\ Use F1 in editor to change to no wrap<->wrap

Clear \\ Clear all variables/objects
Flush \\ Empty the stack
CurDir$=Dir$
Title$="M2000 Pad"
Title Title$, 0   ' hide the console - 0
\\ Gui Elements
Declare NotePad Form
Declare Pad EditBox Form NotePad
Declare HelpPad EditBox Form NotePad
Declare File1 Combobox Form NotePad
Declare Edit1 Combobox Form NotePad
Declare Run1 Combobox Form NotePad
Declare Help1 Combobox Form NotePad
Declare Inform1 Button Form NotePad

\\ we can display an icon (the M2000 by default)
\\ Normal the icon is in the rright side, the control icon for close is in the left side. Here we do the oposite
\\ Also we get the Quit property. Is a property which a Document read when do a busy work of loading to quit it.
With NotePad,"UseIcon", True, "UseReverse", True, "Quit" as Quit

\\ We nead then title height after title displayed toget the height where we place the elements, in resize event
\\ we set the form to produce resize event by grabing the low right corner of form
With NotePad, "Title" as Caption$, "Visible" as Visible, "TitleHeight" as tHeight, "Sizable", True


\\ setting form, to show control box icon using english labels (use 0 for greek)
\\ we have to place afrer "Sizable", true to have "maximeze" enabled from the start.
Method NotePad,"MakeStandardInfo", 1


\\ Elements Properties (some of them changed using Methods, to pass more than one value)
\\ Change bavkground to M2000 Orange
Method Inform1, "Colors", 15, #FFA000

\\ We want the Button to act as a label only
With Inform1, "Locked", true

\\ Set the font for Pad, and for HelpPad, the two EditBoxes
Method Pad, "FontAttr", "Verdana", 12, true   '  size=12, bold=true
Method HelpPad,"FontAttr","Verdana", 10, true 

\\ We call a method to setup EditBox for Text View (we can use keys to move the text)
Method HelpPad, "TextViewOnly"


\\ ShowAlways prevent changing color when HelpPad is inactive
\\ We make some variables bound to properties
With HelpPad, "visible" as helpshow, "ShowAlways", True, "Text" as HelpText$, "enabled" as HelpEnabled
With HelpPad, "NoCenterLineEdit", True, "SetM2000", True, "EditDoc" as HelpEdit ' predifined for word picking
\\ we want HelpPad not shown from beginning, so we disable it
HelpEnabled=false

With Pad, "NoWrap", True, "SetM2000", True, "SelLength" as SelLength

\\ Set labels for menu's headers. and thecolor for check mark/ disable items,  in menus which we have those
With File1,"label","File"
With Edit1,"label","Edit",  "Mark", Color(255,100,0)
With Run1,"label","Run",  "Mark", Color(255,100,0)
With Help1,"label","Help",  "Mark", Color(255,100,0), "Id" as Id$()

\\ set a property variable to read/write text to pad, also we can use Tab
With Pad, "Text" as Pad.Text$, "NoColor", False, "ShowAlways", True, "UseTab", True, "tabwidth", 6

\\ we want to control by menu  these two properties (they can change by keystroke also)
\\ F10 tongle to hidden/no hidden characters, and Ctrl+F9 change the edit style in EditBox
With Pad, "showparagraph" as par_Status, "NoCenterLineEdit" as style_status
\\ they are false by default
par_Status=False
style_status=True

\\ Just for beginnig we make a function to alter the first letter of a name, to be a title
Def TitleStr$(a$)=ucase$(left$(a$,1))+mid$(a$,2)
Filename$=Dir$+"Untitled.gsb"
\\ Caption$ is the Title property of form. This is the forumla to display proper the filename$ (excluding path)
Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
\\ The form is hidden, but we can move it
Method NotePad,"move", 2000, 4000, 8000, 4000
\\ Also we like to give M2000 Orange to layer unter the title
Layer NotePad {Cls #FFA000}

\\ Now we make the menu. We set 4000 twips for each dropdown list (height calculated automatic)
With File1,"MenuStyle", True, "MenuWidth", 4000 
With Edit1,"MenuStyle", True, "MenuWidth", 4000 
With Run1,"MenuStyle", True, "MenuWidth", 4000 
With Help1,"MenuStyle", True, "MenuWidth", 4000 

\\ the for This block used for erasing temporary variables, here the mi$ and mr$
\\ we have to give a Group name (anything, so here we pick "This")
\\ A Menuitem without name is a line separator
\\ Menuradio used in Edit1, all other are Menuitems
\\ the last two items in Edit1 have a third parameter to True, which means they are checkboxes
\\ Internal
\\ MenuItem(a$, Optional enabledthis As Boolean = True, Optional checked As Boolean = False, Optional radiobutton As Boolean = False, Optional firstate As Boolean = False, Optional IdD)

For This {
	const mi$="MenuItem"  \\ is a temporary variable only for For This Block
	const mr$="MenuRadio"
	Method File1, mi$,"Open",True
	Method File1, mi$,"Save",True
	Method File1, mi$,""    \\  only  a line here
	Method File1, mi$,"Close",True
	Method File1, mi$,"Quit",True

	
	With File1, "MenuGroup","This"
	
	Method Edit1, mi$,"Cut",True
	Method Edit1, mi$,"Copy",True
	Method Edit1, mi$,"Paste",True
	Method Edit1, mi$,""
	Method Edit1, mi$,"Less Indent",True
	Method Edit1, mi$,"More Indent",True
	Method Edit1, mi$,""
	Method Edit1, mr$,"Tabs for Indent",True,True
	Method Edit1, mr$,"Spaces for Indent",True,false
	Method Edit1, mi$,""
	Method Edit1, mi$,"Show Hidden Characters", True, True
	Method Edit1, mi$,"Free Style Edit Shift+F9", True, True
	

	
	With Edit1, "MenuGroup","This"

	Method Run1, mi$,"Debug",True
	Method Run1, mi$,""
	Method Run1, mi$,"Test Slow",True
	Method Run1, mi$,"Test Normal", True
	Method Run1, mi$,""
	Method Run1, mi$,"Settings"

	With Run1, "MenuGroup","This"
	Method Help1, mi$,"About",True,,,,"ABOUT"
	Method Help1, mi$,""
	Method Help1, mi$,"Find Topic",True,,,,"FIND"
	Method Help1, mi$,"Open Topic",HelpShow,,,,"OPEN"
	Method Help1, mi$,""
	Method Help1, mi$,"Close Help",HelpShow,,,,"CLOSE"
	

	With Help1, "MenuGroup","This"
}

\\ Some variable for program. We can ue Def for a variable once, if we do that a second time the we get error.
\\ always Def make local variables. We can set a type before for all non typed names after
\\ or we can use as type and give a first value (not an expression here).
\\ by defailt false is the va;ue for boolean type, so the =false not needed
Def boolean LoadState=false,  old_status=false

 \\ We need some properties with inexes, so we make these as arrays 
 \\ They look as arrays but they are objects (PropReference)
 \\ We can give names with dot, isn't a problem. Dot can be used for any name
With Edit1,"ListSelected" as Edit1.Selected(), "MenuEnabled" as Edit1.Enabled()
With Help1, "MenuEnabled" as Help1.Enabled()

\\ Some variables for specific task.
\\ Document make or change a local string variable (or global using <=)  to a Document type object (a linked list of paragraphs)
\\ we have to use Clear Name$ to erase the document's paragraphs.
\\ Using = or <= for globals we append text to it
Document BackUp$="\\Write something...", LoadFile$
Def ok as boolean
Const nl$=chr$(13)+chr$(10)
Pad.Text$=BackUp$
Def what$, lastcommand$, mod2run$

\\ function to retrieve info from help database, help2000.mdb in appdir$
Def boolean HelpView

Function GetHelp$(&word$, find) {
	word$=ucase$(word$)
	Eng=chrcode(word$)<128
	If find Then
		Retrieve appdir$+"HELP2000", "Select * FROM [COMMANDS] WHERE "+If$(Eng-> "ENGLISH","DESCRIPTION")+" Like '"+word$+"%'",1,"",""
	Else
		Retrieve appdir$+"HELP2000", "COMMANDS",1,If$(Eng->"ENGLISH","DESCRIPTION"),word$
	End If
	If number>0 Then
		read new word1$, hlp$, word2$
		=If$(Eng->RightPart$(hlp$,"__<ENG>__"), LeftPart$(hlp$,"__<ENG>__")) :	word$=If$(Eng->word2$, word1$)
	End If
}

\\ this call using Call Local (otherwise we get error because GetHepl$() isn't a global, or a local to FindWord)
Function FindWord {
	read new word$, find=false
	Local hlp$=GetHelp$(&Word$, find)
	If len(hlp$) Else Exit
	HelpText$=word$+nl$+hlp$
	If not helpview Then helpview=true : helpenabled=true
	Call Local Notepad.Resize()
}

\\this call using Call Local too, because inform1 is in this module scope
\\ we use letter$ to pop a string (so we don't have to make a variable first)
Function InformNow {
	With Inform1, "Caption",  letter$
}



\\ so now we have to make some event service functions.
\\ all these functions call local, means they use the same namespace as the one which the object defined
\\ we have to use Read New  or place a new in parameter list () like in NotePad.Unload
\\ this prevents to use a same local variable. Events may be called again, while still executed
\\ to prove that we have to open a big file (rename a big txt file as gsb, say bigger than 10Mbytes)
\\ then open it, and before actual placed in Pad, we can use he same service function to close the NotePad

\\ Form's Events  (NotePad is the object)
\\ The NotePad.Unload event get an argument by reference. If this change to true the unload canceled

Function NotePad.Unload(New &Ok) {
	If LoadState Then Quit=true : Call Local InformNow("Quit Loading..") : Exit
	If Pad.Text$<>BackUp$ Then
		After 50 {Call Local File1.DblClick(4)}
		Ok=True
	End If
}
\\ we can change this in code if we change the font of title (because a new TitleHeight  prodced), or if we remove the header (make it invinsible)
def onetime=true
Function Notepad.Resize {
	Layer NotePad { Cls Color(255, 160, 0) ,0}
	With NotePad, "Width" as NP.Width, "Height" as NP.Height, "TitleHeight" as tHeight
	tHeight1=theight*2
	if onetime then
		Method File1,"move", twipsX*2, tHeight,  twipsX*80, tHeight
		Method Edit1,"move", twipsX*2+twipsX*80, tHeight,  twipsX*80, tHeight
		Method Run1,"move",  twipsX*2+twipsX*160, tHeight,  twipsX*80, tHeight
		Method Help1,"move", twipsX*2+twipsX*240, tHeight,  twipsX*80, tHeight
		Method Inform1,"move", twipsX*2+twipsX*320, tHeight,  twipsX*160, tHeight
		onetime=false
	End if
	If NP.height>1800 Then {
		If helpview Then
			local free=NP.Height-tHeight1-twipsX*3
			local third=free/3
			free=free-third-twipsX*3
			Method Pad,"move", twipsX*2, tHeight1,  NP.Width-twipsX*5, free
			Method HelpPad,"move", twipsX*2, tHeight1+free+twipsX*3,  NP.Width-twipsX*5,third
			helpshow=true
		Else
			helpshow=false
			Method Pad,"move", twipsX*2, tHeight1,  NP.Width-twipsX*5, NP.Height-tHeight1-twipsX*3
		End If
		With Pad, "NoWrap" as NoWrap
		If Not NoWrap Then Method Pad,"Resize"
		Method HelpPad, "resize"
	}
}

\\ The HelpPad (for displaying help) use a newer event, the click, which open a message box, as input box
\\ if the ask() return 1 then in stack of values we get the new value
ms$={Find Topic
Use ALL to get a list of all topics}
Function HelpPad.click {
	Method  HelpPad, "EditTextView", false
	If ask(ms$,,,,, what$)=1 Then Read what$ :Call Local FindWord(what$, true)
}

\\ this is the event to do something with a word clicking on heplPad
Function HelpPad.word {
	Call Local FindWord(letter$, false)
}


\\ From Pad we want to intercept the Ctrl+F5, to call the the first menu item in Run1
\\ We can use a After {} thread (a M2000 Thread), to make the call asyncronus
\\ also we make the key and shift zeroes, to not used by Pad (normaly F5 open the Replace Input Box, if we mark a word )
Function Pad.KeyDown {
	Read New &kc, &Shf
	If kc=116 and shf=2 Then
		kc=0 : shf=0
		After 20{
			Call Local Run1.DblClick(0)
		}
	End If
}


\\Also we want from Pad to get a word, and open/change HelpPad

\???

\\ Also Local can be used if we didn't use &, for by reference variables
\\ PopUpMenu is the standard menu for EditBox, but we can change it
\\ using this event
\\ This event fires when we use right mouse button  or Ctrl+F10, or Contex Menu Key.
Function Pad.PopUp {
      Read Local X, Y
      Method Pad,"PopUpMenu", "",X , Y
}

\\ Each time we change SelStart or SelWidth of Pad, we get an Inform event
Function Pad.Inform {
	Read New L, P
	If old_status<>par_status Then
	With Inform1, "Caption",If$(par_status->"Hidden", "No Hidden")
	old_status=par_status
	Else
	With Inform1, "Caption", format$("{0}-{1}", L,P)
	End If
	\\ set focus to Pad - refresh if not scheduled
	Method Pad,"Show"
}

\\ Helper functions for Edit1
Function SetTabs {
	With Pad, "UseTab", True,"tabwidth",6
	With Inform1, "Caption","Set Tabs"
	Method Pad,"Show"	
}
Function SetSpaces {
	With Pad, "SpaceIndent", 6
	With Inform1, "Caption","Set Spaces"
	Method Pad,"Show"
}
Function ChangeHidden {
	Edit1.Selected(10)=not par_Status
	Method Pad,"PressKey", 121, 0   ' 121=vbkeyF10
	old_status=par_status
	With Inform1, "Caption",If$(Edit1.Selected(10)->"Hidden", "No Hidden")
	Method Pad,"Show"      
}
Function ChangeStyle {
	Edit1.Selected(11)=not style_status
	Method Pad,"PressKey", 120, 1
	\\ no need to refresh, the effect is internal, and we see the cursor
	\\ to leave the center line if free style used, not only in top or bottom page
}

\\ Befor Edit1 opened
Function Edit1.OpenMenu {
	Local X
	X=SelLength>0
	Edit1.Enabled(0)=X
	Edit1.Enabled(1)=X
	Edit1.Selected(10)= par_Status
	Edit1.Selected(11)= style_status
}
\\ We can check in checkboxes and radiobutton withou closing the menu
\\ if we click on checks - (not on names)
\\ here we use If Else.If Else End If

Function Edit1.MenuChecked {
	Read New RadioIndex 
	If RadioIndex=7 Then
		Call Local SetTabs()
	Else.If RadioIndex=8 Then
		Call Local SetSpaces()
	Else.If RadioIndex=10 Then
		Call Local ChangeHidden()
	Else.If RadioIndex=11 Then
		Call Local ChangeStyle()
	Else
		With Inform1, "Caption","??"
		Method Pad,"Show"	
	End If
}

\\ When we double click on a menu item
\\ We use Select Case
\\ In M2000 after a Case can be one line of commands, or a block of commands {}
\\ but no two or more lines of commands
Function Edit1.DblClick {
	Read New Edit1index
	Select Case Edit1index
	Case 0
		Method Pad,"mn1sub" : Method Pad,"Resize"
	Case 1
		Method Pad,"mn2sub"
	Case 2
		Method Pad, "mn3sub" : Method Pad,"GetFocus" : Method Pad,"Resize"
	Case 4
		Method Pad,"PressKey", 9, 1
	Case 5
		Method Pad,"PressKey", 9, 0
	Case 7
		Call Local SetTabs()
	Case 8
		Call Local SetSpaces()
	Case 10
		Call Local ChangeHidden()
	Case 11
		Call Local ChangeStyle()
	End Select
}

\\ Prepare the Run part
Document TestFile$
UseShow$={
	Use statement Show to select when console open. Use { END } to skip waiting for key before end
	}
	
\\ 0,2,3 menuitems call the same 
\\ 1 is the line separator
Function Run1.DblClick {
	Read New Run1index
	if Run1index=1 then
		exit
	else.if Run1index=5 then
		Clear TestFile$
		TestFile$={
		Module A {
			Title "Settings", 0
			Settings
			Wait 2000
			While Control$="SETTINGS"
				Wait 500
			End while
		}
		A : End
		}
		Save.Doc TestFile$, "Test1235.gsb"
		Win appdir$+"m2000.exe", dir$+"Test1235.gsb"
	else.If ask(if$(Run1index=0->"Module to run","Command(s) to execute"	+UseShow$),,,,,mod2run$)=1 Then
		Read mod2run$
		Clear TestFile$
		TestFile$=If$(Run1index=2->"Set Slow"+nl$,"")
		TestFile$="Module TestThis {"+Pad.Text$+nl$+"}"+nl$
		TestFile$="Title "+quote$(LeftPart$(Caption$," -"))+nl$
		TestFile$="Script TestThis :"+If$(Run1index=0->"Test ","")+mod2run$+": Push Key$: Drop: End"
		Save.Doc TestFile$, "Test1234.gsb"
		Win appdir$+"m2000.exe", dir$+"Test1234.gsb"

	End If
}

\\ This is the File1 DblCkick event
\\ We use On Goto who start from 1, so we add one to File1index
\\ We use labels and goto because the logic is a kind of spagheti
\\ From Open1: may we go to Save1:
\\ From Unload: we go to Save2:
\\ From Save2: may we go to Save1:
\\ There several cases to exit
\\ the code use If with blocks {}  ' not updated yet
\\ The Break statement stopped only from a Try {},
\\ so Break make exit from all blocks, and exit from function.

Function File1.DblClick {
	Read New File1index
	Local cont, cont2, f$, NL$={
	}
	File1index++
	\\ Because we want some jumps..we use  On Goto
	\\ on Goto need here a block
	{
		On File1index Goto Open1, Save1, ExitNow, Save2, Unload
Exitnow:
		Exit
Open1:
		If Pad.Text$<>BackUp$ Then {
			If ask("Save Changes first?",Title$)=1 Then Goto Save1
		}
		Layer NotePad {
			\\Using "**" we can go up to drives.
			Try ok {
				Open.file filename$,"**","Load M2000 (Gsb) File","gsb"
			}
			If not ok Then push "" : Dir User
		}
		Method Pad,"GetFocus"
		Read f$
		If f$<>"" Then
			If exist(F$) Then {
				Clear LoadFile$
				Method Pad,"PressKey", 0, 0
				LoadState=true
				Call Local InformNow("Loading...")
				layer NotePad {
					Load.Doc LoadFile$, f$
				}
				\\ set the current directory
				If quit Then break
				Filename$=f$
				dir file.path$(Filename$)
				If not quit Then 
					Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
					Clear Backup$
					BackUp$=LoadFile$
					Clear LoadFile$
					Pad.Text$=BackUp$
				End If
			} Else Pad.text$="": Clear BackUp$
			Call Local InformNow("Rendering...")
			Method Pad, "Resize"
			Call Local InformNow("Ready...")
			LoadState=false
		End If
		Exit
Save1:
		Layer NotePad {
			try ok {
				Save.As Filename$,"**","Save M2000 File","gsb"
			}
			If not ok Then Push "" : Dir User
		}
		If not cont2 Then Method Pad,"GetFocus"
		Read f$
		If f$="" Then Exit 
		If lcase$(file.type$(f$))<>"gsb" Then f$=f$+".gsb"
		If Exist(f$) Then  If Ask(NL$+"Overwrite"+NL$+f$,Title$)<>1 Then Exit
		Try ok {
			Clear BackUp$
			BackUp$=Pad.Text$
			Save.Doc BackUp$, f$
			filename$=f$
			dir file.path$(Filename$)
			Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
		}
		If ok Else beep
		If not cont Then Exit
Save2:
		cont=True
		If Pad.Text$<>BackUp$ Then {
			If ask("Save Changes?",Title$)=1 Then Goto Save1
		}
		Clear BackUp$
		Pad.Text$=""
		If Cont2 Then
			Dir CurDir$
			Method NotePad, "CloseNow"
		Else
			FileName$=Dir$+"Untitled.gsb"
			Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
			Method Pad, "Resize"
			Method Pad,"GetFocus"
		End If
		Exit
Unload:
		Cont2=True : Goto Save2
	}
}

\\ These are the Help1 events
\\ We want to enable/disable 3 and 5 menuitems
GetIndex=lambda Help1 (id$) ->{
	ret=-1&
	Method Help1, "GetMenuId", id$, &ret as ok
	if ok then =ret else =-1&
}

Function Help1.OpenMenu {
	Help1.Enabled(GetIndex("OPEN"))=HelpShow  and not HelpEdit
	Help1.Enabled(GetIndex("CLOSE"))=HelpShow
}

Function Help1.DblClick {
	read new  Help1.index
	call local InformNow(id$(Help1.index))
	Select Case id$(Help1.index)
	Case "ABOUT"
	{
		Local A, info$
		Info$={
			This is an example
			of a notepad for M2000 Programs
			written in M2000
			and run in M2000 Environment
			}
		A=Ask(info$,Title$,"","")
	}
	Case "FIND"
		Call Local HelpPad.click()
	Case "OPEN"
		Method  HelpPad, "EditTextView", True: Call Local Notepad.Resize()
	Case "CLOSE"
		Method  HelpPad, "EditTextView", false : HelpView=false: Call Local Notepad.Resize()
	End Select
	
}
Function Pad.Word() {
	Call Local FindWord(letter$, false)
}

Function Notepad.InfoClick {
	Read New X
	If X=0 Then Call Local Help1.DblClick(0)  ' 0 for first menu item
}
Call Local Notepad.Resize()
\\ make this as the default control (get focus)
With Pad,"Default",True
\\ open as modal
With NotePad,  "Blink", 50, "BlinkTimes", 20
Method NotePad,"Show", 1
Declare Pad Nothing
Declare NotePad Nothing 
Print "Done"
}
MODULE INFO {If Version<9.8 then Error "No proper M2000 version"
If Version=9.8 and revision<4 then Error "No proper M2000 revision for version 9.8"
FONT "ARIA"
PEN 14
CLS,0
Set Fast
Title "Info"   ' open a window in task bar with name info (if  you run Demo, at the exit you get no window in task bar, so we can restore it)
If IsWine Then Font "Verdana"
dir user
Player 0  ' erase any layer
back {
	cls 11, 0   '   backcolor,  split line (0 means no split line)
	\\ split means to define a lower part of form to be scrolled up or down
rem	gradient 11, 0
}
Cls 11,0
WINDOW 12, 0  ' 0 FOR MONITOR 0
\\ Use form without ! for less border
\\ Form ! 100,66
Form ! 80,66
backcolor=5   'point
oldpen=14  ' pen
Refresh 500
Pen 0 {
	cls 7
	ico 1   ' draw icon (a png image, loaded as text as BASE64 encoded)
	Double
	Print Part  "  M2000 Interpreter"+str$(version)+" ("+str$(revision,0)+")"
	Print
	Normal
	Report " A collection of modules for tests version 3"
	
	Pen 5{
		cursor 0, row-1
		Report 1, "George Karras 2019"
	}
}
cls backcolor, row
Scroll split 0  ' reset the row+1 which given in cls
pen oldpen
Clear ' clear local variables
title("Modules ?")
Report {
	Modules ?    (or control+N, display all loaded modules, if nothing loaded display files)
	You can call any module by name, try Info
	Modules (Show every loaded module, plus files on user folder)
	}
Pen if(pen=7->8,7){
	Modules ?
	Print
}
title("List")
Report {
	You can see the global variables, if any exist, defined in console
	Use statement Clear to clear all variables
	}
List
title("Stack")
Report {
	You can see the stack of values, if has any value
	Use statement Flush to empty the stack
	}
Stack
refresh 30
title("Useful Statements")
Report {
	Help All, Help Print, Help
	Monitor  (to see switches), shitches
	(some staments can be used from a module using the Set statement)
	(Set Monitor - because Monitor is known to Console Interepreter)
	Edit info  (press esc to exit editor)
	Edit "disk_file.gsb"  (to edit from disk - saved at exit)
	Edit  (no argument) open command editor (we pick in console line using up/down arrows)
	Save filename   (without quotes, except if we want spaces)
	load filename
	Settings (open dialog for setting environment), 	Start  ' restart console
	Use filename  (use info open another info in another console)
	Dir to show current directory or Dir user to set current dir to user folder
	Files "GSB","PRINT|FOR" (search files *.gsb for words PRINT and FOR)
	Win Dir$	Win Calc
	End (to exit from console)  
	}
Fkey Clear
FKey 1,"Saveme ' save all loaded modules"
FKey 2,"Edit Info ' edit this"
FKey 3,"Info ' this page"
FKey 4,"M2000_Editor_Information  ' about editor"
FKey 5,"Demo1  ' 3d Drawing in a Window"
\\FKey 6,"Edit M2000_editor_information"
FKey 6,"icons ' an example using sprites of type png"
Fkey 7,"Tr 'Three Oscilloscopes"
Fkey 8,"mEditor ' A window based M2000 Editor"
Fkey 9,"kb ' A keyboard to play music"
FKey 10,"Settings"
FKey 11,"Dijkstra"
FKey 19,"List33  ' Listbox control Example"
FKey 18,"Form44  ' Muliple Windows Example"
FKey 17,"Maze2  ' Maze Drawing in console"
FKey 16,"Cal  ' Snoopy Calendar"
FKey 15,"OOP1  ' EventHandler Class"
FKey 14,"Pend  ' Pendulum Animation"
Title("Fkey")
Fkey
\\title("M2000 Writer")
\\Keyboard "Writer"+chr$(13)
End
Sub title(a$)
Pen #ffeeff {
	cursor 0
	Italic 1
	Report a$
	Italic 0
	cursor 6, row-1
}
End Sub
}
MODULE SAVEME {dir user
save info, info
Print "Done"
}
MODULE M2000_EDITOR_INFORMATION {thread.plan sequential   ' can run as concurrent too
linespace twipsY*2
' Mode as read only value return the height of layer form in pt. Using Mode we set to the same Mode but we cut extra space (use linespace also)
Mode Mode   
'Cls,0
backcolor=point
oldpen=pen
Refresh 500
Pen 0 {
	cls 7
	call ico, 1
	Double
	Print part  "  M2000 Interpreter"+str$(version)+" ("+str$(revision,0)+")"
	Print
	Normal
	Report " M2000 Editor"
	Pen 5{
		cursor 0, row-1
		Report 1, "George Karras 2019"
	}
}
cls backcolor, row
pen oldpen
title("Define a Module")
Report {
	Edit Alfa   (open editor to edit Alfa Module, and all modules/functions inside of it)
	}, width-12
title("Define a Function")
\\ we can't put a left parenthesis without a match right parenthesis (including for strings) in a { } string literal
Report {
	}+"Edit Alfa() or Alfa("+{  (open editor to edit Alfa() Function, and all modules/functions inside of it)
	}
title("Open for edit at specific position")
Report {
	Edit Alfa, 100
	}
title("Indent a line")
Report {
	just press tab before any letter, to delete indentation mark the text shift +End and then press shift tab
	You can start a indentation with spaces (Default is tab - characrer 9), using shift tab in a clear line, or a line without leading tabs.
	}, width-12
title("Indent multiple lines")
Report {
	Mark a block and then press tab or shif tab to move text right or left
	}, width-12
title("Functions Keys for Editor")
Report {
	F1 - Toggle Wrapping setting (on or off)
	F2 - search marked or last searched word up - using shift or ctrl to search phrases
	F3 - search marked or last searched word down - using shift or ctrl to search phrases
	F4 - change the letters case using the marked word (no undo for this)
	F5 - Replace marked word with one we provide in inputbox (multiple undo)
	F6, F7, F8 Bookmarks. On press for Set, Delete, Goto Bookmark. Messages displayed
	F9 - Count words  / Shift F9 change Editor Style
	F10 - Show hidden characters (paragraph, spaces as dot, nbsp as space, figure space, tab)
	F10 & Shift - Open Popup Menu
	F11 - Change Syntax Color On, Language Width Normal, Syntax color Off, Language Width Small
	F12 - Open a form displaying all names of loaded modules, we can click on any to read or copy part of source
	Shift F12 Exit without changes (useful if Editor get crazy...)
	}, width-12
title("Other Keys for Editor")
Report {
	Ctrl+X Cut
	Ctrl+C Copy   (copy Html and Simple Text, Html has <pre></pre> if tabs exist in copied text)
	Ctrl+V Paste
	Ctrl+A Select all
	Ctrl+Z Undo (unlimited, but we loose it if we press Esc to leave from editor)
	Ctrl+Y Redo (unlimited too)
	Shift+Tab Insert spaces not tab
	Tab  insert a tab in umarked text, apply indentation in marked text
	Tab + Shift remove indentation in marked text,  Insert spaces as tab if no leading tab exist
	
	Ctrl+Shift Enter place Braces and a line inside with proper indentation
		We can mark text and place braces and indentation for all marked text
	Ctrl+Shift+Space insert a non break space
	Alt+Shift+Space insert a figure space
	Alt +5+9 return ANSI 0x59 (;) 
	Alt "+" 3 0 2 a give â Unicode 0x302
	Pairs:() {} "" []  we press the first and we get the other and cursor set inside them
		Also we can mark text and press one of above to place makred text inside
		we have to press two times undo to undo this
	}, width-12
Press()
Cls
title("PopUp Menu")
Report {
	Open with Shift+F10, Key Context Menu if exist, left mouse button in edit area, right mouse button in header area
	We can move the menu (stay open until lost focus)
	We can resize the menu to get bigger text (also this operation resize other interpreter forms)
	
	First line show line number, character position and can input a line number to move this line to center vertical as possible
	Cut
	Copy
	Paste
	Save and Exit
	Discard Changes
	Search up
	Search down
	Make same All
	Replace word
	Word Wrap
	Drag Enabled (by default drop is enables, to allow drag operation we have to set this)
	Color/Short Language
	Paragraph Mark (show hidden characters, we can edit in this mode)
	Word Count
	Help  (if we makred a word - just click on it- we get a form with information about it).
	Modules/Functions.
	Insert File  (this is a macro which insert a file as Base64 encoded in text, for a string variable).
	Load Resource (this is a macro which insert a binary file to a buffer type variable).
	}, width-12
title("View code without get the cursor from position")
Report {
	We can scroll up or down using vertical scroll bar. Press left or right or up or down or an key to return to previous view 
	Use F1 to change wrap (this also has no affect to cursor).
	Move some lines up or down holding down right mouse button. There is a timer which enable quick move.
	The same timer enabled when we click the top or bottom areas of the scroll bar control.
	}, width-12
title("View code as you change the cursor from position")
Report {
	Use arrows, Home (change from position 1 to first non space  in row, each time we use it).
	End to end of line.
	Page Up, Page Down  (Page is the  half page of view).
	Clicking with right mouse button.
	Shift with all above mark text.

	Using mouse wheel we change half pages (moving the cursor too), shift has no effect.
	Using F6 to F8 (Bookmarks) to jump to a bookmark.

	When we edit a line editor keep the line in the middle of view if it is possible.
	If no warp enabled then the horizontal moving is automated, when we type, or when we move text to drop it, depending of the position of the "running cursor" (if we miss the drop, the cursor return to starting position).
	}, width-12
Press()
Keyboard "info"+chr$(13)
End  ' we can omit this
Sub title(a$)
Pen #ffeeff {
	cursor 0
	Italic 1
	a$=replace$(chr$(9),"      ", a$)
	Report a$
	Italic 0
	cursor 6, row-1
}
End Sub
Sub Press()
	wait 200
	local col=15,  col2=backcolor, threadid
	Input End  ' empty buffer too
	Print @(0,Height);
	Thread {
		Pen col {
		Print Over $(3), "Press space bar or mouse key" 
		}
		swap col, col2
	} as threadid interval 250
\	wait 500	
	Main.Task 10 {
		if keypress(1) or keypress(32) then exit
	rem		if mouse>0 or inkey$<>"" then exit
	}
	Threads Erase
End Sub
}
MODULE FORM44 {Module TryIt {
	Rem : Set slow
	Set fast
	Thread.Plan  Concurrent  ' Sequential
	Refresh 40
	SMOOTH on
	Cls,0
	\\ using ,0 we switch console to minimize state
	\\ any value else or no value restore to normal state
	title "Start Up" ', 0
	N=3
	\\ we choose to use automatic event object
	\\ this event object expect to find Form1() function
	\\ using automatic object we can't disable it
	\\ also events which expect changes to variables
	\\ bypass the stantard callback and resolve to a function
	\\ like  Form1.Unload() which get back the Nook value
	
	Declare Form1(N) Form
	
	\\ Buttons can be clicked or shifted right (same as clicked)
	
	Class Buttons { 
	      Dim Butt() 
	      Module SetCaption { With .Butt(Number), "Caption",Letter$}
	      Function ReadCaption$ { With .Butt(Number), "Caption" as Result$ : = Result$}
	}  
	Dim Controls(N)=Buttons()  \\ an array of arrays
	\\ 
	For i=0 to N-1 {
	      For Controls(i) {
	            \\ need to be a new name for array
	            \\ a For object { } delete any new name
	            \\ so each time this block run, starts with no Button1() array
	            \\ then make one, then we get a copy (and references to actual objects)
	            \\ and then Button1() erased
	            \\ but Controls(i).Butt() can't erased because exist before we enter the loop
	            Declare Button1(2) button Form Form1(i)
	            For j=0 To 1 {
	                  Method Button1(j), "move", 1000+4000*j, 2000,3000,1000
	                  if j=1 then {
	                        Method Button1(j), "curve",3
	                  } else Method Button1(j), "transparent"
	                 
	            }
	            .Butt()=Button1()
	      }
	     Layer Form1(i) {
	            Cls 4, 0
	            Gradient 1,4
	            Cursor 0,3
	            Report 2, "Hello There"
	     }
	      Method Form1(i), "Show"
	}
	\\ check this. After 6 second we can unload two forms
	\\ Ttry to close anything. You can without a problem
	\\ and after 3 seconds one more
	\\ just press enter after Rem 1: to make lines ready for execution
	Rem 1: Wait 6000 : PrintAndRefresh("CloseNow") : For i=1 to 2 : Method Form1(i), "CloseNow" : Next i
	Rem 2: Wait 3000 : PrintAndRefresh("Unload") : Refresh  : Declare Form1() Nothing
	Rem 3: Show \\ get the focus back
	Rem 4: Print "ok" : Exit
	
	Form1_1=true
	Controls(1).SetCaption 0, "Click Me"
	Controls(1).SetCaption 1, "ok"
	Controls(2).SetCaption 1, "Test Me"
	\\ we make a variable bound to a property
	With form1(0), "Visible" As visible
	CloseThisForm=0
	CloseThisTitle$=""
	Function CloseAfter {
	
	      If Ask("Close Form?", CloseThisTitle$)=1 Then {
	      If CloseThisForm=1 Then Form1_1=false
	      Method Form1(CloseThisForm), "CloseNow"
	      }
	}
	Function Form1.Unload {
	      Read New index, &Nook
	      Nook=True  \\ no unload now
	      \\ After make an unamed thread
	      \\ we use this of async waiting for user to
	      \\ provide feedback from a message box
	      with Form1(index), "title" as title$
	      CloseThisTitle$=title$
	      CloseThisForm=Index
	      After 50  { Call Local CloseAfter() }
	}
	Function Button1.Click {
	      Read New K, L
	      Print "Form:";L,"Button:";K
	      Print Controls(L).ReadCaption$(K)
	      if k=1 and l=2 then test
	}
	Function Form1.MouseMove {
	      Read New K, Button, Shft, X, Y
	      If Button=1 Then {
	           Layer Form1(K) {    
	                  move X, Y
	                  circle 500, 1, 14-K
	            }
	      }
	}
	Function Form1.MouseDown {
	      Read New K, Button, Shft, X, Y
	      If Button=2 Then {
	            Method Form1(K), "Control", 1 As UserControl
	            \\ we have to use new names if we "call local" a function
	            With UserControl, "Visible" As uVisible
	            uVisible=Not uVisible  \\ we can't use X~ as X = Not X     
	      }
	}
	'goto aaa
	For i=0 to N-1 {
	\\ Threads get current layer as starting layer
	      Layer Form1(i) {
	            \\ so we make the thread inside Form Layer 
	            Thread {
	            part {
	                  If Form1_1 Then {    
	                              if not scale.x then  thread this erase
	                            \\ third parameter is for color, we can use Color(r,g,b) or Colour(r,g,b) 
	                            \\ for rgb value, or we can give an Html number like #FF0000
	                            \\ another way is by using hex 0X80000012 for system colors
	                            \\ Here we use values from the range 0 to 15 (here from 7 to 15)
	                            \\ and these are the standard colors.
	                           Draw To Random(Scale.x), Random(Scale.y), Random(7,15)
	                           \\ sub PrintAndRefresh can be run because all threads are in the same module
	                           \\ Threads have their execution object and an object to draw, here the form1
	                           \\ When thread call sub, sub run on same execution object.
	                           \\ modules and functions have own execution object
	                           \\ so subs are light and interest because the see every variable as local
	                           \\ but we can make temporary anything
	                           \\ we can also create threads in a sub, without erase them. 
	                           \\ Threads erased when parent object erased, or when we send erase command
	                           \\ or when we exit Task.Main
	                           \\ for the situation of a thread created on a thread we can use Threads Erase
	                           \\ too remove all, including these. This we need it because, the second level of thread may
	                           \\ end after the erasing of module, where we create it, so can run code with variables which
	                           \\ are cleared. So With Threads Erase before exit module we are sure that Threading Pool is empty.
	                           \\ But this in not an every day situation.
	                           \\  (an after {}  thread creation in a thread execution is an example for a second level thread)
	                           Rem 100 :
	                          If random(100)<4 then  PrintAndRefresh("draw lines")
	                          refresh
	                  } Else Thread This Erase
	                  } as mine
	            } As OneMore   Interval 30
	            thread OneMore  execute  static me=i
	            \\ OneMore is a handler, so we lost first and second handler
	            \\ but we dont care, we close thread inside using This
	            \\ or we can let the Main Task erase it at the exit 
	      }
	}
	
	Thread {     
	      PrintAndRefresh(Str$(Now,"hh:mm:ss"))
	} As Inform Interval 1000
	\\ Inform is the Thread Handler, we don't use it here
	aaa:
	\\ Need a thread to run a Main.Task
	Main.Task 100 {
	'Every 100 {
	      \\ using property  \\ 
	      
	            
	            Rem 1 :       Print Type$(Visible), Type$(Form1_1)
	            If Not visible Then break
	            threads
	      
	}
	
	\\  Cleaning;
	\\ A control has two objects, one in form (a UserControl, one type for all),
	\\ and the other is the wrapper, which serve as an event publisher,
	\\ and we can use propertiers and methods
	\\ When a Form unloaded not only erase UserControls but becaue hold referencse to wrappers
	\\ send deconstruct command to each one, to break any reference to form
	\\ and  erase internal collection - just throw references to actual objects
	\\ So our last references to wrappers are in Controls(i)
	\\ We can let M2000 to destroy the arrays, so the referecses, or we can do the job
	\\ and we can reuse it
	\\ so we check this with a jump to there
	Goto there
	For i=0 to N-1 {
	      For Controls(i) {
	            Dim .Butt()
	      }
	}
	there:
	\\ this command unload forms
	Declare Form1() Nothing
	'title "End"
	'Show
	Threads Erase
	Smooth off
	Thread.Plan Sequential  ' set the default again (can be set if no thread exist)
	Refresh 30
	Sub PrintAndRefresh(A$)
	            Print A$
	            Refresh
	End Sub
}
While inkey$<>"" {}
Cls ,0
Report {Form44
You can:
      1. draw on Windows using right mouse button.
      2. slide or click a button to see the response in console.
      3. hide title using left mouse button.
      4. click on Test button on Window 2, to open test dialog.
      5. move the windows
      6. Use Shif + F4 to close a form (even with hidden title)
      
      Closing form 2 stop threads for line drawing.
      Closing form 1 close all forms, program exit
      
      Enjoy
      George Karras
      
      (press any key)

}
push key$ : drop
TryIt
Info
}
MODULE LIST33 {Declare Simple Form
With Simple, "Title" As myTitle$
\\ make window, not show yet
Layer Simple {
      Linespace 60
      Font "Arial Black"
      Window 16, 8000,6000
      Cls 7,0 
      Cursor 0, height div 2
      Report 2,"Hello World"
}
\\ now put a ListBox
Declare Listbox1 Listbox Form Simple
Method Listbox1, "move", 1000,1000,6000,4000
\\ and fill with some data
With ListBox1,"Text",{London
                                    Paris
                                    Athens
                                    Rome
                                    Tirana
                                    Nicosia
                                    Brussels
                                    Copenhagen
                                    Berlin
                                    Dublin
                                    Luxembourg
                                    London2
                                    Paris2
                                    Athens2
                                    Rome2
                                    Tirana2
                                    Nicosia2
                                    Brussels2
                                    Copenhagen2
                                    Berlin2
                                    Dublin2
                                    Luxembourg2
                                    }
\\ and set some properties, and some of them are bind to objects that are properties to objects.
\\ also when we call a method, internal a resolved done in first time, so next time a method call will be faster.
With Listbox1, "transparent", True , "ListIndex" As ListIndex, "ListCount" As  ListCount
With Listbox1, "Find" As Find(),  "List" As List$(), "maychange", true
\\ make simple sizable form (units for forms are in twips)
With Simple,"Sizable", True,"SizerWidth",90
\\ now these are the event handlers
\\ event handlers can see anything defined in parent module
\\ for this reason for &rgb we need a Read New (so a new rgb prepared before a reference assign to it)
\\ any variable can get a reference to other variable once, at defining stage.
Inventory Blocked= "Rome", "Rome2", "Berlin"
Function Simple.Unload {
      Keyboard "!"   \\ like press !
}
Function listbox1.Color {
      Read New &rgb
            rgb=#FF7700
}
Function listbox1.Sep {
      Read New &D
		if exist(Blocked, List$(d)) then d=-1
		
}
Function Listbox1.DblClick {
            Read Where 
            if Right$(List$(Where),1)="✓" then {
                  List$(Where)=leftPart$(List$(Where)+" "," ")
            } else {
                  List$(Where)=leftPart$(List$(Where)+" "," ")+" ✓"
            }
            Mytitle$= List$(Where) 
'            Method Simple,"RefreshAll"
            Method Listbox1,"Refresh"

}
Function simple.click {
            If ListIndex>=0 Then {
                  local K$=List$(ListIndex), i
                  Method listbox1,"Sort"
                  ListIndex=Find(K$)
                  Layer {
                        \\ we print to standard cosnole layer
                        Print ">>", control$
                  }
            } Else Method Listbox1,"Sort"
}
Function Simple.Resize {
      Layer Simple {
            Mode 16
            Cls 7,0
            Cursor 0, height div 2
            Report 2,"Hello World"
            Method Listbox1,"Refresh"
      }
      \\ we put a refresh to console because
      \\ when this handler run, can't run thread k.
      Layer { Refresh}
}
\\ now we want to show (without modal showing)
Method Simple, "Show"
\\ We can put a background task (a thread), triggering each 100 mSec
Thread {
      Print tick  \\ tick is thread manager timer
      refresh
} as K interval 100
a$=Key$ \\ no loop just wait a key, in console only
Threads Erase
Declare Simple Nothing
}
MODULE TEXTOUT {Module UsingEvents {
      Form 60, 32
      Declare WithEvents sp "SAPI.SpVoice"
      That$={Rosetta Code is a programming chrestomathy site.
      The idea is to present solutions to the same task in as many different languages as possible, to demonstrate how languages are similar and different, and to aid a person with a grounding in one approach to a problem in learning another. Rosetta Code currently has 913 tasks, 214 draft tasks, and is aware of 707 languages, though we do not (and cannot) have solutions to every task in every language.}
      EndStream=False
      LastPosition=-1
      TxtWidth=0
      Function sp_Word {
            Read New &StreamNumber, &StreamPosition, &CharacterPosition, &Length
            Rem:  Print StreamNumber, StreamPosition , CharacterPosition, Length
            If  LastPosition=CharacterPosition Then exit
            LastPosition=CharacterPosition
            Local f$=" "
            If TxtWidth=CharacterPosition+length Then f$=". "
            If length+pos+2>width then Print
            Print Mid$(That$, CharacterPosition+1, Length);f$;
            If f$=". " Then Print
            Refresh
      }
      Function sp_EndStream {
            Refresh
            EndStream=True
      }
      Function sp_Sentence {
            Read New &StreamNumber, &StreamPosition, &CharacterPosition, &Length
            if Length>0 and not CharacterPosition=0 then Print
            Print "  ";
            TxtWidth=CharacterPosition+Length-1
      }
      Const  SVEEndInputStream = 4
      Const  SVEWordBoundary = 32
      Const  SVESentenceBoundary = 128
      Const SVSFlagsAsync = 1&
 
      With sp, "EventInterests", SVEWordBoundary+SVEEndInputStream+SVESentenceBoundary
      Method sp, "Speak", That$, SVSFlagsAsync
      While Not EndStream {Wait 10}
      Wait 100
}
UsingEvents
}
MODULE MOVEBUTTON {Declare Form1 Form
Declare Button1 Button Form Form1
Declare TextBox1 TextBox Form Form1
Bx=4
Layer Form1 {
      Linespace 0
      Window 8, 10000, 6000
      Cls 1,0
      Form 30, 10
      Print @(0,4),"123456789012345678901234567890"
      Cursor Bx, 5
      Move !
      Button1_Xpos=Pos.x
      Button1_Ypos=Pos.y
      Xt=Button1_Xpos div Bx
      Yt=Button1_Ypos div 5
}
Method Textbox1,"Move", 1000,1000, 6000,600
Method Button1,"Move", Button1_Xpos, Button1_Ypos, Xt*5, Yt*2
Method Button1,"Curve",1 \\ 2 - 3 (single float)
Method Form1, "Show"
Function Form1.Unload {
      Keyboard "!"
}
Function Button1.Click {
      \\ print to console
      layer Form1 {            
            motion.w 0 ;
            
      }
      Print "Hello"
}
Function Form1.MouseDown {
      Drop 2 ' no need now (keycode and shift)
      Read New X, Y
      Layer Form1 {
            Move X, Y
            Cursor ! \\ transform to char coordinates
            Move ! \\ transform to graphic, at the up left corner of a char
            Method Button1,"Move", Pos.x, Pos.y
      }
}

A$=key$
Declare Button1 Nothing
Declare Form1 Nothing
}
MODULE DR {Module RomanNumbers {
      flush  ' empty current stack
      gosub Initialize
      document Doc$
      while not empty
            read rom$
            print rom$;"=";RomanEval$(rom$)
            Doc$=rom$+"="+RomanEval$(rom$)+{
            }
      end while
      Clipboard Doc$
      end
Initialize:
      function RomanEval$(rom$) {
            Flush
            ="invalid"
            if filter$(rom$,"MDCLXVI")<>"" Then Exit
            \\ "Y" is in top of stack
            Push "CM", "MD", "Q"
            Push "CD", "MD","W"
            Push "XC", "DL", "E"
            Push "XL", "X","R"
            Push "IX","V","T"
            Push  "IV","I","Y"
            \\ stack flush to doublerom
            doublerom=[]
            \\  "M" is in top of stack
            Data "M", 1000, "Q",900
            Data "D", 500,"W", 400
            Data "C",100,"E",90
            Data "L",50,"R", 40
            Data "X", 10, "T", 9
            Data "V", 5, "Y", 4, "I",1
            \\ stack flush to singlerom
            singlerom=[]
            acc=0
            value=0
            count=0
            stack doublerom {
                  if empty then exit
                  read rep$,exclude$,cc$
                  i=instr(rom$,cc$)
                  if i >0 then
                        tmp$=mid$(rom$,i+2)
                        L=Len(tmp$)
                        if L>0 then if Len(filter$(tmp$, exclude$))<>L then rom$="A": exit
                        if Instr(rom$,mid$(rom$,i,1))<i then rom$="A": exit
                        insert i,2 rom$=rep$  ' replace at pos i with rep$ and place a space to i+1
                  end if
                  loop
            }
            rom$=filter$(rom$," ") ' remove spaces if exist
 
            stack singlerom {
                  if empty then exit
                  read cc$, value
                  count=0
                  while left$(rom$,1)=cc$
                         insert 1, 1 rom$=""
                         count++
                         acc+=value            
                  end while
                  if count>3 then exit
                  loop
            }
            if len(rom$)>0  or count>3 Else
                  =Str$(acc,1033)
            end if      
      }
      data "MMMCMXCIX", "LXXIIX", "MMXVII", "LXXIX", "CXCIX","MCMXCIX","MMMDCCCLXXXVIII"
      data "CMXI","M","MCDXLIV","CCCC","IXV", "XLIXL","LXXIIX","IVM"
      data "XXXIX", "XXXX", "XIXX","IVI", "XLIX","XCIX","XCIV","XLVIII"
      return
}
RomanNumbers
}
MODULE G1 {t=0
{
'loop
t++
on t goto 100, 101

end
Print 0100
Print "fault"
0100 Print "ok1"
Restart
10100 Print "ok2"
exit
101 Print "ok"
}
}
MODULE G2 {goto 100

end
Print 0100
Print "fault"
0100 Print "ok1"
}
MODULE G3 {goto 100

end
Print 100
Print "fault"
100 Print "ok1"
}
MODULE G11 {t=0
again:
{
loop
t++
on t goto 100, 101
end
Print 0100
Print "fault"
0100 Print "ok1" : Print "100"
restart
10100 Print "fault"
exit
alfa:
101 Print "ok2", t
}
}
MODULE G12 {alfa:
101  static a=10
110 a--
120 print a
130 if a>1 then goto alfa
140 Clear
}
MODULE G4 {Module beta {
      print "i am beta"    
}
X=4
beta: Print "ok"  \\ call beta then print ok
beta: \\ only rem
Print x
x--
If x<1 Else Goto beta
k=false
x=100

}
MODULE M2 {a=(1,2,3,4,5)
fold1=lambda (a, b)-> {
      push a+b
}
fold2=lambda (a, b$) -> {
      if len(b$) Then {push b$+","+str$(a,"")} else push str$(a,"")
}
'? a#fold(fold1, 0)=a#sum()
odd=lambda (x) ->x mod 2=1
even=lambda (x)->x mod 2=0
add2=lambda (x)-> {
      push x+2
}
square=lambda (x)-> {
      push x*x
}
combine=lambda  -> {
      a=Array([])
      if len(a)=0 then =lambda->{} : exit
      =lambda  a ->{
            for i=0 to len(A)-1 { 
                  m=array(a,i)
                  call m()
            }
      }
}
? "["+a#filter(odd)#fold$(fold2, "")+"]"
? "["+a#filter(even)#map(add2)#fold$(fold2, "")+"]"
a=(,)
z=a#filter(even,(0,))#map(add2)
Print z, type$(z)
a=(1,2,3,4,5)
? a#map(add2, square)
? "["+a#map(add2, square)#fold$(fold2, "")+"]"
}
MODULE FS2 {Form ! 60,40
linespace twipsY*4
Form ! 60
refresh
\\ using M2000 commands
Menu   ' clear Menu list
Files !  + "gsb|txt"   ' ! sorted by name, + add to menu
Print Len(menu$())

a=menu$()

\\ we can use Print a
\\ but get refresh after the last item
\\ so we can use code to diplay names in columns (expand if name is bigger for one column)
k=each(a)
mp=width/tab
mc=mp*height*3/5
m=mc
Print $(6, 15)  ' use numbers from 0 to 9  - colum width 15
While k {
	Print array$(k),
	m--
	if pos>=width then m--
	if m<mp and pos=0 and row=height-1 then
	m=mc
	Pen 15 {
		Print Part "Press a key on keyboard or mouse (except Esc/Break)"
		While mouse=0 and inkey$="" {Refresh}
		Print Over @(0),
	}
	end if
}
}
MODULE DEMO1 {set Fast !
smooth on
Rem : 
 Thread.plan sequential
\\ we can set Thread.plan before any thread created
Rem :  Thread.plan concurrent
\\ concurrent execute one by one statements
\\ except those in { }
\\ also from Revision 52 Part {} as variable works fine with it
local counter1, counter2
Title "", 0 ' 0  to hide console
Set FAST !
\\ by api
Structure VecType {
          x As Double
          y As Double
          z As Double
}
\\ Program
Structure Variables {
      vRot1 As VecType
      vRot2 As VecType
      vRot3 As VecType
      vRot4 As VecType
      vBase As VecType
      vAxis As VecType
}
Buffer Clear Var As Variables
\\ utility function
VecAdr=Lambda Var (a$) -> {
      =Var(0,a$)
}
VecOff=Lambda Var, VecType (a$, b$) -> {
      =Var(0, a$, VecType(b$)!)
}
Class cLine {
      X1, Y1, X2, Y2, color
      Module Render {
            ' read Number from stack
            z=Round(Number,4)
            z1=Round(Number, 4)
            If z>=z1 Then {
                  Move .X1, .Y1
                  Width 3 {Draw to .X2, .Y2, .color}
                  Circle Fill #aa33cc, z/40+200
            } Else {
                  Move .X2, .Y2
                  Circle Fill #aa33cc, z/40+200
                  Width 3 {Draw to .X1, .Y1, .color}
            }
      }
Class:
      Module cLine (.color){
            If Match("NNNN") Then Read .X1, .Y1, .X2, .Y2
      }     
}

\\ find address
vBase=VecAdr("vBase")
vBase.x=VecOff("vBase","x")
vBase.y=VecOff("vBase","y")
vBase.z=VecOff("vBase","z")
vRot1=VecAdr("vRot1")
vRot1.x=VecOff("vRot1","x")
vRot1.y=VecOff("vRot1","y")
vRot1.z=VecOff("vRot1","z")
vRot2=VecAdr("vRot2")
vRot2.x=VecOff("vRot2","x")
vRot2.y=VecOff("vRot2","y")
vRot2.z=VecOff("vRot2","z")
vRot3=VecAdr("vRot3")
vRot3.x=VecOff("vRot3","x")
vRot3.y=VecOff("vRot3","y")
vRot3.z=VecOff("vRot3","z")
vRot4=VecAdr("vRot4")
vRot4.x=VecOff("vRot4","x")
vRot4.y=VecOff("vRot4","y")
vRot4.z=VecOff("vRot4","z")
vAxis=VecAdr("vAxis")
Refresh 100
Declare Alfa Form
With Alfa, "Title", "Demo1", "UseIcon", True, "UseReverse", True  ' icon now is in the left side
Method Alfa,"MakeStandardInfo", 1   ' 1 for English
Def  info$, AskRet
Function Alfa.InfoClick {
	Read New X
	If X=0 then
	after 100 {
			Info$={
				This is an example
				of  using MATH object
				(included in M2000 Interpreter)
				}
			AskRet=Ask(info$,"About Demo1","","")	
	}
	end if
}
\\ a string to hold static background
screen$=""
disp=False
Inventory Depth
aLine=Each(Depth)
once=False
Function DepthSort() {
                   Inventory Queue Depth ' clear Depth, Then make keys As numbers
                   Append Depth, Eval(Var, vRot1.z As double):=1, Eval(Var, vRot2.z As double):=2, Eval(Var, vRot3.z As double):=3
                   Sort Depth As number
}
Thread {
      part {
                  Method Math, "RotVectMult", 4, vRot1, vAxis, vRot1, dAngle
                  Push Eval(Var, vBase.y As double), Eval(Var, vBase.x As double)
                  \\ x is in top, y is after x
                  Over 2, 2 \\  copy two times from second, so double two top
                  Push Eval(Var, vRot4.x As double)+Number : Over 1, 2 \\ copy 2 times top only
                        Read Line1.X1, Line2.X1, Line3.X1
                        Push Eval(Var, vRot4.y As double)+Number : Over 1, 2
                        Read Line1.Y1, Line2.Y1, Line3.Y1
                        Over 2, 4 \\ now original 2 values copied 4 times
                        Line1.X2 = Eval(Var, vRot1.x As double)+Number
                        Line1.Y2 = Eval(Var, vRot1.y As double)+Number
                        Line2.X2 = Eval(Var, vRot2.x As double)+Number
                        Line2.Y2 = Eval(Var, vRot2.y As double)+Number
                        Line3.X2 = Eval(Var, vRot3.x As double)+Number
                        Line3.Y2 = Eval(Var, vRot3.y As double)+Number
                        call local depthsort()
                        counter1++
                        if random(20)>1 then exit
                        Method Math, "Vector", vAxis,.4 -.8*rnd, 1.6, .2-.3*rnd
                        Method Math, "UnitVect", vAxis
      }  As once
} As Compute
dim All(1 to 3)
Layer Alfa {
      Window 12, 10000, 8000;
      Form 40, 20
      Line1=cline(#0000FF, scale.x/2, scale.y/2, scale.x/2, scale.y/2-2220 )
      Line2=cline(#FF0000, scale.x/2, scale.y/2, scale.x/2-2340, scale.y/2-60 )
      Line3=cline(#00FF00, scale.x/2, scale.y/2, scale.x/2-780, scale.y/2-1200 )
      All(1)->Line1
      All(2)->line2
      All(3)->line3
      Declare Math Math
      Method Math, "Vector", vBase,scale.x/2-1500, scale.y/2+1500, 1500 '  -1000
      Method Math, "Vector", vRot1, Line1.X2, Line1.Y2, -1000
      Method Math, "Vector", vRot2, Line2.X2, Line2.Y2, -1200
      Method Math, "Vector", vRot3, Line3.X2, Line3.Y2, 1700
      Method Math, "Vector", vRot4, Line1.X1, Line1.Y1, 0
      Method Math,  "VecDiffMult", 4, vRot1, vBase, vRot1
      Inventory Depth=Eval(Var, vRot1.z As double):=1, Eval(Var, vRot2.z As double):=2, Eval(Var, vRot3.z As double):=3
      Sort Depth As number
      Method Math, "Vector", vAxis, -.8, 1.6, .3
      Method Math, "UnitVect", vAxis
      Rad2Deg =Lambda pidivby180=pi/180 (RadAngle)->RadAngle / pidivby180
      dAngle =5
      Pen 0
      Cls 7
      Gradient 11, 13
      Move 0,0
      Cursor 0, Height-1
      Cls 7, Height-1
      Copy scale.x, scale.y to screen$
      Cursor 0,Height
      together=False
      ok1=true
      Thread {
            ok1~
      } as mm interval 1000/25
      tm=0
      Thread {
            static internal=1
'            Refresh 0
            Move 0,0
            Copy 0,0 use screen$
            Part {
                  tm=timecount
            } as ok1
            Print @(3,3); format$("{0:2:-5}",tm)
                  Cursor 0,height-1

            Part {
                       Part {
                        aLine=Each(Depth)
                        push  Eval(Var, vRot4.z As double) : Over 1, 2
                        while aline {
                                    pp=all(eval(aLine))
                                    pp=>render  Val(eval$(Depth, aLine^))
                        }
                        counter2++
                        } As disp
                   Print Part $(5,Width/4), counter1, counter2,internal, $(7),Str$(Now , "hh:mm:ss" ) 
                  Refresh 5000' execute together
            }  As together
            internal++
            Profiler
      } As PlayThis
}
\\ we set variables outside threads
State=False
blinking=False
Thread {
       If state Then disp~
 } As blink
Thread blink Hold
ExitNow=False
Function Alfa.Unload {
      ExitNow=True
      threads erase
}
Function Alfa.Click {
                  State~
                  If State Then {
                         Thread compute Hold
                         Thread blink interval 1000/4
                         Thread blink Restart
                         blinking=true
                  } Else {
                        disp=False
                        If blinking Then Thread blink  Hold : blinking~
                        Thread compute Restart
                  }
}
if IsWine then
      Thread PlayThis interval 1000/30
else
      Thread PlayThis interval 1000/120
end if  
Thread compute interval 10
Wait 200
Method Alfa, "Show"
\\ Change Task.Main with Every
\\ Task.Main is a Thread
\\ ExitNow needed If we have Every in place of Task.Main
Task.Main 50 {
\\      If counter1>1000 Then Threads Erase : Exit
      If ExitNow Then Exit
}
Threads Erase
Wait 100  \ some delay here
Method Alfa, "CloseNow"
Declare Alfa Nothing
Declare Math Nothing
Print counter1, counter2
Title "Demo Complete"
}
MODULE UPDATE {dir appdir$
save info, info
dir user
save info, info
}
MODULE BJ { Flush  \\empty Stack, we use optional arguments in Modules
 NoPlayers=4
\\ Dealer get one hidden And one open Card
\\ Player's get two open cards, one at a time
\\ Options for Split and Double Down
\\ If Player has a BlackJack Then dealer play for 21, changing cards for other players/splits
\\ Standard Bet 100 credits.  Each player start with 10000 credits
MakeLayer()

Print $(4)
Inventory Suits = "♠":=0, "♥":=4, "♦":=4, "♣":=0 'suit -> color
Inventory Cards = "two":=2, "three":=3, "four":=4, "five":=5
Append Cards, "six":=6, "seven":=7, "eight":=8, "nine":=9
Append Cards, "ten":=10, "jack":=10, "queen":=10, "king":=10, "ace":=1
Global CardsView
\\ use <= to feed CardsView
Inventory CardsView <= 2, 3, 4, 5, 6, 7, 8, 9,10, "jack", "queen", "king","ace"

\\ We use Module because each module has own use of dots..
\\ And we call it inside a For Object {} And outside of it
DealerMoney=0
Module PrintCardOnly (k, Suits, Cards, x=0) {
          For k {
                Pen Suits(.suit!) {
                        Print Part @(10+x,row,15+x,row+1,#FFE4E1,0), Eval$(Suits, .suit)+" "+CardsView$(.card!)
                        Print
                   }
        }
}
' Using a Stack object
StackPack = Stack
Module AppendArray (N, A) {
      Stack N {Data !A}
}
Class OneCard {
      suit=-1, Card
Class:
     Module OneCard {
           \\ ? for optional reading
           read ? .suit, .card
     }
}
\\ 3X52 cards
Dim Pack(Len(Cards)*Len(Suits)*(NoPlayers+1)) \\ Not used here =OneCard()
Pen 14
Double
Pen 14 {Report 2, "BlackJack"}
Normal
Cls, 2
k=0
\\ fill cards to Pack()
For times=NoPlayers+1 To 1 {
      N=each(Suits)
      While N {
            M=each(Cards)
            While M {
                  Pack(k)=OneCard(N^, M^)
                  k++
            }
      }     
}
Layer 1 {
	Report 2, "Prepare Cards"
}
Rem : DisplayAll() ' in order
Suffle()
Rem : DisplayAll() ' at random positions
Print
' first cut for player
layer 1{
	Print "Make a Cut: 0-51:";
	Repeat {
	      N1=Random(0,51)
	      Try {
	            Input ! N1, 10
	      }
	      Stack StackPack {
	            Drop N1
	      }
	} Until N1>=0 And N1<=51
	Print N1
}
\\ used to pass the Dealer's hidden Card
Hidden=OneCard()
DealerHidden=OneCard()
Class PlayerJB {
      Class PlayerGame {
            \\ Class is a Group Factory - a function whuch return Group
            \\ Class Definition in a Group is local else is Global
            \\ until erased when Definition Holder exit or end (a Module/Function where we define a class)
            Playervalue, Bet
            \\ we can define groups using class like this If class constructor work without parammeters
            OneCard LastCard
            Class:
            \\ Class: means that this module exist only at construction stage
            Module PlayerGame {
                  ' This module as part of constructor
                  ' so has own Stack when called as constructor
                 Read .Playervalue, .Bet
                 If Not Empty Then Read .LastCard
            }
      }
      Inventory queue PlayerCards
      OneCard PlayerFaceUp2nd, SplitCard
      Bet=100, PlayerMoney
      Playervalue
      OldPlayerValues=Stack
      Done=false
Class:
      Module PlayerJb (.PlayerMoney) {}
}
Dim Base 1, Players(NoPlayers)=PlayerJB(10000)
Def Val$(x)=If$(x=-1 -> "Black Jack", Str$(x,""))
Card=OneCard()
Function ClearCards {
      Inventory queue ClearCards
      =ClearCards
}
Function PlayerHasNoBlackJack(HasTheDealer) {
      ' we get two parameters
      If Not HasTheDealer Then Exit ' the second parameter droped from Stack
      ' now we read 2nd
      Read k
      Def Range(X, X1, X2)=X>=X1 and X<=X2
      m=false
      If k.PlayerCards(0!).card=12 And Range(k.PlayerFaceUp2nd.card,8 ,11) Then m=m or true
      If k.PlayerFaceUp2nd.card=12 And Range(k.PlayerCards(0!).card,8 ,11) Then m=m or true
      =Not m
}
DealerRow=0
Repeat {
      layer 1 {cls}
      donecount=0
      For i=1 to NoPlayers {
            For Players(i) {
                  .SplitCard=OneCard()
                  .OldPlayerValues=Stack
                  If .done Then donecount++ :  Exit
                  If .PlayerMoney<.Bet Then {
                      Layer 1{
                          Print Format$("Player({0}), you run out of money...Bye Bye", i)
                      }
                        .done=true
                         donecount++
                  } Else {
                     Layer 1{
                           Print format$("Player({0}) Money:",i), .PlayerMoney
                              Print "Play Game ?(Y/N)"
                              If Key$ ~ "[NnΝν]" Then .done=true :  donecount++
                    }
                  }
            }
      }
      if donecount<NoPlayers Then Print "Press space to deal cards" : while Key$<>" " {}
      cls,2
      AllPlayers=NoPlayers
      BlackJack=false
      PlayersBurst=0
      Clear dealervalue
      DealerCards=ClearCards()
      For i=1 to NoPlayers {
            For Players(i) {
                  If .done Then AllPlayers-- : Exit
                  Clear .playervalue
                   .PlayerCards=ClearCards()
                  Print Format$("Player {0} Hand: 1st Card", i)
                  PlayerCard(&.playervalue, .PlayerCards)
            }
      }
      If AllPlayers=0 Then Print "No More Players" : Exit
      Print "Dealer Hand: 1st Card"
      DealerRow=row
      DealerCard(&dealervalue)
      cursor 0,2
      For i=1 to NoPlayers {
            If Not Players(i).done Then {
                  Print @(18),Format$("2nd Card", i)
                  For Players(i) {
                        NextCard()
                        .PlayerFaceUp2nd<=Card
                        PrintCardOnly Card, Suits, Cards, 18
                  }
            }
      }
      Print @(18), "2nd Card"
      NextCard()
      Print @(18), "Face Down Card"
      cls , row+1 
      DealerHidden=Card
      ' now If dealer face up Card is Ace or 10 or Figure can see If has a black jack
      N2=Cards(Card.card!)
      If N2=10 And Cards(DealerCards(0!).card!)=1 Then DealerBlackJack()
      If N2=1 And Cards(DealerCards(0!).card!)=10 Then DealerBlackJack()
      For i=1 to NoPlayers {
           If Not Players(i).done Then
                  If PlayerHasNoBlackJack(BlackJack, Players(i)) Then
                  cls, 2
                  For Players(i) {.PlayerMoney-=.Bet : DealerMoney+=.Bet} 
                  Exit
                  end If
                   For Players(i) {
                         Bet=.Bet
                         Again:
                              Print format$("Player {0} Play", i)
                              If .PlayerCards(0!).card=.PlayerFaceUp2nd.card Then {
                                    If .PlayerMoney<2*.Bet Then exit
                                    Print "Split Cards ?(Y/N)"
                                    If Key$ ~ "[NnΝν]" Then Exit
                                    AllPlayers++
                                    .SplitCard<=.PlayerFaceUp2nd
                                    NextCard()
                                    .PlayerFaceUp2nd<=Card
                                    Stack .OldPlayerValues {Push .PlayerGame(.playervalue, Bet)}
                              }
                              Print "Player Hand:"
                              Hidden=.PlayerFaceUp2nd : .PlayerFaceUp2nd<=OneCard()
                              PrintCardOnly .PlayerCards(0!), Suits, Cards ' show first Card
                              PlayHand(.PlayerCards,&.playervalue, False, False, .PlayerMoney)
                              ' first we get Bet
                              .PlayerMoney-=Bet
                              DealerMoney+=Bet
                              Print
                              If .playervalue>21 Then {
                                    PlayersBurst++
                                    Print "Dealer Win"
                              } else.if .playervalue=-1 Then {
                                    ' dealer has to play with player now
                                    PlayersBurst++
                                    Print Format$("Dealer play against Player({0})",i)
                                    PrintCardOnly DealerCards(0!), Suits, Cards
                                    Hidden=DealerHidden : DealerHidden=OneCard()
                                    \\ ? means undefined value
                                    PlayHand(DealerCards,&dealervalue, true, true, ?)
                                    If dealervalue<>21 Then {
                                            Print "Player Win", Bet*3/2 : .PlayerMoney+=Bet*5/2 ' one we get before
                                            DealerMoney-=Bet*5/2
                                    } Else {
                                          Print "Dealer Win"  
                                    }
                                    If PlayersBurst<AllPlayers Then {
                                          Clear dealervalue, DealerCards
                                          ' dealer take two cards to play with others
                                          Print "Dealer Hand: 1st Card"
                                          DealerCard(&dealervalue, DealerRow)
                                          Print "Dealer Hand: 2nd Card"
                                          NextCard()
                                          Print @(10), "Face Down Card"
                                          DealerHidden=Card
                                          ' now If dealer face up Card is Ace or 10 or Figure can see If has a black jack
                                          N2=Cards(Card.card!)
                                          If N2=10 And Cards(DealerCards(0!).card!)=1 Then DealerBlackJack()
                                          If N2=1 And Cards(DealerCards(0!).card!)=10 Then DealerBlackJack()
                                    }
                              }
                              ' Data push to end of Stack
                              ' Push push to top of Stack
                              ' Read read always from top
                                    If .SplitCard.suit<>-1 Then {
                                    Card=If(Bet>.Bet -> .PlayerCards((Len(.PlayerCards)-1)!), OneCard())
                                    Stack .OldPlayerValues {Data .PlayerGame(.playervalue, Bet, Card) : Read NextGame}
                                    Bet=NextGame.Bet
                                    Drop .PlayerCards Len(.PlayerCards) ' erase all cards
                                    Append .PlayerCards, "Split":=.SplitCard
                                    '.playervalue=Cards(.SplitCard.Card!)  ' this is the same
                                    .playervalue=NextGame.playervalue
                                    NextCard()
                                    .PlayerFaceUp2nd<=Card
                                    .SplitCard.Suit=-1
                                    Goto Again
                              }
                        Card=If(Bet>.Bet -> .PlayerCards((Len(.PlayerCards)-1)!), OneCard())
                        Stack .OldPlayerValues {Data .PlayerGame(.playervalue, Bet, Card)}
                  }
           end If      
      }
      If PlayersBurst<AllPlayers And Not BlackJack Then {
            Print "Dealer Play"
            PrintCardOnly DealerCards(0!), Suits, Cards
            Hidden=DealerHidden : DealerHidden=OneCard()
            PlayHand(DealerCards,&dealervalue, true, false, ?)
            Layer 1 {
                  Pen 3 {
                        Report 2, "Table Results"
                        For i=1 to NoPlayers {
                              For Players(i) {
                                    Repeat {
                                          If .done Then exit
                                          Stack .OldPlayerValues { Read NextGame }
                                          playervalue=NextGame.playervalue
                                          Bet=NextGame.Bet
                                          If Not playervalue=-1 Then {
                                                If Bet>.Bet Then {
                                                      Print "Face Up Card"
                                                      PrintCardOnly NextGame.LastCard, Suits, Cards
                                                }
                                                If playervalue>21 Then {
                                                     Print Format$("Dealer Win Player({0})", i)
                                                } Else.If dealervalue>playervalue And dealervalue<22 Then {
                                                     Print Format$("Dealer Win Player({0})", i)
                                                } Else.If dealervalue>21 Or dealervalue<playervalue Then {
                                                      Print Format$("Player({0}) Win Dealer", i)
                                                      .PlayerMoney+=Bet*2
                                                      DealerMoney-=Bet*2
                                                } Else {
                                                      Print Format$("Player({0}) keep bet for next time", i)
                                                       .PlayerMoney+=Bet
                                                      DealerMoney-=Bet
                                                }
                                                Print format$("Player({0}): {1}  Dealer: {2}", i, Val$(playervalue), Val$(dealervalue))
                                          }
                                    } Until Len(.OldPlayerValues)=0
                                    Refresh
                              }
                        }
                  }
                  Print "Press space to continue" : while Key$<>" " {}
            }
            Cls ,2
      }
} Always
Print "Dealer Money:", DealerMoney
Print "Press space to exit" : while Key$<>" " {}
Player 0
cls,0
End
Sub Suffle()
      Layer 1 {
            Print
            Local N=Len(Pack())-1, N2, i, j, total=N*4+4, cur=1
            For j=1 To 4 {
                  For i=0 To N {
                        If cur Mod 4=3 Then Print Over format$("Suffle {0:0}%",cur/total*100)
                        N2=random(0, N)
                        While N2=i {N2=random(0, N)}
                        Swap Pack(i), Pack(N2)
                        cur++
                  }
            }
            AppendArray StackPack, Pack()
            Print
      }
End Sub
Sub DisplayAll()
      For k=0 To Len(Pack())-1 {
            PrintCard(k)
      }
End Sub
Sub PrintCard(k)
      For Pack(k) {
            Pen Suits(.suit!) {
                  Print Eval$(Suits, .suit)+Eval$(Cards, .card),
            }
       }
End Sub
Sub DealCard()
      Layer 1 {
            Print "PRESS A KEY TO DEAL CARD"
            If Key$="9" Then  Stack STACKPACK {Flush}
      }
End Sub
Sub NextCard()
          Rem :  DealCard()
            If Len(StackPack)=0 Then {
                  Suffle()
                  Stack StackPack {
                        Drop Random(0, 51)
                  }
            }
            Stack StackPack {
                  Read Card
            }
End Sub
Sub PlayerCard(&acc, MyCards)
      NextCard()
      PrintCardOnly Card, Suits, Cards
      acc+=Cards(Card.Card!)
      Append MyCards, len(MyCards):=Card
End Sub
Sub DealerCard(&acc, thisrowtoo=-1)
      NextCard()
      PrintCardOnly Card, Suits, Cards
      local oldrow=row
      If thisrowtoo>=0 Then
      cursor 0, thisrowtoo
      PrintCardOnly Card, Suits, Cards
      cursor 0, oldrow
      end If
      acc+=Cards(Card.Card!)
      Append DealerCards, len(DealerCards):=Card
End Sub
Sub PlayHand(MyCards, &acc, nomessage, sorryblackjack)
      ' Optional - We have to pass a ? If we have module or Sub
      Read ? MyMoney
      Local N2, morevalues=0, ok, Card=OneCard(), DoublingDown
      If MyCards(0!).card=12 Then morevalues=10
      Repeat {
            If Hidden.suit>=0 Then {
                  N2=Hidden.card
                  PrintCardOnly Hidden, Suits, Cards
                  Append MyCards, Len(MyCards):=Hidden
                  Hidden=OneCard()
            } Else {
                  NextCard()
                  If DoublingDown Then {
                        Print @(10), "Face Down Card"
                  } Else {
                        PrintCardOnly Card, Suits, Cards
                  }
                  N2=Card.Card
                  Append MyCards, Len(MyCards):=Card
            }
            If N2=12 Then {
                  If morevalues=0 Then {
                        morevalues=10
                  } Else N2=13 : morevalues=-50
            }
            If acc=10 And N2=12 And Len(MyCards)=2 Then acc=-1: Pen 15 {Print "BlackJack" }: Exit
            If morevalues>0 And Cards(if(N2<13 -> N2, 1)!)=10 And Len(MyCards)=2 Then acc=-1: pen 15 {Print "BlackJack" } : Exit
            If N2<=12 Then {
                  acc+=Cards(N2!)
            } Else acc+=11
            If acc>21 And Not DoublingDown Then Print "Busting" : Exit
            If acc=21 Then Exit
            If nomessage Then {
                  If sorryblackjack Then {
                              ok=acc>20 Or acc+morevalues=21
                  }  Else  ok=acc>16 Or (acc+morevalues<22 And acc+morevalues>16)
            } Else {
                  If DoublingDown Then ok=True : Exit
                  If Len(MyCards)=2 Then If acc=9 or acc=10 or acc=11 And acc+morevalues<>21 Then DoublingDown=true
                  If DoublingDown Then {
                        If MyMoney>=2*Bet Then {
                              Print "Doubling Down ?(Y/N)"
                              DoublingDown=Not Key$ ~ "[NnΝν]"
                        } Else DoublingDown=False
                  }
                  If DoublingDown Then {
                        ' get a card Face Down
                        Bet*=2
                        ok=false
                  } Else {
                        Print Part "Stand or Hit ?(S/H)"
                        ok=Key$ ~ "[SsΣσ]"
                  }
            }
      } Until ok
      If acc=-1 Then morevalues=0
      While morevalues>0 {
            If acc+morevalues<22 Then Exit
            morevalues-=10
      }
      If morevalues<0 Then Exit Sub
      acc+=morevalues
End Sub
Sub DealerBlackJack()
      Pen 15 {Print "BlackJack" }
      PrintCardOnly Card, Suits, Cards
      Print "Face Up Card"
      Print "Dealer Win All"
      Print "Press space to continue" : while Key$<>" " {}
      BlackJack=True
End Sub
Sub MakeLayer()
      Font "Arial"
      back {
            Cls #477148,0
            Local k=if( scale.x*4/3<scale.y->40, 60)
      }
      Form ! k, 30
      linespace twipsY*4
      Mode Mode*.8;
      
      Cls #477148,0    ' Poker Green Color
      cursor width/2, 2
      Move !   ' move graphic cursor to cursor
      myMode=Mode
      x1=scale.x/2
      y1=scale.y-pos.y
      y2=pos.y+motion.y
      x2=x1+motion.x
      player 0
      Layer 1 {
            window myMode, x1, y1
            motion x2,y2
            Cls #FFE4C4,0
            Pen 0
            show
            bold 1
            Print $(4)
      }
      Cursor 0,0

End Sub
}
MODULE JSON {' Process data in json format

' we can load from external file with Inline "libName"
' or multiple files Inline "file1" && "file2"
' but here we have the library in a module
Inline Code Lib3
' So now we make a Parser object (a group type in M2000)
Parser=ParserClass()
' We can display any function, module that is public and known list
Modules ?
' And this are all known variables (or and objects)
List !
'exit
Document json$
' We can load from file
'Load.Doc json$, "alfa.json"
json$={{
      "zero": 0,
      "alfa":-0.11221e+12,
      "array" : [
            -0.67,
            "alfa1",
            [
                  10,
                  20 
            ],
            "beta1",
            1.21e12,
            [
            ],
            21.12145,
            "ok"
      ],
      "delta": false, "epsilon" : true, "Null Value" : null
}}
Save.Doc json$, "json2.json"    \\ by default in Utf-8 with BOM
' just show multiline text
' Report display lines and stop after 3/4 of console height lines
' just press a key or click mouse button
Report json$
' so now we get text to a new object
alfa=Parser.Eval(json$)
' check t
Print Type$(alfa)  ' it is a group
Print "alfa.type$=";alfa.type$  \\ this is a read only property

Report "as one line"
Report Parser.Ser$(alfa, 0)

Report "as multiline"
Report Parser.Ser$(alfa, 1)

Print "Using Print"
Print Parser.ReadAnyString$(alfa)

Print "Value for alfa, id alfa"
Print Parser.ReadAnyString$(alfa,"alfa")
Report "as multiline"
Report Parser.Ser$(Parser.Eval(Parser.ReadAnyString$(alfa,"array", 2)), 1)
' We get a copy of an array as a Group (a group which return an array)
Alfa3=Parser.Eval(Parser.ReadAnyString$(alfa,"array", 2))
' First value is for actual object, second value is a reafonly property of this object
Print type$(Alfa3),  Alfa3.type$
Dim B()
' Now Alfa3 run Value part and pass a pointer of array
' B()  is an array and here take a pointer to Alfa3 array (as value of Alfa3)
B()=Alfa3
' each() make an iterator for B()
N=each(B())
While N {
      \\ Using B() we get values always. but if we have "object" or "array" then Print prints items **
      Print B(N^)
}
' ** Print show here nothing because if value is object then "print" just leave a column and continue to next one
Print B()
' we have to use Group() to get group not value of group (if any).
' Group() works for "named" group, not for stored in an array or an inventory or a stack
Print Parser.StringValue$(Group(Alfa3),  0)
Print Parser.StringValue$(Group(Alfa3),  1)
' Now we want to pass a new value
' Interpreter want to match type of expression from left side to right side
' Because Parser.StringValue$ is actuall a Group (As property),
' we have a second linked name:  Parser.StringValue
' we have to use Parser.StringValue()
' and all values must be groups, as those provided by Parser
Parser.StringValue(Group(Alfa3),  1)=Parser.Numeric(1234)
Print Parser.StringValue$(Group(Alfa3),  1)
Print Parser.StringValue$(Group(Alfa), "array", 2, 0)
' we have to use Parser.StringValue$()
Parser.StringValue$(Group(Alfa), "array", 2, 0)=Parser.JString$("Changed to String")
Print Parser.StringValue$(Group(Alfa), "array", 2,0)
Try ok {
      Print Parser.StringValue$(Group(Alfa), "array", 2)
}
If  Error or not ok Then Print Error$
Parser.StringValue.Add = True
Parser.StringValue$(Group(Alfa), "array", 2, 10)=Parser.JString$("Changed to String 2")
Parser.StringValue(Group(Alfa), "Last value")=Parser.Boolean(true)
Report "as multiline"
Report Parser.Ser$(alfa3, 1)
Report Parser.Ser$(alfa, 1)
Parser.StringValue.Add = False
Parser.StringValue.Del = True
Parser.StringValue(Group(Alfa), "array", 0)=Parser.Null()
Parser.StringValue(Group(Alfa), "delta")=Parser.Null()
Parser.StringValue.Del = False
For Parser {
      .StringValue(Group(Alfa), "array", 1,5)=.Arr((.Numeric(10), .Jstring$("ok 20"), .Boolean(true)))
}
Report Parser.Ser$(alfa, 1)
}
MODULE LIB3 {      Class ParserClass {
      Private:
            Class bStream {
                  Private:
                  cnt, Buffer A
                  Public:
                  Value (&c) {Try { c=eval(.A, .cnt) : .cnt++:=true}}
                  Class:
                  Module final bStream (a$){
                        Buffer .A as Integer*Len(a$)
                        Return .A, 0:=a$           
                  }
            }
            Func=Lambda->false
            char=0
            ' using obj as pointer to  Stack 
            obj=Stack
            Function final IsId {
                  If .char=34 Then =.IsString(false)
            }
            Function final IsTrue {
                  ' U+0074 U+0072 U+0075 U+0065
                  If .char=0x74 Then If .func() Then If .char=0x72 Then If .func() Then If .char=0x75 Then If .func() Then If .char=0x65 Then PushIt() : =True
                  Sub PushIt()
                        Stack .obj {
                              Push .Boolean(True)
                        }
                  End Sub
            }
            Function final IsFalse {
                  ' U+0066 U+0061 U+006c U+0073 U+0065
                  If .char=0x66 Then If .func() Then If .char=0x61 Then If .func() Then If .char=0x6c Then If .func() Then If .char=0x73 Then If .func() Then If .char=0x65 Then PushIt() : =True
                  Sub PushIt()
                        Stack .obj {
                              Push .Boolean(False)
                        }
                  End Sub
            }
            Function final IsNull {
                  ' U+006E U+0075 U+006C U+006C
                  If .char=0x6e Then If .func() Then If  .char=0x75 Then If .func() Then If .char=0x6c Then If .func() Then If .char=0x6c Then PushIt() : =True
                  Sub PushIt()
                        Stack .obj {
                              Push .Null()
                        }
                  End Sub
            }
            Function final IsSemiCol {
                    If .char=0x3a Then =true 
            }
            Function final IsComma {
                    If .char=0x2c Then =true 
            }
            Function final IsObject {
                  If  .char=123 Else exit
                  inventory objinv
                 ' we push object with a pointer to objinv
                 Stack .obj { Push .Object(objinv)}
                 .Trim
                 While .IsId() 
                       .Trim
                       If  .IsSemiCol() Then
                             .Trim
                             If .IsValue() Then
                                   Stack .obj {
                                          Shift 2   ' move top as second
                                          ' letter$ is ok If top is string, and throw it
                                          Append objinv, Letter$:=Group
                                    }
                              End If
                       Else
                             Exit
                       End If
                       .Trim
                        If not .IsComma() Then exit
                       .Trim
                  End While
                  If .char=125 Then =true  Else .obj<=Stack : .func<=lambda->0 
            }
            Function final IsValue {
                  If .IsString(True) Then
                         =True    
                  Else.if .IsNumber() Then
                        =True
                  Else.if .IsTrue() Then
                        =True
                  Else.if .IsFalse() Then
                        =True
                  Else.if .IsNull() Then
                        =True
                  Else.if .IsArray() Then
                        =True
                  Else.if .IsObject() Then
                        =True
                  Else
                        ? "what", .char
                        Stack .obj { Stack}
                        .func<=lambda->0
                  End If
            }
            Function final Digits (private_stack){
                  While .func()
                        Select Case .char
                        Case 48 to 57
                        {
                              =true
                             Stack private_stack { Data .char}
                        }
                        Else Case
                             break
                        End Select
                  End While    
            }
            Function final IsNumber {
                  a=Stack
                  Select Case .char
                  Case 45 ' -
                  {
                              oldfunc=.func            
                              Stack a { Data .char}
                              If .Func() Then
                                    Select Case .char
                                    Case 48 
                                    {
                                            Stack a { Data .char}
                                            If  .func() Then
                                                If .char=46 Then
                                                      Fraction()
                                                      Exponent()
                                                End If
                                          End If
                                    }
                                    Case 49 to 57
                                    {
                                          Stack a { Data .char}
                                          If .Digits(a) Then {}
                                          Fraction()    
                                          Exponent()
                                    }
                                    Else Case
                                          a=stack
                                    End Select
                              End If
                  }
                  Case 48  ' 0
                  {
                        oldfunc=.func
                        Stack a { Data .char}
                        If  .func() Then
                            If .char=46 Then
                                  Fraction()
                                  Exponent()
                            End If
                      End If
                  }
                  Case 49 to 57
                  {
                              oldfunc=.func
                              Stack a { Data .char} 
                              If .Digits(a) Then {}
                              Fraction()
                              Exponent()
                  }
                  End Select
                  
                  If len(a)>0 Then {
                        b=each(a)
                        Document D$
                        While b
                              D$=chrcode$(StackItem(b))
                        End While
                        .func<=oldfunc
                        If len(D$)>1 Then For i=2 to len(D$) { .Trim}
                        Stack .obj { Push .Numeric(D$) }
                        =True
                  }
                  '  here is an auto exit from function. Sub as command is an exit
                  Sub Fraction()
                        If .char=46 Then Stack a { Data .char}
                        If .Digits(a) Then { }
                  End Sub
                  Sub Exponent()
                        If .char=101 or .char=61 Then
                              Stack a { Data .char}
                              If .func() Then
                                    If .char=43 or .char=45  Then
                                          Stack a { Data .char }
                                          If .Digits(a) Else
                                                a=Stack  ' cleat by point to new Stack
                                          End if
                                    Else.if  .char>47 and .char<58  Then
                                          Stack a { Data .char}
                                          If .Digits(a) Then {}
                                    Else 
                                           a=Stack
                                    End If
                              End If
                        End If
                  End Sub
            }
            Function final IsString (as_object){
            If .char=34 Else exit
                  Document D$
                  While  .func()
                        If .char=34 Then 2000
                        If .char=92 Then
                              ' special care
                              If .func() Then
                                    Select Case .Char
                                    Case 117 'u
                                    GetHex()
                                    Case 114 ' r
                                    .char<=0x0d
                                    Case 110 ' n
                                    .char<=0x0a
                                    Case 116 ' t
                                    .char<=0x09
                                    Case 98 ' b
                                    .char<=0x08
                                    Case 102 ' f
                                    .char<=0x0c
                                    Case 0x22, 0x2f , 0x5c 
                                    Else
                                    Exit   ' not normal
                                    End Select
                              End If
                        End If
                        D$=chrcode$(.char)
                  End While
                  Exit
      02000    Stack .obj { 
                        If as_object Then Push .JString$(D$) Else Push D$
                  } : =True 
                  Sub GetHex()
                        Local D$
                        Document D$="0x"
                        For i=1 to 4
                              If .func() Then End If
                                    If  Chrcode(.char) ~ "[0123456789ABCDEFabcdef]"  Then
                                          D$=Chrcode(.char)
                                    Else
                                          Goto 3000
                                   End If
                              End If
                        Next I
                        If i<>5 Then 3000
                        .Char=Eval(D$)
      03000    End Sub
            }
            Function final IsArray {
                
                  If  .char=91 Else exit
                  Dim Gr()
                  ' We place a pointer ro Array
                  .Trim
                  If .char=93 Then  =true : Stack .obj { Push .Arr(Gr())}  : exit
                        While .IsValue()
                              Stack .obj {
                                    Dim Gr(Len(Gr())+1)
                                    Gr(len(Gr())-1)=Group
                              }
                              .Trim
                              If not .IsComma() Then exit
                              .Trim
                        End While
                  ' Push later pointer to array (maybe altered in redimension)
                  If .char=93 Then  =true :  Stack .obj { Push .Arr(Gr())}  Else .Func<=lambda->false
            }
            Module final Trim  {
                  While  .func()
                         If  .char<33 or .char=160 Else exit      
                  End While
            }
            Function final  IsContainer {
                 .Trim
                 Select Case chrcode$(.char)
                 Case "{"
                        =.IsObject() 
                 Case "["
                        =.IsArray()
                 end select
            }
      ' merge a foreign group here
            Module final ReadArrayItem (temp, object){
                   Select Case temp.type$
                        Case "String","Boolean","Number", "Null"
                        {
                              If object Then Error "No object "+quote$(temp.type$)
                              Push temp.str$
                        }
                        Case "Object"
                        {
                              If not Empty Then
                                 Call .ReadObject temp, object, letter$
                              Else
                                    If object Then Push Temp : exit
                                    Push .ser$(group(temp),0)
                              End If
                        }
                        Case "Array"
                        {
                              If not Empty Then
                                    ' recursion only with Call statement for modules
                                    Call .ReadArrayItem, Array(temp, number), object
                              Else
                                    If object Then Push Temp : exit
                                    Push .ser$(group(temp),0)
                              End If
                        }
                        End Select
            }
            Module final ReadObject (json, object){
                  If type$(json)="Inventory" Then
                        If exist(json, Letter$) Then
                              temp=eval(json)
                        Else
                             push "none"
                             Break  ' exit Module final  (Break do something Else in Select End Select)
                        End If
                  Else
                        temp=json
                  End If
                        Select Case temp.type$
                        Case "String","Boolean","Number", "Null"
                        {
                              If object Then Error "No object "+quote$(temp.type$)
                              Push temp.str$
                        }
                        Case "Object"
                        {
                              If not Empty Then
                                    Call .ReadObject temp, object ', letter$
                              Else
                                    If object Then Push Temp : exit                              
                                    Push .ser$(group(temp),0)
                              End If
                        }
                        Case "Array"
                        {
                              If not Empty Then
                                    Call .ReadArrayItem array(temp, number), object
                              Else
                                    If object Then Push Temp : exit
                                    Push .ser$(group(temp),0)
                              End If
                        }
                        End Select
            }
            Module final Worker (object){                        
                         If match("IN") Or match("IS") Then   ' inventory & number or inventory and string
                         '    maybe we have more items in Stack
                               Push object : ShiftBack 2
                              .ReadObject
                         Else
                              read Temp  ' get  a group which returns Iventoty or an mArray
                              If Type$(Temp)="mArray" Then
                                    If not Empty Then
                                          Call .ReadArrayItem, Array(Temp, number), object
                                    Else
                                          If object Then Push Temp : exit
                                          Push .ser$(Temp,0)
                                    End If
                              Else
                                    If not Empty Then
                                                Call .ReadObject Temp, object
                                    Else
                                          If not Empty Then
                                                Call .ReadObject Temp, object
                                          Else
                                                If object Then Push Temp : exit
                                                If Type$(Temp)="Inventory" Then
                                                      Push .ser$(.Object(Temp),0)
                                                Else
                                                      Push .ser$(group(Temp),0)
                                                End If
                                          End if
                                   End If
                              End If
                        End If
            }
      Public:
      \\ This is the Public part
      \\ First we set Public some class for later use
      \\ Using Pointer to Array in Class Arr
            Class Arr {
            Private:
                  MyValue
            Public:
                  Property Type$ {Value} ="Array"
                  Value {
                        =.MyValue
                  }
            Class:
                  Module final Arr (.MyValue) {}
            }
            Class Null {
                 Property Type$ {Value} ="Null"
                 Property Str$ {Value}="null"
                 Value { =0}
            }
            Class JString$ {
            Private:
                  MyValue$=""
            Public:
                  Property Type$ {Value} ="String"
                  Property Str$ {
                        Value{
                              Link parent MyValue$ to MyValue$
                              value$=quote$(string$(MyValue$ as json))
                        }
                  }
                  Value {
                        =.MyValue$
                  }
            Class:
                  Module final JString (.MyValue$) {}
            }
            Class Numeric {
            Private:
                  MyValue$=""
            Public:
                  Property Type$ {Value} ="Number"
                  Property Str$ {
                        Value{
                              Link parent MyValue$ to MyValue$
                              value$=MyValue$
                        }
                  }
                  Value {
                        =Val(.MyValue$)
                  }
            Class:
                  Module final Numeric {
                  If match("S") Then
                        Read .MyValue$
                  Else
                        value$=trim$(str$(Number))
                        ' M2000 return -.3 for -0.35
                        ' using ? str$(MyValue, "0.#############")
                        ' we get locale decimal char - maybe is comma
                        ' so using str$(MyValue) we get integer or float with char "." for decimal always
                        ' so we have to add 0
                        If left$(value$, 1)="." Then
                              value$="0"+value$
                        Else
                               If  value$ ~ "-.*" Then value$=replace$("-.","-0.", value$)
                         End If
                        .Myvalue$<=value$
                  End If
                  }
            }
            Class Boolean {
            Private:
                  MyValue=false
            Public:
                  Property Type$ {Value} ="Boolean"
                  Property Str$ {
                        Value{
                              Link parent MyValue to MyValue
                              If MyValue Then {
                                    value$="true"
                              } Else value$="false"
                        }
                  }
                  Value {
                        =.MyValue
                  }
            Class:
                  Module final Boolean (.MyValue) {}
            }
            Class Object {
            Private:
                  Inventory MyValue
            Public:
                  Property Type$ {Value} ="Object"
                  Value {
                        =.MyValue
                  }
            Class:
                  Module final Object (.MyValue) {}
            }
      \\ Empty group, with $, so we get two vars, Ser and Ser$ ( Ser$ we want to return a value type String)
            Group Ser$
            Module final SetSpace (.ser.space) { ' set space for values - 6 by default
            }
            Function final UseDecimalPoint$ {
                  ' use this to change standard decimal point to local decimal point character
                  =str$(val(letter$),"")
            }
            Function final ReadNumber$ {
                        .Worker false   'modules get caller Stack
                        =.UseDecimalPoint$( Letter$)
            }           
            Function final ReadAnyString$ {
                        \\ read an inventory
                        .Worker false
                        =Letter$
            }
            Function final ReadAny {
                        \\ read an inventory
                        .Worker true
                        Read A
                        =A
            }
            Function final Eval {
                  ' Letter$  pop a string ftom Stack Else give error
                   .func<=Lambda z=.bStream(Letter$) -> {
                         link .char to c
                         ' we can't pass reference in a private member
                         =z(&c)
                   }
                  ' In this Parser we use a dedicated Stack
                  ' for use from recuirsive memberts
                  ' .obj is a pointer to Stack
                  ' we can delete it simply setting a new Stack
                  ' .obj<=Stack 
                  ' or we can flush all elements Using a command Flush
                  ' .obj,  char and .func() are visible from group members
                  ' test
                  Stack .obj { Flush}
                  .char<=0
                  If   .IsContainer()  Then
                        ' we get the pointer
                        =StackItem(.obj)
                        .obj<=Stack
                  Else
                        ' return an Empty object
                        inventory emptinv
                        =.Object(emptinv)
                  End If
            }
            Group StringValue$ {
                  Add=false
                  Del=false
                  ' from revision 12 we can place temp in parameter block
                  Set (temp) {
                        ' always first read is for the assigned value to Group
                        Read temp1
                        If type$(temp)<>"Group" Then error "Need a group"
                        If not valid(temp.type$="") Then error "not a proper group"
                        If not valid(temp1.type$="") Then error "not a proper group for value"
                        ' because Null() is out of this scope we have to link
                        Link parent Null() to MyNull()
                        Null=MyNull()
                        ' or we can hard code the Null object
'                        Group Null {
'                                  Property Type$ {Value} ="Null"
'                                  Property Str$ {Value}="null"
'                                  Value { =0}
'                       }
                        Dim Base 1, A(1)
                        \\ now we get the second interface for arrays
                        \\ bb() has a reference to b (one reference allowed)
                        \\ but b is pointer to array and can change to point to other arrrays
                        \\ we need ths to perform some tasks which belong to standard arrray interface
                        b=(,) : Link b to bb()  
                        A(1)=Group(temp)
                        Do
                              again=false
                              Select Case A(1).type$
                              Case "Array"
                              {
                                    If match("N") Then
                                          Read where
                                          If len(A(1))<=where and Empty Then
                                          ' only the last array we can redimension
                                                If .add and not .del Then
                                                      cursize=Len(A(1))
                                                      b=A(1) ' A(1) has a pointer so now b has the same pointer
                                                      ' dim preserve values
                                                      Dim bb(where+1)  ' need one more because all "automatic arrays" have base 0
                                                      Stock bb(cursize) sweep Len(b)-cursize, Group(Null)
                                                Else
                                                      Error "Index out of limits"+str$(where)
                                                End If
                                          Else
                                                If where<0 Then Error "Index out of limits "+str$(where)
                                          End If
                                          If Empty Then
                                                If .del Then
                                                      cursize=Len(A(1))
                                                      b=A(1) ' A(1) has a pointer so now b has the same pointer
                                                      If where<cursize-1 Then
                                                            Stock bb(where+1) Keep cursize-where, bb(where)
                                                      End If
                                                      Dim bb(cursize-1)   ' bb(0) is an empty array
                                                Else
                                                      Return A(1), where:=Group(temp1)
                                                End If
                                          Else
                                                A(1)=Array(A(1),where)
                                                again=True
                                          End If
                                    Else
                                          Error "No Index Found"
                                    End If
                              }
                              Case "Object"
                              {
                                    If match("S") Then
                                          Read k$
                                          If Exist(A(1), k$)   Then
                                                If Empty Then
                                                      If .del Then
                                                           Delete A(1) , k$
                                                      Else
                                                            Return A(1), k$:=Group(temp1)
                                                      End If
                                                Else
                                                      A(1)=Eval(A(1))  ' Eval(inventory_pointer) return  object pointer
                                                      again=True
                                                End If
                                        Else.if .add and not .del Then
                                                 If Empty Then
                                                            Append A(1), k$:=Group(temp1)
                                                Else
                                                      Error "No such Tag "+k$
                                                End If
                                         Else
                                               Error "No such Tag "+k$
                                         End If
                                    Else
                                          Error "No Tag Found"
                                    End If
                              }
                              End Select
                         until not again
                  }
                  Value (temp) {
                        If type$(temp)<>"Group" Then error "Need a group"
                        If not valid(temp.type$="") Then error "not a proper group"
                        Dim Base 1, A(1)
                        A(1)=Group(temp)
                        Do
                              again=false
                              Select Case A(1).type$ 
                              Case "String", "Number", "Null", "Boolean"
                                    Exit
                              Case "Array"
                              {
                                    If match("N") Then
                                          A(1)=Array(A(1), Number)
                                    Else
                                          Error "No Index Found"
                                    End If
                                    again=True
                              }
                              Case "Object"
                              {
                                    If match("S") Then
                                          If Exist(A(1), Letter$)   Then
                                                A(1)=Eval(A(1))  ' Eval(inventory_pointer) return  object pointer
                                          Else
                                                Error "No such Tag"
                                          End If
                                    Else
                                          Error "No Tag Found"
                                     End If     
                                    again=True
                              }
                              End Select
                        until not again
                         =A(1).str$
                  }
            }
      Class:
      \ one time definitions
            Class CreatSerialize$ {
            Private:
                  usen=0
                  n=0
                  nl1$={
                  }
                  Function final Jarray$ (json1, n){
                        \\ json1 is group type Array
                                 A=json1
                              \\ A is mArray (pointer to Array)
                              nl$=.nl1$
                              If .usen>0 Then
                                    nl$=nl$+string$(" ",  n+.space)
                              End If
                              document a$
                              a$="["
                              If Len(A)>0 Then
                                    If .usen>0 Then a$=nl$
                                     k=each(A)
                                     M=len(A)-1
                                     while k
                                          For This {
                                                \\ temporary group
                                                Temp=array(k)
                                                select Case temp.type$
                                                Case "Number", "Null","Boolean", "String"
                                                a$=temp.str$
                                                Case "Array"
                                                {
                                                      nn=0
                                                      If .usen>0 Then
                                                            nn=n +.space
                                                      End If
                                                      a$=.Jarray$(Temp, nn, "")
                                                }
                                                Case "Object"
                                                {
                                                     nn=0
                                                      If .usen>0 Then
                                                            nn=n +.space
                                                      End If
                                                      a$=.Jobject$(Temp, nn,"")
                                                }
                                                Else Case
                                                      a$=" "+temp.type$
                                                end select
                                                 If k^<M Then
                                                     a$=", "
                                                      If .usen>0 Then a$=nl$
                                                Else
                                                      If .usen>0 Then a$=.nl1$
                                                End If
                                          }
                                    End While
                               Else
                                     If .usen>0 Then  a$=.nl1$
                               End If
                               If .usen>0 Then a$=string$(" ", n)
                        a$="]"
                           =a$+letter$
                  }
                  Function final Jobject$ (json1, n){
                                    json=json1
                                    \\ json has to be an object inventory
                                    nl$=.nl1$
                                    If .usen>0 Then
                                          nl$=nl$+string$(" ",  n+.space)
                                    End If
                                    document a$
                                    a$="{"
                                    If .usen>0 Then a$=nl$
                                     k=each(json)
                                     M=len(json)-1
                                     while k
                                          a$=quote$(eval$(json, k^)) +" : "
                                          select Case json(k^!).type$
                                          Case "Array"
                                          {
                                                nn=0
                                                If .usen>0 Then
                                                      nn=n +.space
                                                End If
                                                a$=.Jarray$(eval(k), nn, "")
                                          }
                                          Case  "Boolean", "Null", "Number", "String"
                                                a$=json(k^!).str$
                                          Case "Object"
                                          {
                                                nn=0
                                                If .usen>0 Then
                                                      nn=n +.space
                                                End If
                                                a$=.Jobject$(eval(k), nn, "")
                                          }
                                          Else Case
                                                a$=" "+json( k^!).type$
                                          end select
                                          If k^<M Then
                                               a$=", "
                                                If .usen>0 Then a$=nl$
                                          Else
                                                If .usen>0 Then a$=.nl1$
                                          End If
                                    End While
                               If .usen>0 Then a$=string$(" ", n)
                              a$="}"
                              =a$+letter$
                  }
                  Class Object {
                  Private:
                        Inventory MyValue
                  Public:
                        Property Type$ {Value} ="Object"
                        Value {
                              =.MyValue
                        }
                  Class:
                        Module final Object (.MyValue) {}
                  }
            Public:
                  space=10
                  Value (json, n) {
                              a$=.nl1$
                              b$=""
                              .usen<=n
                              n--
                              If n<=0 Then  a$="" : n=0 Else b$=string$(" ", n)
                              If type$(json)<>"Group" Then
                                    If type$(json)="Inventory" Then
                                          =b$+.Jobject$(.Object(json),n, a$)
                                    Else.if type$(json)="mArray" Then
                                          =b$+.Jarray$(json, n, a$)
                                    End If
                              Else
                                    If json.type$="Object" Then
                                          =b$+.Jobject$(json, n,a$)
                                    Else.if json.type$="Array" Then
                                          =b$+.Jarray$(json, n, a$)
                                    End If
                              End If
                  }
            }
            Module final ParserClass {
                  \ constructor
                  \ Let work as Push .CreatSerialize$() : Read .Ser
                  \ So now Group Ser loaded from CreatSerialize$()
                  \ Class CreatSerialize$ is a Function final, and because it is after Class:
                  \ Deleted before ParserClass return Group
                  Let .Ser=.CreatSerialize$()
            }
      }
}
MODULE R2 {\\ we can change mid$(), only for this sub
\\ integer has value 3 (as a M2000 read only value)
\\ also control$ is a string read only value
function mid$(a$, x) {
	=string$(a$, x)
}
Module Inside {
	Print mid$("aaa",2), "from inside module"
}
see_work()
inside
print mid$("aaa",2), integer, control$="MAIN"

sub see_work()
	Local integer=10, control$="Hello"
	\\ we can redifine functions, but using New, we make a new one, without erasing an other
	\\ if you change new with global you get error because mid$() defined as local in this module
	\\ so a local function has priority over a global one
	\\ We get error because the local one expect string first, not a number
	function new mid$(x) {
		read x
		=str$(x,"0.00")
	}
	'inside
	Print mid$(10), integer, control$
end sub
}
MODULE FL {\\ Slow,  Fast and Fast !
\\ Normal is Fast
Set Fast !
Rem Try To unhide this line : Test "flowers"
N=Random(!123567)
N=7
Dim Px(N+1), Py(N+1), Pz(N+1)
For i=1 To N {      \\ x.twips and y.twips are the resolution of the displayed form in twips.
      Px(i)=random(50,1100)*15
      Py(i)=random(50, 800)*15
      Pz(i)=random(2,6)*500
}
Dim Dx(100),Dy(100)
For i=0 To 99 {
      Dx(i)=COS(i*36)*150
      Dy(i)=SIN(I*27)*150
}
Let mx=Mouse.X, my=Mouse.Y
Let kk=Pi/5, kkk=kk, mx1=mx, my1=my, nnn=100, m=0
Refresh 1000
Cls #1155AA, 0
j=0
Repeat {
      Cls
      j++
      nnn= nnn Mod 64
      For i=1 To N {      \\ x.twips and y.twips are the resolution of the displayed form in twips.
            Px(i)+=Dx((j+3*i) Mod 100) +mx1-mx
            Py(i)+=Dy((j+i) Mod 100) +my1-my
            Let mx1=mx, my1=my
            Move Px(i),Py(i)
            \\ M2000 have intresting blocks, like the Witdh { } block, to change line width inside it, or Pen {} block to alter pen color,  Path {} block to alter region, area and fill transparency.
            Width 5 {    \\ setting line width
                  Pen #AA6600  {  \\using colors like html hex values
                        nnn+=kk    
                       kkk=Pi-nnn/Pi
                       For q=Pi/8 To 2*Pi-Pi/8 Step Pi/4 {
                              Move Px(i), Py(i)
                             Path #FF66FF, abs(m) { curve angle Pi/3+q-kkk, Pz(i)/6,Pi/4+q-kkk,Pz(i),Pi+q-kkk,Pz(i)*2/3 }
                        }
                        Move Px(i),Py(i)
                        Circle Fill #FFAA20, Pz(i)/3
                  }
            }
            m=Keypress(1)
            If m then {
                  px(i)=Mouse.X
                  py(i)=Mouse.Y
            }
            mx=Mouse.X
            my=Mouse.Y
      }
      Refresh 1000
 }  Until Keypress(2)

Hold   \\ save screen to memory
Move Scale.X/2, Scale.Y/2
def speed(i)=1.45*i
i=8
While i<120 {
      Legend  "Game Over","ARIAL BLACK", speed(i), i/180,2,0
      Refresh 1000
      Wait 30
      release  \\ copy from memory
      i*=1.05
}
SET FAST
CLS
}
MODULE FB {Cls , 0
Report {
	Fibonacci sequence
	
	The Fibonacci sequence is a sequence   Fn   of natural numbers defined recursively: 
				F0 = 0 
				F1 = 1 
				Fn = Fn-1 + Fn-2, if n>1 

	We use a BigNum class to get the first 2000 Fibonacci numbers.

}
Cls, row
Class BigNum {
      a=stack
      Function Digits {
            =len(.a)*14-(14-len(str$(stackitem(.a,len(.a)) ,"")))
      }
      Operator "+" (n) {
            \\ we get a copy, but .a is pointer
             \\ we make a copy, and get a new pointer
            .a<=stack(.a)
           
            acc=0
            carry=0
            const d=100000000000000@
                  k=min.data(Len(.a), len(n.a))
                  i=each(.a, 1,k )
                  j=each(n.a, 1,k)
                  while  i, j {
                        acc=stackitem(i)+stackitem(j)+carry
                        carry= acc div d
                        return .a, i^+1:=acc mod d
                  } 
                  if len(.a)<len(n.a) Then  {
                        i=each(n.a, k+1, -1)
                        while i {
                              acc=stackitem(i)+carry
                              carry= acc div d
                              stack .a  {data acc mod d}
                        }
                  } ELse.if len(.a)>len(n.a) Then  {
                        i=each(.a, k+1, -1)
                        while i {
                              acc=stackitem(i)+carry
                              carry= acc div d
                              Return .a, i^+1:=acc mod d
                              if carry else exit
                        }     
                  }
                  if carry then stack .a { data carry}
      }
      Function tostring$ {
            if len(.a)=0 then ="0" : Exit
            if len(.a)=1 then =str$(Stackitem(.a),"") : Exit
            document buf$=str$(Stackitem(.a, len(.a)),"")
            for i=len(.a)-1 to  1 {
                  Stack .a {
                        buf$=str$(StackItem(i), "00000000000000")
                  }
            }
            =buf$
      }
      class:
      Module BigNum (s$) {
            s$=filter$(s$,"+-.,")
            if s$<>""  Then {
                  repeat {
                        If len(s$)<14 then Stack .a { Data  val(s$) }: Exit
                        Stack .a { Data  val(Right$(s$, 14)) }
                        S$=Left$(S$, len(S$)-14)
                  } Until S$=""
            }
      }
} 

Inventory K=0:=BigNum("0"),1:=BigNum("1")
fib=Lambda K (x as decimal)-> {
      If Exist(K, x) Then =Eval(K) :Exit
      Ret=If(x>1->Lambda(x-1)+Lambda(x-2), bignum(str$(x,"")))
      Append K, x:=Ret
      =Ret
}
Set Fast!
For i=1 to 2000 {
      N=Fib(i)
      Print i
      Print N.tostring$()
      Refresh
}
Set Fast
}
MODULE BN {Dim Mod$(0 to 99), Mul(0 to 9,0 to 9)
for j=0 to 9 : For i=0 to 9:Mod$(i+j*10)=str$(i mod 10,0): Mul(i,j)=i*j : Next i :Next j
profiler
a$="1231231231231231231231231231232132131213130989802139080120931920389"
\\ a$ x n
n1$="1234567767765675576765234324243122131213122113123120898031238910823"
Print val(n1$)*val(a$)
k=0
acc=0
a$=strrev$(a$)
inventory num
rev3$=""
n1=len(n1$)
while n1>0 
n=val(mid$(n1$,n1,1))
n1--
rev2$=string$("0", k)
rev1$=""
k++

if n>0 then
      if not exist(num, n) then
      digit=0&
      For i=1 to len(a$)
      digit+=n*val(mid$(a$,i,1))
      rev1$+=str$(digit mod 10,0)
      digit/=10&
      Next i
      if digit then rev1$+=str$(digit mod 10,0)
            Append num, n:=rev1$
      else
            rev1$=num$(n)
      End if
      rev2$+=rev1$
      if len(rev3$)=0 then
            swap rev2$, rev3$
      else
            swap rev1$, rev3$
            rev3$=""
            if rev2$<rev1$ then swap rev1$, rev2$
            digit=0
            For i=1 to len(rev1$)
            digit+=val(mid$(rev1$, i, 1))+val(mid$(rev2$, i, 1))
            rev3$+=str$(digit mod 10,0)
            digit/=10&
            next i
            if digit>0 then rev3$+=str$(digit mod 10,0)
      end  if
      End if
End While
Print strrev$(rev3$)
print timecount
}
MODULE DI {Function ProDiv$ {
      Read a$, b$, pp
      Let v$="", gg=len(b$), p=pp,  mm=0
      {
            s=len(b$)
            c$=left$(a$,s)
            if c$<b$ then  s++: c$=left$(a$, s) : if s=len(b$) then exit
            d1=val(c$) div val(b$)
            if gg<s-1 then { 
                  if v$="0" then mm=-s+gg
                  v$=v$+string$("0",s-1-gg) 
            }
            v$=v$+str$(d1,"0")
            r$=str$(val(c$)-val(b$)*d1,"0")
            gg=len(r$)
            a$ =r$+mid$(a$,s+1)
            cc=false
            if len(a$)=len(b$) then {
                  if a$>b$ then cc=true
            }  else cc=len(a$)>len(b$) and a$<>"0" 
            if cc else if p=0 then  exit
            if p>0  and not cc then {
                  mm=len(v$)+1
                  a$=a$+string$("0",p) : p=0 
            }
            loop
      }
      \\ scientific notation
      if mm<>0 then {
            if mm>1 then {
                  =Left$(v$,1)+"."+mid$(v$,2,mm-2)+mid$(v$,mm+1)+"E+"+str$(mm-2,"00")
            } else.if mm<0 then {
                  =Mid$(v$,-mm+1,1)+"."+Mid$(v$,-mm+2)+"E-"+str$(abs(mm),"00")
            }
      } else {
            mm=len(v$)
            if mm>1 then {
              =Left$(v$,1)+"."+mid$(v$,2)+"E+"+str$(mm-1,"00")
            } else =V$
      }
}
Def ExpStr$(x)= str$(X,"0.00000000000000000E-00")
a$="57645834674367349573945793457359374512154545412313137868768787874738942834756234896582946937658926582565"
b$="3224241711"
op=Pen
Pen 11{
      Print "Calculation for ";
}
Print a$;~(12);"/";~(op);b$
Print ExpStr$(val(a$)/val(b$))
Print
Print "Expanded:", ProDiv$(a$, b$, 100)
a$="1"
b$="3224241711"
Print
Pen 11 {
      Print "Calculation for ";
}
Print a$;~(12);"/";~(op);b$
Print ExpStr$(val(a$)/val(b$))
Print
Print "Expanded:", ProDiv$(a$, b$, 100)
}
MODULE HU {Module Huffman {
      comp=lambda (a, b) ->{
            =array(a, 0)<array(b, 0)
      }
      module InsertPQ (a, n, &comp) {
            if len(a)=0 then stack a {data n} : exit
            if comp(n, stackitem(a)) then stack a {push n} : exit
             stack a {
                  push n
                  t=2: b=len(a)
                   m=b
                   While t<=b {
                         t1=m
                        m=(b+t) div 2
                        if m=0 then  m=t1 : exit 
                        If comp(stackitem(m),n) then t=m+1:  continue
                        b=m-1
                        m=b
                  }
                  if m>1 then shiftback m
            }
      }
 
      a$="this is an example for huffman encoding"
 
      inventory queue freq
      For i=1 to len(a$)   {
            b$=mid$(a$,i,1)
            if exist(freq, b$) then Return freq, b$:=freq(b$)+1 : continue
            append freq, b$:=1
      }
      sort ascending freq
      b=stack
      K=each(freq)
      LenA=len(a$)
      While k {
            InsertPQ b, (Round(Eval(k)/lenA, 4), eval$(k, k^)), &comp
      }
      While len(b)>1 {
            Stack b {
                 Read m1, m2
                 InsertPQ b, (Array(m1)+Array(m2), (m1, m2) ), &comp
            }
      }
      Print  "Size of stack object (has only the Root):"; len(b)
      Print "Root probability:";Round(Array(Stackitem(b)), 3)
      inventory encode, decode
 
      Traverse(stackitem(b), "")
      message$=""
      For i=1 to len(a$)
      message$+=encode$(mid$(a$, i, 1))
      Next i
 
      Print  message$
      j=1
      check$=""
      For i=1 to len(a$)
            d=each(encode)
            While d {
                  code$=eval$(d)
                  if mid$(message$, j, len(code$))=code$ then {
                        check$+=decode$(code$)
                        Print decode$(code$); : j+=len(code$)
                  }
            }
      Next i
      Print
      Print len(message$);" bits ", if$(a$=check$->"Encoding/decoding worked", "Encoding/Decoding failed")
 
 
      Sub Traverse(a, a$)
            local b=array(a,1)      
            if type$(b)="mArray"  Else {
                  Print  @(10); quote$(array$(a, 1));" "; a$,@(20),array(a)
                  Append decode, a$ :=array$(a, 1)
                  Append encode, array$(a, 1):=a$
                  Exit Sub   
            }
            traverse(array(b), a$+"0")
            traverse(array(b,1), a$+"1")
      End Sub
}
Huffman
 
}
MODULE RE {Module CheckIt {
      declare global ObjRegEx "VBscript.RegExp"
      Function RegEx.Replace$(from$, what$) {
            Method ObjRegEx, "Replace", from$, what$ as response$
            =response$
      }
      Function RegEx.Test(what$) {
            Method ObjRegEx, "Test", what$ as response
            =response
      }
      Print Type$(ObjRegEx)
      With ObjRegEx, "Global", True, "Pattern" as pattern$
      pattern$="Mona Lisa"
      Print RegEx.Test("The Mona Lisa is in the Louvre.")=true
      Print RegEx.Replace$("The Mona Lisa is in the Louvre.", "La Gioconda")
      Pattern$ = " {2,}"
      Print "Myer Ken,  Vice President,  Sales and Services"
      \\ Removing some spaces
      Print RegEx.Replace$("Myer Ken,  Vice President,  Sales and Services", " ")
      pattern$="(\d{3})-(\d{3})-(\d{4})"
 
      Method ObjRegEx, "Execute", "555-123-4567, 555-943-6717" as MyMatches
      Print Type$(MyMatches)  ' it is a IMatchCollection2
      With MyMatches, "Count" as count, "Item" as List$()
      For i=0 to Count-1 : Print List$(i) : Next i
 
 
      Print RegEx.Replace$("555-123-4567, 555-943-6717", "($1) $2-$3")
      Pattern$ = "(\S+), (\S+)"
      Print RegEx.Replace$("Myer, Ken", "$2 $1")
      Method ObjRegEx, "Execute", "Myer, Ken" as MyMatches
      Rem : DisplayFunctions(MyMatches)
      \\ we can use Enumerator
      With MyMatches, "_NewEnum" as New Matches
      Rem : DisplayFunctions(Matches)
      With Matches, "Value" as New item$
      While Matches {
           Print Item$
      }
      \\ Or just using the list$()
      For i=0 to Count-1 : Print List$(i) : Next i
      declare ObjRegEx Nothing
      End
      Sub DisplayFunctions(x)
            Local cc=param(x),  ec=each(cc)
            while ec {
                  Print eval$(ec)   ' print every function/property of object x
            }
      End Sub
}
Checkit
}
MODULE RE1 {Module Internal {
      what$="Mona Lisa"
      Document a$="The Mona Lisa is in the Louvre."
      Find a$, what$
      Read FindWhere
      If FindWhere<>0 then Read parNo, parlocation
      \\ replace in place
      Insert  FindWhere, Len(what$)  a$="La Gioconda"
      Report a$
 
      n$="The Mona Lisa is in the Louvre, not the Mona Lisa"
      Report Replace$("Mona Lisa", "La Gioconda", n$, 1, 1)  ' replace from start only one
      dim a$()
      a$()=Piece$("Myer, Ken",", ")
      Print a$(1)+", "+a$(0)="Ken, Myer"
}
Internal
}
MODULE RO {Module RankLanguages {
      Const Part1$="<a href="+""""+ "/wiki/Category", Part2$="member"
      Const langHttp$="http://rosettacode.org/wiki/Category:Programming_Languages"
      Const categoriesHttp$="http://www.rosettacode.org/mw/index.php?title=Special:Categories&limit=5000"
      Def long m, i,j, tasks, counter, limit, T, t1
      Def string LastLang$, job$
 
      Document final$, languages$, categories$
      httpGet$=lambda$  (url$, timeout=1000)->{
            Declare htmldoc "Msxml2.ServerXMLHTTP"
            With htmldoc , "readyState" as ready
            Report "Download:"+url$
            Method htmldoc "open","get", url$, True
            Method htmldoc "send"
            Profiler
            While Ready<>4 {
                  Wait 20
                  Print Over format$("Wait: {0:3} sec", timecount/1000)
                  If timecount>timeout then Exit
            }
            If ready=4 Then  With  htmldoc, "responseText" as ready$ : =ready$
            Declare htmldoc Nothing
            print
      }
 
      languages$=httpGet$(langHttp$, 30000)
      If Doc.Len(languages$)=0 then  Error "File download failed (languages)"
 
      Inventory Lang
 
      m=Paragraph(languages$, 0) 
      If Forward(languages$,m) then {
            While m {
                  job$=Paragraph$(languages$,(m))
                  If Instr(job$, part1$) Else Continue
                  i = Instr(job$, "</a>")
                  If i Else Continue   ' same as If i=0 Then Continue
                  j = i
                   i=Rinstr(job$, ">", -i)
                  If i Else Continue
                  LastLang$=MID$(job$, i+1, j-i-1)
                  if Instr(job$, "Category:"+lastlang$) then Append lang, lastlang$:=0  :  Print Over format$("Languages: {0}", len(lang))
            }
      }
      Print
      Document categories$=httpGet$(categoriesHttp$, 30000)
      If Doc.Len(categories$)=0 then  Error "File download failed (categories)"
      limit=Doc.Par(categories$)
      If limit<Len(Lang) then Error "Invalid data"
      Refresh
      set slow
      m=Paragraph(categories$, 0) 
      counter=0
      If Forward(categories$,m) then {
            While m {
                  job$=Paragraph$(categories$,(m))
                  counter++
                  Print Over format$("{0:2:-6}%", counter/limit*100)
                  i=Instr(job$, part2$) 
                  If  i Else Continue          
                  i=Rinstr(job$, "(", -i)
                  If  i Else Continue
                  tasks=Val(Filter$(Mid$(job$, i+1),","))
                  If tasks Else Continue
                  i=Rinstr(job$, "<", -i)
                  If i Else Continue
                  j = i
                  i=Rinstr(job$, ">", -i)
                  If i Else Continue
                  LastLang$=MID$(job$, i+1, j-i-1)
                  If Exist(Lang, LastLang$) Then {
                         Return Lang, LastLang$:=Lang(LastLang$)+tasks
                  }
            }
      }
      Print
      \\ this type of iventory can get same keys
      \\ also has stable sort
      Report "Make Inventory list by Task"
      Inventory queue ByTask
      t1=Len(Lang)
      T=Each(Lang)
      While T {
            Append ByTask, Eval(T):=Eval$(T!)
            Print Over format$("Complete: {0} of {1}", T^+1, t1 )
      }
      Print
      Report "Sort by task (stable sort, sort keys as numbers)"
      Sort descending ByTask as number
      Report "Make List"
      T=Each(ByTask)
      final$="Sample output on "+Date$(Today, 1033, "long date")+{:
 
      }
      While T {
            final$=format$("rank:{0::-4}. {1:-5} entries - {2}", T^+1, Eval$(T!), Eval$(T))+{
            }
      }
      Report "Copy to Clipboard"
      clipboard final$
      \\ present to console with 3/4 fill lines then stop for space bar or mouse click to continue
      Report final$     
}
RankLanguages
}
MODULE CE {a$="THIS IS MY TEXT TO ENCODE WITH CAESAR CIPHER"
Function Cipher$(a$, N) {
      If Len(a$)=0 Then Exit
      a$=Ucase$(a$)
      N=N mod 25 +1
      \\ Integer in Mem is unsigned number
      Buffer Mem as Integer*Len(a$)
      Return Mem, 0:=a$
      For i=0 to Len(a$)-1 {
            If Eval(mem, i)>=65 and Eval(mem, i)<=90 then Return Mem, i:=(Eval(mem, i)-65+N) mod 26+65
       }
       =Eval$(Mem)
}
B$=Cipher$(a$, 12)
Print B$
Print Cipher$(B$,12)
}
MODULE CO {Module Check {
      \\ we use an internal object for Math functions (here for Atan2)
      Declare Math Math
      Const tau=2*Pi, Center=2
      \\ change console size,  and center it ( using ;) to current monitor      
      Window 12, 800*twipsX,600*twipsY;
      \\ actual size maybe less (so can fit text exactly)
      Double  ' Double height characters
      Report Center, "Color wheel"
      Normal  ' restore to normal
      Atan2=Lambda Math (a, b) ->{
            Method Math, "Atan2", a, b As ret
            =ret
      }
      \\ brightness=1 for this program
      hsb2rgb=Lambda (hue, sat) ->{
            If sat == 0 Then {
                = 255, 255, 255
           } Else {
                  h=frac(hue+1)*6
                  f = frac(h)  
                  p = Int((1-sat)*255 + 0.5)
                  q = Int((1-sat*f)*255 + 0.5)
                  t = Int((1-sat*(1-f))*255 + 0.5)
                  Select Case Int(h)
                  Case 1
                      = q, 255, p
                  Case 2
                      = p, 255, t
                  Case 3
                     = p, q, 255
                  Case 4
                      = t, p, 255
                  Case 5
                      = 255, p, q
                  Else Case
                      = 255, t, p
                  End Select
          }
      }
      Let OffsetX=X.twips/2-128*TwipsX, OffsetY=Y.twips/2-128*TwipsY
      \\ a pixel has a size of TwipsX x TwipsY
      OffsetX=(OffsetX div TwipsX)*TwipsX
      OffsetY=(OffsetY div TwipsY)*TwipsY
      \\ We set hsb2rgb, OffsetX, OffsetY as closures to PrintPixel
      \\ We send to stack the R G B values using Stack ! array
      \\ hsb2rgb() return an array of values
      \\ we pop these values using Number
      PrintPixel = Lambda  hsb2rgb, OffsetX, OffsetY (x,y, theta, sat)  -> {
            Stack ! hsb2rgb(theta,sat)  
            PSet Color(number, number, number), x*TwipsX+offsetX, y*TwipsY+offsetY
      }
      \\ set Atan2, tau as closures to HueCircle
      \\ we can rotate/flip the wheel by changing signs in Atan2() and
      \\ by changing order of arguments (dx,dy) or (dy,dx). 8 combinations
      HueCircle= Lambda Atan2, tau (PrintPixel) -> {
            Let  c_width=256, c_height=256
            Let  cx=c_width/2, cy=c_height/2
            Let  radius=If(cx<=cy->cx, cy)
            c_width--
            c_height--
            dy=-cy
            For y=0 To c_height {
                  dy++ : dy2=dy*dy : dx=-cx
                  For x=0 To c_width {
                        dx++ : dist=Sqrt(dx^2+dy2)
                        If dist>radius Then continue
                        Call PrintPixel(x,y, Atan2(dx, -dy)/tau, dist/radius)
                  }
            }
      }
      Call HueCircle(PrintPixel)
      Scr$=""  ' we use this string  to load an image
      Move 0,0
      \\ scale.x, scale.y are twips height and width, of current layer
      Copy scale.x, scale.y to Scr$
      Clipboard Scr$  ' save window to clipboard
}
Check
a$=KEY$
\\ CALL INFO NOW \\ DELETE THIS LINE IF INFO NOT EXIST IN MODULE'S LIST
INFO
}
MODULE SH {hide
wait 100
Desktop  ' copy dedcktop to background
BackGround {
	img$=""
	move 0,0
	copy scale.x, scale.y to img$
}
wait 1000
show
Title "Shift Console"
cx=pos
cy=row
Escape off
x=motion.x
y=motion.y
t=1000/25
for i=1 to 200 step 5
motion x+i*twipsy, y+i*twipsx
wait t
Next i
wait 1000
motion x, y
Escape on
Form  ' cut border
x=motion.xw
y=motion.yw
t=1000/25
for i=1 to 200 step 5
motion.w x+i*twipsy, y+i*twipsx
wait t
Next i
wait 1000
motion.w x, y
Bmp$=""
Move 0,0
Copy scale.x, scale.y to Bmp$
form ;    ' clear screan and restore border
image bmp$
refresh
cursor cx,cy
Move scale.x/2, scale.y/2
Image img$, scale.x/3
sprite img$,5 ,45,30,40
clipboard img$
Title "Shift Console.. complete"
}
MODULE GR {\\ Gray Code
Module GrayCode {
      Function bin$(a) {
            a$=""
            do {
                  n= a mod 2
                  a$=if$(n=1->"1", "0")+a$
                  a=a div 2
            } until a==0
            =a$
      }
      Function GrayEncode(a) {
            =binary.xor(a, binary.shift(a,-1))
      }
      Function GrayDecode(a) {
            b=0
            do {b=binary.xor(a, b) : a=binary.shift(a,-1) } until a=0
            =b
      }
      For i=0 to 32 {
            g=GrayEncode(i)
            b=GrayDecode(g)
            Print format$("{0::-2} {1:-6} {2:-6} {3:-6} {4::-2}", i, bin$(i), bin$(g), bin$(b), b)
      }
}
GrayCode
}
MODULE AC {\\ M2000 Interpreter
\\ accumulator factory
foo=lambda acc=0 (n as double=0) -> {
      if n=0 then =acc : exit 
      acc+=n
      =lambda n=acc (x) -> {
            \\ x has no type here, can be any numeric type (also can be an object too)       
            \\ accumulator is double, and is a closure (a copy of n in foo)
            n+=x
            \\ any variable in M2000 hold  first type
            \\ if x is an object then we get error, except if object use this operator
            x=n
            \\ so we return x type
            =x
      }
}
x=foo(1)
call void x(5)
call void foo(3)   ' void tell to interpreter to throw result
print x(2.3) ' prints 8.3
print foo()=4

}
MODULE TR {\\ goto no_random_mode
m=random(700,1100)/1000
mode 8, scale.x*m, scale.y*m

no_random_mode:
\\ Version 2 we make the drawing to scale based to height
let sc=scale.y/14000, yoffset=100
mode 11*scale.y/14000
Escape Off
Flush
Global alfa=60*4
\\ check for linux (there is no smooth function, we can give the command but we get not the proper results)
if not iswine then Smooth On  \\ use Gdi+
Cls 5,0
Pen 14
Gradient 5,1

\\ set refresh to 1500 msec
Refresh 1500 
\\ temporary we use double heigt characters
Double
Report 2, {Example three oscilloscopes},8000*sc
Normal
Gosub put_a_title
Gosub define_module_b
Gosub make_classes

Triangle=drw(4000*sc,2500*sc+yoffset)
Tk=Display(8000*sc,500*sc+yoffset,8000*sc,4000*sc,45, sc)
b 2000*sc,3, &Triangle.a(), 0
Hexagon=drw(4000*sc,6750*sc+yoffset)
Hk=Display(8000*sc,4750*sc+yoffset,8000*sc,4000*sc,15, sc)
b 2000*sc,6, &Hexagon.a(), 0
My_Circle=drw(4000*sc,11000*sc+yoffset)
Ck=Display(8000*sc,9000*sc+yoffset,8000*sc,4000*sc,30, sc)
b 2000*sc,alfa div 2, &My_Circle.a(), 0
flash=true
introtime=0
timeinterval=600
Dim Fcol(-1 to 0)
Fcol(-1)=#ff3322, #773300
thread {
	flash~
	introtime++
	if flash then
		timeinterval*=.9
		Thread this interval timeinterval
	else 
		Thread this interval 200
	end if
} as t1 interval timeinterval
Hold
i=0
k=1
tipstop=8000*sc
Every 10 { 
      Pen 15 {
            Refresh 1500
            Release  ' we get the background using Hold.
            if t1>0  then Print.Info(flash) : if introtime>50  then Thread t1 Erase : t1=0        

            Triangle.draw_to (i+alfa/6) mod alfa
                  Draw to tipstop, pos.y
                  Tk.tip
                       
            Hexagon.draw_to (i+alfa/12) mod alfa
                  Draw to tipstop, pos.y
                  Hk.tip
                       
            My_Circle.draw_to i
                  Draw to tipstop, pos.y
                  Ck.tip
            If keypress(1) Then
                  k++
            Else.If keypress(2) Then
                  k--
            End If
            i+=k
            i=i mod# alfa
      }
      If inkey$<>"" Then Exit
}
Threads Erase
Escape off
\\ call info again
Keyboard "info"+chr$(13)
smooth off
Exit
put_a_title:
      Move -320*sc, scale.y
      Path { 
          legend "Μ2000","Arial Black", 90*sc,pi/2,0,0,100 
      } ;
      Move -320*sc, scale.y-10000*sc
      Fill 2000*sc, 10000*sc, #775566, #221133,1,1
      Path { } ;
Return
define_module_b:
Module b {
      Read a, n, &ar(), cir
      Dim ar(alfa,2)
      z=pi/2
      km=0
      x=pos.x
      y=pos.y
      If cir Then Circle a
      g=n/2
      kk=alfa/n
      Step Angle -(pi/2+pi/n),a
      b=(x-pos.x)*2/kk
      d=Abs(y-pos.y)
      Step Angle -(pi/2+pi/n),-a
      If cir Then If d>0 Then Circle d
      Step Angle -(pi/2+pi/n)+z,a
      Step Angle 0,0
      For i=0 to 2*pi Step pi/g
            x1=pos.x
            y1=pos.y
            For L=1 to kk
                  Move x1, y1
                  Draw Angle i+z, b*L
                  ar(km,0)=pos.x
                  ar(km,1)=pos.y
                  km++ 
                  km=km mod alfa
                  If cir Then Circle Fill 11,30,1,11
            Next L
      Next i
      Step Angle -(pi/2+pi/n)+z,-a
}
Return
make_classes:
Class drw {
      Dim a(0)
      x, y
      Module drw {
            Read .x, .y
            Move .x, .y
      }
      Module draw_to {
            If Match("N") Then
                  Read i
                  i=Abs(int(i)) mod alfa
                  Move .x,.y
                  Draw to .a(i,0), .a(i,1)
            Else
                  For i=0 to alfa-1
                        Move .x,.y
                        Draw to .a(i,0), .a(i,1)
                  Next i
            End If
      }
}
Class Display {
      x, y, wi, he, stp, tp=-1
      dscr$, counter, sc
      Module Display {
            Read .x,.y,.wi,.he, .stp, .sc
            .y-=30
            .he+=60
            .tp<=1
            x1=pos.x
            y1=pos.y
            Move .x, .y
            Fill .wi, .he, 1,7
            Move .x+100, .y+.he-100
            Pen 11 {
                  Legend "Osc 2000", "Verdana", 8,pi/2,0,0
            }
            Move x1, y1
      }
      Module Tip {
            If .tp=-1 Then Exit
            tp1=pos.y
            If .dscr$<>"" Then { copy .x+.stp, .y use .dscr$ } Else .tp=tp1
            .counter++
            If .counter mod (alfa div 4)=1 Then Move .x+.stp/2, .y : Width 1,3 { Draw 0 ,.he,14 } 
            Move .x, tp1
            Draw to .x+.stp, .tp
            .tp<=tp1
            Move .x,.y
            copy .wi-.stp/2, .he To .dscr$
            Move .x, .y+.he/2
            Pen 14 { Draw .wi }
            Move .x+.wi/2,.y+200
            Pen 12 {
                  Legend Format$("Oscilloscope: {0}sec 10x",str$(.counter/10,"000000.0")), "Lucida Console", 11*.sc, 0, 2, 1, 20
            }
      }
}
Return
Sub Print.Info(x)
	Cursor 0,12
	Pen Fcol(x) {
		Report 2, {
			Press
			Keyboard
			any key - exit
			Mouse buttons
			left - Acc. left
			right - Acc. right
			}, 3000*sc   \\ width 
	}
End Sub
}
MODULE HT {text alfa.html {
<!doctype html>
<html>
<head>
<title>Hello There</title>
<meta name="GENERATOR" content="M2000">
<meta name="FORMATTER" content="M2000">
<meta content="this, other, that" name=keywords>
<meta content=All name=robots> 
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1253">
<meta NAME="Author" CONTENT="GEORGE KARRAS">
<style type="text/css">
body {
    overflow:hidden;
}
</style>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#800080" alink="#ff0000" >
<h2>My First JavaScript</h2>

<button type="button"
onclick="document.getElementById('demo').innerHTML = Date()">
Click me to display Date and Time.</button>

<p id="demo"></p>

</body>
}
browser "alfa.html",motion.xw+motion.x,motion.yw+motion.y, scale.x,6000
Print {click, and pres Esc, or use statement Browser ""}
}
MODULE KB {Function CallMe {
     \\  Fkey Clear  - not used
      \\ Keyboard - can play two or more notes at once
      \\ some keybards can play max 6 notes, some other max 4
            refresh 5000
      Thread.Plan Sequential
      Play 0 \\ clear music threads
          
      dim note1$(10,3), note2$(10,3)
      FillArray()
      \\Form ! 60,30      
      back$=""
      \\ hold previous screen, then draw new one, then copy to back$, then release the old one
      \\ then call FadeInScreen passing a dummy function as call back, to use the Back$
      hold
      Refresh 5000
      Move 0,0
      Pen 14
      Gradient 5,5
      Cursor 0,0
      Double
      Report 2, "Keyboard 005"   
      Normal
      Report 2,{Menu
      1-Exit  3-Xylophone 4-Piano 5-Saxophone  8-Show Keys/Notes 9-Rythm Yes 0-Rythm No
      
      Space bar - set higher the volume for each note
      -- George Karras --
      
      }
      Global kb$=" ", dur=300, org=5, f=0, vol$="V90", voi(18), use(17) ' 0 ..17,
      n=1
      For i=1 to 16 { use(i)=True }
      use(10)= false \\ For drum machine
      \\ compute virtual clavie position
      mm=2*(scale.x div 14)
      mm2= mm div 2
      kk=scale.y/5
      kk1=scale.y/4
      gram=scale.y/20
      '      Scroll Split -Height/2
      DisplayNoRefresh(mm, kk, mm2, kk1)
      Move 0,0
      Copy scale.x, scale.y to back$
      start.at=scale.x*.9
      Function Dummy1 {
            move start.at, 0
            Image back$
            start.at-=scale.x/10
            if start.at<0 then start.at=0
      }
      Function Dummy0 {
            move 0, 0
            Image back$
      }
      Release
       if random(10)<6 then
            FadeInScreen2 Lazy$(&Dummy1()),1.3
      else
            FadeInScreen Lazy$(&Dummy0()),1.3
      end if
      call local Dummy0()
      refresh 5000
      Scroll Split  Height/2+1
      Cursor 0, Height/2+1
      Module ClKey {
            Read a$, press, sel
            If press Then {
            If Instr(kb$,a$+"-")>0 Then Exit
            Next()
            voi(sel)=f
            Print a$, f
            Score f, dur, a$+vol$ : kb$<=kb$+a$+"-": Play f, org
            } else {
                  kb$<=Replace$(a$+"-","", kb$)
                  If voi(sel)>0 Then {
                   Play voi(sel), 0 
                   use(voi(sel))~
                   voi(sel)=0
                   }
            }
            Sub Next()
            Local i
            For i=1 to 16 {
                  If use(i) Then Exit
            }
            If i<17 Then { f<=i : use(i)~ } else f<=1: use(1)=True : Print "!!!!!!!!"
            End Sub
      }
      \\ 10 for drum machine
      Thread { Score 10,400,"CV90CC  ab Cd eCC" : Play 10,1 } as L Interval 60
      Thread {
            ClKey "A#2", KeyPress(asc("A")), 1
            ClKey "B2", KeyPress(asc("Z")), 2
            ClKey "C3", KeyPress(asc("X")), 3
            ClKey "C#3", KeyPress(asc("D")), 4
            ClKey "D3", KeyPress(asc("C")), 5
            ClKey "D#3", KeyPress(asc("F")), 6
            ClKey "E3", KeyPress(asc("V")), 7
            ClKey "F3", KeyPress(asc("B")), 8
            ClKey "F#3", KeyPress(asc("H")), 9
            ClKey "G3", KeyPress(asc("N")), 10
            ClKey "G#3", KeyPress(asc("J")), 11
            ClKey "A3", KeyPress(asc("M")), 12
            ClKey "A#3", KeyPress(asc("K")), 13
            \\ https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
            ClKey "B3", KeyPress(0xBC), 14 \\ VK_OEM_COMMA
            ClKey "C4", KeyPress(0xBE), 15 \\ VK_OEM_PERIOD
            ClKey "C#4", KeyPress(0xBA), 16 \\ VK_OEM_1
            ClKey "D4", KeyPress(0xBF), 17 \\VK_OEM_2  
      } as al Interval 50
      Print "οκ"
      Threads
      Thread L Interval 6000
      Main.Task 10 {
            Display(mm, kk, mm2, kk1)
            Refresh 1000
            If KeyPress(asc("1")) Then Exit
            If KeyPress(asc("3")) Then org<=14 : dur<=100 
            If KeyPress(asc("4")) Then org<=5 : dur<=300
            If KeyPress(asc("5")) Then org<=65 : dur<=5000
            If KeyPress(asc("8")) Then n=1-n
            If KeyPress(asc("9")) Then Thread L Restart
            If KeyPress(asc("0")) Then Thread L Hold
            If KeyPress(32) Then { vol$ <= "V127"  } else vol$ <=if$(dur=300->"V100", "V110")
            Print "--------"
      }
      Threads Erase
      Print "End"
      \\ delete this line
      \\Keyboard "Info"+chr$(13)
      Scroll Split  0
     
      Exit
      Sub DisplayNoRefresh(p0,y0, p1, y1)
            Clavie(p0, y0, p1, y1, 0, &note1$())
            Clavie(p0-p1/2,y0,p1,y1*2/3, -1, &note2$())
      End Sub
      Sub Display(p0,y0, p1, y1)
            Clavie(p0, y0, p1, y1, 0, &note1$())
            Clavie(p0-p1/2,y0,p1,y1*2/3, -1, &note2$())
            Refresh 1000
      End Sub
      Sub Clavie(p0, y0,p1, y1, p3, &n$())
            Link n$() to n()
            p3-!
            Local k=-1, i
            For i=p0 to 9*p1+p0 step p1
            k++
            If n$(k,0)<>"" Then {
                  Move i+p3*p1/6, y0
                  If p3 Then {
                        Fill p1-p3*p1/3-15,y1-15, 7* (1-(voi(n(k,2))>0))+1, 0,1
                  } else {
                        Fill p1-15,y1-15,15,7* (1-(voi(n(k,2))=0))+1,1
                  }
                  Move i+p3*p1/6, y0
                  Fill @ p1-p3*p1/3,y1,2,1
                  Move i+p3*p1/6, y0+y1-gram
                  Pen p3*15 { Fill @ p1-p3*p1/3,gram,5,n$(k,n)}
            }
            Next i
      End Sub
      Sub FillArray()
      Local n,p, n$, k$, no
      Stack New {
            Data "A#2", "A", 1, 1, 2
            Data "B2", "Z", 2, 1, 1
            Data "C3", "X", 3, 2, 1
            Data "C#3", "D", 4, 3, 2
            Data "D3", "C", 5, 3, 1
            Data "D#3", "F", 6, 4, 2
            Data "E3", "V", 7, 4, 1
            Data "F3", "B", 8, 5, 1
            Data "F#3", "H", 9, 6, 2
            Data "G3", "N", 10, 6, 1
            Data "G#3", "J", 11, 7, 2
            Data "A3", "M", 12, 7, 1
            Data "A#3", "K", 13, 8, 2
            Data "B3", ",", 14, 8, 1
            Data "C4", ".", 15, 9, 1
            Data "C#4",";", 16 , 10, 2
            Data "D4", "/", 17, 10, 1 
            While Not Empty {
            Read n$, k$, no, n, p
                  If p=1 Then {
                      note1$(n-1,0):= n$, k$, no  \\ feed a row
                  } else {
                        note2$(n-1,0):= n$, k$, no
                  }
            }
      }
      End Sub
}
Inline code LibFade
FadeScreen Lazy$(&CallMe()), 1.7
}
MODULE AU {Declare form1 Form
Declare combo1 combobox Form form1
Declare text1 textbox Form form1
With form1,"Title" As title$
With combo1,"Edit", True,"UseOnlyTheList", false,"autocomplete", True, "listIndex" As ListIndex,"ShowAlways", True
With combo1,"label","Combo1", "ListText" As item$, "list" As list$(), "text" As combo1$
item$={alfa
            delta
            gamma
            beta
            }
With combo1,"Find" As Find()
Method combo1,"Sort"
combo1$=list$(find("gam*"))

Method combo1,"Move", 1000,1000,6000,600
Method text1, "Move", 1000,2900,6000,600

With text1, "left" As left, "text" As text1.text$ , "ShowAlways", True
Print left
Method form1, "show"
Method text1,"GetFocus"
Function form1.unload {
      Keyboard "!"
      show
}
Function combo1.dblclick {
        text1.text$=combo1$
        title$=combo1$
        If find(title$)= -1 Then {
            Method combo1,"additem",title$
            Method combo1,"Sort"
            listindex=find(title$)
      }
}
Function combo1.click {
      If listindex>=0 Then text1.text$=list$(listindex)
}
Function combo1.scroll {
      If listindex>=0 Then text1.text$=list$(listindex)
}
a$=key$
Declare Text1 nothing
Declare combo1 nothing
Declare form1 nothing
}
MODULE ICO {\\$ ..........\appdata\roaming\m2000\m2000png.png
Binary {
      iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA+vAAAP
      1wExQtGTAAAADXRFWHRDb21tZW50ACSZhQMALhdS/QAAAUZJREFUeJzFlosNwyAM
      RNl/A2bJcK6S1MT4D5QUdCpSif04O7QFyn/nOYDK2ZjaNwVwHMclHlgkhVu/hGkA
      QIJpSS2tQpT74dIArMS12uKOeBIAeOKuDMpJr0SrigDAsbwB4KzsE9h3VVl7AFiG
      EGCXA2cCLEPKAX56zQm+NwNgufCKA14ZOgcyp9UccnsA/DJsd4ACaC6oPWCd1uoR
      D+C5KOSl1GRZS9cWUKU5NAcCNYDaB1vRHADQIOFjjr4xOgAckQNGcmxgqhBiGAB8
      AA7zKgAmxhB7AJQS0EROiD0OxKeUPWIDOLIcGAGQEDMAigMRBO2LHnoUoNNTtQiC
      VnatBNcaCgdAiJFSCAAPgt/h/C2Yh6A/CqrN8u7WADgEB7HBCEAEIffZtdauZB2C
      AWSndxNqYxOADZGu/yxAtmfS/wf+AYExPhJPvgsIMdG8AAAAAElFTkSuQmCC
} As ico
read com
if com=1 then 
	Move 0,0
	Image ico, scale.x/width*2  ' (twips/character)
else
	push ico
end if


}
MODULE ICONS {function dummy {
	if isWine then sp=10 : r=30 else sp=40 : r=60
	Escape off
	Def a,b,c
	call ico, 2
	read ico
	\\gradient 5,0
	\\ call global
	Fade 5, 0
	useM200sprites=random(1,2)=1
	move scale.x/2, scale.y/2
	legend str$(sp,0)+If$(useM200sprites->" M2000"," GDI+")+{ Sprites
	rotating,resizing
	changing opacity
	}, "Arial Black", 22,0,2,1,150
	hold
	Wait 500
	mouse.icon hide
	n=0
	p=false
	if useM200sprites then
		spr$=""
		image ico (5) to spr$    ' use 5 (magenta) as transparent color
		every 1000/r {
			release
			if p then 
			move mouse.x, mouse.y
			sprite spr$,5,n-29,200,50
			hold
			p=false
			end if
			
			For i=1 to sp {
				move Random(14000)+1000, Random(10000)+1000
				let  a=random(90), b=random(50)+150, c=random(50)-50*(random(10)=1)
				sprite spr$,5, a,b,c
			}
			move mouse.x, mouse.y
			sprite spr$,5,n,200
			n+=29
			refresh 1500
			if keypress(2) then exit
			p= keypress(1)
		}
	else
		Set Fast !
		every 1000/r {
			release
			if p then 
			move mouse.x, mouse.y
			sprite ico,,n-29,200,50
			hold
			p=false
			end if
			
			For i=1 to sp {
				move Random(14000)+1000, Random(10000)+1000
				let  a=random(90), b=random(50)+150, c=random(50)-50*(random(10)=1)
				sprite ico, , a,b,c
			}
			move mouse.x, mouse.y
			sprite ico,,n,200
			n+=29
			if keypress(2) then exit
			p= keypress(1)
			refresh 1500

		}
		Set Fast
	end if
	release
	all$=""
	move 0,0
	copy scale.x, scale.y to all$
	mouse.icon show
	If Ask("Save the file","icons","Save it","No", all$)=1 then
	Menu  ' erase menu list
	files + "screen*.bmp"
	copy "screen"+str$(menuitems+1,"000")+".bmp"
	End if
	Refresh 30
	cls,0
	
	\\ In console M2000 has no events, except for this:,  an old variant of Menu can get the finish event in a global menu.
	\\ so giving the globalmenu Menu statement open the menu end leave it there to be used in a loop or something.
	Menu
	Menu title "MOVE ME" 
	Menu fill #F377FF, 7, 0
	files + "screen*.bmp"
	if menuitems=0 then exit
	global ex=false, loadnow=0
	Module Global globalmenu {
	\\ unhide this to exit menu if get a double click
	\\	ex<=true  \\ we can use this to exit on double click or enter.
		if menu=0 then ex<=true : Print "You press Esc" else loadnow<=menu
	}
	Print @(0,0), "Select Image or End:";
	Menu @ "globalmenu" !
	wait 200
	menu1=0
	do {
		wait 100
		refresh
		if keypress(2) or ex then exit
		menu1=menu
		if menu1=0 then continue
	\\ using this line we open one if double click or press enter
	Rem	if  loadnow=0 then continue
	\\using this we get response also as we move the menu caret
	 	if loadnow=0 then loadnow<=menu1
		move 0,0
		image menu$(loadnow), scale.x
		Print @(0,0), "Image:";menu$(loadnow)
		loadnow<=0
	} always
	Menu
	Escape On
}
Inline Code LibFade
function dummy1 {
	gradient 1, 5
	a$=key$
}
FadeScreen &Dummy(), 1.7
}
MODULE COMPILER {Module CompilerExample {
	Set Fast !
	Module lexical_analyzer (a$){
	        lim=Len(a$)
	        LineNo=1
	        ColumnNo=1
	        Document Output$
	        Buffer Scanner as Integer*lim
	        Return Scanner, 0:=a$
	        offset=0
	        buffer1$=""
	        flag_rem=true
	        Ahead=lambda Scanner (a$, offset)->{
	                =false
	                Try {
	                        \\ second parameter is the offset in buffer units
	                        \\ third parameter is length in bytes
	                        =Eval$(Scanner, offset,2*len(a$))=a$
	                }
	        }
	        Ahead2=lambda Scanner (a$, offset)->{
	                =false
	                Try {
	                        =Eval$(Scanner, offset,2) ~ a$
	                }
	        }
	        const nl$=chr$(13)+chr$(10), quo$="""", er$="@", Ansi=3
	        Try {
	                Do
	                If Ahead("/*", offset) Then {
	                        offset+=2 :     ColumnNo+=2
	                        While not Ahead("*/", offset)
	                                If Ahead(nl$, offset) Then
	                                        lineNo++: ColumnNo=1 : offset+=2
	                                Else
	                                        offset++ : ColumnNo++
	                                End If
	                                if offset>lim then
	                                        Error "End-of-file in comment. Closing comment characters not found"+er$
	                                End if
	                        End While
	                        offset+=2 : ColumnNo+=2
	                } Else.if Ahead(nl$, offset) Then{
	                        LineNo++: ColumnNo=1
	                        offset+=2
	                } Else.if Ahead(quo$, offset) Then {
	                        Output$=format$("{0::-10}{1::-10} ", LineNo, ColumnNo)
	                        offset++ : ColumnNo++
	                        strin=offset
	                        While not Ahead(quo$, offset)
	                                If Ahead("/", offset) Then
	                                        offset+=2 : ColumnNo+=2
	                                else
	                                        offset++ : ColumnNo++
	                                End if
	                                checkerror()
	                        End While
	                        Output$="String "+quote$(Eval$(Scanner, strin, (offset-strin)*2))+nl$
	                        offset++ : ColumnNo++
	                } Else.if Ahead("'", offset) Then {
	                        Output$=format$("{0::-10}{1::-10} ", LineNo, ColumnNo)
	                        offset++ : ColumnNo++
	                        strin=offset
	                        While not Ahead("'", offset)
	                                If Ahead("/", offset) Then
	                                        offset+=2 : ColumnNo+=2
	                                else
	                                        offset++ : ColumnNo++
	                                End if
	                                checkerror()
	                        End While
	                        lit$=format$(Eval$(Scanner, strin, (offset-strin)*2))
	                        select case len(lit$)
	                        case 1
	                                Output$="Integer "+str$(asc(lit$),0)+nl$
	                        case >1
	                                {Error "Multi-character constant."+er$}
	                        case 0
	                                {Error "Empty character constant."+er$}
	                        end select
	                        offset++ : ColumnNo++
	                } Else.if Ahead2("[a-z]", offset) Then {
	                        strin=offset
	                        Output$=format$("{0::-10}{1::-10} ", LineNo, ColumnNo)
	                        offset++ : ColumnNo++
	                        While Ahead2("[a-zA-Z0-9_]", offset)
	                                        offset++ : ColumnNo++
	                        End While
	                        Keywords(Eval$(Scanner, strin, (offset-strin)*2))
	                } Else.if Ahead2("[0-9]", offset) Then {
	                        strin=offset
	                        Output$=format$("{0::-10}{1::-10} Integer ", LineNo, ColumnNo)
	                        offset++ : ColumnNo++
	                        While Ahead2("[0-9]", offset)
	                                        offset++ : ColumnNo++
	                        End While
	                        if Ahead2("[a-zA-Z_]", offset) then  
	                                {Error " Invalid number. Starts like a number, but ends in non-numeric characters."+er$}
	                        else
	                                Output$=Eval$(Scanner, strin, (offset-strin)*2)+nl$
	                        end if
	                } Else {
	                        Symbols(Eval$(Scanner, Offset, 2))              
	                        offset++ : ColumnNo++
	                }
	                Until offset>=lim
	        }
	        er1$=leftpart$(error$,er$)
	        if er1$<>"" then
	                Print
	                Report "Error:"+er1$
	                Output$="(Error)"+nl$+"Error:"+er1$
	        else
	                Output$=format$("{0::-10}{1::-10}", LineNo, ColumnNo)+" End_of_Input"+nl$
	        end if
	        Push Output$
	        Exit
	        Clipboard Output$
	        Save.Doc Output$, "lex.t", Ansi
	        document lex$
	        Load.Doc lex$,"lex.t", Ansi
	        Report lex$
 
	        Sub Keywords(a$)
	                select case a$
	                case "if"
	                        a$="Keyword_if"
	                case "else"
	                        a$="Keyword_else"
	                case "while"
	                        a$="Keyword_while"
	                case "print"
	                        a$="Keyword_print"
	                case "putc"
	                        a$="Keyword_putc"
	                else case
	                        a$="Identifier "+a$
	                end select
	                Output$=a$+nl$
	        End sub
	        Sub Symbols(a$)
	                select case a$
	                case " ", chr$(9)
	                        a$=""
	                case "("
	                        a$="LeftParen"
	                case ")"
	                        a$="RightParen"
	                case "{"
	                        a$="LeftBrace"
	                case "}"
	                        a$="RightBrace"
	                case ";"
	                        a$="Semicolon"
	                case ","
	                        a$="Comma"
	                case "*"
	                        a$="Op_multiply"
	                case "/"
	                        a$="Op_divide"
	                case "+"
	                        a$="Op_add"
	                case "-"
	                        a$="Op_subtract"
	                case "%"
	                        a$="Op_mod"
	                case "<"
	                {       if Ahead("=", offset+1) Then
	                                offset++
	                                a$="Op_lessequal"
	                                ColumnNo++
	                        else
	                                a$="Op_less"
	                        end if
	                }
	                case ">"
	                {       if Ahead("=", offset+1) Then
	                                offset++
	                                ColumnNo++
	                                a$="Op_greaterequal"
	                        else
	                                a$="Op_greater"
	                        end if
	                }
	                case "="
	                {       if Ahead("=", offset+1) Then
	                                offset++
	                                ColumnNo++
	                                a$="Op_equal"
	                        else
	                                a$="Op_assign"
	                        end if
	                }
	                case "!"
	                {       if Ahead("=", offset+1) Then
	                                offset++
	                                ColumnNo++
	                                a$="Op_notequal"
	                        else
	                                a$="Op_not"
	                        end if
	                }
	                case "&"
	                {       if Ahead("&", offset+1) Then
	                                offset++
	                                ColumnNo++
	                                a$="Op_and"
	                        else
	                                a$=""
	                        end if
	                }
	                case "|"
	                {       if Ahead("|", offset+1) Then
	                                offset++
	                                ColumnNo++
	                                a$="Op_or"
	                        else
	                                a$=""
	                        end if
	                }
	                else case
	                        {Error "Unrecognized character."+er$}
	                end select
	                if a$<>"" then
	                Output$=format$("{0::-10}{1::-10} ", LineNo, ColumnNo)+a$+nl$
	                end if
	        End Sub
	        Sub checkerror()
	                if offset>lim then {
	                        Error "End-of-line while scanning string literal. Closing string character not found before end-of-line."+er$
	                } else.if  Ahead(nl$,offset) then {
	                        Error "End-of-file while scanning string literal. Closing string character not found."+er$
	                }
	        End Sub
	}
	Module syntax_analyzer (b$){
	        enum tokens {
	                Op_add, Op_subtract, Op_not=5, Op_multiply=10, Op_divide, Op_mod, 
	                Op_negate,  Op_less, Op_lessequal, Op_greater, Op_greaterequal,
	                Op_equal, Op_notequal, Op_and, Op_or, Op_assign=100, Keyword_if=110,
	                Keyword_else, Keyword_while, Keyword_print, Keyword_putc, LeftParen, RightParen,
	                LeftBrace, RightBrace, Semicolon, Comma, Identifier, Integer, String, End_of_input
	        }
 
	        Inventory precedence=Op_multiply:=13, Op_divide:=13, Op_mod:=13, Op_add:=12, Op_subtract:=12
	        Append  precedence, Op_negate:=14, Op_not:=14, Op_less:=10, Op_lessequal:=10, Op_greater:=10 
	        Append  precedence, Op_greaterequal:=10, Op_equal:=9, Op_notequal:=9, Op_assign:=-1, Op_and:=5
	        Append  precedence, Op_or:=4
 
	        Inventory symbols=Op_multiply:="Multiply", Op_divide:="Divide", Op_mod:="Mod", Op_add:="Add"
	        Append  symbols, Op_negate:="Negate", Op_not:="Not", Op_less:="Less", Op_subtract:="Subtract"
	        Append  symbols, Op_lessequal:="LessEqual", Op_greater:="Greater", Op_greaterequal:="GreaterEqual"
	        Append  symbols, Op_equal:="Equal", Op_notequal:="NotEqual",  Op_and:="And", Op_or:="Or" 
 
	        def lineNo, ColumnNo, m, line$, a, lim, cur=-1
	        const nl$=chr$(13)+chr$(10), Ansi=3
	        Dim lex$()
	        lex$()=piece$(b$,chr$(13)+chr$(10)) 
	        lim=dimension(lex$(),1)-1
	        op=End_of_input
	        flush
	        k=0
	        Try {
	                push (,)   ' Null
	                getone(&op)
	                repeat
	                stmt(&op)
	                shift 2  ' swap two top items
	                push ("Sequence", array, array)
	                k++
	                until op=End_of_Input
	        }
	        er$=error$
	        if er$<>"" then print er$ : flush: break
	        Print "Ast"
	        Document Output$
	        prt_ast()
	        Push Output$
	        exit
	        clipboard Output$
	        Save.Doc Output$, "parse.t", Ansi
	        document parse$
	        Load.Doc parse$,"parse.t", Ansi
	        Report parse$
 
	        sub prt_ast(t)
	                if len(t)<1 then
	                        Output$=";"+nl$
	                else.if len(t)=3 then
	                        Output$=t#val$(0) +nl$
	                        prt_ast(t#val(1)) : prt_ast(t#val(2))
	                else
	                        Output$=t#val$(0) +nl$
	                end if
	        end sub
	        sub expr(p)   ' only a number
	                local x=(,), prev=op
	                if  op>=Identifier then
	                        x=(line$,)
	                        getone(&op)
	                else.if op=LeftParen then
	                        paren_exp()
	                        x=array
	                else.if op<10 then
	                        getone(&op)
	                        expr(precedence(int(Op_negate)))
	                        read local y
	                        if prev=Op_add then
	                                x=y
	                        else
	                                if prev=Op_subtract then prev=Op_negate
	                                x=(symbols(prev), y,(,))
	                        End if
	                else
	                         {error "??? "+eval$(op)}
	                end if
	                local prec
	                while exist(precedence, int(op))
	                        prev=op : prec=eval(precedence)
	                        if prec<14 and prec>=p else exit
	                        getone(&op)
	                        expr(prec+1)  ' all operators are left associative (use prec for right a.)
	                        x=(symbols(int(prev)), x, array)
	                End While
	                Push x
	        end sub
	        sub paren_exp()
	                expected(LeftParen)
	                getone(&op)
	                expr(0)
	                expected(RightParen)
	                getone(&op)
	        end sub
	        sub stmt(&op)
	                local t=(,)
	                if op=Identifier then
	                        t=(line$)
	                        getone(&op)
	                        expected(Op_assign)
	                        getone(&op) 
	                        expr(0)
	                        read local rightnode
	                        Push ("Assign",t,rightnode)
	                        expected(Semicolon)
	                        getone(&op)
	                else.if op=Semicolon then
	                        getone(&op)
	                        Push (";",)
	                else.if op=Keyword_print then
	                        getone(&op)
	                        expected(LeftParen)
	                        repeat
	                                getone(&op)
	                                if op=String then
	                                        Push ("Prts",(line$,),(,))
	                                        getone(&op)
	                                else
	                                        expr(0)
	                                        Push ("Prti", array,(,))
	                                end if
	                                t=("Sequence", t, array)
	                        until op<>Comma
	                        expected(RightParen)
	                        getone(&op)
	                        expected(Semicolon)
	                        getone(&op)
	                        push t
	                else.if op=Keyword_while then
	                        getone(&op)
	                        paren_exp()
	                        stmt(&op)
	                        shift 2
	                        Push ("While",array, array)
	                else.if op=Keyword_if then
	                        getone(&op)
	                        paren_exp()
	                        stmt(&op)
	                        local s2=(,)
	                        if op=Keyword_else then
	                                getone(&op)
	                                stmt(&op)
	                                read s2
	                        end if
	                        shift 2
	                        Push ("If",array ,("If",array,s2))
	                else.if op=Keyword_putc then
	                        getone(&op)
	                        paren_exp()
	                        Push ("Prtc",array,t)
	                        expected(Semicolon)
	                        getone(&op)
	                else.if op=LeftBrace then
	                        Brace()
	                else
	                        error "Unkown Op"       
	                end if
	        end sub
	        Sub Brace()
	                        getone(&op)
	                        while op<>RightBrace and op<>End_of_input
	                                stmt(&op)
	                                t=("Sequence", t, array)
	                        end while
	                        expected(RightBrace)
	                        getone(&op)
	                        push t
	        End Sub
	        Sub expected(what)
	                if not op=what then {Error "Expected "+eval$(what)+str$(LineNo)+","+Str$(ColumnNo)}
	        End Sub
	        sub getone(&op)
	                op=End_of_input
	                while cur<lim
	                cur++
	                line$=trim$(lex$(cur))
	                if line$<>"" then exit
	                end while
	                if cur=lim then exit sub
	                LineNo=Val(line$,"int",m)
	                line$=mid$(line$, m)
	                ColumnNo=Val(line$,"int",m)
	                line$=trim$(mid$(line$, m))
	                Rem : Print LineNo, ColumnNo
	                m=instr(line$," ")
	                if m>0 then op=Eval("."+leftpart$(line$, " ")) else op=Eval("."+line$)
	        end sub
	}
	Module CodeGenerator (s$){
	        Function code$(op$) {
	                =format$("{0::-6} {1}", pc, op$)
	                pc++
	        }
	        Function code2$(op$, n$) {
	                =format$("{0::-6} {1} {2}", pc, op$, n$)
	                pc+=5
	        }
	        Function code3$(op$,pc, st, ed) {
	                =format$("{0::-6} {1} ({2}) {3}", pc, op$, ed-st-1, ed)
	        }
 
	        Enum tok {
	                gneg, gnot, gmul, gdiv, gmod, gadd, gle, gsub, glt
	                gle, ggt, gge, geq, gne, gand, gor, gprtc, gprti, gprts,
	                gif, gwhile, gAssign, gSeq, gstring, gidentifier, gint, gnone
	        }
 
	        \\ Inventories are lists with keys, or keys/data (key must be unique)
	        \\ there is one type more the Invetory Queue which get same keys.
	        \\ But here not used.
	        Inventory symb="Multiply":=gmul, "Divide":=gdiv, "Mod":=gmod, "Add":=gadd
	        Append  symb, "Negate":=gneg, "Not":=gnot,"Less":=glt,"Subtract":=gsub
	        Append  symb, "LessEqual":=gle, "Greater":=ggt, "GreaterEqual":=gge, "Sequence":=gSeq
	        Append  symb, "Equal":=geq, "NotEqual":=gne,  "And":=gand, "Or":=gor, "While":=gwhile
	        Append  symb, "Prtc":=gprtc,"Prti":=gprti,"Prts":=gprts, "Assign":=gAssign, "If":=gif
	        Append  symb, "String":=gstring, "Identifier":=gidentifier, "Integer":=gint, ";", gnone
 
	        Inventory DataSet
	        \\ We set string as key. key maybe an empty string, a string or a number.
	        \\ so we want eash string to saved one time only.
	        Inventory Strings
 
	        Const nl$=chr$(13)+chr$(10), Ansi=3
	        Def z$, lim, line$, newvar_ok, i=0
	        Document message$=nl$
	        Global pc     \\ functions have own scope, so we make it global, for this module, and childs.
 
	        Dim lines$()
	        s$=filter$(s$,chr$(9))   \\ exclude tabs
	        Lines$()=piece$(s$,nl$) \\ break to lines
	        lim=len(Lines$())
	        Flush ' empty stack (there is a current stack of values which we use here)
 
	        Load_Ast()
	        If not stack.size=1 Then Flush : Error "Ast not loaded"
	        AST=array   \\ pop the array from stack
	        Document Assembly$, Header$
 
	        \\ all lines of assembly goes to stack. Maybe not in right order.
	        \\ Push statement push to top, Data statement push to bottom of stack
 
	        CodeGenerator(Ast)
	        Data  code$("halt") ' append to end of stack
	        \\ So now we get all data (letters) from stack
	        While not empty
	                Assembly$=letter$+nl$
	        end while
	        \\ So now we have to place them in order
	        Sort Assembly$
 
	        \\ Let's make the header
	        Header$=format$("Datasize: {0} Strings: {1}", Len(Dataset),Len(strings))
	        \\ we use an iterator object, str^ is the counter, readonly, but Eval$() use it from object.
	        str=each(strings)    
	        While str
	                Header$=nl$+Eval$(str)
	        End while
	        Assembly$=nl$
	        \\ insert to line 1 the Header
	        Insert 1 Assembly$=Header$
	        \\ Also we check for warnings
	        If len(message$)>2 then Assembly$="Warnings: "+nl$+message$
	        \\ So now we get a report
	        \\ (at each 3/4 of window's lines, the printing stop and wait for user response, any key)
	        Push Assembly$
	        Exit
	        Report Assembly$
	        Clipboard Assembly$
	        Save.Doc Assembly$, "code.t", Ansi
	        End
	        \\ subs have 10000 limit for recursion but can be extended to 1000000 or more.
	        Sub CodeGenerator(t)
 
	                If len(t)=3 then
	                        select case  t#val(0)
	                        Case gSeq
	                                CodeGenerator(t#val(1)) : CodeGenerator(t#val(2))
	                        Case gwhile
	                        {
	                                local spc=pc
	                                CodeGenerator(t#val(1)) 
	                                local pc1=pc
	                                pc+=5 ' room for jz
	                                CodeGenerator(t#val(2))
	                                data code3$("jz",pc1, pc1, pc+5)
	                                data code3$("jmp",pc,  pc, spc)
	                                pc+=5  ' room for jmp
	                        }
	                        Case gif
	                        {
	                                CodeGenerator(t#val(1)) 
	                                local pc1=pc, pc2
	                                pc+=5
	                                CodeGenerator(t#val(2)#val(1)) 
	                                If len(t#val(2)#val(2))>0 then
	                                        pc2=pc
	                                        pc+=5
	                                        data code3$("jz",pc1, pc1, pc)
	                                        CodeGenerator(t#val(2)#val(2))
	                                        data code3$("jmp",pc2, pc2, pc)
	                                else
	                                        data code3$("jz",pc1, pc1, pc)
	                                end If          
	                        }
	                        Case gAssign
	                        {
	                                CodeGenerator(t#val(2))
	                                local newvar_ok=true
	                                CodeGenerator(t#val(1))
	                        }
	                        case gneg to gnot, gprtc to gprts
	                                CodeGenerator(t#val(1)) : data code$(mid$(eval$(t#val(0)),2))
	                        case gmul to gor
	                        {
	                                CodeGenerator(t#val(1))
	                                CodeGenerator(t#val(2))
	                                data code$(mid$(eval$(t#val(0)),2))
	                        }
	                        End select
	                Else.if len(t)=2 then
	                        select case  t#val(0)
	                        Case gString
	                        {
	                                local spos
	                                If exist(strings,t#val$(1)) then
	                                        spos=eval(strings!)
	                                else
	                                        append strings, t#val$(1)               
	                                        spos=len(strings)-1
	                                end If
	                                Push code2$("push",str$(spos,0))
	                        }
	                        Case gInt
	                                Push code2$("push",t#val$(1), pc)
	                        Case gIdentifier
	                        {
	                                local ipos
	                                If exist(dataset,t#val$(1)) then
	                                        ipos=Eval(dataset!)  ' return position
	                                else.if newvar_ok then
	                                        Append dataset, t#val$(1)
	                                        ipos=len(dataset)-1
	                                else
	                                        message$="Variable "+t#val$(1)+" not initialized"+nl$
 
	                                end If
	                                If newvar_ok then
	                                        Push code2$("store","["+str$(ipos, 0)+"]")
	                                else
	                                        Push code2$("fetch","["+str$(ipos, 0)+"]")
	                                end If
	                        }
	                        end select
	                End If
	        End Sub
	        Sub Load_Ast()
	                        If i>=lim then Push (,) : exit sub
	                        do
	                        line$=Trim$(lines$(i))
	                        I++
	                        tok$=piece$(line$," ")(0)
	                        until line$<>"" or i>=lim
	                        If tok$="Identifier" then
	                                Push (gidentifier,trim$(Mid$(line$,11)))
	                        else.if tok$="Integer" then
	                                long n=Val(Mid$(line$,8))  ' check overflow
	                                Push (gint, Trim$(Mid$(line$,8)))
	                        else.if tok$="String" then
	                                Push (gstring,Trim$(Mid$(line$,7)))
	                        else.if tok$=";" then
	                                Push (,)
	                        Else
	                                local otok=symb(tok$)
	                                Load_Ast() 
	                                Load_Ast()
	                                Shift 2
	                                Push (otok,array, array)
	                        End If
	        End Sub
	}
	Module Virtual_Machine_Interpreter (a$){
		\\ function to extract string, replacing escape codes.
		Function GetString$(a$) {
			s=instr(a$, chr$(34))
			m=rinstr(a$,chr$(34))-s
			if m>1 then
				\\ process escape codes
				=format$(mid$(a$, s+1, m-1))
			else
				=""
			end if
		}
 		const nl$=chr$(13)+chr$(10)
		\\ we can set starting value to any number  n where 0<=n<=232
		enum op {	halt_=232, add_, sub_, mul_, div_, mod_, not_, neg_, and_, or_, lt_,
			    	gt_, le_, ge_, ne_, eq_, prts_, prti_, prtc_, store_, fetch_, push_,
				jmp_, jz_
	    	}
	     	exit_now=false
		Inventory  func=halt_:=lambda->{exit_now=true}
		Append  func, push_:=lambda->{sp--:return stack_, sp:=eval(code_, pc as long):pc+=4}
		Append  func, jz_:=lambda->{
			sp++: if eval(stack_, sp-1)=0 then pc=eval(code_, pc as long) else pc+=4
		}
		Append  func, jmp_:=lambda->{pc=eval(code_, pc as long)}
		Append  func, fetch_:=lambda->{sp--:Return stack_, sp:=eval(stack_, eval(code_, pc as long)):pc+=4}
		Append  func, store_:=lambda->{Return stack_, eval(code_, pc as long):=eval(stack_, sp):sp++:pc+=4}
		Append  func, add_:=lambda->{Return stack_, sp+1:=uint(sint(eval(stack_, sp+1))+sint(eval(stack_, sp))):sp++}
		Append  func, sub_:=lambda->{Return stack_, sp+1:=uint(sint(eval(stack_, sp+1))-sint(eval(stack_, sp))):sp++}
		Append  func, mul_:=lambda->{Return stack_, sp+1:=uint(sint(eval(stack_, sp+1))*sint(eval(stack_, sp))):sp++}
		Append  func, div_:=lambda->{Return stack_, sp+1:=uint(sint(eval(stack_, sp+1)) div sint(eval(stack_, sp))):sp++}
		Append  func, mod_:=lambda->{Return stack_, sp+1:=uint(sint(eval(stack_, sp+1)) mod sint(eval(stack_, sp))) :sp++}
		Append  func, not_:=lambda->{Return stack_, sp:=if(eval(stack_, sp)=0->uint(-1),0)}
		Append  func, neg_:=lambda->{Return stack_, sp:=uint(-sint(eval(stack_, sp)))}
		Append  func, and_:=lambda->{Return stack_, sp+1:=binary.and(eval(stack_, sp+1),eval(stack_, sp)):sp++	}
		Append  func, or_:=lambda->{Return stack_, sp+1:=binary.or(eval(stack_, sp+1),eval(stack_, sp)):sp++	}
		Append  func, lt_:=lambda->{Return stack_, sp+1:=uint(if(sint(eval(stack_, sp+1))<sint(eval(stack_, sp))->-1, 0)):sp++}
		Append  func, gt_:=lambda->{Return stack_, sp+1:=uint(if(sint(eval(stack_, sp+1))>sint(eval(stack_, sp))->-1, 0)):sp++}
		Append  func, le_:=lambda->{Return stack_, sp+1:=uint(if(sint(eval(stack_, sp+1))<=sint(eval(stack_, sp))->-1, 0)):sp++}
		Append  func, ge_:=lambda->{Return stack_, sp+1:=uint(if(sint(eval(stack_, sp+1))>=sint(eval(stack_, sp))->-1, 0)):sp++}
		Append  func, ne_:=lambda->{Return stack_, sp+1:=uint(if(eval(stack_, sp+1)<>eval(stack_, sp)->-1, 0)):sp++}
		Append  func, eq_:=lambda->{Return stack_, sp+1:=uint(if(eval(stack_, sp+1)=eval(stack_, sp)->-1, 0)):sp++}
		Append  func, prts_:=lambda->{Print #-2, string$(eval(stack_,sp));: Refresh:sp++}
		Append  func, prti_:=lambda->{Print #-2, str$(sint(eval(stack_,sp)),0);: Refresh:sp++}
		Append  func, prtc_:=lambda->{Print #-2, chrcode$(eval(stack_,sp));: Refresh:sp++}
		Rem : Form 120, 60 ' change console width X height to run Ascii Mandlebrot example
		\\ change Report with Print #-2,   (report stop when scrolling 3/4 of height of console, waiting key or mouse key to continue)
		Print #-2,  "Virtual Assembly Code:"+{
		}+a$
		Print "Prepare Byte Code"
 
		\\ get datasize
		a$=rightpart$(a$, "Datasize:")
		m=0
		data_size=val(a$, "int", m)
		a$=mid$(a$, m)
		\\ make stack
		if data_size>0 then Buffer Clear stack_ as long*data_size
		\\ dim or redim buffer append 1000 long as is.
		Buffer stack_ as long*(1000+data_size)
		\\ get strings
		a$=rightpart$(a$, "Strings:")
		m=0
		strings=val(a$, "int", m)
		a$=rightpart$(a$, nl$)
 
		if strings>0 then
			Dim strings$(strings)
			for i=0 to strings-1
				strings$(i)=GetString$(leftpart$(a$, nl$))
				a$=rightpart$(a$, nl$)
			Next i
		End if
		buffer clear code_ as byte*1000
		do
			m=0
			offset=val(a$,"int", m)
			if m<0 then exit
			a$=mid$(a$,m)
			line$=trim$(leftpart$(a$,nl$))
			if line$="" then line$=trim$(a$) else a$=trim$(rightpart$(a$, nl$))
			op$=if$(instr(line$," ")>0->leftpart$(line$," "), line$)
			if not valid(eval(op$+"_")) then exit
			opc=eval(op$+"_")
			Return code_, offset:=opc
			if opc>=store_ then
				line$=rightpart$(line$," ")
				select case opc
				case store_, fetch_
					Return code_, offset+1:=val(rightpart$(leftpart$(line$,"]"),"[")) as long : offset+=4
				case push_
					Return code_, offset+1:=uint(val(line$)) as long : offset+=4
				case jz_, jmp_
					Return code_, offset+1:=val(rightpart$(line$,")")) as long : offset+=4
				end select 
			end if
		Always
		Print "Press any key" : Push key$ : Drop
		\\ Prepare VM
		let pc=0, sp=len(stack_) div 4
		do
			b=func(eval(code_, pc))
			pc++
			call local b()
		until exit_now
		Print "done"
	}
	Push {
	{
	        /*
	        This is an integer ascii Mandelbrot generator
	        */
	        left_edge= -420;
	        right_edge=300;
	        top_edge=300;
	        bottom_edge = -300;
	        x_step=7;
	        y_step=15;
 
	        max_iter=200;
 
	        y0 = top_edge;
	        while (y0 > bottom_edge) {
	                x0 = left_edge;
	                while (x0 < right_edge) {
	                        y = 0;
	                        x = 0;
	                        the_char = ' ';
	                        i = 0;
	                        while (i < max_iter) {
	                                x_x = (x * x) / 200;
	                                y_y = (y * y) / 200;
	                                if (x_x + y_y > 800 ) {
	                                        the_char = '0' + i;
	                                        if (i > 9) {
	                                                the_char = '@';
	                                        }
	                                        i = max_iter;
	                                }
	                                y = x * y / 100 + y0;
	                                x = x_x - y_y + x0;
	                                i = i + 1;
	                        }
	                        putc(the_char);
	                        x0 = x0 + x_step;
	                }
	                putc('\n');
	                y0 = y0 - y_step;
	        }
	}
	} 
 
	Form ! 120, 60
	Refresh
	Print "Lexical Analyzer" : Refresh
	lexical_analyzer
	Print "Syntaxl Analyzer" : Refresh
	syntax_analyzer
	Print "Code Generator" : Refresh
	CodeGenerator
	Virtual_Machine_Interpreter
	Set Fast 'restore speed setting
}
CompilerExample
}
MODULE CC {move scale.x/2, scale.y/2
legend "This is centered", "Arial", 22,pi/6,2 , 0 , 300
}
MODULE FADE {Read X, Y
Module FadeScreen (&Paint(), tempo) {
      tempo=abs(tempo)
      move 0,0 
      if tempo==0 or tempo<1.3 then tempo=2
      Function GetBack2Buffer  {
            def b$
            def pic(x)=(x div twipsx)*twipsx
            copy pic(scale.x), pic(scale.y) to b$
            move pic(scale.x) div 2, pic(scale.y) div 2
            =image(b$)  ' return Buffer
      }
      Img1=GetBack2Buffer()
      refresh 200
      i=100
      Call Paint()
      Hold
      Repeat {
            Release
            sprite Img1,,,,i-1,1
            refresh 100
            wait (100-i) div 40
            i-=i / tempo
      } until i<1
}
Function PaintBack {
      Gradient X, Y
}

FadeScreen Lazy$(&PaintBack()), 1.7

}
MODULE LIBFADE {Module FadeScreen (&Paint(), tempo) {
      tempo=abs(tempo)
      move 0,0 
      if tempo==0 or tempo<1.3 then tempo=2
      Function GetBack2Buffer  {
            def b$
            def pic(x)=(x div twipsx)*twipsx
            copy pic(scale.x), pic(scale.y) to b$
            move pic(scale.x) div 2, pic(scale.y) div 2
            =image(b$)  ' return Buffer
      }
      Img1=GetBack2Buffer()
      refresh 200
      i=100
      t$=""
      oldrow=row      
      Call Paint()
      move scale.x/2, scale.y/2
      Hold
      Repeat {
            Release
            sprite Img1,1,,,101-i-1,1
            refresh 100
            wait (100-i) div 40
            i-=i / tempo
      } until i<1
      sprite img1
      cls ,oldrow-1
      scroll split 0  ' no split
      
}
Module FadeInScreen (&Paint(), tempo) {
      tempo=abs(tempo)
      move 0,0 
      if tempo==0 or tempo<1.2 then tempo=2
      Function GetBack2Buffer  {
            def b$
            def pic(x)=(x div twipsx)*twipsx
            copy pic(scale.x), pic(scale.y) to b$
            move pic(scale.x) div 2, pic(scale.y) div 2
            =image(b$)  ' return Buffer
      }
      Img1=GetBack2Buffer()
      refresh 200
      i=100
      Call Paint()
      move scale.x/2, scale.y/2
      Hold
      Repeat {
            Release
            sprite Img1,,,,i-1,1
            refresh 100
            wait (100-i) div 40
            i-=i / tempo/2
      } until i<1
}
Module FadeInScreen2 (&Paint(), tempo) {
      tempo=abs(tempo)
      move 0,0 
      if tempo==0 or tempo<1.2 then tempo=2
      Function GetBack2Buffer  {
            def b$
            def pic(x)=(x div twipsx)*twipsx
            copy pic(scale.x), pic(scale.y) to b$
            move pic(scale.x) div 2, pic(scale.y) div 2
            =image(b$)  ' return Buffer
      }
      Img1=GetBack2Buffer()
      release
      refresh 2000
      i=400
      Repeat {
            Call Paint()
            move scale.x/2, scale.y/2
            sprite Img1,,,,min.data(i-1,100),1
            refresh 1000
            wait (100-i) div 40
            i-=i / tempo/4
      } until i<1
}
}
MODULE PP {function dummy {
	ro=row
	p
	cls 5, row-1
	Pen 14
}
Inline Code LibFade
FadeScreen &Dummy(), 1.7
}
MODULE COMP {\\ compose lambda functions
\\ We can put closures (as copy of values, or copy of pointers if a variable is a pointer)

\\ In M2000, there are: Values, Pointers, Refereneces.  Pointers hold Objects. Values maybe objects too. References are just names with no own value or poiner, but refer to another variable
\\ We can use reference to array items, with an internal copy in copy out, method. First interpreter make a hidden variable, copy the item to that variable, then pass the variable to function or module by reference, and at return copy back the variable to the array item (checking if it can be done, maybe the array has change). We can't pass values to references, except of a string. A reference passed as week reference, a string with the a proper name for the variable, to stack of values (as a value), so a Read statement which has & before a name, search for a string, and then resolve it or not. If not raise error. We can read the string (the weakr reference) and read it any other time (a copy of it), if we know that this variable exist. Also there are "string pointer"

\\Arrays can passed by reference without copy in copy out (by using a weak reference too)

X=10
k$=weak$(x)
k$.++
Print Eval(k$.)=11
Print x=11
Dim a(10)=100
k$=Weak$(a(5))
k$.++
Print Eval(k$.)=101
Print a(5)=101

Module ByRefArrItemOrVariable(&x) {
	x++
}
ByRefArrItemOrVariable &a(5)
Print a(5)=102
\\ we can add space between name and parameter list
Module ByRefArray1 (&b()) {
	b(5)++
}

ByRefArray1 &a()
Print a(5)=103


\\ we can send the pointer (array is an object)
\\ Interpreter know that we wish to use the pointer, because we choose a name without parenthesis

Module ByRefArray2 (b) {
	Return b, 5:=Array(b,5)+1
	link  b to a()
	a(5)++
}

ByRefArray2 a()
Print a(5)=105

Function ByCopyArray(b()) {
	For i=Dimension(b(), 1,0) to Dimension(b(), 1,1)
		b(i)+=1
	Next i
	=b()
}
Print Dimension(a(), 1,0), Dimension(a(), 1,1)
Dim z()
z()=ByCopyArray(a())
Print z()

\\ We can pass an expression for late evalution:
x=10 
z=3
Module DoSomething(&s()) {
	Print s()
}
DoSomething Lazy$(x**z)   'return 1000
function dummy {
	x++
	=x**z
}
DoSomething Lazy$(&dummy())   'return 1331

function dummy2 {
	Read New k
	x++
	=x**z+k
}
a$=Lazy$(&dummy2())   'return 1331
\\ so now expression is function body in a$
\\ Unremark this to see the definition of function
Rem : Report a$
Module DoSomething2(&s()) {
	Print s(100)
}
DoSomething2 a$
Print Function(a$, 200)


\\ Normally a function can be passed by reference
\\ the reference is the actual code
Def OneLine(X)=X**2+5*x+6
DoSomething2 &OnelIne()    ' 10506
\\ for groups including the reference of group
Group {
	x=100
	Function InGroup {
		
	}
	
}

Module CheckFirst {
      RAD = lambda -> number/180*pi
      ASIN = lambda RAD -> {
          Read x : x=Round(x,10)
            If x>=0 and X<1 Then {
                  =RAD(abs(2*Round(ATN(x/(1+SQRT(1-x**2))))))
            } Else.if x==1 Then {
                  =RAD(90)
            } Else error "asin exit limit"
      }
      ACOS=lambda ASIN (x) -> PI/2 - ASIN(x)
      POW3 = Lambda ->number**3
      POW3INV =Lambda ->number**(1/3)
      COSRAD =lambda ->Cos(number*180/pi)
      SINRAD=lambda ->Sin(number*180/pi)
      Composed=lambda (f1, f2) -> {
            =lambda f1, f2 (x)->{
                  =f1(f2(x))
            }
      }
      Dim Base 0, A(3), B(3), C(3)
      A(0)=ACOS, ASIN, POW3INV
      B(0)=COSRAD, SINRAD, POW3
      C(0)=Composed(ACOS, COSRAD), Composed(ASIN, SINRAD), Composed(POW3INV, POW3)
      Print $("0.00")
      For i=0 To 2 {
            Print A(i)(B(i)(.5)), C(i)(.5)
      }
            Print $("")
}
CheckFirst
 
}
MODULE COMP2 {Dim A(10)=1000, Z()
Function b(m) {
	link m to c()
	c(3)=10
	=m
}
z()=b(a())
Print z(3), a(3)

}
MODULE CL {Class zz {
      module bb {
            Superclass A {
                  unique:
                  counter
            }
            Superclass B1 {
                  unique:
                  counter
            }
            Superclass B2 {
                  unique:
                  counter
            }
            \\ We can make a group Alfa with a member, another group Beta
            \\ Group Beta can't see parent group, but can see own member groups
            \\ Group Alfa can see everything in nested groups, in any level,
            \\ but can't see inside modules/functions/operator/value/set
            Group Alfa {
                  Group Beta { }
            }
            Alfa=A
            Alfa.Beta=B1
            \\ we make 3 groups for marshaling counters
            \\ each group get a superclass
            Marshal1=A
            Marshal2=B1
            Marshal3=B2
            \\ Now we want to add functionality7
            \\ Inc module to add 1 to counter
            \\ a Value function to return counter
            \\ Without Value a group return a copy
            \\ If a group has a value then we can get copy using Group(nameofgroup)
            \\ just delete Group Marshal1 and remove Rem when we make Marshal1 using a class function
            Group Marshal1 {
                  Module Inc {
                        For SuperClass {.counter++}
                  }
                  Value {
                        For SuperClass {=.counter}
                  }
            }
            Class AnyMarshal {
                  Module Inc {
                        For SuperClass {.counter++}
                  }
                  Value {
                        For SuperClass {=.counter}
                  }
            }
            \\ here we merge groups
            Rem : Marshal1=AnyMarshal()
            Marshal2=AnyMarshal()
            Marshal3=AnyMarshal()
 
            \\ So now we see counters (three zero)
            Print Marshal1, Marshal2, Marshal3 \\ 0, 0, 0
            \\ Now we prepare Alfa and Alfa.Beta groups
            Group Alfa {
                  Group Beta {
                        Function SuperClass.Counter {
                              For SuperClass {
                                    =.counter
                              }           
                        }      
                  }
                  Module PrintData {
                        For SuperClass {
                              Print .counter, This.Beta.SuperClass.Counter()
                        }
                  }
            }
            \\ some marshaling to counters
            Marshal1.inc
            Marshal2.inc
            Marshal2.inc
            Marshal3.inc
            \\ lets print results
            Print Marshal1, Marshal2, Marshal3 \\ 1   2   1
            \\ Calling Alfa.PrintData
            Alfa.PrintData  \\ 1   2
            \\ Merging a group in a group make a change to superclass pointer inside group
            Alfa.Beta=B2 \\ change supeclass
            Alfa.PrintData  \\ 1   1
            For i=1 to 10 : Marshal3.inc : Next i
            Alfa.PrintData  \\ 1   11
            Alfa.Beta=B1 \\ change supeclass
            Alfa.PrintData  \\ 1   2
            Epsilon=Alfa
            Print Valid(@alfa as epsilon), Valid(@alfa.beta as epsilon.beta) \\ -1   -1
            Epsilon.PrintData \\ 1 2
            Alfa.Beta=B2 \\ change supeclass
            Alfa.PrintData  \\ 1   11
            Epsilon.PrintData \\ 1 2
            \\ validation being for top group superclass and all members if are same
            \\ but not for inner superclasses. This maybe change in later revisions of language.
            Print Valid(@alfa as epsilon), Valid(@alfa.beta as epsilon.beta) \\ -1  0
 
      }
}
Dim A(10)
A(3)=zz()
A(3).bb
}
MODULE OOP1 {\\ events without using Event objects
\\ We use weak reference to register events in eventhandler
\\ if A is a variable a &A is a string contain the actuall name of A, and this is a weak reference
\\ Normally when we do a Read &B the read instruction get the string as a name for  a variable  and check if exist as variable
\\ so Read make references from weak references
\\ M2000 has also the pointer. A pointer is different from the reference, because has nothing to do with name of entities
\\ For example  a=(1,2,3,4) set a as a pointer to array. Passing by value a we pass the object by a pointer.
\\ We can pass &a so if we change the array inside a module or funcion, then we get the change back
\\ A weak reference can be stored as string, and maybe later be invalid, if the storage, an array, passed back as return value,
\\ or pushed to stack of values, and the module where we defined the refered entitites, terminate, and clear all own variables.

\\for this example we make "static" groups (as named the user objects in M2000).
\\The word static used for static variables which stay in every call of a module or function, from the same execution object.
\\ (perhaps a thread which is a separate execution object call a module with specific for the thread static variables)
\\ Here we don't use threads. We have one loop, which call one function of the EventHandler, the observe()
\\ if this functions return true then the loop exit, and the program terminate


\\we have three classes (they are global functions, which construct groups)
\\ The mouseListene and the keylistener, and the EventHandler
\\ Inside EventListener we have one more class (this isn't global)
\\ The Widdget class
\\ This class has the state for an event, and used from button function, a member of EventHandler
\\ So with this EventHandler we can make buttons, with a name. The function button() return a Group
\\ So for the example we make three buttons to three named groups, B1, B2 and B3
\\ Each widget has a weak reference to EventHandler and a name, when constructed,
\\ but has no listeners.
\\ Also the listeners have to link to EventHandler, and this is the work of EventList() function
\\ The Eventlist() is a member of EventHandler and get a listener class, and return a handler
\\ To register an event we have to use register method passing the handler and the weak reference and a  button (widget)
\\ So buttons and handlers are entities from EventHandler
\\ The actual events are not part of the EventHandler. They are inside the listeners classes.
\\ Each listener has a contruction member (same name as the class name),
\\ a register member to add more widgets to same listener,
\\ and the  CheckEvent(), which return true if event happen.

\\The EventHandler pass &this  as own weak reference to each new wigdet.
\\The Listeners added to an array inside the EventHandler with a list of weak references to widgets.
\\The observe() function cehck all stored listeners, calling the CheckEcent() on listener.
\\ if an event happen then all subscribers (all widgets) get a call in callback()  function with the name of the event
\\ each widget then using the weak refrence to EventHandler do a query passig an id, an iinfo string (what$) and a reference of it
\\ The query method (module in M2000) use id and what$ to display information, and use reference to read the caption of widget
\\ perhaps the caption may change, so we can't stored this in listener's list in EventHandler.

\\ So from observe(), pressing 1 or 2 keys or mouse key, we can call  one or more  widget's callback(),
\\ which all  call back the query method, which the later read the widget caption.
\\ B1 listen 1 and 2 keys, B2 listen 1 key, B3 listen a mouse key (right key)



Module OOP {
	Set Fast
	cls 1, 0
	pen 14
	report 2, "Event Listener"
	report "Use keys 1, 2 and mouse left, and for exit mouse right"
	cls, 2
	class mouselistener {
	      name$="MousePress",  yourkey,  auto
	      dim ref$()
	      module mouselistener {
	            read .yourkey
	            .name$<=format$("{0}({1})",.name$,.yourkey)
	      }
	      module register {
	            .auto++
	            dim .ref$(.auto)
	            read .ref$(.auto-1)   \\ weak reference
	      }
	      function CheckEvent {
	            =Mouse=.yourkey
	      }
	}
	class keylistener {
	      name$="KeyPress", yourkey, auto
	      dim ref$()
	      module keylistener {
	            read .yourkey
	            .name$<=format$("{0}({1})",.name$,.yourkey)
	      }
	      module register {
	            .auto++
	            dim .ref$(.auto)
	            read .ref$(.auto-1)   \\ weak reference
	      }
	      function CheckEvent {
	            =keypress(.yourkey)
	      }
	}
	class EventHandler {
	      auto, autoevents, EnableEvents
	      Dim Events()
	      class widget {
	            \\ in classes we can define variables without value
	            ref$  \\ weak reference
	            id, caption$, Enabled=True
	            module linkme {
	                  read .ref$
	            }
	            module widget {  \\ this is used as construction function, but is a module
	                  read .id
	                  read .caption$
	            }
	            function Callback {
	                  read some$
	                  push .ref$ : read &ref  \\ this is the link
	                  =ref.query(.id, some$, &this)
	            }
	      }
	      function button {    \\ this is the button construction
	         .auto++
	         read txt$
	         makeme =.widget(.auto,txt$)  
	         makeme.linkme &this
	         =makeme   \\ we make a group a floating group to export
	      }
	      function EventList {
	            handle=.autoevents  \\ we execute some commands..
	            .autoevents++
	            dim .Events(.autoevents)
	            read .Events(handle)   \\ .. and then we can read function parameter
	            =handle
	      }
	      module register {
	           read handler, ref$
	            .Events(handler).register  ref$
	      }
	     function observe {
	     if not .EnableEvents then =true : exit
	           print "observe for events"
	           for i=0 to .autoevents-1 {
	                 for .Events(i) {
	                        if  .checkevent() then {
	                              for j=0 to .auto-1 {
	                                    for this {     \\ we use a for this {} to make temporary variables
	                                                           \\ because we can't relink a link.  so we make a fresh here
	\\              the link statement to this:    push  .ref$(j) : read &Link
	                                          link weak .ref$(j) to &link
	                                          call link.callback(.name$)
	                                     }
	                                }
	                        }
	                 }
	           }
	     }
	      function query {
	            read id, what$, &nicesmallgroup
	            print under "Inside EventHandler";
	            print under
	            print  part "I get a query from a widget object ";id
	            print
	            print part "Say:";what$
	            print
	            for nicesmallgroup {
	                  Print part "I get the caption:";.caption$
	                  print
	                  =0
	            }          
	      }
	}
	EventHandler=EventHandler()  \\ create handler
	B1=EventHandler.button("Button1")  \\ create subjects
	B2=EventHandler.button("Button2") 
	B3=EventHandler.button("Button3") 
	
	for EventHandler {
	      PressKeyOne=.Eventlist(keylistener(49))
	      .Register  PressKeyOne, &B1  \\register event to subject
	      .Register  PressKeyOne, &B2 
	      .Register .Eventlist(keylistener(50)) , &B1 
	      .Register  .Eventlist(Mouselistener(1)) , &B3 
	      .EnableEvents=True  
	}
	every 150 {
	      if EventHandler.observe() then exit
	      if mouse=2 then exit
	} 
}
OOP
info
}
MODULE EM {Module Checkit {
      ' erase stack of values, so we can add data
      Flush
      Report "Top rank per group"
      Report "Find the top   N   salaries in each department,   where   N   is provided as a parameter. "
10  Input "N%=",N%
      if N%<1 then 10
      Enum Departments {D050,D101,D190,D202}

      \\ Inventroy Department need unique keys
      Inventory Department
      \\ each item in this inventory should be an inventory too
      Class Empl {
            name$, id$, salary
            Class:
            Module Empl(.name$, .id$, .salary) {}
      }
      Data "Tyler Bennett",		"E10297", 32000, D101
      Data "John Rappl",		"E21437", 47000, D050
      Data "George Woltman",	"E00127", 53500, D101
      Data "Adam Smith",		"E63535", 18000, D202
      Data "Claire Buckman",		"E39876", 27800, D202
      Data "David McClellan",		"E04242", 41500, D101
      Data "Rich Holcomb",		"E01234", 49500, D202
      Data "Nathan Adams",		"E41298", 21900, D050
      Data "Richard Potter",		"E43128", 15900, D101
      Data "David Motsinger",	"E27002", 19250, D202
      Data "Tim Sampair",		"E03033", 27000, D101
      Data "Kim Arlich",			"E10001", 57000, D190
      Data "Timothy Grove",		"E16398", 29900, D190
      Data ""
      Read name$
      While name$<>""  {
            Read id$, salary, dep
            Rem : Print name$, id$, salary, dep
            If Exist(Department, dep) Then {
                  z=Eval(Department)    ' get pointer to inventory
                  AppendOne()            
            } Else {
                  z=queue
                  AppendDep()            
                  AppendOne()
            }
            Read name$
      }
      Sort Department as number
      i=each(Department)
      \\ make depname as type of Departments
      depname=D050
      oldtab=tab
      Print $(4),
      Print over ~(1, 7),@(10), $(4,6),"Dep." ,@(16), $(4,20), "Employee Name",$(6,8), "Emp. ID", "Salary"
      Print Under
      Print $(4),
      While i {
            \\ when we pass a number to a enum variable
            \\ if the number exist, get that enum item else raise error
            depname=val(eval$(i, i^))
            \\ z is a pointer to inventory 
            z=Eval(i)
            Sort descending z as number
            k=each(z,1,N%)
            While k {
                  Empl=Eval(k)
                  For Empl {
                        \\ eval$(depname) return the name of enum variable (like D050)
'                        Print Format$("{0:6}{1:20}{2:8}{3::-8}",Eval$(depname), .name$, .id$, .salary)
			Print Part $(4,10),"", $(4,6),~(15,2), Eval$(depname),@(16), $(4,20), ~(14), .name$,$(6, 8), ~(pen,2),.id$, ~(14),.salary
			Print under
                  }
            }
      }
      Print $(4),"Done", $(0)
      Sub AppendDep()
            Append Department, dep:=z
      End Sub
      Sub AppendOne()
                  Append z, salary:=Empl(name$, id$, salary)
      End Sub
}
Checkit 
}
MODULE TRAVERSAL {Report {
          Tree traversal
                   1
                  / \
                 /   \
                /     \
               2       3
              / \     /
             4   5   6
            /       / \
           7       8   9

} 
Pen 15 {Print "Using tuple (arrays)"}
Print
Module CheckIt {
      Null=(,)
      Tree=((((Null,7,Null),4,Null),2,(Null,5,Null)),1,(((Null,8,Null),6,(Null,9,Null)),3,Null))
      
      Module preorder (T) {
            Print "preorder:    ";
            printtree(T)
            Print
            sub printtree(T)
                  Print T#val(1);" ";      
                  If len(T#val(0))>0 then printtree(T#val(0))
                  If len(T#val(2))>0 then printtree(T#val(2))
            end sub
      }
      preorder Tree
      
      Module inorder (T) {
            Print "inorder:     ";
            printtree(T)
            Print
            sub printtree(T)
                  If len(T#val(0))>0 then printtree(T#val(0))
                  Print T#val(1);" ";
                  If len(T#val(2))>0 then printtree(T#val(2))
            end sub
      }
      inorder Tree
      
      Module postorder (T) {
            Print "postorder:   ";
            printtree(T)
            Print
            sub printtree(T)
                  If len(T#val(0))>0 then printtree(T#val(0))
                  If len(T#val(2))>0 then printtree(T#val(2))
                  Print T#val(1);" ";
            end sub
      }
      postorder Tree
      
      Module level_order (T) {
            Print "level-order: ";
            Stack New {
                  printtree(T)
                  if empty then exit
                  Read T
                  Loop
            }
            Print
            sub printtree(T)
                  If Len(T)>0 then
                        Print T#val(1);" ";
                        Data T#val(0), T#val(2)
                  end if
            end sub
      }
      level_order Tree
      Print
}
CheckIt
Pen 15 {Print "Using OOP - passing objects to modules"}
Print
Module OOP {
      \\ Class is a global function (until this module end)
      Class Null {
      }
      \\ Null is a pointer to an object returned from class Null()
      Global Null->Null()
      Class Node {
      Public:
            x, Group LeftNode, Group RightNode
      Class:
            \\ after class:  anything exist one time,
            \\ not included in final object
            Module Node {
                  .LeftNode<=Null
                  .RightNode<=Null
                  Read .x
                  \\ read ? for optional values
                  Read ? .LeftNode, .RightNode
            }
      }
      \\ NodeTree return a pointer to a new Node
      Function NodeTree {
            \\ ![] pass currrent stack to Node()
            ->Node(![])
      }
 
      Tree=NodeTree(1, NodeTree(2,NodeTree(4, NodeTree(7)), NodeTree(5)), NodeTree(3, NodeTree(6, NodeTree(8), NodeTree(9))))
 
      Module preorder (T) {
            Print "preorder:    ";
            printtree(T)
            Print
            sub printtree(T as pointer)
                  If T is Null then Exit sub
                  Print T=>x;" ";
                  printtree(T=>LeftNode)
                  printtree(T=>RightNode)
            end sub
      }
      preorder Tree
      Module inorder (T) {
            Print "inorder:     ";
            printtree(T)
            Print
            sub printtree(T as pointer)
                  If T is Null then Exit sub
                  printtree(T=>LeftNode)
                  Print T=>x;" ";
                  printtree(T=>RightNode)
            end sub
      }
      inorder Tree
      Module postorder (T) {
            Print "postorder:   ";
            printtree(T)
            Print
            sub printtree(T as pointer)
                  If T is Null then Exit sub
                  printtree(T=>LeftNode)
                  printtree(T=>RightNode)            
                  Print T=>x;" ";
            end sub
      }
      postorder Tree
      Module level_order (T) {
            Print "level-order: ";
            Stack New {
                  printtree(T)
                  if empty then exit
                  Read T
                  Loop
            }
            Print
            sub printtree(T as pointer)
                  If T is Null else
                        Print T=>x;" ";
                        Data T=>LeftNode, T=>RightNode
                  end if
            end sub
      }
      level_order Tree
      Print
}
OOP
Pen 15 {Print "Using OOP - modules are members of objects "}
Module OOP {
      \\ Class is a global function (until this module end)
      Class Null {
      }
      \\ Null is a pointer to an object returned from class Null()
      Global Null->Null()
      Class Node {
      Public:
            x, Group LeftNode, Group RightNode
            Module preorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T as pointer)
                        If T is Null then Exit sub
                        call visitor(T=>x)
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)
                  end sub
            }
            Module inorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T as pointer)
                        If T is Null then Exit sub
                        printtree(T=>LeftNode)
                        call visitor(T=>x)
                        printtree(T=>RightNode)
                  end sub
            }
            Module postorder (visitor) {
                  T->This
                  printtree(T)
                  sub printtree(T as pointer)
                        If T is Null then Exit sub
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)            
                        call visitor(T=>x)
                  end sub
            }
            Module level_order (visitor){
                  T->This
                  Stack New {
                        printtree(T)
                        if empty then exit
                        Read T
                        Loop
                  }
                  sub printtree(T as pointer)
                        If T is Null else
                              call visitor(T=>x)
                              Data T=>LeftNode, T=>RightNode
                        end if
                  end sub
            }
      Class:
            \\ after class:  anything exist one time,
            \\ not included in final object
            Module Node {
                  .LeftNode<=Null
                  .RightNode<=Null
                  Read .x
                  \\ read ? for optional values
                  Read ? .LeftNode, .RightNode
            }
      }
      \\ NodeTree return a pointer to a new Node
      Function NodeTree {
            \\ ![] pass currrent stack to Node()
            ->Node(![])
      }
 
      Tree=NodeTree(1, NodeTree(2,NodeTree(4, NodeTree(7)), NodeTree(5)), NodeTree(3, NodeTree(6, NodeTree(8), NodeTree(9))))
 
      printnum=lambda (title$) -> {
            Print
            Print title$;
            =lambda (x)-> {
                  Print x;" ";
            }
      }
      Tree=>preorder printnum("preorder:    ")
      Tree=>inorder printnum("inorder:     ")
      Tree=>postorder printnum("postorder:   ")
      Tree=>level_order printnum("level-order: ")
      Print
      Print
}
OOP
Pen 15 {Print "OOP - Event object as visitor"}
Module OOP {
      \\ Class is a global function (until this module end)
      Class Null {
      }
      \\ Null is a pointer to an object returned from class Null()
      Global Null->Null()
      Class Node {
      Public:
            x, Group LeftNode, Group RightNode
            Module preorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T as pointer)
                        If T is Null then Exit sub
                        call event visitor, T=>x
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)
                  end sub
            }
            Module inorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T as pointer)
                        If T is Null then Exit sub
                        printtree(T=>LeftNode)
                        call event visitor, T=>x
                        printtree(T=>RightNode)
                  end sub
            }
            Module postorder (visitor) {
                  T->This
                  printtree(T)
                  sub printtree(T as pointer)
                        If T is Null then Exit sub
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)            
                        call event visitor, T=>x
                  end sub
            }
            Module level_order (visitor){
                  T->This
                  Stack New {
                        printtree(T)
                        if empty then exit
                        Read T
                        Loop
                  }
                  sub printtree(T as pointer)
                        If T is Null else
                              call event visitor, T=>x
                              Data T=>LeftNode, T=>RightNode
                        end if
                  end sub
            }
      Class:
            \\ after class:  anything exist one time,
            \\ not included in final object
            Module Node {
                  .LeftNode<=Null
                  .RightNode<=Null
                  Read .x
                  \\ read ? for optional values
                  Read ? .LeftNode, .RightNode
            }
      }
      \\ NodeTree return a pointer to a new Node
      Function NodeTree {
            \\ ![] pass currrent stack to Node()
            ->Node(![])
      }
 
      Tree=NodeTree(1, NodeTree(2,NodeTree(4, NodeTree(7)), NodeTree(5)), NodeTree(3, NodeTree(6, NodeTree(8), NodeTree(9))))
      Event PrintAnum {
            read x
      }
      Function PrintThis(x) {
                Print x;" ";      
      }
      Event PrintAnum New PrintThis()
      printnum=lambda PrintAnum (title$) -> {
            Print
            Print title$;
            =PrintAnum
      }
      Tree=>preorder printnum("preorder:    ")
      Tree=>inorder printnum("inorder:     ")
      Tree=>postorder printnum("postorder:   ")
      Tree=>level_order printnum("level-order: ")
}
OOP
}
MODULE PERM1 {Report "A program that performs a permutation test to judge whether the treatment had a significantly stronger effect than the placebo. "
Print "Treatment group "
Print 85, 88, 75, 66, 25, 29, 83, 39, 97
Print "Control group"
Print 68, 41, 10, 49, 16, 65, 32, 92, 28, 98
Print "Please wait  - ctrl-C or Esc to exit"
Refresh
Module Checkit {
      Global data(), treat=0
      data()=(85, 88, 75, 66, 25, 29, 83, 39, 97,68, 41, 10, 49, 16, 65, 32, 92, 28, 98)
      Function pick(at, remain, accu) {
            If remain Else =If(accu>treat->1,0):Exit
            =pick(at-1,remain-1,accu+data(at-1))+If(at>remain->pick(at-1, remain, accu),0)
      }
      total=1
      For i=0 to 8 {treat+=data(i)}
      For i=19 to 11 {total*=i}
      For i=9 to 1 {total/=i}
      gt=pick(19,9,0)
      le=total-gt
      Print Format$("<= : {0:1}% {1}", 100*le/total, le)
      Print Format$(" > : {0:1}% {1}", 100*gt/total, gt)
}
Checkit
}
MODULE ITER {Print "Associative array/Iteration"
Module checkit {
      \\ Inventories are objects with keys and values, or keys (used as read only values)
      \\ They use hash function.
      \\ Function TwoKeys return Inventory object (as a pointer to object)
      Function TwoKeys {
            Inventory Alfa="key1":=100, "key2":=200
            =Alfa
      }
      M=TwoKeys()
      Print Type$(M)="Inventory"
      \\ Normal Use:
            \\ Inventories Keys are case sensitive
            \\ M2000 identifiers are not case sensitive
      Print M("key1"), m("key2")
      \\ numeric values can convert to strings
      Print M$("key1"), m$("key2")
      \\ Iteration
      N=Each(M)
      While N {
            Print Eval(N)  ' prints 100, 200 as number
            Print M(N^!)  ' The same using index N^
      }
      N=Each(M)
      While N {
            Print Eval$(N)  ' prints  100, 200 as strings
            Print M$(N^!)  ' The same using index N^
      }
      N=Each(M)
      While N {
            Print Eval$(N, N^)  ' Prints Keys
      }
      \\ double iteration
      Append M, "key3":=500
      N=Each(M, 1, -1)  ' start to end
      N1=Each(M, -1, 1) ' end to start
      \\ 3x3 prints
      While N {
            While N1 {
                  Print format$("{0}*{1}={2}", Eval(N1), Eval(N), Eval(N1)*Eval(N))
            }
      }
      \\ sort results from lower product to greater product (3+2+1, 6 prints only)
      N=Each(M, 1, -1)  
      While N {
            N1=Each(M, N^+1, -1) 
            While N1 {
                  Print format$("{0}*{1}={2}", Eval(N1), Eval(N), Eval(N1)*Eval(N))
            }
      }
      N=Each(M)
      N1=Each(M,-2, 1)  ' from second from end to start
      \\ print only 2 values. While block ends when one iterator finish
      While N, N1 {
            Print Eval(N1)*Eval(N)
      }         
}
Checkit
}
MODULE ST {Print "A stack object"
Module Checkit {
      a=Stack
      Stack a {
            Push 100, 200, 300
      }
      Print StackItem(a, 1)=300
      Stack a {
            Print StackItem(1)=300
            While not empty {
                  Read N
                  Print N
            }
      }
}
Checkit
}
MODULE ST1 {Print "Current Stack"
Module Checkit {
      Read a, b
      Print a, b
}
\\ add parameters in a FIFO, and this FIFO merged to current stack
Push 100
Checkit 10, 20
Print StackItem(1)=100
Module Checkit {
      Read a, b
      Print a=20, b=100
}
Checkit 20
 
Function alfa {
      k=0
      n=0
      while not empty {
            k+=number
            n++
      }
      if n=0 then Error "No parameters found"
      =k/n
}
 
Print alfa(1,2,3,4)=2.5
}
MODULE MAZE2 {Module Maze2 {
      \\ depth-first search
      While Inkey$<>"" {}  ' drop keys
      Const View as boolean=True
again:
      Form 80,50
      let w=random(2,6)*10, h=random(1,4)*10, slice=w*h div 60
      let  slice=if(slice=0->1, slice) : counter =1 
      Double
      \\center proportional text double size
      Report 2, Format$("Maze {0}x{1}",w,h)
      Normal
      Refresh
      Set Fast !
      stack new {
            Profiler
            Dim maze$(1 to w+1, 1 to h+1)="#"
            Include=Lambda w,h (a,b) ->a>=1 and a<=w and b>=1 and b<=h
            Flush ' empty stack
            if random(1,2)=1 then
                  entry=(if(random(1,2)=1->2, w),Random(1, h/2)*2)
            else
                  entry=(random(1,w/2)*2,If(Random(1,2)=1->2,h))
            end if
            maze$(entry#val(0), entry#val(1))=" "
            forchoose=(,)
            Push Entry
            do
                  do
                        NewForChoose(!entry)
                        status=len(forchoose)
                        if status>0 then
                              status--
                              forchoose=forchoose#val(random(0,status))
                              if status>0 then Push forchoose
                              OpenDoor(!Entry, !forchoose)
                              if view then counter=if(counter=0->slice, counter-1) : if counter=0 then ShowMaze()      
                        else
                              exit
                        end if
                        entry=forchoose
                  Always
                  if empty then exit
                  Read entry
            Always
            ShowMaze()
            Print timecount/1000
      }
      counter=10
      every 200 {
            counter--
            if inkey$<>"" or mouse<>0 then counter=-1 : exit
            if counter<1 then exit
      }
      if counter=0 then goto again
      End
      Sub NewForChoose(x,y)
            Local x1=x-2, x2=x+2, y1=y-2, y2=y+2, arr=(,)
            Stack New {
                  if include(x1,y) then if Maze$(x1,y)<>" " Then push (x1, y) 
                  if include(x2,y) then if Maze$(x2,y)<>" " Then push (x2, y)
                  if include(x,y1) then if Maze$(x,y1)<>" " Then push (x, y1)
                  if include(x,y2) then if Maze$(x,y2)<>" " Then push (x, y2)
                  forchoose= Array([])
            }
      End Sub
      Sub OpenDoor(x1,y1, x2,y2)
            Local i
            if x1=x2 then
                  y1+=y2<=>y1
                  for i=y1 to y2 {maze$(x1, i)=" " } 
            Else
                  x1+=x2<=>x1
                  for i=x1 to x2 {maze$(i, y1)=" "}                   
            End if
      End Sub
      Sub ShowMaze()
            Refresh 5000
            cls ,4  ' split screen - preserve lines form 0 to 3
            Local i, j, t=40-w div 2
            For j=1 to h+1 { Print @(t) : for i=1 to w+1 {Print maze$(i,j);}:Print}
            Print
            Refresh 100
      End Sub     
}
Maze2
keyboard "info"+chr$(13)
}
MODULE MAZE {Module Maze {
      width% = 40
      height% = 20
      \\ we can use DIM maze$(0 to width%,0 to  height%)="#"
      \\ so we can delete the two For loops
      DIM maze$(0 to width%,0 to  height%)
      FOR x% = 0 TO width%
          FOR y% = 0 TO height%
              maze$(x%, y%) = "#"
          NEXT y%
      NEXT x%
 
      currentx% = INT(RND * (width% - 1))
      currenty% = INT(RND * (height% - 1))
 
      IF currentx% MOD 2 = 0 THEN currentx%++
      IF currenty% MOD 2 = 0 THEN currenty%++
      maze$(currentx%, currenty%) = " "
 
      done% = 0
      WHILE done% = 0 {
          FOR i% = 0 TO 99
              oldx% = currentx%
              oldy% = currenty%
              SELECT CASE INT(RND * 4)
                  CASE 0
                      IF currentx% + 2 < width% THEN currentx%+=2
                  CASE 1
                      IF currenty% + 2 < height% THEN currenty%+=2
                  CASE 2
                      IF currentx% - 2 > 0 THEN currentx%-=2
                  CASE 3
                      IF currenty% - 2 > 0 THEN currenty%-=2
              END SELECT
              IF maze$(currentx%, currenty%) = "#"  Then {
                  maze$(currentx%, currenty%) = " "
                  maze$(INT((currentx% + oldx%) / 2), ((currenty% + oldy%) / 2)) = " "
             }
          NEXT i%
          done% = 1
          FOR x% = 1 TO width% - 1 STEP 2
              FOR y% = 1 TO height% - 1 STEP 2
                  IF maze$(x%, y%) = "#" THEN done% = 0
              NEXT y%
          NEXT x%
      }
 
 
      FOR y% = 0 TO height%
          FOR x% = 0 TO width%
              PRINT maze$(x%, y%);
          NEXT x%
          PRINT
      NEXT y%
}
Maze
}
MODULE MINESWEEPER {Module Minesweeper {
      Font "Arial Black"
      Bold 0
      Form 60,40
      Refresh 1000
      Def com$, com_label$
      Def x, b_row, b_col, where, top_where
      Def rows=4, columns=6, swap_first%
      Def boolean skiptest, end_game, cheat
      Dim Board$(0 to rows+1, 0 to columns+1)="? "
      Def mines%, i%, j%, used%, acc%, n%, m%
      mines%=max.data(random(int(columns*rows*.1),int(columns*rows*.2)-1), 1)
      For i%=1 to rows:For j%=1 to columns
            Board$(i%,j%)=". "
      Next j%:Next i%
      used%=mines%
      While used%
            used%--
            Do
                  i%=random(1,rows)
                  j%=random(1, columns)
            Until right$(Board$(i%,j%),1)=" "
            Board$(i%,j%)=".*"
      End While
      used%=rows*columns-mines%
      \\ remove rem so to never loose from first open
      Rem : 
      swap_first%=used%
      \\ when mines%=0 or used%=0 then player win
      Report {Minesweeper - rosettacode task
            Commands:
            -  ? 1 2  flag/unflag 1 2
            -  1 2   open 1 2
            -  q  to quit
            You can pass multiple commands in a line, but q erase all before execute
      } 
      top_where=Row
      While not End_Game {GameLoop()}
      End
      Sub PrintBoard()
      Cls, top_where
      Print
      Print "   X  ";
      For j%=1 to columns {
            Print format$("{0::-3}  ", j%);
      }
      Print
      For i%=1 to rows {
            Print format$(" {0::-3}  ", i%);
            For j%=1 to columns {
                  Print "  ";Left$(Board$(i%,j%),1);"  ";
                  \\ rem above and unrem follow line to display mines
                  Rem: Print "  ";Board$(i%,j%)+" ";
            }
            Print
      }      
      End Sub
      Sub PrintMines()
      Cls, top_where
      Print
      Print "   X  ";
      For j%=1 to columns {
            Print format$("{0::-3}  ", j%);
      }
      Print
      For i%=1 to rows {
            Print format$(" {0::-3}  ", i%);
            For j%=1 to columns {
                  Print "  ";Right$(Board$(i%,j%),1);"  ";
            }
            Print
      }      
      End Sub
      Sub GameLoop()
            Local com$, loopagain as boolean
            PrintBoard()
            InputCommand()
            do 
                  loopagain=true
                  while not empty
                              \\ process game command
                        Read com$
                        if com$="q " Then
                              Print "Quit" : end_game=True : exit
                        Else.if com$="o " Then
                              OpenCell()
                        Else.if com$="n " Then
                              OpenCell2()
                        Else.if com$="? " Then
                              SwapCell()
                        Else.if com$="c " Then
                              Exit Sub                        
                        End if
                  End While
                  If mines%=0 or used%=0 then
                        PrintBoard(): Print "Player Win": end_game=True: Exit Sub
                  End if
                  If mines%=-1 then
                        if swap_first%=used% then
                              mines%=rows*columns-used%
                              Local n%, m%
                              While mines%
                                    Let n%=random(1,rows), m%=random(1, columns)
                                    If Board$(n%, m%)=". " then  Board$(n%, m%)=".*" : mines%=0
                              End While
                              Board$(i%, j%)=". "
                              mines%=rows*columns-used%
                              swap_first%=-100
                              Push i%, j%, "o "
                              loopagain=false
                        else
                              PrintMines(): Print "Player Loose": end_game=True : Exit Sub
                        end if
                  End If
            Until loopagain
            Flush
            Refresh if(End_Game->10,1000)
      End Sub
      Sub InputCommand()
            where=row
            While com$=""
                  cls, where
                  Print "x x | ? x x | q >";
                  Refresh 10
                  Try {
                        Input "", com$
                  }
            End While
            x=1
            Flush 
            While com$<>""
                  com_label$=""
                  ParseCommand()
                  if len(com_label$)<>2 then
                        com$="" : Print com_label$ : Flush
                        Refresh 10
                        push key$ : drop
                  else
                        Data com_label$, b_col, b_row
                  End if
            End While
            Refresh 1000
      End Sub
      Sub ParseCommand()
            com_label$="o "
            skiptest=true
            ReadColumn()
            if len(com_label$)<>2 then
                  com$=""     
            Else.if x=-1 then
                  com_label$=lcase$(Left$(com$,1))+" "
                  com$=mid$(com$, 2)
                  x=1
                  if len(com_label$)<>2 then
                        com_label$="no command found"
                  else.if com_label$="? " then
                        ReadColumn()
                        if x>-1 then ReadRow()
                  else.if com_label$="c " then
                        cheat=true  
                  else.if com_label$="q " then
                        flush
                        com$=""                  
                  else
                        com_label$="Use q or ? for commands"
                        com$=""
                  End if      
            else
                  ReadRow()
                  if x>-1 then com_label$="o "
            End if 
      End Sub
      Sub ReadRow()
            com$=mid$(com$,x)
            b_row=val(com$, "??", x)
            if x=-1 then
                  com_label$="Need a row"
            else.if b_row<1 or b_row>rows then
                  com_label$="Need a row from 1 to "+str$(rows)
                  x=-1 
            else
                  com$=mid$(com$,x+1)
                  x=1
            End if
      End Sub
      Sub ReadColumn()
            com$=mid$(com$,x)
            b_col=val(com$, "??", x)
            if x=-1 then
                  if not skiptest then com_label$="Need a column"
            else.if b_col<1 or b_col>columns then
                  com_label$="Need a column from 1 to"+str$(columns)
            else
                  com$=mid$(com$,x+1)
                  x=1
            End if
            skiptest=false
      End Sub
      Sub SwapCell()
            Read j%, i%
            If left$(Board$(i%,j%),1)="?" then
                  Board$(i%,j%) ="."+Right$(Board$(i%,j%),1)
                  If cheat Then if Right$(Board$(i%,j%),1)="*" then mines%++
            Else.If left$(Board$(i%,j%),1)="." then
                  Board$(i%,j%) ="?"+Right$(Board$(i%,j%),1)
                  If cheat Then if Right$(Board$(i%,j%),1)="*" then mines%--
            End if
      End Sub
      Sub OpenCell()
            Read j%, i%
            If left$(Board$(i%,j%),1)="." then {
                  if Right$(Board$(i%,j%),1)="*" then mines%=-1 : flush : exit
                  acc%=0
                  used%--
                  Local n%, m%
                  For n%=i%-1 to i%+1 {
                        For m%=j%-1 to j%+1 {
                                If Right$(Board$(n%,m%),1)="*" then acc%++
                        }
                  }
                  For n%=i%-1 to i%+1 {
                        For m%=j%-1 to j%+1 {
                             if not (n%=i% and m%=j%) then
                                   if not Right$(Board$(n%,m%),1)="*" then
                                         If left$(Board$(n%,m%),1)="." then
                                              Push n%, m%, "n "  ' reverse to stack
                                              Rem : Print stack.size : Refresh
                                         End If
                                   End If
                             End If
                        }
                  }
                  Board$(i%,j%)=if$(acc%=0->"  ",str$(acc%, "# "))
            }
      End Sub
      Sub OpenCell2()
            Read J%, i%
            If left$(Board$(i%,j%),1)="." then {
                  if Right$(Board$(i%,j%),1)="*" then exit
                  acc%=0
                  used%--
                  For n%=i%-1 to i%+1 {
                        For m%=j%-1 to j%+1 {
                                If Right$(Board$(n%,m%),1)="*" then acc%++
                        }
                  }
                  \\ if cell has no mines around then we check all
                  if acc%=0 then
                        Local n%, m%
                        For n%=i%-1 to i%+1
                              For m%=j%-1 to j%+1
                                   if not (n%=i% and m%=j%) then
                                         if not Right$(Board$(n%,m%),1)="*" then
                                               If left$(Board$(n%,m%),1)="." then
                                                    Push n%, m%, "o "  ' reverse to stack
                                                    Rem : Print stack.size : Refresh
                                               End If
                                         End If
                                   End If
                              Next m%
                        Next n%
                  End If
                  Board$(i%,j%)=if$(acc%=0->"  ",str$(acc%, "# "))
            }
      End Sub     
}
Minesweeper
Info   ' call the info module
}
MODULE IBAN {\\ IBAN checker
Function MakeIBANfun$ {
      Inventory countrylength = "AL" := 28, "AD" := 24, "AT" := 20, "AZ" := 28, "BE" := 16, "BH" := 22, "BA" := 20, "BR" := 29
      Append  countrylength, "BG" := 22, "CR" := 21, "HR" := 21, "CY" := 28, "CZ" := 24, "DK" := 18, "DO" := 28, "EE" := 20
      Append  countrylength, "FO" := 18, "FI" := 18, "FR" := 27, "GE" := 22, "DE" := 22, "GI" := 23, "GR" := 27, "GL" := 18
      Append  countrylength, "GT" := 28, "HU" := 28, "IS" := 26, "IE" := 22, "IL" := 23, "IT" := 27, "KZ" := 20, "KW" := 30
      Append  countrylength, "LV" := 21, "LB" := 28, "LI" := 21, "LT" := 20, "LU" := 20, "MK" := 19, "MT" := 31, "MR" := 27
      Append  countrylength, "MU" := 30, "MC" := 27, "MD" := 24, "ME" := 22, "NL" := 18, "NO" := 15, "PK" := 24, "PS" := 29
      Append  countrylength, "PL" := 28, "PT" := 25, "RO" := 24, "SM" := 27, "SA" := 24, "RS" := 22, "SK" := 24, "SI" := 19
      Append  countrylength, "ES" := 24, "SE" := 24, "CH" := 21, "TN" := 24, "TR" := 26, "AE" := 23, "GB" := 22, "VG" := 24
 
     =Lambda$ countrylength (Iban0$)->{
            Iban$=Filter$(Ucase$(Iban0$), " ")
            Iban$=Filter$(Iban$, Filter$(Iban$,"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"))
            Def Decimal ch, c
            {            
                  If Not Exist(countrylength, Left$(Iban$,2)) Then Exit
                  length=Eval(countrylength)
                  If Not Len(Iban$)=length Then exit
                  Buffer ScanChar as Integer*length
                  Return ScanChar, 0:=Mid$(Iban$,5), length-4:=Mid$(Iban$,1,4)
 
                  For i=0 to length-1 {
                        ch=Eval(ScanChar, i)
                        if ch>=48 and ch<=57 then {
                              c = c*10+ch-48    
                        } else.if ch>=65 and ch<=90 then {
                              c = c*100+ch-55
                        } else c=-1: exit
                  }
                  c = c mod 97
            }
            =Iban0$ + If$(c=1 ->" (Valid)", " (Invalid)")
      }
}
IbanCheck$=MakeIBANfun$()
Print IbanCheck$("GB82 WEST 1234 5698 7654 32")    ' valid
Print IbanCheck$("GB82 TEST 1234 5698 7654 32")
Print IbanCheck$("SA03 8000 0000 6080 1016 7519")   ' valid
Print IbanCheck$("GR16 0110 1250 0000 0001 2300 695X")
Print IbanCheck$("MK11 2222 3333 4444 555")
}
MODULE HTTP {Module CheckIt  {
      Declare  xml "Microsoft.XMLHTTP"
      const testUrl$ = "http://www.rosettacode.org"
      With  xml, "readyState" as ReadyState
      Method xml "Open", "Get", testUrl$, True  ' True means Async
      Method xml "send"
      \\ We set a thread to count time
      k=0
      Thread {
            k++
      }  as TimeOut interval 300   ' change thread interval to give more time to collect
      \\ In main thread we can check ReadyState and Mouse button
      Task.Main 100 {
            Print ReadyState
            If ReadyState=4 then exit
            if k>20 then exit   ' 20*100= 2 sec
            if mouse then exit ' exit if mouse click
      }
      \\ So now we can read
      if ReadyState=4 then {
            With  xml, "responseText" AS AA$
            \\ break AA$ to lines
            Document BB$=AA$
            \\ using line breaks as CRLF
            Print "Press space or mouse to change page"
            Report BB$
      }
      Declare xml Nothing
}
CheckIt
}
MODULE CAL {\\ Calendar - for "REAL" programmers
\\ All statements in UPPERCASE
\\ Output to 132 characters console - as a line printer
\\ USE COURIER NEW  (FONT "COURIER NEW")

\\ CHANGE THE 
GLOBAL CONST PRINT_IT AS BOOLEAN=FALSE
MODULE GLOBAL SNOOPY  {
IF NOT PRINT_IT THEN CURSOR 0,ROW ELSE IF ROW>0 THEN PAGE 1 
PRINT $(,8)
PRINT #-2, {
					   XXXX
					  X    XX
					 X  ***  X		  XXXXX
					X  *****  X	       XXX     XX
				     XXXX ******* XXX	   XXXX 	 XX
				   XX	X ******  XXXXXXXXX    El@	   XX XXX
				 XX	 X ****  X			     X** X
				X	 XX    XX     X 		     X***X
			       X	 //XXXX       X 		     XXXX
			      X 	//   X				   XX
			     X	       //    X		XXXXXXXXXXXXXXXXXX/
			     X	   XXX//    X	       X
			     X	  X   X     X	      X
			     X	  X    X    X	     X
			      X   X    X    X	     X			  XX
			      X    X   X    X	     X		       XXX  XX
			       X    XXX      X	      X 	      X  X X  X
			       X	     X	       X	      XX X  XXXX
				X	      X 	XXXXXXXX\     XX   XX  X
				 XX	       XX	       X     X	 @X  XX
				   XX		 XXXX	XXXXXX/     X	  XXXX
				     XXX	     XX***	   X	 X
					XXXXXXXXXXXXX *   *	  X	X
						     *---* X	 X     X
						    *-* *   XXX X     X
						    *- *       XXX   X
						   *- *X	  XXX
						   *- *X  X	     XXX
						  *- *X    X		XX
						  *- *XX    X		  X
						 *  *X* X    X		   X
						 *  *X * X    X 	    X
						*  * X**  X   XXXX	    X
						*  * X**  XX	 X	    X
					       *  ** X** X     XX	   X
					       *  **  X*  XXX	X	  X
					      *  **    XX   XXXX       XXX
					     *	* *	 XXXX	   X	 X
					    *	* *	     X	   X	 X
			      =======*******   * *	     X	   X	  XXXXXXXX\
				     *	       * *	/XXXXX	    XXXXXXXX\	   )
				=====**********  *     X		     )	\  )
				  ====* 	*     X 	      \  \   )XXXXX
			     =========**********       XXXXXXXXXXXXXXXXXXXXXX

}
}
MODULE CALENDAR (YEAR, LOCALEID) {
      FUNCTION GETMAX(YEAR, MONTH) {
            A=DATE(STR$(YEAR)+"-"+STR$(MONTH)+"-1")
            MAX=32
            DO {
                  MAX--
                  M=VAL(STR$(CDATE(A,0,0,MAX), "M"))  
            } UNTIL M=MONTH
             =MAX+1    
      }
      FUNCTION SKIPMO(YEAR, MONTH) {
            A=DATE(STR$(YEAR)+"-"+STR$(MONTH)+"-1")
            =(VAL(STR$(A, "W"))-8) MOD 7 +7
      }
      FUNCTION TITLE$(A$) {
            =UCASE$(LEFT$(A$,1))+LCASE$(MID$(A$, 2))
      }
      LOCALE LOCALEID
      IF NOT PRINT_IT THEN CURSOR 0,HEIGHT-1  ' LAST LINE, SO EACH NEW LINE SCROLL ALL LINES UP
      SNOOPY
      
      PRINT UNDER  ' PRINT UNDERLINE
      PRINT OVER $(2), YEAR
      PRINT
      FOR J=0 TO 1 {
            PRINT
            FOR I=1 TO 6 {
                  MONTH=I+J*6
                  PRINT  PART @((I-1)*22), $(2,21), UCASE$(LOCALE$(55+MONTH))
            }
            PRINT
            DIM SKIP(1 TO 6), COUNT(1 TO 6), D(1 TO 6)=1
            FOR I=1 TO 6 {
                  MONTH=I+J*6
                  IF I>1 THEN PRINT " ";
                  FOR K=42 TO 48 :PRINT " ";UCASE$(LEFT$(LOCALE$(K),2));:NEXT K 
                  SKIP(I)=SKIPMO(YEAR, MONTH)
                  COUNT(I)=GETMAX(YEAR, MONTH)
            }
            PRINT 
            FOR I=1 TO 6 {
                      IF I>1 THEN PRINT " ";
                      FOR K=1 TO 7 {
                        SKIP(I)--
                        IF  SKIP(I)>0 THEN PRINT "   "; :CONTINUE
                        COUNT(I)--
                        PRINT FORMAT$(" {0::-2}", D(I));
                        D(I)++
                  }
            }
            PRINT
            PRINT @(0)
            FOR M=1 TO 5 {
                  FOR I=1 TO 6 {
                        IF I>1 THEN PRINT " ";
                        FOR K=1 TO 7 {
                              COUNT(I)--
                              IF COUNT(I)<0 THEN PRINT "   "; : CONTINUE
                              PRINT FORMAT$(" {0::-2}", D(I));
                              D(I)++
                        }
                  }
            PRINT 
            }
      }     
}
WHILE INKEY$<>"" :  END WHILE
IF PRINT_IT THEN PRINTING ON
FONT "COURIER NEW"
PEN 0
CLS 15, 0
FORM 132,68      
CALENDAR 1966, 1032 ' GREEK
GOSUB WAITKEY_OR_MOUSE
FOR I=2019 TO 2025
CALENDAR I, 1033  ' ENGLISH
GOSUB WAITKEY_OR_MOUSE
NEXT I
IF PRINT_IT THEN PRINTING OFF
CLEAR  ' CLEAR VARIABLES FROM THIS MODULE
KEYBOARD "INFO"+CHR$(13)
END
WAITKEY_OR_MOUSE:
IF PRINT_IT THEN RETURN
WHILE INKEY$="" AND MOUSE=0
END WHILE
RETURN
}
MODULE LINKED_LIST {\\ This example use pointers to groups.
\\ Class Node
\\ Node type has two pointers to groups: pred and succ
\\ Class 

Module Checkit {
      Form 80, 50
      Class Null {}
      Global Null->Null()
      Class Node {
            group pred, succ
            dat=0
            Remove {
                  Print "destroyed", .dat
            }
            class: 
            module Node {
                  .pred->Null
                  .succ->Null
                  if match("N") Then Read .dat
            }
      }
      Class LList {
            Group Head, Tail
            Module PushTail(k as pointer) {
                  if .Tail is Null then {
                        .Head<=k
                        .Tail<=k
                  } else {
                        n=.Tail
                        .Tail<=k
                        k=>pred=n=>pred
                        n=>pred=k
                        k=>succ=n
                  }
            }
            Function RemoveTail {
                  n=.Tail
                  if n is .Head then {
                        .Head->Null
                        .Tail->Null
                  } Else { 
                        .Tail<=n=>succ
                        .Tail=>pred=n=>pred
                        n=>pred->Null
                  }
                  for n {
                        .succ->Null
                        .pred->Null
                  }
                  =n
            }
            Module PushHead(k as pointer) {
                  if .head is Null then {
                        .Head<=k
                        .Tail<=k
                  } else {
                        n=.head
                        .head<=k
                        k=>succ=n=>succ
                        n=>succ=k
                        k=>pred=n
                  }
            }
            Function RemoveHead {
                  n=.Head
                  if n is .Tail then {
                        .Head->Null
                        .Tail->Null
                  } Else { 
                      .Head<=n=>pred
                      .Head=>succ=n=>succ
                       n=>succ->Null    
                   }
                  for n {
                        .succ->Null
                        .pred->Null
                  }
                  =n
            }
            Module RemoveNode(k as pointer) {
                  pred=k=>pred
                  succ=k=>succ
                  if pred is succ then {
                        if .head is k else Error "Can't remove this node"
                        k=.RemoveHead()
                        clear k
                  } else {
                       pred=>succ=succ
                       succ=>pred=pred 
                  }
            }
            Module InsertAfter(k as pointer, n as pointer) {
                  pred=k=>pred
                  n=>pred=pred
                  n=>succ=k
                  pred=>succ=n
                  k=>pred=n
            }
            Function IsEmpty {
                  = .Head is null or .tail is null
            }
      class:
            Module LList {
                  .Head->Null
                  .Tail->Null
            }
      }
      m->Node(100)
 
      L=LList()
      L.PushTail m
      If not L.Head is Null then Print L.Head=>dat=100
      for i=101 to 103 {
            m->Node(i)
            L.PushTail m
            Print "ok....", i
      }
      for i=104 to 106 {
            m->Node(i)
            L.PushHead m
            Print "ok....", i
      }
 
      Print "Use Head to display from last to first"
      m=L.Head
      do {
            Print m=>dat
            m=m=>pred
      } Until m is null
      Print "ok, now find 3rd and remove it"
      m1=L.Head
      i=1 
      Index=3
      While i<Index {
            if m1 is null then exit
            m1=m1=>pred
            i++
      }
      If i<>Index then {
            Print "List has less than "; Index;" Items"
      } Else {
            Print "First add one new node"
                  newNode->Node(1000)
                  L.InsertAfter m1, newNode
                  L.RemoveNode m1
                  clear m1  ' last time m1 used here
                  newNode=Null
            Print "ok.............."
      }
      Print "Use Tail to display from first to last"
      m=L.Tail
      do {
            Print m=>dat
            m=m=>succ
      } Until m is null
 
 
      useother=True
      While not L.IsEmpty(){
            For This {
                  \\ we have to use a temporary variable name, here A
                         A=If(useother->L.RemoveTail(),L.RemoveHead())
                         ? A=>dat
                        useother~
                        \\ now we can try to perform removing
                        clear A
             }
      }
      Print "list is empty:"; L.IsEmpty()    
}
Checkit
}
MODULE LZW {Module FastM2000 {
      plaintext$="TOBEORNOTTOBEORTOBEORNOT"
      Function encodeLZW$(i$) {
            Def long c, d, i, l, o$, w$
            Inventory dict
            For i = 0 to 255 {Append dict , Chr$(i):=i}
            l = i
            i = 1
            w$ = LEFT$(i$,1)
            Repeat{
                  d = 0
                  Repeat {
                        c = d
                        IF i > Len(i$) Then Exit
                        if exist(dict, w$) Then { 
                              d=eval(dict)
                        } Else  Append dict, w$:=l: Exit
                        if d<l Then i += 1 : w$ += Mid$(i$, i, 1)  
                  } Until d >= l
                  l += 1 : w$ = Right$(w$, 1)
                  o$ += Chr$(c Mod 256) + Chr$(c div 256)
            } Until i > Len(i$)
            = o$
      }
      encodeLZW$ = encodeLZW$(plaintext$)
      
      Document Doc$={ Lempel-Ziv-Welch (LZW) compression
      }
      For i = 1 to Len(encodeLZW$) STEP 2
              Doc$= Str$(Asc(Mid$(encodeLZW$,i)) + 256*Asc(Mid$(encodeLZW$,i+1)))
      Next i
      insert to 2,1  Doc$=""  ' remove first space
      
      Doc$={
      }+"Compression ration:"+str$((len(encodeLZW$) div 2)/len(encodeLZW$)*100, " ##")+{%
      }
      Function decodeLZW$(i$) {
            Def c, i, l, o$, t$, w$
            Inventory Dict
            For i = 0 to 255 {Append dict , i:=chr$(i)}
            l = i
            c = Asc(i$) + 256*Asc(Mid$(i$,2))
            w$ = dict$(c)
            o$ = w$
            IF Len(i$) < 4 Then = o$
            For i = 3 to Len(i$) STEP 2 {
                  c = Asc(Mid$(i$,i)) + 256*Asc(Mid$(i$,i+1))
                  IF c < l Then {
                        t$ = dict$(c)
                  } Else t$ = w$ + LEFT$(w$,1)
                  o$ += t$
                  Append dict, l:=w$ + LEFT$(t$,1)
                  l += 1 : w$ = t$
            }
            = o$
      }
      Doc$=decodeLZW$(encodeLZW$)+{
      }
      Clipboard Doc$
      Report Doc$
}
FastM2000
}
MODULE UTF8 {Module checkit {
      linespace 60
      Form ! 60,40
      Cls,0
      Report 2, "Read a file character by character/UTF8"
      \\ prepare a file
      \\ Save.Doc and Append.Doc  to file, Load.Doc and Merge.Doc from file
      Report ! 4 ' set 4 to tab size
      Report {
            	The task of this module is simple a reading one by one char, from a UTF8 encoded file. We can save and read entire files in UTF8 encoding, but here we want to  save a file as UTF8 and then read one by one all characters as UTF8 encoded, and diplay them (after converted to UTF-16LE, from a ready made function)
            	We have to read more than one byte to make it one character. But maybe we have less, so we have to stop reading, if that happen. So when we need more we try to get more, and maybe we get error. We use a Try block to get the error in the code, and do something for it.
            	We use buffers as memory area to get the data at a predefined length. So when we use:
            	Get #file_Handler, two
            	intrerpreter check that two is a buffer, get the length and try to get the same length of bytes to that buffer. Each buffer have a base structure and maybe a count value, of how many of them can be stored. The folowwing statement say that the base structure is a byte and we have two of them
            	Buffer Two as byte*2
            	The variable Two is a reference to an object. Two(0) is the real address of offset 0, of buffer two.
            	Here we don't use address, only offsets. We can read using Eval() the byte at any offset, included in the buffer, unless we get an error. So Eval(two, 0) return the byte as an assign value (0 to 255). Also we can use the string reading, Eval$(two,0,2) which return a string with 2 bytes, from offset 0, from buffer referred by two.
            	The following statement perform a memory copy (twice, one to the string and one to the source), with control over the offsets and lengths.
            	Return Bytes, 1:=Eval$(three, 0, 3)
            	So we put from offset 1 (has base structure bytes, so is the second byte), 3 bytes from buffer referred by three.
            }
      document a$
      a$={First Line
            Second line
            Third Line
            Ελληνικά Greek Letters
            yä®€
            成长汉
            }
      Save.Doc a$, "checkthis.txt", 2  ' 2 for UTF-8
      b$="*"
      final$=""
      buffer Clear bytes as byte*16
      Buffer One as byte
      Buffer Two as byte*2
      Buffer Three as byte*3
      Locale 1033
      Fall=100/FileLen("checkthis.txt")
      open "checkthis.txt" for input as #f
      seek#f, 4 ' skip BOM
      While b$<>"" {
            Print Over $(1), ~(11), seek(#f)/Fall
            GetOneUtf8Char(&b$)
            final$+=b$
      }
      Print Over $(1), ~(15), "reading done........."
      close #f
      Print
      \\ from cursor settting, Report get the 
      Cursor 20
      Report final$, width-20-8
      Print
      Sub GetOneUtf8Char(&ch$)
            ch$=""
            if Eof(#f) then Exit Sub
            Get #f, One
            Return Bytes, 0:=Eval(one, 0)
            local mrk=Eval(one, 0)
            Try ok {
                  If Binary.And(mrk, 0xE0)=0xC0 then {
                        Get #f,one
                        Return Bytes, 1:=Eval$(one, 0,1) 
                        ch$=Eval$(Bytes, 0, 2)
                  } Else.if Binary.And(mrk, 0xF0)=0xE0 then {
                        Get #f,two
                        Return Bytes, 1:=Eval$(two,0,2)
                        ch$=Eval$(Bytes, 0, 3)
                  } Else.if Binary.And(mrk, 0xF8)=0xF0 then {
                        Get #f,three
                        Return Bytes, 1:=Eval$(three, 0, 3)
                        ch$=Eval$(Bytes, 0, 4)
                  } Else ch$=Eval$(Bytes, 0, 1)
            }
            if Error or not ok then ch$="" : exit sub
            ch$=left$(string$(ch$ as Utf8dec),1)
      End Sub
}
checkit
Italic 1 : Report "Press any key to return to Info": Italic 0
Push Key$ : Drop
Info
}
MODULE RF {Module checkit {
      \\ prepare a file
      \\ Save.Doc and Append.Doc  to file, Load.Doc and Merge.Doc from file
      document a$
      a$={First Line
            Second line
            Third Line
            Ελληνικά Greek Letters
            }
      Save.Doc a$, "checkthis.txt", 2  ' 2 for UTF-8
 
      Buffer1=Buffer("checkthis.txt")
      Print Len(Buffer1)=Filelen("checkthis.txt")
      b$=String$(Eval$(Buffer1, 0) as UTF8Dec)
      Report b$
      openfile$=FILE$("text file","txt")
      Merge.doc a$, openfile$
      Edit.Doc a$
}
checkit
}
MODULE RFL {\\ read a file line by line
Module checkit {
      \\ prepare a file
      document a$
      a$={First Line
            Second line
            Third Line
            }
      Save.Doc a$, "checkthis.txt", 0  ' 0 for UTF-16LE
      Flush
      Open "checkthis.txt" For Wide Input as #F
      While not Eof(#f) {
            Data Seek(#f)
            Line Input #F, b$
            Print  b$
      }
      Close #f
      Dim  Index()
      \\ copy stack to index(), flush stack
      Index()=Array([])
      \\ change base to base 1
      Dim  Base 1, Index(len(index()))
      Open "checkthis.txt" For Wide Input as #F
            Seek#F, Index(2)
            Line Input #F, b$
            Print b$  ' print second line
      Close #f
      \\ prepare Ansi file
      Print "Ansi File"
      Save.Doc a$, "checkthis.txt",  1033  ' we use specific locale
      Flush \\ flush the stack to get indexes
      oldlocale=locale
      locale 1033
      \\ no Wide clause
      Open "checkthis.txt" For  Input as #F
      While not Eof(#f) {
            Data Seek(#f)
            Line Input #F, b$
            Print  b$
      }
      Close #f
      Dim  Index()
      \\ copy stack to index(), flush stack
      Index()=Array([])
      \\ change base to base 1
      Dim  Base 1, Index(len(index()))
      Open "checkthis.txt" For Input as #F
            Seek#F, Index(2)
            Line Input #F, b$
            Print b$  ' print second line
      Close #f
      locale oldlocale
}
checkit
}
MODULE PERMALL {Module Checkit {
      Global a$
      Document a$
      Module Permutations (s){
            Module Level (n, s, h)   {
                  If n=1 then {
                        while Len(s) {
                              m1=each(h)     
                              while m1 {
                                    Print Array$(m1);" ";
                              }
                               Print Array$(S)
                               ToClipBoard()
                               s=cdr(s)
                         }
                  } Else {
                        for i=1 to len(s) {
                              call Level n-1, cdr(s),  cons(h, car(s))
                              s=cons(cdr(s), car(s))
                        }  
                  }
                  Sub ToClipBoard()
                        local m=each(h)
                        Local b$=""
                        While m {
                              b$+=If$(Len(b$)<>0->" ","")+Array$(m)+" "
                        }
                        b$+=If$(Len(b$)<>0->" ","")+Array$(s,0)+" "+{
                        }
                        a$<=b$   ' assign to global need <=
                  End Sub
            }
            If len(s)=0 then Error 
            Head=(,)
            Call Level Len(s),  s, Head
      }
      Clear a$
      Permutations (1,2,3,4)
      Permutations (100, 200, 500)
      Permutations ("A", "B", "C","D")  
      Permutations ("DOG", "CAT", "BAT")    
      ClipBoard a$
}
Checkit
}
MODULE PERMSTEP {Module StepByStep {
      Function PermutationStep (a) {
            c1=lambda (&f, a) ->{
                  =car(a)
                  f=true
            }
            m=len(a)
            c=c1
            while m>1 {
                  c1=lambda c2=c,p, m=(,) (&f, a) ->{
                        if len(m)=0 then m=a
                        =cons(car(m),c2(&f, cdr(m)))
                        if f then f=false:p++:  m=cons(cdr(m), car(m)) : if p=len(m) then p=0 : m=(,):: f=true
                  }
                  c=c1  
                  m--    
            }
            =lambda c, a (&f) -> {
                  =c(&f, a)
            }
      }
      k=false
      StepA=PermutationStep((1,2,3,4))
      while not k {
                 Print StepA(&k) 
      }
      k=false
      StepA=PermutationStep((100,200,300))
      while not k {
                 Print StepA(&k) 
      }
      k=false
      StepA=PermutationStep(("A", "B", "C", "D"))
      while not k {
                 Print StepA(&k) 
      }
      k=false
      StepA=PermutationStep(("DOG", "CAT", "BAT"))
      while not k {
                 Print StepA(&k) 
      }      
}
StepByStep
}
MODULE FACT {Cls , 0
Report {
	Factorial Task
	Definitions
               • The factorial of   0   (zero)   is defined as being   1   (unity).
               • The   Factorial Function   of a positive integer,   n,   is defined as the product of the sequence:
                                                                      n,   n-1,   n-2,   ...   1 
                                                                      
}
Cls, row
Module CheckIt {
      Locale 1033 ' ensure #,### print with comma
      Function factorial (n){
            If n<0 then Error "Factorial Error!"
            If n>27 then Error "Overflow"
 
            m=1@:While n>1 {m*=n:n--}:=m
      }
      Const Proportional=4
      Const ProportionalLeftJustification=5
      Const NonProportional=0
      Const NonProportionalLeftJustification=1
      For i=1 to 27 
      \\ we can print over (erasing line first), without new line at the end
      \\ and we can change how numbers apears, and the with of columns
      \\ numbers by default have right justification
      \\ all $() format have temporary use in this kind of print.
      Print Over $(Proportional),$("\f\a\c\t\o\r\i\a\l\(#\)\=",15), i, $(ProportionalLeftJustification), $("#,###",40), factorial(i)
      Print        \\ new line
      Next i
}
Checkit
}
MODULE TTT {Module Tic.Tac.Toe {
      Dim Board$(1 to 3, 1 to 3)=" "
      WinGame=False
      p=Board$()
      RandomPosition=lambda -> {
            =(random(1,3), random(1,3))
      }
 
      BoardItemEmpty=Lambda p (x, y) -> {
            =Array$(p, x, y)=" "
      }
      BoardSetItem=Lambda p (x, y, w$) -> {
            link p to a$()
            a$(x, y)=w$
      }
      T=9
      R=0
      C=0
      Repeat {
            Print "Computer Move:"
            CompMove()
            T--
            DrawBoard()
            CheckWin()
            if WinGame Then Print "Computer Win": Exit
            if T=0 then exit
            Repeat {
                  GetRowCol("Input Row", &R)
                  GetRowCol("Input Column", &C)
                  If BoardItemEmpty(R,C) then call boardsetitem(R,C,"O") : exit 
            } Always
            T--
            DrawBoard()
            CheckWin()
            if WinGame Then Print "You Win": Exit
      } until T=0 or WinGame
      Sub DrawBoard()
      Print "R/C 1 2 3"
      Print " 1) "; Board$(1,1);"|";Board$(1,2);"|";Board$(1,3)
      Print "    -+-+-"
      Print " 2) "; Board$(2,1);"|";Board$(2,2);"|";Board$(2,3)
      Print "    -+-+-"
      Print " 3) "; Board$(3,1);"|";Board$(3,2);"|";Board$(3,3)
      End Sub
      Sub CheckWin()
            WinGame=false
            local i,j,three$
            For i=1 to 3
                  three$=""
                  For j=1 to 3 : three$+=Board$(i,j) : Next j
                  CheckThree()
                  three$=""
                  For j=1 to 3 :  three$+=Board$(j,i) :Next j
                  CheckThree()
            Next i
            three$=""
            For i=1 to 3 : three$+=Board$(i,i): Next i
            CheckThree()
            three$=""
            For i=1 to 3:three$+=Board$(i,4-i): Next i
            CheckThree()
      End Sub
      Sub CheckThree()
            if instr(three$," ")=0 then  WinGame=WinGame or Filter$(three$, left$(three$,1))=""
      End Sub
      Sub CompMove()
            if T<9 and Board$(2,2)=" " then {
                  call boardsetitem(2,2,"X")
            } Else {
                  local i=3, j=3, found=false
                  if T<=6 then {
                        CompThink("X","X")
                  } 
                  let i=3, j=3
                  If Not found And T<6 then {
                        CompThink("O","X")    
                  }
                  If not found then {
                        Repeat {
                              comp=RandomPosition()
                              If BoardItemEmpty(!comp) then call boardsetitem(!comp, "X") : exit
                        } Always
                  }
            }
      End Sub
      Sub CompThink(Bad$, Good$)
                        While i>0 {
                              j=3
                              While j>0 {
                                    if Board$(i,j)=" " then {
                                          Board$(i,j)=Bad$
                                          CheckWin()
                                          if WinGame then {
                                                 Board$(i,j)=Good$:i=0:j=0: found=true
                                          } Else Board$(i,j)=" "
                                    }
                                    j--
                              }
                              i--
                        }
 
      End Sub
      Sub GetRowCol(What$, &W)
            Print What$;":";
            Repeat {
                  W=Val("0"+Key$)
            } until W>=1 and W<=3
            Print Str$(W,"")
      End Sub
}
Tic.Tac.Toe
}
MODULE GUESS {Module GuessNumber {
      Read Min, Max
      chosen = Random(Min, Max)
      print "guess a whole number between ";Min;" and ";Max
      do
                  \\ we use guess so Input get integer value
                  \\ if we press enter without a number we get error
                  do
                        \\ if we get error then we change line, checking the cursor position
                        If Pos>0 then Print
                        Try ok {
                              input "Enter your number " , guess%
                        }
                  until ok
                  Select Case guess%
                  case  min to chosen-1
                        print "Sorry, your number was too low"
                  case chosen+1 to max
                        print "Sorry, your number was too high"
                  case chosen 
                        print "Well guessed!"
                  else case
                        print "That was an invalid number"
                  end select
      until guess% = chosen
}
GuessNumber 5, 15
}
MODULE GUESS1 {Module QBASIC_Based {
      supervisor:
      GOSUB initialize
      GOSUB guessing
      GOTO continue
 
      initialize:
      \\ Not need to RANDOMIZE TIMER
      \\ we can use Random(1, 100) to get a number from 1 to 100
      n = 0: r = INT(RND * 100 + 1): g = 0: c$ = ""
      RETURN
 
      guessing:
      WHILE g <> r
                INPUT "Pick a number between 1 and 100:"; g
                IF g = r THEN
                    PRINT "You got it!"
                    n ++
                    PRINT "It took "; n; " tries to pick the right number."
                ELSE.IF g < r THEN
                    PRINT "Try a larger number."
                    n ++
                ELSE
                    PRINT "Try a smaller number."
                    n++
                END IF
      END WHILE
      RETURN
 
      continue:
      WHILE c$ <> "YES" AND c$ <> "NO"
          INPUT "Do you want to continue? (YES/NO)"; c$
          c$ = UCASE$(c$)
      END WHILE
      IF c$ = "YES" THEN GOTO supervisor
}
QBASIC_Based
}
MODULE DAY {Print "December 25 is a Sunday in:"
For Year=2008 to 2121 { 
      if  Str$(Date("25/12/"+str$(Year,"")),"w")="1" Then {
            Print Year
      }
}
\\ is the same with this:
Print "December 25 is a Sunday in:"
For Year=2008 to 2121 { 
      if  Str$(Date(str$(Year,"")+"-12-25"),"w")="1" Then {
            Print Year
      }
}
 
}
MODULE FILETIME {Module CheckIt {
      \\ without *for wide output*  we open for ANSI (1 byte per character)
      \\ but here we need it only for the creation of a file
      Open "afile" for output as #f
      Close #f
      Print file.stamp("afile")   'it is a number in VB6 date format.
      \\ day format as for Greece
      Print Str$(File.Stamp("afile"),"hh:nn:ss dd/mm/yyyy") , "utc write time - by default"
      Print Str$(File.Stamp("afile" ,1),"hh:nn:ss dd/mm/yyyy") , "utc write time, 1"
      Print  Str$(File.Stamp("afile" ,-1),"hh:nn:ss dd/mm/yyyy"), "local write time, -1"
      Print Str$(File.Stamp("afile" ,2),"hh:nn:ss dd/mm/yyyy"), "utc creation time, 2"
      Print  Str$(File.Stamp("afile" ,-2),"hh:nn:ss dd/mm/yyyy"), "local creation time, -2"
}
Checkit
}
MODULE SPEED {Cls,0
Report {
	Time a function
	Using a timer (with the least granularity available) to time how long a function takes to execute
	
	The Test function get one type each time
	
	10000% is Integer 16bit
	
	10000& is Long 32bit
	
	10000@ is Decimal
	
	10000# is Currency
	
	10000~ is Float
	
	10000 is Double (default) 
	
}
cls,row
Module Checkit {
      Module sumtolimit (limit) {
           sum=limit-limit
           n=sum
           n++
           while limit {sum+=limit*n:limit--:n-!}
      }
      Profiler
      sumtolimit 10000%
      Print TimeCount
      Profiler
      sumtolimit 10000&
      Print TimeCount
      Profiler
      sumtolimit 10000#
      Print TimeCount
      Profiler
      sumtolimit 10000@
      Print TimeCount
      Profiler
      sumtolimit 10000~
      Print TimeCount
      Profiler
      sumtolimit 10000
      Print TimeCount
}
Print "Set Slow - more screen refresh - more time to OS"
Set Slow
Checkit
Print "Set Fast - the default"
Set Fast
Checkit
Refresh
Print "Set Fast !  - less screen refresh"
Set Fast !
Checkit
Refresh
Set Fast
}
MODULE STIME {print str$(now,"long time"), time$(now)
}
MODULE SDATE {Print str$(today, "yyyy-mm-dd")
Print str$(today, "dddd, mmm, dd, yyyy")
Print Date$(today, 1033, "dddd, MMM, dd, yyyy")
Print Date$(today, 1036, "dddd, MMM dd, yyyy")
Print Date$(today, 1047, "dddd, MMM dd, yyyy")
Print Date$(today, 1048, "dddd, MMM dd, yyyy")
Module Checkit(locale_id, Locale_out) {
      Enum zones {HAST=-10, HADT,PST, MST, CST, EST, AST, NST=-3.5, UTC=0, WET=0, GMT=0, BST=1,IST=1, CET=1, EET, MSK,MSD}
      INP$="March 7 2009 7:30pm EST"
      dim a$()
      a$()=Piece$(INP$," ")
      date1=date(leftpart$(INP$, a$(3)), locale_id)
      zone=UTC
      Try {
            zone=Eval(a#val$(4))
      }
      date0=date1+time(a$(3))
      Document doc$="Input date:"+{
      }
      doc$= Date$(date0 , Locale_out, "MMMM d, yyyy ")+" "+Lcase$(Time$(date0,1033, "hh:mmtt"))+" "+eval$(zone)+{
      }+"12 hours later:"+{
      }
      m=each(zones)
      while m {
            date2=date1+ctime(time(a$(3)),12+eval(m)-zone,frac(eval(m)-zone)*60,0)      
            doc$=Date$(date2 , Locale_out, "MMMM d, yyyy ")+Lcase$(Time$(date2,1033, "hh:mmtt"))+" "+eval$(m)+{
            }
      }
      Report Doc$
      Clipboard Doc$
}
Checkit 1033, 1036
Checkit 1033, 1032
}
MODULE ENV {Module CheckIt {
      \\ using read only variablles
      Print "Platform: ";Platform$
      Print "Computer Os: "; Os$
      Print "Type of OS: ";OsBit;" bit"
      Print "Computer Name:";  Computer$
      Print "User Name: "; User.Name$
      \\ using WScript.Shell
      Declare objShell "WScript.Shell"
      With  objShell, "Environment" set env ("Process")
      With env, "item" as Env$()
      Print Env$("PATH")
      Print Env$("HOMEPATH")
      Declare objShell Nothing
      \\ using internal Information object
      Declare OsInfo INFORMATION
      With OsInfo, "build" as build, "NtDllVersion" as NtDllVersion$
      Method OsInfo, "GetCurrentProcessSID" as PID$
      Method OsInfo, "IsProcessElevated" as isElevated
      Print "Os build number: ";build
      Print "Nr Dll version: ";NtDllVersion$
      Print "ProcessSID: ";pid$
      Print "Is Process Eleveted: ";isElevated
      Declare OsInfo Nothing
}
Checkit
}
MODULE HELLO {Module CheckIt {
      Declare Simple Form
      \\ we can define form before open
      Layer Simple {
            \\ center Window with 12pt font, 12000 twips width and 6000 twips height
            \\ ; at the end command to center the form in current screen
            Window 12, 12000, 6000;
            \\ make layer gray and split screen 0
            Cls #333333, 0
            \\   set split screen to 3rd line, like Cls ,2 without clear screen
            Scroll Split 2
            Cursor 0, 2
      }
      With Simple, "Title", "Hello Form"
      Function Simple.Click {
            Layer Simple {
                  \\ open msgbox
                  Print Ask("Hello World")
                  Refresh
            }
      }
      \\ now open as modal
      Method Simple, "Show", 1
      \\ now form deleted
      Declare Simple Nothing
}
CheckIt
}
MODULE BUTTON {Module CheckIt {
      Declare Form1  Form
      Declare Label1 Button Form Form1
      Declare Button1 Button Form Form1
      Method Label1,"move", 2000, 2000, 4000, 600
      Method Button1,"move", 2000, 3000, 4000, 600
      With Label1, "Caption" as caption$, "Locked", true, "Caption" as cap
      With Button1, "Caption", "click me", "Default", True   ' make this the default control
      caption$="There have been no clicks yet"
      m=0
      Function Button1.Click {
                  m++
                  cap=m
      }
      Method Form1, "Show",1
      Declare Form1 Nothing
}
Checkit
}
MODULE INTERACTION {Module CheckIt {
      Declare form1 form
      Declare textbox1 textbox form form1
      Declare buttonInc Button form form1
      Declare buttonRND Button form form1
      Method textbox1, "move", 2000,2000,4000,600
      Method buttonInc, "move", 2000,3000,2000,600
      Method buttonRND, "move", 4000,3000,2000,600
      With form1, "Title", "Rosetta Code: GUI component interaction"
      With textbox1,"vartext" as textbox1.value$, "Prompt", "Value:", "ShowAlways", true
      With buttonInc,"Caption","Increment"
      With buttonRND,"Caption","Random"
      textbox1.value$="0"
      Function Local1(new Feed$) {
            \\ this Function can be used from other Integer 
            \\ this$ and thispos, exist just before the call of this Function
            local sgn$
            if feed$="" and this$="-" then thispos-- :  exit
            if left$(this$,1)="-" then sgn$="-": this$=mid$(this$, 2)
            if this$<>Trim$(this$)  then  this$=Feed$ :  thispos-- : exit
            If Trim$(this$)="" then this$="0" : thispos=2 : exit
            if instr(this$,"+")>0 and sgn$="-" then this$=filter$(this$, "+") : sgn$=""
            if instr(this$,"-")>0  and sgn$="" then this$=filter$(this$, "-") : sgn$="-"
            if filter$(this$,"0123456789")<>"" then this$=Feed$ :  thispos-- : exit
            if len(this$)>1 then While  left$(this$,1)="0" {this$=mid$(this$, 2)} 
            this$=sgn$+this$
            if this$="-0" then this$="-" : thispos=2
        }
      Function TextBox1.ValidString {
                  \\ this Function called direct from textbox
                  Read  New &this$, &thispos
                  Call Local local1(textbox1.value$)
      }
      Function buttonInc.Click {
               textbox1.value$=str$(val(textbox1.value$)+1, "")
      }
      Function buttonRND.Click {
            If  AsK$("Change Value with random number", "Question", "Yes", "No")="Yes" Then {
                      textbox1.value$=str$(Random(0, 10000), "")
                      After 100 {Try {Method textbox1,"GetFocus"}}
            }
      }
      \\ open modal
      Method form1, "show", 1
      Declare form1 nothing
}
Checkit
}
MODULE INTER2 {\ this is global, but call as local in events, which means with local visibility for identifiers
\\ so thispos and this$ has to exist in caller 's context

Cls, 0
Report {
	You can increment the value if is less from 10
	You can decrement the value if is higher than 0
	If value is 0 then you can write a new value
	You can use enter as click event, or a mouse clik on either button.
} 
Function Global Local1(new Feed$) {
            \\ this function can be used from other Integer 
            \\ this$ and thispos, exist just before the call of this function
            local sgn$
            if feed$="" and this$="-" then thispos-- :  exit
            if left$(this$,1)="-" then sgn$="-": this$=mid$(this$, 2)
            if this$<>Trim$(this$)  then  this$=Feed$ :  thispos-- : exit
            If Trim$(this$)="" then this$="0" : thispos=2 : exit
            if instr(this$,"+")>0 and sgn$="-" then this$=filter$(this$, "+") : sgn$=""
            if instr(this$,"-")>0  and sgn$="" then this$=filter$(this$, "-") : sgn$="-"
            if filter$(this$,"0123456789")<>"" then this$=Feed$ :  thispos-- : exit
            if len(this$)>1 then While  left$(this$,1)="0" {this$=mid$(this$, 2)} 
            this$=sgn$+this$
            if this$="-0" then this$="-" : thispos=2
        }
Module CheckIt {
      Declare form1 form
      Declare textbox1 textbox form form1
      Declare buttonInc Button form form1
      Declare buttonDec Button form form1
      Method textbox1, "move", 2000,2000,4000,600
      Method buttonInc, "move", 2000,3000,2000,600
      Method buttonDec, "move", 4000,3000,2000,600
      With textbox1,"vartext" as textbox1.value$, "Prompt", "Value:" ', "ShowAlways", True
      With buttonInc,"Caption","Increment" 
      With buttonDec,"Caption","Decrement","Locked", True
      textbox1.value$="0"
 
      Function controlIncDec(what$){
            With buttonInc, "locked",  not val(what$)<10
            With buttonDec, "locked", not val(what$)>0
      }
      finishEnter=false      
      Function TextBox1.ValidString {
                  \\ this function called direct from textbox
                  Read  New &this$, &thispos
                  Call Local local1(textbox1.value$)
                  Call Local controlIncDec(this$)
      }
      Function TextBox1.Enable {
            With TextBox1, "Enabled", true
            finishEnter=false
      }
      Function TextBox1.Disable {
            With TextBox1, "Enabled", false
            finishEnter=true
      }
      Function TextBox1.Enter {
            Call Local TextBox1.Disable()
      }
      Function buttonInc.Click {
                if  not finishEnter then Call Local TextBox1.Disable()
               textbox1.value$=str$(val(textbox1.value$)+1, "")
                if val(textbox1.value$)=0 then Call Local TextBox1.Enable()
      }
      function buttonDec.Click {
                if  not finishEnter then Call Local TextBox1.Disable()
                textbox1.value$=str$(val(textbox1.value$)-1, "")     
                if val(textbox1.value$)=0 then Call Local TextBox1.Enable()
      }
      Call Local controlIncDec(textBox1.Value$)
      Method form1, "show", 1
      Declare form1 nothing
}
Checkit
}
MODULE PRTRY {\\ use printer properties to set number of copies
Printer !

if ask("Is printer on","Printing Test","Yes","No")=1 then
	set slow
	\\ use PAGE 1 for new page Portrait or leave it to produce new page if more lines needed.
	\\  PAGE 0 set page to Landscape
	
	printing on
	
	\\ don't forget to set pen to black.
	Pen 0
	\\ you can define font also
	font "Courier New"
	\\ you can define characters by lines, so Mode (size of character) and Linespace produced automatic
	Form 80, 66
	For I=1 TO 85
	Print I
	Next I
	
	printing off
end if
set fast
}
MODULE ADDMUL {\\ Sum and product of an array
Module Checkit {
      a = (1,2,3,4,5,6,7,8,9,10)
      print a#sum() = 55
      sum = lambda->{push number+number}
      product = lambda->{Push number*number}
      print a#fold(lambda->{Push number*number}, 1), a#fold(lambda->{push number+number},0)
      dim a(2,2) = 5
      Print a()#sum() = 20
}
checkit
}
MODULE MULSH {Module CheckIt {
      Dim Base 1, A(12)
      Mult=lambda (n)-> {
            Flush  ' empty stack
            For i=1 to n : Data i*n : Next i
            =Array([])   ' copy stack in an array, and return a pointer
      }
      i=Each(A())
      Print "  |";
      while i {
            Print Format$("{0:0:-4}",i^+1);
            A(i^+1)=Mult(i^+1)
      }
      Print
      Print "--+"+string$("-",4*12)
      For i=1 to 12 {
            Print Format$("{0:0:-2}|",i); 
            For j=1 to 12 {
                  If len(A(j)())>=i then {
                        Print Format$("{0:0:-4}",A(j)(i-1));
                  } Else Print "    ";
            }
            Print
      }
}
CheckIt

Module CheckIt2 {
      Dim Base 1, A(12)
      Mult=lambda (n)-> {
            Flush  ' empty stack
            For i=1 to n : Data i*n : Next i
            =Array([])   ' copy stack in an array, and return a pointer
      }
      i=Each(A())
      Print "  |";
      while i {
            Print Format$("{0:0:-4}",i^+1);
            A(i^+1)=Mult(i^+1)
      }
      Print
      Print "--+"+string$("-",4*12)
      For i=1 to 12 {
            j=Each(A())
            Print Format$("{0:0:-2}|",i); 
            While j {
                  r1=A(j^+1)
                  If len(r1)>=i then {
                        Print Format$("{0:0:-4}",Array(r1,i-1));
                  } Else Print "    ";
            }
            Print
      }
}
CheckIt2
}
MODULE PA15 {Module Puzzle15 {
\\ BASIC STYLE  FROM COMMODORE BASIC
\\ http://www.rosettacode.org/wiki/15_Puzzle_Game#COMMODORE_BASIC
REM {
I make a function RND() and I set Base for arrays to 1 Also I put some semi colons to Print statement Also I have to put variables after NEXT statements To be actual BASIC compatible we have to set FOR NEXT like BASIC, because for M2000 the direction defined by the starting-ending values, so always we get at least one time the block between FOR NEXT. So we can use:

SET SWITCHES "+FOR"

But here we don't have to skip FOR NEXT and no STEP clause used.

Also the code is not the best, because we can move from 4 position to 5 (we can't do that with real puzzle) 
}
Escape OFF
TRY {
            00 BASE 1 : DEF RND(X)=RND
            10 REM 15-PUZZLE GAME
            20 REM COMMODORE BASIC 2.0
            30 REM ********************************
            40 GOSUB 400 : REM' INTRO AND LEVEL
            50 GOSUB 510 : REM' SETUP BOARD
            60 GOSUB 210 : REM' PRINT PUZZLE
            70 PRINT "TO MOVE A PIECE, ENTER ITS NUMBER:"
            80 INPUT X
            90 GOSUB 730 : REM' CHECK IF MOVE IS VALID
            100 IF MV=0 THEN PRINT "WRONG MOVE" : GOSUB 1050 : GOTO 60
            110 D(Z)=X : D(Y)=0
            120 GOSUB 210 : REM' PRINT PUZZLE
            130 GOSUB 950 : REM' CHECK IF PUZZLE COMPLETE
            140 IF PC THEN 160
            150 GOTO 70
            160 PRINT"YOU WON!"
            170 END
            180 REM
            190 REM' *******************************
            200 REM' PRINT/DRAW THE PUZZLE
            210 FOR P=1 TO 16
            220   IF D(P)=0 THEN D$(P)="     " : GOTO 260
            230   S$=STR$(D(P))
            240   N=LEN(S$)
            250   D$(P) = LEFT$("   ",3-N)+S$+"  "
            260 NEXT P
            270 PRINT "+-----+-----+-----+-----+"
            280 PRINT "!";D$(1);"!";D$(2);"!";D$(3);"!";D$(4);"!"
            290 PRINT "+-----+-----+-----+-----+"
            300 PRINT "!";D$(5);"!";D$(6);"!";D$(7);"!";D$(8);"!"
            310 PRINT "+-----+-----+-----+-----+"
            320 PRINT "!";D$(9);"!";D$(10);"!";D$(11);"!";D$(12);"!"
            330 PRINT "+-----+-----+-----+-----+"
            340 PRINT "!";D$(13);"!";D$(14);"!";D$(15);"!";D$(16);"!"
            350 PRINT "+-----+-----+-----+-----+"
            360 RETURN
            370 REM
            380 REM' *******************************
            390 REM' INTRO AND LEVEL OF DIFFICULTY
            400 PRINT CHR$(147)
            410 DIM SH(3) : SH(1)=10 : SH(2)=50 : SH(3)=100
            420 PRINT "15 PUZZLE GAME FOR COMMODORE BASIC 2.0" : PRINT : PRINT
            430 PRINT "PLEASE ENTER LEVEL OF DIFFICULTY,"
            440 PRINT "1(EASY), 2(MEDIUM) OR 3(HARD):";
            450 INPUT V
            460 IF V<1 OR V>3 THEN 440
            470 RETURN
            480 REM
            490 REM' *******************************
            500 REM' BUILD THE BOARD
            510 DIM D(16) : DIM D$(16) : REM' BOARD PIECES
            520 REM' SET PIECES IN CORRECT ORDER FIRST
            530 FOR P=1 TO 15
            540   D(P) = P
            550 NEXT P
            560 D(16) = 0 : REM' 0 = EMPTY PIECE/SLOT
            570 Z=16      : REM' Z = EMPTY POSITION
            580 PRINT: PRINT "SHUFFLING PIECES";
            590 FOR N=1 TO SH(V)
            600   PRINT".";
            610   X = INT(RND(0)*4)+1
            620   R = Z+(X=1)*4-(X=2)*4+(X=3)-(X=4)
            630   IF R<1 OR R>16 THEN 610
            640   D(Z)=D(R)
            650   Z=R
            660   D(Z)=0
            670 NEXT N
            680 PRINT CHR$(147)
            690 RETURN
            700 REM
            710 REM' *******************************
            720 REM' CHECK IF MOVE IS VALID
            730 MV = 0
            740 IF X<1 OR X>15 THEN RETURN
            750 REM' FIND POSITION OF PIECE X
            760 P=1
            770 IF D(P)=X THEN Y=P : GOTO 810
            780 P=P+1 : IF P>16 THEN PRINT "UH OH!" : STOP
            790 GOTO 770
            800 REM' FIND POSITION OF EMPTY PIECE
            810 P=1
            820 IF D(P)=0 THEN Z=P : GOTO 860
            830 P=P+1 : IF P>16 THEN PRINT "UH OH!" : STOP
            840 GOTO 820
            850 PRINT Y;Z
            860 REM' CHECK IF EMPTY PIECE IS ABOVE, BELOW, LEFT OR RIGHT TO PIECE X
            870 IF Y-4=Z THEN MV=1 : RETURN
            880 IF Y+4=Z THEN MV=1 : RETURN
            890 IF Y-1=Z THEN MV=1 : RETURN
            900 IF Y+1=Z THEN MV=1 : RETURN
            910 RETURN
            920 REM
            930 REM' *******************************
            940 REM' CHECK IF PUZZLE IS COMPLETE / GAME OVER
            950 PC = 0
            960 P=1
            970 IF D(P)<>P THEN RETURN
            980 P=P+1
            990 IF P<16 THEN 970
            1000 PC = 1
            1010 RETURN
            1020 REM
            1030 REM' ******************************
            1040 REM' A SMALL DELAY
            1050 FOR T=0 TO 400
            1060 NEXT T
            1070 RETURN
}
\\ SET BACK THE BASE OF ARRAYS
BASE 0
}
Puzzle15
}
MODULE CRYPTO {\\ https://en.wikipedia.org/wiki/RIPEMD
\\ The original RIPEMD function was designed in the framework of the EU project RIPE (RACE Integrity Primitives Evaluation) in 1992
\\ RIPEMD-160 is 160bit cryptographic hash function.

Module Checkit {
	Function Prepare_RiPeMd_160 {
		Dim Base 0,  K(5), K1(5)
		K(0)=0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E
		K1(0)=0x50A28BE6,0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000
		Dim Base 0,r(80), r1(80), s(80), s1(80)
		r(0)=0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
		r(16)=7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8
		r(32)= 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12
		r(48)=1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2
		r(64)=4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
		k=r() : k*=4   ' k is a pointer to array. We have to multiply to make them offsets
		
		r1(0)=5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12
		r1(16)=6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2
		r1(32)=15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13
		r1(48)=8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14
		r1(64)=12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
		
		k=r1() : k*=4
		
		s(0)=11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8
		s(16)=7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12
		s(32)=11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5
		s(48)=11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12
		s(64)=9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
		
		s1(0)=8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6
		s1(16)=9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11
		s1(32)=9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5
		s1(48)=15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8
		s1(64)=8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
		
		Dim Base 0, T(5), TT(5)
		T(0)=lambda ->binary.xor(binary.xor(number,number),number)
		T(1)=lambda (B,C,D)->binary.or(binary.and(B,C), binary.and(binary.not(B), D))
		T(2)=lambda ->binary.xor(binary.or(number, binary.not(number)), number)
		T(3)=lambda (B,C,D)->binary.or(binary.and(B,D), binary.and(C,binary.not(D)))
		T(4)=lambda ->binary.xor(number, binary.or(number, binary.not(number)))
		
		\\ no need for variables we read form stack with number
		TT(0)=lambda ->binary.xor(number, binary.or(number, binary.not(number)))
		TT(1)=lambda (BB,CC,DD)->binary.or(binary.and(BB,DD), binary.and(CC,binary.not(DD)))	
		TT(2)=lambda ->binary.xor(binary.or(number, binary.not(number)), number)
		TT(3)=lambda (BB,CC,DD)->binary.or(binary.and(BB,CC), binary.and(binary.not(BB),DD))	
		TT(4)=lambda ->binary.xor(binary.xor(number,number),number)
		
		\\ return of this function is a lambda function
		\\ all arrays are closures to this lambda
		=lambda K(),K1(),TT(), T(),r(),r1(), s(), s1() (&message$, ansi as boolean=true, ansiid=1033)-> {
			set fast!
			def h0 = 0x67452301, h1 = 0xEFCDAB89, h2 = 0x98BADCFE
			def h3 = 0x10325476, h4 = 0xC3D2E1F0
			def i, j, l, padding, l1, blocks, acc, f64 as boolean=true, oldid
			if ansi then oldid=locale : locale ansiid
			\\ we use a buffer of 64 bytes
			buffer clear message as byte*64
			l=len(message$)*if(ansi->1,2 )
			if binary.and(l,63)>55 then  padding=64 
			padding+= 64 - (l Mod 64)
			l1=padding+l+1
	
			f64=binary.and(l,63)<>0
	
			blocks=l1 div 64
rem
			Print "blocks:";blocks
			\\ now prepare the buffer
			PrepareBuffer()
			def decimal  A, B, C, D, E, AA, BB, CC, DD, EE, T, TT
			do
			A  = h0 : B  = h1 : C  = h2 : D  = h3 : E  = h4
			AA = h0 : BB = h1 : CC = h2 : DD = h3 : EE = h4
			for J=0 to 79 {
				JJ=J DIV 16
				PUSH binary.add(Binary.Rotate(binary.add(A,T(JJ)(B,C,D),eval(message ,r(j) as long),k(jj)), s(j)), e)
				A = E : E = D : D = Binary.Rotate(C, 10) : C = B : READ B 
				PUSH binary.add(Binary.Rotate(binary.add(AA,TT(JJ)(BB,CC,DD),eval(message, r1(j) as long),k1(jj)),s1(j)),EE)
				AA = EE : EE = DD : DD = Binary.Rotate(CC, 10) : CC = BB : READ BB
			}
			push binary.add(h1, C, DD)
			h1 = binary.add(h2, D, EE)
			h2 = binary.add(h3, E, AA)
			h3 = binary.add(h4, A, BB)
			h4 = binary.add(h0, B, CC)
			Read h0
			blocks--
rem
			print over $(0,8), blocks : Refresh
			if blocks=0 then exit
			PrepareBuffer()
			always
rem
			print
			buffer ans as byte*20
			\\ we put ulong (long ar ulong in buffers)
			Return ans, 0:=h0 as long, 4:=h1 as long,8:=h2 as long, 12:=h3 as long, 16:=h4 as long
			=ans
			if ansi then locale oldid
			set fast
			Sub PrepareBuffer()
				
				if l-acc>=64 then
					LoadPart(64)
				else.if blocks=1 then
					return message, 0:=string$(chr$(0),32)
					if l-acc=0 and f64 then
						Return message, 56:=l*8 as long, 60 :=binary.shift(l,-29) as long
					else
						Return message, l-acc:=0x80, 56:=l*8 as long, 60 :=binary.shift(l,-29) as long
						if l>acc then LoadPart(l-acc)
					end if
				else
					Return message, l-acc:=0x80
					LoadPart(l-acc)
				end if
			End Sub
			sub LoadPart(many)
				\\ str$() convert to ansi, one byte per character
				\\ using 1033 as Ansi language
				if ansi then
					Return message, 0:=str$(mid$(message$,1+acc, many))
				else
					Return message, 0:=mid$(message$, 1+acc, many)
				end if
				acc+=many
			end sub
		}
	}
	Module TestHash (RIPEMD){
		Flush
		\\ push data to stack of values, as fifo (each entry append to end of stack)
		Data "b3be159860842cebaa7174c8fff0aa9e50a5199f","Rosetta Code"
		Data "9c1185a5c5e9fc54612808977ee8f548b2258d31",""
		Data "0bdc9d2d256b3ee9daae347be6f4dc835a467ffe","a"
		Data "8eb208f7e05d987a9b044a8e98c6b087f15a0bfc","abc"
		Data "5d0689ef49d2fae572b881b123a85ffa21595f36", "message digest"
		Data "f71c27109c692c1b56bbdceb5b9d2865b3708dbc","abcdefghijklmnopqrstuvwxyz"
		Data "b0e20b6e3116640286ed3a87a5713079b21f5189"
		Data "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
		Data "9b752e45573d4b39f4dbd3323cab82bf63326bfb", String$("1234567890",8)
rem		Data "52783243c1697bdbe16d37f97f68f08325dc1528", String$("a",1000000)
		
		While not empty
			Read check$, text$
			Print "RIPEMD160 for ";quote$(Left$(if$(len(text$)>30->left$(text$,27)+"...",  text$),30))
			\\ pass text$ by reference
			Display(RIPEMD(&text$))
		End While
		
		sub Display(ans)
			local answer$
			for i=0 to len(ans)-1
				answer$+=hex$(eval(ans,i),1)
			next i
			Print lcase$(answer$)
			Print lcase$(answer$)=check$
		end sub
	}
	TestHash Prepare_RiPeMd_160()	
}
Checkit
}
MODULE DIJKSTRA {Module Dijkstra`s_algorithm {
        const max_number=infinity '1.E+306
        GetArr=lambda (n, val)->{
                dim d(n)=val
                =d()
        }
        term=("",0)
        Edges=(("a", ("b",7),("c",9),("f",14)),("b",("c",10),("d",15)),("c",("d",11),("f",2)),("d",("e",6)),("e",("f", 9)),("f",term))
        Document Doc$="Graph:"+{
        }
        ShowGraph()
        Doc$="Paths"+{
        }
        Print "Paths"
        For from_here=0 to 5
                pa=GetArr(len(Edges), -1)
                d=GetArr(len(Edges), max_number)
                Inventory S=1,2,3,4,5,6
                return d, from_here:=0
                RemoveMin=Lambda S, d, max_number-> {
                        ss=each(S)
                        min=max_number
                        p=0
                        while ss
                                val=d#val(eval(S,ss^)-1)
                                if min>val then let min=val : p=ss^ 
                        end while
                        =s(p!)  ' use p as index not key
                        Delete S, eval(s,p)
                }
                Show_Distance_and_Path$=lambda$ d, pa, from_here, max_number (n) -> {
                        ret1$=chr$(from_here+asc("a"))+" to "+chr$(n+asc("a"))
                        if d#val(n) =max_number then =ret1$+ "No Path" :exit
                        let ret$="", mm=n, m=n
                        repeat
                                n=m
                                ret$+=chr$(asc("a")+n)
                                m=pa#val(n)
                        until  from_here=n 
                        =ret1$+format$("{0::-4} {1}",d#val(mm),strrev$(ret$))
                }
                while len(s)>0 
                        u=RemoveMin()
                        rem Print u, chr$(u-1+asc("a"))
                        Relaxed()
                end while
                For i=0 to len(d)-1
                        line$=Show_Distance_and_Path$(i)
                        Print line$
                        doc$=line$+{
                        }
                next
        next
        Clipboard Doc$
        End
        Sub Relaxed()
                local vertex=Edges#val(u-1), i
                local e=Len(vertex)-1, edge=(,), val
                for i=1 to e
                        edge=vertex#val(i)
                        if edge#val$(0)<>"" then
                                val=Asc(edge#val$(0))-Asc("a")
                                if d#val(val)>edge#val(1)+d#val(u-1) then  return d, val:=edge#val(1)+d#val(u-1) : Return Pa, val:=u-1
                        end if
                next 
        end sub
        Sub ShowGraph()
                Print "Graph"
                local i
                for i=1 to len(Edges)
                        show_edges(i)
                next
        end sub
        Sub show_edges(n)
                n--
                local vertex=Edges#val(n), line$
                local e=each(vertex 2 to end), v2=(,)
                While e 
                        v2=array(e)
                        line$=vertex#val$(0)+if$(v2#val$(0)<>""->"->"+v2#val$(0)+format$(" {0::-2}",v2#val(1)),"")
                        Print line$
                        Doc$=line$+{
                        }
                end while
        end sub
}
Dijkstra`s_algorithm

}
MODULE ANT {Flush
Set Fast !
Escape off
Esc=False
Form 120,102
Double
Print "Langton's ant"
Print "press right mouse button to draw partial image"
Print "press left mouse button to exit"
Normal
N=100
refresh
Enum CellColor {black=0,white=#FFFFFF}
Enum Direction{North=90, West=180, South=270, East=0}
Function Rotate(cd as Direction, clockwise=true) {
		cd=(cd+if(clockwise->270,90)) mod 360
		=cd  ' return a Direction Enum type
}
 
dim rect(1 to N, 1 to N)=white
cx=N div 3
cy=N div 3
cd=North
rect(cx,cy)=black
endmove=False
m=1
while not endmove
	movecell()
	if m mod 20=0 then if keypress(1) then if ask("Quit")=1 then  Esc=true : exit while
	m++ : if keypress(2) then Disp()
end while
if not Esc then
	Disp(true)
	refresh 40
	a$=key$
end if
Escape ON
Set Fast
keyboard "INFO"+chr$(13)
sub movecell()
	select case rect(cx,cy)
	case black
		cd=Rotate(cd, false) : rect(cx, cy)=white
	case white
		cd=Rotate(cd) : rect(cx, cy)=black
	end select
	select case cd
	case North
		cy--
	case West
		cx--
	case South
		cy++
	case East
		cx++
	end select
	endmove= cx<1 or cx>N or cy<1 or cy>N
end sub
sub disp(clip=false)
	Local Doc$, i, j
	Document Doc$
	for j=1 to N:for i=1 to N
		Doc$=if$(rect(i, j)=White->"_","#")
	next
	Doc$={
	}
	next
	cls
	Print #-2,Doc$
	refresh 1000
	if clip then clipboard Doc$ : Cursor 0, 100 : Print "Done", @(100),"Press any key"
end sub

}
MODULE ANON {\\ Anonymous Functions
curry=lambda (f)->{
        \\ get arguments as a stack object and store reference to s
        \\ f and s are closures to returned anonymous function
        =lambda f, s=[] -> {
                \\ pass arguments [] to f() if any
                \\ pass arguments using a copy of s
                \\ passing done using ! symbol before a stack object
                =f(![], !stack(s))
        }
}
sum=lambda -> {
        s=0   \\ number pop numbers from stack
        while not empty : s+=number:end while
        =s
}
curried=curry(sum, 5,7,9)
Print curried(1,2,3)=5+7+9+1+2+3  ' true
Print curried(10,20,30)=5+7+9+10+20+30 ' true
Print curried()=5+7+9  ' true
curried2=curry(sum)
Print curried2()=0
curried2=curry(sum, 10,20,30,40)
Print curried2(1,2,3,4)=110
\\ make a closure for a lambda function
disp=lambda title$="my title:" (that$) -> {
        Print title$;that$
}
Call disp("Anonymous Function")
Dim A(10)
A(3)=disp
ret=A(3)("Call from array")
Inventory Abc="100":=disp
ret=Abc("100")("Call from inventory")
ret=lambda title$="another tilte1:" (that$)->{Print title$;that$}("call anonymous function")
ret=lambda title$="another tilte2:" (that$)->{
        Print title$;that$
}("call anonymous function")
}
MODULE CHAIN {\\ Chain of Responsibility design pattern 
\\ a Class: part in Class Function removed from object after first copy (when copied from Class function)
\\ So constructors are not part of Logger Group (Group is the type of a user object in M2000)
Form 80,50
Global enum LogLevel    {
		None = 0,
		Info = 1, 
		Debug = 2, 
		Warning = 4,
		Error = 8,   
		FunctionalMessage = 16, 
		FunctionalError = 32, 
		All = 63
		}
Class Logger {
Private:
logMask=0&
Group NextLogger
Public:
	Module Final Message(msg$, severity) {
		If not Valid(.NextLogger=>Null) Then
			.NextLogger=>Message msg$, severity
		End If
		If Binary.And(.logMask ,severity)<>0 Then
			.WriteMessage msg$
		End If
	}
	Module WriteMessage (m$) {
		Print m$
	}
	Module Final SetNext ( p as pointer) {
		.NextLogger<=p
	}
	Function Final Dispose {
		x=valid(.NextLogger=>Dispose())
		Clear .NextLogger
	}
Class:
	Module Logger (z) {
		.logMask<=z
		Class EmptyLogger {
			Null
		}
		.NextLogger<=Pointer(EmptyLogger())
	}
}
Class ConsoleLogger {
	Module  Final WriteMessage (m$) {
		Print "Writing to console: " + m$
	}
Class:
	Module ConsoleLogger {
		This=Logger(![])
	}
}
Class EmailLogger {
	Module  Final WriteMessage (m$) {
		Print "Sending via email: " + m$
	}
Class:
	Module EmailLogger {
		This=Logger(![])
	}
}
Class FileLogger {
	Module  Final WriteMessage (m$) {
		Print "Writing to Log File: " + m$
	}
Class:
	Module FileLogger {
		This=Logger(![])
	}
}
A=ConsoleLogger(All)
B=EmailLogger(FunctionalMessage+FunctionalError)
C=FileLogger(Warning+Error)
C.SetNext Pointer(B)
B.SetNext Pointer(A)


C.Message "Entering function ProcessOrder().", Debug
C.Message "Order record retrieved.", Info
C.Message "Customer Address details missing in Branch DataBase.", Warning
C.Message "Customer Address details missing in Organization DataBase.", Error
C.Message "Unable to Process Order ORD1 Dated D1 For Customer C1.", FunctionalError
C.Message "Order Dispatched.",FunctionalMessage
Call C.Dispose()  ' no need we use weak refrences (automatic created If poiner produced for named groups
}
MODULE CHAIN2 {\\ Chain of Responsibility design pattern  2
\\ example from https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern
\\ This example use real pointers to groups
\\ so we have one group, the logger and two groups inside it in a chain
Form 80,50
Global enum LogLevel    {
		None = 0,
		Info = 1, 
		Debug = 2, 
		Warning = 4,
		Error = 8,   
		FunctionalMessage = 16, 
		FunctionalError = 32, 
		All = 63
}
Class Logger {
Private:
	logMask=0&
	Group NextLogger
Public:
	Module Final Message(msg$, severity) {
	If Binary.And(.logMask ,severity)<>0 Then
		.WriteMessage msg$
	End If
	If not Valid(.NextLogger=>Null) Then
		.NextLogger=>Message msg$, severity
	End If
}
Module WriteMessage (m$) {
	Print m$
}
 Module Final SetNext ( p as pointer) {
	If  valid(.NextLogger=>Null) Then
		.NextLogger<=p
	else
		.NextLogger=>SetNext p
	End If
}
Function Final Dispose {
	x=valid(.NextLogger=>Dispose())
	Clear .NextLlogger
}
Class:
	Module Logger (z) {
		.logMask<=z
		Class EmptyLogger {
			Null
		}
		.NextLogger<=Pointer(EmptyLogger())
	}
}
Class ConsoleLogger {
	Module  Final WriteMessage (m$) {
		Print "Writing to console: " + m$
	}
Class:
	Module ConsoleLogger {
		This=Logger(![])	'  ![] pass current stack of values to function Logger()
	}
}
Class EmailLogger {
Module  Final WriteMessage (m$) {
Print "Sending via email: " + m$
}
Class:
	Module EmailLogger {
		This=Logger(![])
	}
}
Class FileLogger {
	Module  Final WriteMessage (m$) {
		Print "Writing to Log File: " + m$
	}
Class:
	Module FileLogger {
		This=Logger(![])
	}
}
Logger->ConsoleLogger(All)


Logger=>SetNext Pointer(EmailLogger(FunctionalMessage+FunctionalError))
Logger=>SetNext Pointer(FileLogger(Warning+Error))


Logger=>Message "Entering function ProcessOrder().", Debug
\\ better to use a For object {} structure
For Logger {
	.Message "Order record retrieved.", Info
	.Message "Customer Address details missing in Branch DataBase.", Warning
	.Message "Customer Address details missing in Organization DataBase.", Error
	.Message "Unable to Process Order ORD1 Dated D1 For Customer C1.", FunctionalError
	\\ we can use Logger=>Message also
	Logger=>Message "Order Dispatched.",FunctionalMessage
	call .Dispose() 
}
Logger->0&   ' or Clear Logger
}
INFO