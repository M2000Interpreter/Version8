MODULE A {Superclass alfa {
      Unique:
            counter=1
      Public:
            Value {
                  For SuperClass {
                        =.counter
                        .counter++
                  }
            }
            Module Reset (x){
                  For SuperClass {
                        .counter<=x
                  }
            }
}
a=alfa
b=alfa
Print a=1, b=2, a=3, a=4, b=5 ' true true true true true
\\ we have to use group(a) to get the group not the value
\\ we use ( ) to get a copy
z->(group(a))
Print eval(z)=6, a=7, b=8, eval(z)=9 ' true true true true
z=>Reset 100
Print eval(z)=100, a=101, b=102, eval(z)=103 ' true true true true
For z {
      .Reset 10
}
Print eval(z)=10, a=11, b=12, eval(z)=13 ' true true true true
}
MODULE GEORGE {Binary {
      /9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQIBAQEBAQIB
      AQECAgICAgICAgIDAwQDAwMDAwICAwQDAwQEBAQEAgMFBQQEBQQEBAT/2wBDAQEB
      AQEBAQIBAQIEAwIDBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE
      BAQEBAQEBAQEBAQEBAT/wAARCABQAFADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEA
      AAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIh
      MUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6
      Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZ
      mqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx
      8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREA
      AgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAV
      YnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hp
      anN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPE
      xcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD+
      2GymJXCnLLzjJAOP6/410FtdEZUsM5yFAIzzgnP51zdqrfKT24xnBOOn9K2IA2VY
      KAMfeAyOuOfyrdSqJaLc3ioydt/vOkiutqBjkcZPzdc9K+fPjN+2D+z7+z3byj4o
      /ErQ9D1GOMSjw9DIdW8ROGVmU/Y4Q0gBCk7nCjpyK8N/b8/aP8R/s7fBaC6+H8LX
      nxU+I/iOHwH8O7eO2W+nsriaKWe6vxCQVb7NbwSsu8FBK8O7KkivzW/Z1/4J8weO
      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
} As A

Gradient 13,5
ImgRenderX=scale.x div 2
For ImgRenderX=ImgRenderX to ImgRenderX/4 step 150
	TopMargin=(scale.y-(ImgRenderX)*image.y(A)/image.x(A)) div 2
	LeftMargin=(scale.x-ImgRenderX) div 2
	move LeftMargin, TopMargin
	Image A, ImgRenderX
Next
cursor 12, height-2
Writer
Escape Off
while mouse=0 and inkey$=""
	refresh
End While
Escape On
cls 
}
MODULE B {\\ m is an auto array (a tuple)
\\ z is an iterator of m
m=(1,2) : Print valid(m^)=false ' bug return valid(m^)=true
z=each(m): Print Valid(z^)=true
}
MODULE C {dim a(), b()
a()=(1,2,3)
b()=(3,2,1)
for i=0 to 2
print max(a(i), b(i)), max(b(i), a(i))
print min(a(i),b(i)), min(b(i), a(i))
print compare(a(i), b(i)), a(i), b(i)
next i


dim a()
a()=(1,2,3)
for i=0 to 2
print max(a(2-i), a(i)), max(a(2-i), a(i))
print min(a(2-i),a(i)), min(a(2-i), a(i))
print compare(a(i), a(2-i)), a(2-i), a(i)
next i
}
MODULE B1 {Module ViewStatic  {
      static Img1, tempo=1, gx=3, gy=5
      ? tempo, gx, gy
      tempo++
      gx++
      gy++
}
clear
for i=1 to 10
	ViewStatic
next   
clear
}
MODULE BB {Print "check mouse buttons"
Print "Press Esc to exit"
m=false
Every 100 {
if mouse.key then { m=true } else m=false
print not m
}
}
MODULE BB1 {Print "press mouse button"
a=mouse
while not a {a=mouse: print a ,  not -a}
? "ok"
}
MODULE D {\\ Identifiers in Greek language
\\ see DR for the same program with statements in English language

\\ [] return the pointer of last current stack, and leave an empty current stack
? "The Greek Version - Statements/Messages in Greek language"
Τμήμα Λατινικοί_Αριθμοί {
      Άδειασε
      Διαμέσου Αρχικοποίηση
      Έγγραφο Εγγ$
      Ενώ όχι κενό
            Διάβασε λατ$
            Τύπωσε λατ$;"=";ΤιμήΛατινικού$(λατ$)
            Εγγ$=λατ$+"="+ΤιμήΛατινικού$(λατ$)+{
            }
      Τέλος Ενώ
      Πρόχειρο Εγγ$
      Τέλος
Αρχικοποίηση:
      Συνάρτηση ΤιμήΛατινικού$(λατ$) {
            Άδειασε
             ="άκυρο"
            Αν Φίλτρο$(λατ$,"MDCLXVI")<>"" Τότε Έξοδος
            \\ θα μπουν ανάποδα, το τελευταίο πρώτο.
            Βάλε "CM", "MD", "Q","CD", "MD","W", "XC", "DL", "E","XL", "X","R", "IX","V","T", "IV","I","Y"
            διπλό_λατινικό=[]
            \\ θα μπουν με το τελευταίο να είναι τελευταίο.
            Σειρά "M", 1000, "Q",900,"D", 500,"W", 400,"C",100,"E",90, "L",50,"R", 40,"X", 10, "T", 9, "V", 5, "Y", 4, "I",1
            απλό_λατινικό=[]
            σύνολο=0
            μια_τιμή=0
            μετρητής=0
            Σωρός διπλό_λατινικό {
                  Αν κενό Τότε Έξοδος
                  Διάβασε απ$, μη_έγγυροι_χαρακτήρες$,χαρακτ$
                  ι=Θέση(λατ$,χαρακτ$)
                  Αν ι >0 Τότε
                        προσωρινή_τιμή$=Μεσ$(λατ$,ι+2)
                        λ=Μήκος(προσωρινή_τιμή$)
                        Αν λ>0 Τότε Αν Μήκος(Φίλτρο$(προσωρινή_τιμή$, μη_έγγυροι_χαρακτήρες$))<>λ Τότε λατ$="A": Έξοδος
                        Αν Θέση(λατ$,Μεσ$(λατ$,ι,1))<ι Τότε λατ$="A": Έξοδος
                        insert ι, 2 λατ$=απ$ '  2 λέμε αλλα δίνουμε 1 χαρακτήρα και ο μεταφραστής θα βάλει ένα διάστημα 
                  Τέλος Αν
                  Κυκλικά
            }
            λατ$=Φίλτρο$(λατ$," ")
            Σωρός απλό_λατινικό {
                  Αν κενό Τότε Έξοδος
                  Διάβασε χαρακτ$, μια_τιμή
                  μετρητής=0
                  Ενώ Αρισ$(λατ$,1)=χαρακτ$
                         Παρεμβολή 1, 1 λατ$=""
                         μετρητής++
                         σύνολο+=μια_τιμή
                  Τέλος Ενώ
                  Αν μετρητής>3 Τότε έξοδος
                  Κυκλικά
            }
            Αν Μήκος(λατ$)>0 ή μετρητής>3 Αλλιώς
            =Γραφή$(σύνολο,1033)
            Τέλος Αν
      }
      Σειρά "MMMCMXCIX", "LXXIIX", "MMXVII", "LXXIX", "CXCIX","MCMXCIX","MMMDCCCLXXXVIII"
      Σειρά "CMXI","M","MCDXLIV","CCCC","IXV", "XLIXL","LXXIIX","IVM"
      Σειρά "XXXIX", "XXXX", "XIXX","IVI", "XLIX","XCIX","XCIV","XLVIII"
      Επιστροφή
}
Λατινικοί_Αριθμοί
}
MODULE DD {Print "A structure in a Class"
class beta {
      structure alfa1 {
            a as long*4
            b as long*4
      }
      structure alfa {
            a as long*4
            b as long*4
            c as alfa1*3
      }
      buffer delta as alfa*3
}
beta=beta()
Print "Offset b in structure alfa"
Print beta.alfa("b")
list
}
MODULE DD1 {local group alfa {
      x=10, y%=50, z$="anything here"
      dim M(4)=10
      event alfa {read b}
      document a$="100"
      class allo {
            q=4
      }
      Group M {
            k=10
      }
      function delta {
           
      }
      module kappa {
           
      }
}
testMe()
Print "After the call"
List !
Modules ?

End
Sub testMe()
Print "Create a second alfa group, hidding the old one"
local group alfa {
      x=10, y%=50,z$="anything here"
      dim M(4)=10
      event alfa {read b}
      document a$="100"
      class allo {
            q=4
      }
      Group M {
            k=10
      }
      function delta {
           
      }
      module kappa {
           
      }
}
List !
Modules ?
End Sub

}
MODULE DD2 {Print "Make some constant lambda functions"
const b=lambda->100
const b%=lambda->100
const b$=lambda$->"hello"
Print b%()
Print b$()
Try ok {
      b=lambda->500
}
if Error or Not ok Then Print Error$
Print b()
}
MODULE DD3 {cursor 0,height-1
Pen 11 {Print "When report stop press space or mouse button"}
Report "Reassign a lambda function in a Group - static link group, we use a unique name of group as local identifier"
Report {
      group alfa {
            x=100
            b=lambda->{
                  =.x
                  .x++
            }
      }
}
\\ this is in a global module A
group alfa {
      x=100
      b=lambda->{
            =.x
            .x++
      }
}
\\ get a copy to alfa
Report {
	We make a beta as a copy of alfa
}
beta=alfa
Print "alfa.b()=";alfa.b()
Print  "beta.b()=";beta.b()
Report {
	Try to change function with a fake one
	function alfa.b {
		=500
	}
}
function alfa.b {
      =500
}
Modules ?
Print "alfa.b()=";alfa.b()

Report {
	 References for functions are strings with code. We get  {CALL EXTERN 3}A.ALFA, but is not the actual hard link. The actual code is in lambda object. 3 is the actual "slot" or index in a var(), an array of variants inside M2000 code where all the variables and this object exist.
}
pen 15 {Report 2,  &alfa.b()}
Report {
	We can make a link of alfa.b() to f() (only for new identifiers). The reference has the same weak reference to the name of group. So we can make a reference if the group has a name (is not keep it by a pointer, or exist in an array or other object like stacks and inventories)
}
Link  alfa.b() to f()
Report {
	This is the function f() code (a reference to a function is actual the code of the function in a string in a block {}). We see two things. One is a line 11001edit which used when an error happen to display the line of the code, and the other is the weak reference of the actual group, which copied by the link statement (a link statement is actual two statements a Push and a Read). We can't assign a second reference.
}
Pen 15 {Report 2,  &f()}
Report  {
	This function can be changed because has no "hard link" with lambda
	All functions except final in groups can be changed:
	function f {
               =500
         }
}

function f {
      =500
}
Print "f()=";f()
Print "alfa.b()=";alfa.b()
Print  "beta.b()=";beta.b()
\\ we can test pointers
\\ there is two type of pointers
\\ 1. pointers to float groups (holded in containers or by pointers)
\\ 2. pointer to named groups (using a weak reference)
\\ this type has no use when referenced group get out of scope
\\ but as all pointers can change value later
\\ pointers can be null, using p->0 but they hold just an empty group
\\ so never a pointer in M2000 has a real null value, but an "empty" one.
Report {
	Reassign a lambda function in a float group -group handled by pointer(s) - no static linked
	We use p->pointer((beta)), is the same as p->(beta)
	Parenthesis used to make the beta a copy as a float group, so we get the pointer to that float group
	Without Parentesis the pointer is a weak reference to beta, so if we pass the pointer as a return value the beta group deleted and the weak reference be invalid. Using the float group, we can move it (like a float object) any where. The float group destroyed when no pointer points to it.
	So the copy we get has the last state of the object, where beta.x is 102.
	We can use -> in place of = for a return value from a function, but we have to use (name_of_group) to return a float group not a reference.
}
\\ p->(beta) is the same as this:
p=pointer((beta)) ' a copy of beta
Print "p=>b()=";p=>b(),"p=>b()="; p=>b()
Print "beta.b()=";beta.b()
\\ p->beta is same as this
Report {
	Now we change p to point to beta, using p=pointer(beta)  same as p->beta  (we use pointer() to pass as an argument, where we can't use ->)
}
p=pointer(beta) ' as reference to beta
Print "p=>b()=";p=>b(),"p=>b()="; p=>b()
Print "beta.b()=";beta.b()
}
MODULE DD4 {Report {
	This example show how to use closures in lambda functions
}
n=lambda ->500
a=lambda n (x)->{
      if x<=0 then=0 : exit
      =lambda(x-1)+x+n()
}
Print a(3)=1506
Print a(10)=5055
n=lambda->100
\\ closures are copies, and are like globals for lambda
Print a(3)=1506
\\ closures can be change only from inside
\\ if they are value types (lambda is a value type)
m=lambda->100
a=lambda n, m (x)->{
      if x>5 then n=lambda ->500
      if x<=0 then=0 : n=m : exit
      =lambda(x-1)+x+n()
}

Print a(3)=306
Print a(10)=1055
\\ touple is an array, can have zero items (,)
\\ or one ore more, and it is a reference type
z=(m,)
Print Function("m")=100
Link z to Z()
Print Z(0)()=100
a=lambda z (x) -> {
      if x<=0 then=0 : exit
      link z to z()
      =lambda(x-1)+x+z(0)()
}
\\ now we change value in z(0), which is the z
Print a(10)=1055
z(0)=lambda->300
\\ so now lambda change because hold a closure to a reference
Print a(10)=3055
Print eval(z)(0)()=300
\\ without using link we can get the first element in 0 posiiton, and ask for function
\\ this function has a life for the moment of call
\\ interpreter just open the lambda object, invoke, and close again.
a=lambda z (x) -> {
      if x<=0 then=0 : exit
      =lambda(x-1)+x+Eval(z)(0)()
}
Print a(10)=3055
}
MODULE DD5 {class a {
      counter as long
}
b=lambda k=pointer(a()) (x)-> {
      k=>counter+=x
      \\ we can return pointers from groups (if they are float type)
      ->k
}
m=b(30)
Print m=>counter=30
\\ get a pointer and convert it to a named group, and then return  a float group (as is, without pointer)
def copy(x as group)=x
group k=b(300)
z=b(300)
Print z=>counter=630
Print m=>counter=630
Print z is m ' false
z->b(300)
Print z is m 'true
Print z=>counter=930
Print k.counter=330 ' old value
}
MODULE DD6 {group beta {
      x$="1000mm"
      m=100
}
\\  beta copied here
inventory alfa=1:=(list:=1,2,300:=(1,2,3,3,5,beta), 500:="ok")

dim g()
\\  beta copied here
g()=(100,beta,(1, (list:=1:=beta,2,"z":=(1,200,3,alfa), "s":="string"), "Hello there"), 500@, "ok")
g(1).m*=100
Print g(1).m=10000
link g() to g$()
Print type$(g(2), 1)="Inventory"
Print type$(g(2), 1!)="List"   ' show type of inventory (list or queue)
Print type$(g(2), 2)="String", g(2)#val$(2)="Hello there"
Print g$(2)(2)="Hello there"    ' using g$() a reference to g()
Print g$(2)(1)("s")="string"
Print g$(2)(1)("z")(3)(1)(500)="ok"
\\ new this also
Print  g(2)(1)("z")(3)(1)(300)(5).m=100 ' multiple object opening until a group object
\\ new this also. we can get a pointer from inner group
n->g(2)(1)("z")(3)(1)(300)(5)
Print n=>m=100
n=>m++ ' increment one
Print g(2)(1)("z")(3)(1)(300)(5).m=101
Print g(2)(1)("z")(3)(1)(300)(5).x$="1000mm"
n=>x$="2000mm"
Print g(2)(1)("z")(3)(1)(300)(5).x$="2000mm"
m=g() ' we get a pointer to array ' these are not the same as the group's pointers
\\ stacks, inventories and arrays (not those we make with Dim) are pointers
\\ we can use IS operator to check two of them if show same object
z=list:=100, 150:=m, 200
Print z(150)(2)(1)("z")(3)(1)(300)(5).m=101
\\ using g() we pass a copy
\\ but anything which is a pointer (like a list, or a pointer to array) only pointer copied
\\ groups may have or may haven't pointers. Those with no pointers copied when we get an array copy.
\\ Only arrays with names with parenthesis copied. So here we get a copy of g().
z=list:=100, 150:=g(), 200
g(1).m+=100
Print g(1).m=10100
Print z(150)(2)(1)("z")(3)(1)(300)(5).m=101 ' group has a pointer/ also list is the same
Print z(150)(1).m=10000 ' group copied
n=>m++
Print z(150)(2)(1)("z")(3)(1)(300)(5).m=102
Print g(2)(1)("z")(3)(1)(300)(5).m=102
}
MODULE DD7 {module Checkit {
      Stack New {
            Data "foo://example.com:8042/over/there?name=ferret#nose", "urn:example:animal:ferret:nose"
            Data "jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true", "ftp://ftp.is.co.za/rfc/rfc1808.txt"
            Data "http://www.ietf.org/rfc/rfc2396.txt#header1", "ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two"
            Data "mailto:John.Doe@example.com", "news:comp.infosystems.www.servers.unix", "tel:+1-816-555-1212"
            Data "telnet://192.0.2.16:80/", "urn:oasis:names:specification:docbook:dtd:xml:4.1.2", "ssh://alice@example.com"
            Data "https://bob:pass@example.com/place", "http://example.com/?a=1&b=2+2&c=3&c=4&d=%65%6e%63%6F%64%65%64"
            a=Array([])
      }
      function prechar$(a$, b$) {
            if a$<>"" then {=quote$(b$+a$)} else ={""}
      }
      z=each(a)
      document s$="["+{
      }
      While z {
            a$=array$(z)
            s1$={           "uri": }+quote$(a$)+{,
                  "authority": }+ quote$(string$(a$ as URLAuthority))+{,
                  "userInfo": }+ quote$(string$(a$ as URLUserInfo))+{,
                  "scheme": }+quote$(string$(a$ as URLScheme))+{,
                  "hostname": }+quote$(string$(a$ as UrlHost))+{,
                  "Port": }+quote$(string$(a$ as UrlPort))+{,
                  "pathname": }+quote$(string$(a$ as UrlPath))+{,
                  "search": }+prechar$(string$(a$ as URLpart 6),"?")+{,
                  "hash": }+prechar$(string$(a$ as UrlFragment),"#")+{
            }
            s$="     {"+{
            }+s1$+"     }"
            \\ z^ is the iteraror's counter (z is an iterator of a, a touple - array in M2000)
            if z^<len(a)-1 then s$=" ,"   ' append to document
            s$={
            }
      }
      s$="]"
      Print "Press any keyboard key or mouse key to continue scrolling"
      Report s$   
      Clipboard s$
}
Checkit
}
MODULE DD8 {Module Pairs {
      \\ using Gdi+ antialiasing (not work with Wine in Linux, but we get no error)
      smooth on
      Const center=2, right=3, left=1, blue=1, angle=0, dotline=3
      Const size9pt=9, size11pt=11
      Cls ,0 ' use current background color, set split screen from line 0
      Cursor 0,3
      Report center, "Coordinate pairs"
      x = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
      y = (2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0)
      dx=scale.x/2/len(x)
      dy=dx 'ratio 1:1
      graH=dy*len(x)
      Basex=scale.x/4
      Basey=(scale.y+graH)/2
      Move Basex, Basey
      \\ draw use relative coordinates
      Draw 0,-graH
      \\ Step just move graphic cursor
      Step 0, graH
      Draw scale.x/2, 0
      Step -scale.x/2, 0
      \\ scX is 1, not used
      max=Y#max()
      \\ Auto scale for Y, using 0 for start of axis Y
      scY=-graH/((max+5^log(max) ) div 100)/100
      \\ make vertical axis using dots with numbers center per dx
      j=1
      For i=basex+dx to basex+dx*x#max() Step dx
            Move i, basey
            Step 0, twipsy*10
            Legend format$("{0}",array(x,j)), "courier", size9pt, angle, center
            Width 1, dotline { draw 0, -graH-twipsy*10,7}
            j++
      Next i
      \\ the same for horizontal axis
      HalfTextHeight=Size.y("1","courier", size9pt)/2
      For i=basey-dy to basey-dy*x#max() Step dy
            Move basex, i
            Step -twipsx*10
            Width 1, dotline { draw scale.x/2+twipsx*10,,7}
            Move basex-100, i+HalfTextHeight
            Legend format$("{0}",(i-basey)/scY), "courier", size9pt, angle, left
      Next i
      ex=each(x) : ey=each(y)
     \\ start from first point. We use Draw to for absolute coordinates
      Move array(x,0)*dx+Basex, array(y,0)*scy+Basey
      While ex, ey {
            Width 2 {
                  Draw to array(ex)*dx+Basex, array(ey)*scy+Basey, blue
            }
      }
      \\ second pass for marks and labels
      ex=each(x) : ey=each(y)
      While ex, ey {
            Move array(ex)*dx+Basex, array(ey)*scy+Basey
            Step -75, -75
            Pen 12 {draw 150: draw 0,150 : draw -150 : draw 0,-150}
            Pen 13 {
                  Step 200, -200
                  Legend format$("({0}-{1})",array(ex),array(ey) ), "courier bold", size11pt, angle, right
            }
      }
      \\ screenshot to clipboard
      Screenshot$=""
      Move 0,0
      Copy scale.x, scale.y to Screenshot$
      Clipboard Screenshot$
      a$=key$
}
Pairs
}
MODULE DD8GRNEW {\\ Like DD8 but better
\\ Using Greek identifiers
\\ we get the pairs and then short them
\\ Also the first array X may have now spaces more than one (look second χ=(,,,,))
\\ Now we can use negatives in second array so a ψ-=100 make some under zero.
\\ For X we get always the lower value as the first value in X-axis.
\\ For Y we make a first value according to the lower
\\ also we can make narrow the graph changing the ΖουμΧ value (2 for half the width of console screen)
Τμήμα Ζεύγη_Τιμών {
      \\ χρήση Gdi+ ομαλοποίησης γραμμών (δεν δουλεύει σε Wine σε Linux, αλλά δεν γυρίζει λάθος)
      Ομαλά ναί
      Σταθερές κέντρο=2, δεξιά=3, αριστερά=1, μπλε=1, γωνία=0, γραμμή_με_τελίτσες=3
      Σταθερές μέγεθος_9pt=9, μέγεθος_11pt=11
      Οθόνη ,0
      Δρομέας 0,3
      Αναφορά κέντρο, "Γράφημα: Ζεύγη Τιμών"
      Άδειασε
      χ=(0,1,2,3,4,5,6,7,8,9)
Σημ    χ=(1,2,3,4,5,6,9,10, 15,19)
Σημ      χ+=10  \\ αύξηση κατά 10
Σημ      χ*=3   \\ πολλαπλασιασμός επί 3, άρα το τελευταίο ειναι στο 29*3=87
      Σειρά ! χ
      ψ= (2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0)
Σημ      ψ-=100
Σημ      ψ*=40
      μέγιστο=ψ#μεγ()
      ελάχιστο=ψ#μικ()
      Σειρα ! ψ
      \\ Μοιράζουμε τα στοιχεία της τελευταίας σειράς που μπήκε
      \\ πίσω από το καθένα της πρώτης.
      Μ=Μέγεθος.Σωρού δια 2
      Για ι=0 εως Μ-1 : ΦέρεΠίσω Μ+ι : Επόμενο
      \\ Μαζεύουμε τα ζεύγη στα Α(ι,0) κα Α(ι,1)
      Πίνακας Βάση 0,  Α(10,2)
      Μ--
      Για ι=0 εως Μ: Διάβασε Α(ι,0), Α(ι,1) : Επόμενο
      \\ Τώρα τα ταξινομούμε ώστε να είμαστε σίγουροι ότι
      \\ στο Α(Μ,0) έχουμε το μεγαλύτερο και στο Α(0,0) το μικρότερο
      \\ (για τον Χ άξονα)
      Ταξινόμηση Α(), 0, Μ, 0,0
          
      ΕύροςΤιμώνΧ=Α(Μ,0)-Α(0,0)
      ΒάσηΤιμώνΧ=Α(0,0)
      μέρη=ΕύροςΤιμώνΧ  'Αν(ΕύροςΤιμώνΧ<10->10,ΕύροςΤιμώνΧ)
      κλΧ=1
      Αν μέρη>15 τότε
            κλΧ=ΕύροςΤιμώνΧ δια 15 : μέρη=Στρογγ(ΕύροςΤιμώνΧ/κλχ+.5,0)
      Αλλιώς
            κλΧ=ΕύροςΤιμώνΧ / μέρη:
      Τέλος Αν
      ΖουμΧ=1.2
      δχ=χ.σημεία/ΖουμΧ/(μέρη+δεκ(κλΧ))
      δψ=υ.σημεία/1.5/10
      βαθμόςΥ=δψ*10
      ΒάσηΧ=(χ.σημεία-χ.σημεία/ΖουμΧ)/2
      ΒάσηΥ=(υ.σημεία+βαθμόςΥ)/2
      Θέση ΒάσηΧ, ΒάσηΥ
      Χάραξε 0,-βαθμόςΥ
      Βήμα 0, βαθμόςΥ
      Βήμα χ.σημεία/ΖουμΧ, 0
      Χάραξε -χ.σημεία/ΖουμΧ, 0
      κανε αα(μέγιστο, κάτω=0, Ν=50)=ΑΝ(μέγιστο=0->0, Ν*(((μέγιστο+2^Λογ(Απολ(μέγιστο)) ) διά Ν)-(μέγιστο>0)-κάτω))
      \\ άλαξε το 100 με το 50 ή το 500
      μέγιστο=αα(μέγιστο,,100)
      ελάχιστο=αα(ελάχιστο,1,100)
      κλψ=-βαθμόςΥ/(μέγιστο-ελάχιστο)


      \\Φτιάχνουμε οριζόντιους γραμμές με τελίτσες ανά δχ
      \\ Το ύψος.σημείου είναι ο αριθμός σε twips του ύψους ενός σημείου στο μέσο που γράφουμε
      \\ αν στην οθόνη έχουμε 96dpi, τότε έχουμε σε 1 ίντσα, 1440 twips, ή 96 σημεία,
      \\ άρα κάθε σημείο θα έχει 1440/96 = 15 twips
      \\ και πράγματι τόσο είναι το Ύψος.Σημείου σε 96dpi. Όμως μπορεί να έχουμε οθόνη με διαφορετικά dpi.
      \\ Αν θέλουμε να μετρήσουμε αποστάσεις βάσει σημείων πρέπει να πολλαπλασιάζουμε με τον αριθμό
      \\ των twips ανά σημείο. Ορισμένες φορές μπορεί να μην έχουμε τετράγωνο σημείο, δηλαδή να διαφέρουν
      \\ τα  Ύψος.Σημείου με Πλάτος.Σημείου. Για το λόγο αυτό χρησιμοποιούμε και τα δύο.
      κ=1
      τ=ΒάσηΤιμώνΧ
      δτ=κλΧ
      αν δτ=0 τότε δτ=1

      
      Για ι=ΒάσηΧ έως ΒάσηΧ+δχ*μέρη Ανά δχ
            Θέση ι, ΒάσηΥ
            Βήμα 0, Ύψος.Σημείου*10
            Επιγραφή μορφή$("{0}",τ), "courier", μέγεθος_9pt, γωνία, κέντρο
            Αν ι>ΒάσηΧ Τότε Πάχος 1, γραμμή_με_τελίτσες { Χάραξε 0, -βαθμόςΥ-Ύψος.Σημείου*10,7}
            κ++ : τ+=δτ
      Επόμενο
      \\ φτιάχνουμε κάθετες γραμμές ανά δψ
      ΜισόΎψοςΚειμένου=Μέγεθος.Υ("1","courier", μέγεθος_9pt)/2
      ΣτόχοςΥ=ΒάσηΥ-δψ*10
      Για ι=ΒάσηΥ έως ΣτόχοςΥ Ανά δψ
            Θέση ΒάσηΧ, ι
            Βήμα -Πλάτος.σημείου*10
            Αν ι<ΒάσηΥ Τότε Πάχος 1, γραμμή_με_τελίτσες { Χάραξε χ.σημεία/ΖουμΧ+Πλάτος.σημείου*10,,7}
            Θέση ΒάσηΧ-Πλάτος.Σημείου*6, ι+ΜισόΎψοςΚειμένου
            Επιγραφή μορφή$("{0}",(ι-ΒάσηΥ)/κλΨ+ελάχιστο), "courier", μέγεθος_9pt, γωνία, αριστερά
      Επόμενο
      
      \\ Τώρα χαράζουμε μια γραμμή που θα περάσει από όλα τα σημεία
      \\ με την Χάραξε Έως δίνουμε απόλυτες συντεταγμένες (χωρίς το Έως δίνουμε σχετικές)
      δχ/=κλΧ
      ΒάσηΥ-=ελάχιστο*κλψ
      Θέση ΒάσηΧ, πίνακας(ψ,0)*κλΨ+ΒάσηΥ
      ΒάσηΧ-=Α(0,0)*δχ

      Για ι=0 έως Μ
            Πάχος 2 {
                  Χάραξε έως Α(ι,0)*δΧ+ΒάσηΧ, Α(ι, 1)*κλΨ+ΒάσηΥ, μπλε
            }
      Επόμενο
      \\ Δεύτερο πέρασμα για επιγραφές και σημάδια

      Για ι=0 έως Μ
            Θέση Α(ι,0)*δΧ+ΒάσηΧ, Α(ι, 1)*κλΨ+ΒάσηΥ
            Βήμα -Πλάτος.σημείου*5, -Ύψος.Σημείου*5
            \\ τετράγωνο γύρω από το σημείο
            Πένα 12 {
                  Χάραξε Πλάτος.σημείου*10
                  Χάραξε 0,Ύψος.Σημείου*10
                  Χάραξε -150
                  Χάραξε 0,-Ύψος.Σημείου*10
            }
            Πένα 13 {
                  Βήμα Πλάτος.σημείου*13, -Ύψος.Σημείου*13
                  Επιγραφή μορφή$("{0}|{1}", Α(ι,0), Α(ι,1) ), "courier bold", μέγεθος_11pt, γωνία, δεξιά
            }
      Επόμενο
      \\ Αντιγραφή οθόνης στο πρόχειρο
      ΑντίγραφοΟθόνης$=""
      Θέση 0,0
      Αντίγραψε χ.σημεία, υ.σημεία στο ΑντίγραφοΟθόνης$
      Πρόχειρο ΑντίγραφοΟθόνης$
      \\ αναμονή πατήματος πλήκτρου
      Βάλε Κομ$ : Πέτα
      Ομαλά όχι    ' επαναφορά
}
Ζεύγη_Τιμών
}
MODULE DD9 {Report {Execute a Clear statement to erase static variables from console. Static variables reduce a bit the speed of interpreter. Except for static varibales in threads, they erased when a thread erased}

a=10
Module Checkit {
      if random(10)=1 then Clear ' erase all statics and variables from this level
      Module Checkit {
            flush
            module Checkit {
                  static k=(Queue:=1,2)
                  Try {
                        Read ? k as queue
                  }
                  Print type$(k)
                  Print k
            }
            group alfa {
                  x=10
            }
            z->(alfa)
            Checkit
            Checkit z
            Checkit (Queue:=1,2,3,1,2,3)
            Checkit (List:=1,2,3)
      }
      Checkit
}
Checkit
Print a ' a exist always
}
MODULE F1 {Report {
	OOP part 1
	We make a group alfa as named group in this module, with a private x variable, and two modules (as methods)
	We check that alfa.x not exist using valid(alfa.x)
}
Group alfa {
      private:
            x=10
      public:
      \\ we can use Print as module name
      Module Print {
            Print .x
      }
      Module IncX {
            .x++
      }
}
alfa.print    ' print 10
Print valid(alfa.x)=false
alfa.incX
alfa.print   ' print 11
}
MODULE F2 {module checkit {
      Report{
             OOP part2
             We make a class b1 which is a function which return a float group (nameless), but not a pointer to a group
             We make b as pointer of a float group (which made by b1() function)
             Just for the example we call beta(), a subroutine, which expect a z idenifier whch not exist
             So we catch this in a Try {} structure
             Now we make Z as pointer of a new float group using z->b1()
             We call sub alfa() using a local b as a predefined pointer to a float group b1().
             If we didin't pass a group or we pass ?, we use b as the predefined
             If we have something else in stack we get error, so before that type of call we have to know what we have in stack or we can use ?
      }
      flush ' we use alfa() with an optional parameter. if stack has wrong type then we get error
      rem push 1  \\ this raise eror in alfa()
      def long counter=0
      class b1 {
            x=10
      }
      \\ b is a pointer to a new group from b1()
      b->b1()
      Try {
            beta()
      }
      Print Error$ ' z not found in scope, we can't use it as pointer
      \\ z is a pointer to a new group from b1()
      z->b1()
      \\ now z exist
      rem {
             alfa(?)  ' use these  if you use the Push 1 (see above)
             beta(?)
      }
      alfa() ' 11 - use of internal pointer to group
      beta() ' 11
      Print b=>x=10 ' true
      alfa(z) ' 12
      alfa(z) '13
      beta() ' 14
      alfa() ' 11  - use of internal pointer to group
      Print b=>x=10 ' true
      alfa(b) '11
      alfa(b) '12
      Print b=>x=12 ' true
      Print z=>x=14
      beta() ' 15
      Print z=>x=15
      Print counter
      Rem Flush ' if you use the Push 1

      Sub alfa()
            \\ we make a local variable b
            \\ we assign a fresh group
            \\ then we read optional a pointer
            local b : b->b1() : Read ? b as pointer
            \\ now we make a second local variable
            \\ we assign a pointer
            local z : z->b
            beta()
      End Sub
      Sub beta()
            \\ increment member x
            z=>x++
            Print z=>x
            \\ subs have same scope as the module from where called
            counter++
      End Sub
}
Checkit
}
MODULE F3 {Module Checkit {
      group alfa {
      x=10
      }
      b->alfa
      checkme(b)
      Print b=>x=10
      Print alfa.x=10
      checkme2(b)
      Print b=>x=11
      Print alfa.x=11
      checkme3(&b)
      Print b=>x=12
      Print alfa.x=12
    
      \\ sub is like End if execution find it
      sub checkme(a as group)
            print type$(a)
            a.x++
            Print a.x
      End sub
      sub checkme2(a as pointer)
            print type$(a)
            a=>x++
            Print a=>x
      End sub
      sub checkme3(&a as pointer)
            print type$(a)
            a=>x++
            Print a=>x
      End sub
}
Checkit
}
MODULE F4 {\\ gosub call subs (subs with () or plain subs)
\\here we call a plain sub which is like we place the lines between label and return in the code where we call it
gosub modules
Report {
	This is a definition for alfa group with one public variable x
	group alfa {
		x=10
	}
}
group alfa {
	x=10
}
Report {
	we make b as pointer to alfa (is a simple reference - is a pointer to a static object)
	static object means named object, which exist until the get out of scope
	
	We have three modules and we call them passing the pointer b
	In each module we increase x value
	
	For first module we pass the b and read it as a group. So we get a new group as a copy
	For second module we pass the b and read it as pointer so we get the change after the call (this is the default if a in module is a new variable)
	For third module we pass the pointer by reference s &b, so we get the change after the call
	
}
b->alfa
checkme b
Print b=>x=10
Print alfa.x=10
checkme2 b
Print b=>x=11
Print alfa.x=11
checkme3 &b
Print b=>x=12
Print alfa.x=12
End
modules:
module checkme {
            Read a as group
            print type$(a)
            a.x++
            Print a.x
}
module checkme2 {
            Read a as pointer
            print type$(a)
            a=>x++
            Print a=>x
}
Module  checkme3 {
            Read &a as pointer
            print type$(a)
            a=>x++
            Print a=>x
}
Return
}
MODULE F5 {report {
	Same as F4 but now we use modules not subs
	A module has own scope
	A sub has the scope from where caled
}
flush  '' emprty the stack
gosub modules
group alfa {
x=10
}
b->alfa
\\ also here we can call like checkme ?  where ? means get the default value
\\ but we have to provide the default value before the actual read
\\ the last moduleget a group pointer by reference so we can't provide a default value
checkme
checkme b
Print b=>x=10
Print alfa.x=10
checkme2
checkme2 b
Print b=>x=11
Print alfa.x=11
checkme3 &b
Print b=>x=12
Print alfa.x=12
End
modules:
module checkme {
            group a {
                  x=100
            }
            Read ? a as group
            print type$(a)
            a.x++
            Print a.x
}
module checkme2 {
            group a1 {
                  x=100
            }
            a->a1
            Read ? a as pointer
            print type$(a)
            a=>x++
            Print a=>x
}
Module  checkme3 {
            Read &a as pointer
            print type$(a)
            a=>x++
            Print a=>x
}
Return


}
MODULE F6 {\\ using static variables
\\ a class function is a global one
\\ from the definition point until the function get out of scope
\\ here the scope is the checkme and for gloabals the checkit module
Module CheckMe {
      Class alfa {
            x=1000
      }
      Global Enum aaa {a,b,c,d}
      \\ use Clear to clear static from level of modules like Checkit
      Rem : Clear
      Module Checkit {
            \\ we can use stacks, arrays, inventories and pointers to groups
            \\ enumerators
            \\ for stacks
            static z=(stack:=1,2), m=(1,2,3,4), k->alfa()
            static b as aaa=a, cc=(List:="a":=100,"b":=500,"c":=200)
            read ? z
            Print k=>x
            k=>x++
            Print z
            Stack z {
                  if isnum then print number
            }
            Print m
            m++
            Return cc, "a":=cc("a")+1
            If Exist(cc,"a") Then Print Eval(cc)
     
      }
      flush  ' empty stack
      Checkit
      Checkit
      Checkit (stack:=5,6,7)
      Checkit
      Checkit
}
CheckMe
Clear  ' clear all static variables
}
MODULE F7 {Report "Using advapi32.SystemFunction036 as external function to make random bytes in a buffer"
Module checkit {
      Declare random1 lib "advapi32.SystemFunction036" {long lpbuffer, long length}
      Buffer Clear Alfa as long*2
      Print Eval(Alfa,0)
      Print Eval(Alfa,1)
      call void random1(alfa(0), 8)
      Print Eval(Alfa,0)
      Print Eval(Alfa,1)
}
checkit
}
MODULE F8 {Report {
	Another example using advapi32.dll to declare three external functions
	We use Constan identifiers at a global level.
	Also the Global scope end when this module exit
}
Declare Global CryptAcquireContext Lib "advapi32.CryptAcquireContextW" {Long &hProv, pszContainer$,pszProvider$, long dwProvType, long dwFlags}
Declare Global CryptReleaseContext Lib "advapi32.CryptReleaseContext" {Long hProv, Long dwFlags}
Declare Global CryptGenRandom Lib"advapi32.CryptGenRandom" {Long hProv, Long dwLen, Long &ByRef}
Global Const PROV_RSA_FULL As Long = 1
Global Const VERIFY_CONTEXT As Long = 0xF0000000&
 
\\ a call to a function can be done like a procedure call (calling a module)
\\ we have to drop the return value, because any value except zero raise an error
\\ we use the clause Void to drop the value

\\ In CryptGenRandom() we pass a Long which is a pointer to a Long variable
\\ So we say to declaration Long &Byref (then name can be anything, but not a string identifier, we wand number)
\\ So when we call the CryptGenRandom() we pass the &Rand  where Rand is long variable (it is a variant of type LONG inside)

 
Function  Random2 {
      Long Rand=0, hProv=0
      Call void CryptAcquireContext(&hProv, "", "", PROV_RSA_FULL, VERIFY_CONTEXT)
      Call Void CryptGenRandom( hProv, 4&, &Rand)
      Call Void CryptReleaseContext(hProv, 0&)
      =Rand
}
m= Random2()
mUnsigned=uint(m)
Print m
Print mUnsigned
Print hex$(mUnsigned, 4)
Print sint(mUnsigned)=m

Print m=eval("0x"+hex$(mUnsigned, 4)+"&")  ' using & at the end we get the signed long 32 bit
Print type$(mUnsigned)
m1=sint(mUnsigned)
Print type$(m1)
m2=binary.and(m1, 0xFF00FF00)
Print type$(m2)
k=0xFF00FF00
Print type$(k)
k1=Binary.Shift(k,-8)
Print type$(k1)
k2=Binary.Rotate(k,-8)
Print type$(k2)
\\ binary.add() make the addition of two 32bit numbers and a Mod 2^32,
\\ so always we cut the overflow bit
\\ The type interal is Currency, not a long, but it used in this functions like it is a 32bit value
k3=binary.add(0xFF123456,0xF1234567,0xFFFFFFFF)
Print type$(k3)
}
MODULE URL {Report {See also DD7 module which decoding for URI use internal funations
Here we see the decoding using M2000 code (slow)
}
Module checkit {
      document doc$
      any=lambda (z$)->{=lambda z$ (a$)->instr(z$,a$)>0}
      one=lambda (z$)->{=lambda z$ (a$)->z$=a$}
      number$="0123456789"

      series=Lambda -> {
                  func=Array([])
                  =lambda func (&line$, &res$)->{
                        if line$="" then exit
                        k=each(func)
                        def p=0,ok as boolean
                        while k {
                              ok=false : p++ : f=array(k)
                              if not f(mid$(line$,p,1)) then exit
                              ok=true
                        }
                        if ok then res$=left$(line$, p) : line$=mid$(line$, p+1)
                        =ok
                  }
      }

      is_any=lambda series, any (c$) ->series(any(c$))
      is_one=lambda series, one (c$) ->series(one(c$))
      Is_Alpha=series(lambda (a$)-> a$ ~ "[a-zA-Z]")
      Is_digit=series(any(number$))
      Is_hex=any(number$+"abcdefABCDEF")

      optionals=Lambda -> {
                  func=Array([])
                  =lambda func (&line$, &res$)->{
                        k=each(func)
                        def ok as boolean
                        while k {
                              f=array(k)
                              if f(&line$,&res$) then ok=true : exit
                        }
                        =ok
                  }
      }
      repeated=Lambda (func)-> {
                  =lambda func (&line$, &res$)->{
                        def ok as boolean, a$
                        res$=""
                        do {
                              sec=len(line$)
                              if not func(&line$,&a$) then exit
                              res$+=a$
                              ok=true
                        } until line$="" or sec=len(line$)
                        =ok
                  }
      }

      oneAndoptional=lambda (func1, func2) -> {
            =lambda func1, func2 (&line$, &res$)->{
                              def ok as boolean, a$
                              res$=""
                              if not func1(&line$,&res$) then exit
                              if func2(&line$,&a$) then res$+=a$
                              =True
                        }      
      }
      many=Lambda -> {
                  func=Array([])
                  =lambda func (&line$, &res$)->{
                        k=each(func)
                        def p=0,ok as boolean, acc$
                        oldline$=line$
                        while k {
                              ok=false
                              res$=""
                              if line$="" then exit
                              f=array(k)
                              if not f(&line$,&res$) then exit
                              acc$+=res$
                              ok=true
                         }
                        if not ok then {line$=oldline$} else res$=acc$
                        =ok
                  }
      }
      is_safe=series(any("$-_@.&"))
      Is_extra=series(any("!*'(),"+chr$(34)))
      Is_Escape=series(any("%"), is_hex, is_hex)
      \\Is_reserved=series(any("=;/#?: "))
      is_xalpha=optionals(Is_Alpha, is_digit, is_safe, is_extra, is_escape)
      is_xalphas=oneAndoptional(is_xalpha,repeated(is_xalpha))
      is_xpalpha=optionals(is_xalpha, is_one("+"))
      is_xpalphas=oneAndoptional(is_xpalpha,repeated(is_xpalpha))
      Is_ialpha=oneAndoptional(Is_Alpha,repeated(is_xpalphas))
      is_fragmentid=lambda is_xalphas (&lines$, &res$) -> {
            =is_xalphas(&lines$, &res$)
      }
      is_search=oneAndoptional(is_xalphas, repeated(many(series(one("+")),is_xalphas)))
      is_void=lambda (f)-> {
            =lambda f (&oldline$, &res$)-> {
                  line$=oldline$
                  if f(&line$, &res$) then {oldline$=line$ } else res$=""
                  =true
            }
      }
      is_scheme=is_ialpha
      is_path=repeated(oneAndoptional(is_void(is_xpalphas), series(one("/"))))
      is_uri=oneAndoptional(many(is_scheme, series(one(":")), is_path), many(series(one("?")),is_search))
      is_fragmentaddress=oneAndoptional(is_uri, many(series(one("#")),is_fragmentid ))
      
      Flush ' empty the stack of values

      data "foo://example.com:8042/over/there?name=ferret#nose"
      data "urn:example:animal:ferret:nose"
      data "jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true "
      data "ftp://ftp.is.co.za/rfc/rfc1808.txt"
      data "http://www.ietf.org/rfc/rfc2396.txt#header1"
      data "ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two"
      data "mailto:John.Doe@example.com"
      data "tel:+1-816-555-1212"
      data "telnet://192.0.2.16:80/"
      data "urn:oasis:names:specification:docbook:dtd:xml:4.1.2"

      while not empty {
            read What$
           
            pen 15 {
                  Print(What$)
            }
            a$=""
            If is_scheme(&What$, &a$) Then Print( "Scheme="+a$ ): What$=mid$(What$,2)
            If is_path(&What$, &a$) Then {
                  count=0
                  while left$(a$, 1)="/" { a$=mid$(a$,2): count++}
                  if count>1 then {
                        domain$=leftpart$(a$+"/", "/")
                        if left$(what$,1)=":"  and instr(what$,"@")<instr(what$,"/")  and instr(what$,"@")>0  then
                        username$=domain$
                        Print "uername:"+username$
                        what$=mid$(what$,2)
                        password$=leftpart$(what$,"@")
                        Print "password:"+password$
                        what$=rightpart$(what$,"@")
                        domain$=leftpart$(what$+"/", "/")
                        what$=Rightpart$(what$,"/")
                        end if
                        
                        a$=rightpart$(a$,"/")
                        
                        if domain$<>"" Then Print( "Domain:"+Domain$)
                        if a$<>"" Then Print("Path:"+a$)
                  } else.if left$(What$,1) =":" then {
                        Print( "path:"+a$+What$): What$=""
                  } Else Print("Data:"+ a$)

            }

            if left$(What$,1) =":" then {
                  is_number=repeated(is_digit)
                  What$=mid$(What$,2): If is_number(&What$, &a$) Then Print("Port:"+a$)
                  if not left$(What$,1)="/" then exit
                  If is_path(&What$, &a$) Then {
                        while left$(a$, 1)="/" { a$=mid$(a$,2)}
                        if a$<>"" Then Print("Path:"+a$)
                  }
            }
            if left$(What$, 1)="?" then {
                        What$=mid$(What$,2)
                        If is_search(&What$, &a$) Then {
                        v$=""
                        if left$(What$, 1)="=" then {
                              What$=mid$(What$,2)
                              If is_search(&What$, &v$) Then Print("Query:"+a$+"="+v$)
                        }  else Print("Query:"+a$)
                        }
            }
            While left$(What$, 1)="#"  {
            What$=mid$(What$,2)
            if not is_xalphas(&What$, &a$) Then exit
            Print( "fragment:"+a$)
            }
            if What$<>"" Then print("Data:"+ What$)
      }
      clipboard doc$
      Sub Print(a$)
            print a$
            doc$=a$+{
            }
      End Sub
}
Checkit
}
MODULE T1 {a=(1,2,3,4,5)
Print a#rev()
Print a#sum()=15
Print a#max()=5, a#min()=1
k=-1
L=-1
Print a#max(K)=5, a#min(L)=1
Print K=4 ' 5th position
Print L=0 ' 1st position
Print a#pos(3)=2 ' 3rd position
Print a#val(4)=5
\\ tuples in tuple
a=((1,2),(3,4))
Print a#val(0)#val(1)=2
Print a#val(1)#val(1)=4
a=(1,2,3,4,5,6,7,8,9)
fold1=lambda ->{
      push number+number
}
Print a#fold(fold1)=a#sum()
Print a#fold(fold1,1)=a#sum()+1
even=lambda (x)->x mod 2=0
b=a#filter(even, (,))
Print b ' 2 4 6 8
Print a#filter(even)#fold(fold1)=20
map1=lambda (a)->{
      push a+100
}
c=b#map(map1)
Print c ' 102,103, 104, 105
numbers=lambda p=1 (x) ->{
      push x+p
      p++
}
oldnumbers=numbers ' we get a copy of numbers with p=1
c=c#map(numbers)
Print c ' 103, 106, 109, 112
zfilter=lambda -> number>106
tostring=lambda -> {
      push chrcode$(number)
}
oneline=lambda -> {
             shift 2 ' get second as first
             push letter$+letter$
}
Line$=c#filter(zfilter)#map(tostring)#fold$(oneline,"")
print Line$="mp", chrcode$(109)+chrcode$(112)
zfilter=lambda -> number>200
Line$=""
Line$=c#filter(zfilter)#map(tostring)#fold$(oneline,"")
\\ lines$ can't change value becuse filter has no items to give
Print Line$=""
\\ if we leave a second parameter without value the we get No Value error
Try {
      Line$=c#filter(zfilter, )#map(tostring)#fold$(oneline,"")
}
Print error$=" No value"
\\ second parameter is the alternative source
Line$=c#filter(zfilter,(109,112))#map(tostring)#fold$(oneline,"")
Print Line$="mp"
c=(1,1,0,1,1,1,1,0,1,1,0)
\\ hard insert
Print c#pos(1,0,1) ' 1  means 2nd position
Print c#pos(3->1,0,1) ' 6  means 7th position
\\ using another tuple
Print c#pos((1,0,1)) ' 1  means 2nd position
Print c#pos(3->(1,0,1)) ' 6  means 7th position
t=(1,0,1)
Print c#pos(t) ' 1  means 2nd position
Print c#pos(3->t) ' 6  means 7th position
}
MODULE R1 {Report {Recerse a string holding the right chaacters in order (not reversed)
Using StrRev$() we get error in third exanple
}
Function DispRev$(a$) {
      i=1: j=Len(a$): if j=0 then ="": exit
      z$=String$(" ",j): j++
      do {
            k$=mid$(a$, i, 1)
            if i<len(a$) then {
            while len.disp(k$+mid$(a$, i+1,1)) =len.disp(k$) {
                  k$+=mid$(a$, i+1,1) : i++ : if i>len(a$) then exit
                  j-- } : j-- : insert j, len(k$) Z$=K$
            } else j-- :Insert j,1 z$=k$
            i++
           
      } until i>len(a$)
       =z$
}
Print DispRev$("abcd")="dcba"
Print DispRev$("")=""
Print DispRev$("s⃝df̅")="f̅ds⃝", StrRev$("s⃝df")="f̅ds⃝"
}
MODULE W1 { Report {
        This is an evolutionary Algorithm, where is a target string, a fitness functions which return a number of how many charachters are at the right position, but no information returned for which character is in wrong position.
        So we use a random solution as the start point
        Then algorithm make small changes and produce a number of solutions, and get the better one using the fitness function
        So the alogrithm produce always a same or better solution in each iteration.
        Finally we get the solution with the maximum fitness, which means we get the target string.
        Without the algorithm we need to more then  1.18376868261619E+39 strings to check
        Or Miliion of computational years.
        Here the tools to find it are two major:
              The small random changes
              The choise of a better solution from a list of solutions
         And a minor to make it faster
               After a level of fitness we use less changes (only one character), changing the starting lambda function with another. Lambda functions are first citizens in M2000.
        
        From the code the statement Dim a$(1 to gen)<<mutate$(f$) place for each item in a$() a new solution from mutate$() providing a starting string
        
 }
 Module WeaselAlgorithm {
      Print "Evolutionary Algorithm"
      \\ Weasel Algorithm
      \\ Using dynamic array, which expand if no fitness change,
      \\ and reduce to minimum when fitness changed
      \\ Abandon strings when fitness change
      \\ Also lambda function Mutate$ change when topscore=10, to change only one character
      l$="ABCDEFGHIJKLMNOPQRSTUVWXYZ "
      randomstring$=lambda$ l$ ->{
            res$=""
            For i=1 to 28: res$+=Mid$(L$,Random(1,27),1):next i
            =res$
      }
      m$="METHINKS IT IS LIKE A WEASEL"
      lm=len(m$)
      fitness=lambda m$, lm (this$)-> {
            score=0 : For i=1 to lm {score+=If(mid$(m$,i,1)=mid$(this$, i, 1)->1,0)} : =score
      }
      Mutate$=lambda$ l$ (w$)-> {
            a=random(1,28) : insert a, 1 w$=mid$(l$, random(1,27),1)
            If random(3)=1 Then b=a:while b=a {b=random(1,28)} : insert b, 1 w$=mid$(l$, random(1,27),1)
            =w$
      }
      Mutate1$=lambda$ l$ (w$)-> {
            insert random(1,28), 1 w$=mid$(l$, random(1,27),1) : =w$
      }
      f$=randomstring$()
      topscore=0
      last=0
      Pen 11 {Print "Fitness |Target:", @(16),m$, @(47),"|Total Strings"}
      Print Over $(3,8), str$(topscore/28,"##0.0%"),"",$(0),f$, 0
      count=0
      gen=30
      mut=0
      {
            last=0
            Dim a$(1 to gen)<<mutate$(f$)
            mut+=gen
            oldscore=topscore
            For i=1 to gen {
                  topscore=max.data(topscore, fitness(a$(i)))
                  If oldscore<topscore Then last=i:Exit
            }
            If last>0 Then {
                  f$=a$(last) : gen=30 : If topscore=10 Then mutate$=mutate1$
            } Else gen+=50
            Print Over $(3,8), str$(topscore/28,"##0.0%"), "",$(0),f$, mut : refresh
            count+=min(gen,i)
            If topscore<28 Then loop
      }
      Print
      Print "Results"
      Print "I found this:"; a$(i)
      Print "Total strings which evalute fitness:"; count
      Print "Done"
}
WeaselAlgorithm
}
MODULE S1 {Report {
	Drawing 5 spheres using a lambda function each time different, which produce a texture
	The last one is the Transparent function which read the color of the point where we
	Aftr the drwaing complete we get it in cliboard as an image (a DIB type) whichw we can import to any application which imports images from clipboard.
	
	Press a key
}
Push key$: Drop
Module CheckIt {
      Flush
      Form ! 60, 40    ' use ! to reduce form (for safe area for TV)
      oldback=point  ' read color from 0,0  ' (Mode, Form. and Widow statement reset graphic cursor)
      Cls 0 ' Black
      Gradient 0,1
      Pen 14 ' Yellow
      Set Fast !
      Refresh 500
      Module Sphere (R as long, X0 as long, Y0 as long, fun){
            R2 = R * R
            Def Long X, Y, D2
            Let Scale=twipsx/R*13.5
            For Y = -R To R step twipsx {
            Move X0-R, Y+Y0
            For X = -R To R step twipsy {
                  D2 = X **2 + Y **2
                  IF R2>D2 THEN Pset Fun(Max.Data(Min.Data((Sqrt(R2 - D2) - ( X + Y) / 2 )*Scale ,255),0))
                  Step twipsx
            }
            }
      }
      Blue=lambda (c)->{
            c1=c/4+192
            =Color(c,c,c1)
      }
      Blue1=lambda (c)->{
            c1=c/4+Random(150,192)
            =Color(c,c,c1)
      }
      Mystery=lambda m=1 (c)->{
            c1=c/4+m
            m+=10
            if m>192 then m=1
            =Color(c,c,c1)
      }
      Mystery2=lambda m=1, p=true (c)->{
            c1=c/4+m
            if p then m+=10
            Else m=-10   ' we can break the if statement when e didn't use an if inside
            if m>192 then m-=10 : p=false
            If m<0 then m+=10: p=true
            =Color(c,c,c1)
      }
      Buffer Alfa as byte*8
      \\ we place the Alfa as a closuer (Alfa is a pointer to a Buffer object)
      Trans =lambda Alfa (c) -> {
            Return Alfa, 0:=-point as long
            Return Alfa, 4:=-color(c,c, c/4+192) as long
            for i=0 to 2: Return Alfa, i:=(Eval(Alfa, i)+Eval(Alfa, i+4))/2: Next i
            =-Eval(Alfa, 0 as long)
      }
      Sphere 2400, 9000,7000, Blue
      Sphere 800, 6000, 7000, Blue1
      Sphere 1200, 5000,5000, Mystery
      Sphere 1200, 10000,6000, Mystery2
      Sphere 1200, 8000,5000, trans
      \\ set spped to normal  (Fast is normal)
      Set Fast
      Refresh 30
      copy$=""
      move 0,0
      copy scale.x, scale.y to copy$
      clipboard copy$
      Print Part @(0,height),"Press a Key"
      A$=Key$
      Cls oldback
      Clear ' clear variables
      \\ addition using clipboard.image$ to read a DIB image to string variable
      A$=Clipboard.Image$
      Move 3000, 3000
      Image A$, 6000    ' produce the image with a width of 6000 twips, and a height based on image ratio of Width/Height
      Move 3000,1000
      Image A$, 2000,2000  ' define both width and height (stretching the image)
}
Checkit
}
MODULE M1 {  Print @(tab(1)),
  Report {
         This example use code to make functions for filters to fold, and or map an array
         There are #functions to do that, but here we use code to do these functions (see M2)
         Se help  #map amd help #filter tp see the use of internal functions
         
         
         You can follow the code using Stop where you want to stop it then use exit statement to exit
         From stop state you can use List amd Modules ? to see variables and modules in modules list
         Also you can use print or you can change variables. Try ? C to print C array at the Stop statement (see the code). From editor mark the stop staterment here and press F3 to find it at the lines bellow. Use F2 to serch back.
         
         Press a key
        }, width-tab(1)*2
Print
      Push key$: Drop
Module FilterMapFold {
      Form 80,40
      \\ HasString()
      \\ used to find if an array has strings or numbers
      \\ looking first element
      \\ because a is an iterator of array we have to copy first item
      \\ in a fresh array, which is base 0 by default
      \\ car(a) return first item as an array of one item
      \\ cdr(a) return all others as an array - not used here
      \\ (,) is the empty array - we can use Len() to check this
      HasString=Lambda (&a) ->{
            z=car(a)
            if len(z)=0 then =false :exit
            link z to s()
            =type$(s(0))="String"
      }
      \\ FilterFold$()
      \\ get an array or a pointer to array or an iterator to array
      \\ then optional get filter
      \\ then get the fold function (not optional)
      \\ then get the initial string value - optional
      \\ return string
      FilterFold$=lambda$ HasString (w)-> {
            f=lambda->true
            res$=""
            Read ? f
            Read fold, ? res$
            flush ' empty stack no other arguments allowed
            if not valid(w^) then {m=each(w)} else m=w
            if HasString(&m) then {
                  while m {
                        if not f(array$(m)) then continue
                         Call fold(array$(m), &res$)
                  }
            } else {
                  while m {
                        if not f(array(m)) then continue
                         Call fold(array(m), &res$)
                  }
            }
            =res$
      }
      \\ FilterFold()
      \\ get an array or a pointer to array or an iterator to array
      \\ then optional get filter
      \\ then get the fold function (not optional)
      \\ then get the initial number value - optional
      \\ return number
      FilterFold=lambda HasString (w)-> {
            f=lambda->true
            res=0
            Read ? f
            Read fold, ? res
            flush ' empty stack no other arguments allowed
            if not valid(w^) then {m=each(w)} else m=w
            if HasString(&m) then {
                  while m {
                        if not f(array$(m)) then continue
                         Call fold(array$(m), &res)
                  }
            } else {
                  while m {
                        if not f(array(m)) then continue
                         Call fold(array(m), &res)
                  }      
            }
            =res
      }
      \\ FilterMap()
      \\ get an array or a pointer to array or an iterator to array
      \\ check to see if is an iterator, if not make one
      \\ then optional get filter function
      \\ check if has string or number
      \\ then optional get mapfunction
      \\ return a poinrer to a new array with results
      \\ [ ] get all items from stack and return a stack object
      \\ Array([])  convert stack object to array
      FilterMap=lambda HasString (w)-> {
            if not valid(w^) then {m=each(w)} else m=w
            f=lambda->true
            if HasString(&m) then {
                  map$=lambda$->Letter$
                  Read ? f, map$
                  flush ' empty stack no other arguments allowed
                  while m {
                        if not f(array$(m)) then continue
                        data map$(array$(m))
                  }
            } Else {
                  map=lambda ->Number
                  Read ? f, map
                  flush ' empty stack no other arguments allowed
                  while m {
                        if not f(array(m)) then continue
                        data map(array(m))
                  }
            }
           =Array([])
      }
      \\ we can combine filters using filter()
      \\ we can have any number of lambda functions as parameters
      \\ if any function return false then exit and return falsa
      \\ so return true only if all functions return true
      \\ here we use it with one parameter
      \\ s is a pointer to stack object
      \\ stack(s) is a stack object as copy of s
      \\ ! stack(s)  paste all items to current stack, the lambda stack
      \\ so filter  return a lambda which works for any number and type of arguments
      \\ we use T and F as boolean values - only for print statement
      \\ because True and False are doubles, not boolean, but works nice in boolean expressions
      \\ All comparisons return boolean.
      Function filter {
            Def boolean T=True, F=False
            dim all() : all()=Array([]) : L=len(all())-1
            =lambda all(), L , F, T -> {
                s=[] : =T
                for i=0 to L { if all(i)(!stack(s)) else =F : exit
                }
            }
      }
      \\ example for two parameters
      greater=lambda (x, z)->x>z
      divided=lambda (x, z)->x mod z=0
      myfilter=filter(greater, divided)
      Print myfilter(10,2)=true, myfilter(2,10)=false, myfilter(7,3)=false
    
      \\ combine$()
      \\ take any number of lambda functions, which return string/object result
      \\ combine$() get all parameters to an array and make it  a closure in the returned lambda
      \\ stackitem$() return any type from stack (string or object), without dropping it
      \\ because function's stack always erased at the exit, it make the drop for us.
      Function combine$ {
            dim all$()
            all$()=Array$([])
            L=len(all$())-1
            =lambda$ all$(), L -> {
                for i=0 to L {Push all$(i)(![])} : =StackItem$()
            }
      }
      \\ combine(
      \\ take any number of lambda functions, which return number/object result
      \\ combine() get all parameters to an array and make it  a closure in the returned lambda
      \\ stackitem() return any type from stack (number or object), without dropping it
      \\ because function's stack always erased at the exit, it make the drop for us.
      Function combine {
            dim all()
            all()=Array([])
            L=len(all())-1
            =lambda$ all(), L -> {
                for i=0 to L {Push all(i)(![])} : =StackItem()
            }
      }
      \\ so now we see some example of using these functions
      \\ b is a pointer to array
      b=(1,2,3,4,5,6,7,8)
      \\ just  return a copy of b
      Print FilterMap(b)
      \\ we make a lambda to be used to FilterFold
      \\ second parameter has to be passed by reference
      \\  We can use FilterFolder with String Arrays or Number Arrays
      \\ but we get number  as result (from FilterFolder$ we get string)
      \\ so the reference here must be for a number
      \\ the first parameter here is number because we have number array to fold
      mul=lambda (x, &p) -> {
            p*=x
      }
      \\ using initial value 1  (default is 0, but here 0 isn't good)
      Print FilterFold(b,,mul,1)
      \\ so now we use the same number array but for string result
      \\ we make a text with one to eight starts, like a triangle of stars
      bar$=lambda$ (x, &ret$) ->{
            ret$+=string$("*", x)+{
            }
      }
      \\ Report using 2 center each line, so we get something like a tree
      \\ also report use proportional spacing
      Report 2, FilterFold$(b,,bar$) +"*"
      \\ we can make a new array adding three times b, so now b point to a new array
      b=cons(b,b,b)
      \\ we want the sum of all numbers in b
      Sum=lambda (x, &total)->{
            total+=x
      }
      \\ we leave empty the filter, we place the sum function. Initial value is 0 and this is nice here.
      Print FilterFold(b, ,Sum)
      \\ We want now to get an array of all squares of even numbers in array
      \\ so we want  the Even function as filter (return a boolean)
      \\ and the square function which return squares
      Even=lambda (x)->x mod 2=0
      Square=lambda (x)->x**2
      \\ this is the same
      Square=lambda (x) -> {
            =x**2
      }
      \\ and this is the same too
      Square=lambda -> {
            Read x
            =x**2
      }
      \\ or better , using  Number  which pop a number from lambda's stack
      Square=lambda ->Number**2
      \\ so now we get an array with all values
      Print FilterMap(b, Even, Square)
      \\ We can get the sum too easy:
      Print FilterFold(FilterMap(b, Even, Square), , sum)
      \\ Warning
      \\ Each( )can't work with expression, it need a pointer to array or an array like a()
      \\ so we use c as a pointer to array
      c=FilterMap(Each(b 1 to 8), Even, Square)
      \\ we can see items and length
      Print c, len(c)
      \\ so now we can use each(c,1,2) to get the two first items
      \\ and using FilterFold we get the sum ot those two items
      Print FilterFold(each(c,1,2), , sum)
      Stop
      \\ We can use two dimensional arrays, or more (maximum ten dimensions)
      \\ we can set different base (low bound) for each dimension
      \\ Dim is always like a "Dim Preserve" in VB6
      Dim z(1 to 4, 1 to 2)
      z(1,1)=1,2,3,4,5,6,7,8
      \\ So now we pass z() to FilterFold, and this check that it has numbers
      \\ and apply the proper code to support the sum function
      Print FilterFold(z(), , sum)
      \\ no it has numbers
      Print HasString(&Z())
      \\ so now we see examples with strings in array
      a=("car","boat","cat","frog")
      \\ check that HasString() works
      Print HasString(&a) ' true
      \\ filters
      \\ check if a$ has a "t" upper or lower case
      HasAt=lambda (a$)->instr(lcase$(a$),"t")>0
      \\ check if a$ has three characters length
      IsThreeLetters=lambda (a$)->len(a$)=3
      \\ maps
      \\ convert to uppercase
      capitalize$=lambda$ (a$)->Ucase$(a$)
      \\ add "123"
      add123$=lambda$ (a$)->a$+"123"
      \\ add brackets
      addbrackets$=lambda$ (a$)->"["+a$+"]"
      \\ Using filterMap with no filter/map, so we get the first two items by each()
      Print filterMap(each(a,1,2))
      \\ now we get all items capitalize
      Print filterMap(a,,capitalize$)
      \\ now we get items with three letters capitalize
      Print filterMap(a,isThreeletters,capitalize$)
      \\  We pass a composite filter using  filter()
      \\ so now we want items with three letters and  have a "t" inside, and map to capitalize
      Print filterMap(a,filter(isThreeletters,HasAt), capitalize$)
      \\  Here we get all items with three letters an apply combine map of two functions
      \\ last function applied last
      Print filterMap(a,isThreeletters, combine$(capitalize$, add123$))
      \\  Here we get all items with three letters an apply combine map
      \\ last applied the addbrackets so we get [CAR123] [CAT123]
      Print filterMap(a,isThreeletters, combine$(capitalize$, add123$, addbrackets$))
      \\ So now we make a folding function
      \\ using string for items and by reference string for accumulator
      appendstring=lambda (x$, &all$)->{
            all$+=x$
      }
      \\ we get all items in a string without spaces
      Print FilterFold$(a,,appendstring)
      \\ we use each with no coma using "to" and Start and End (1 and -1), in reverse
      \\ so we get the items in a string in reverse order
      \\ reverse, we can use each(a, -1, 1)
      Print FilterFold$(each(a End to Start),,appendstring)
      \ like this
      Print FilterFold$(each(a,-1,1),,appendstring)
      \\ we can apply a filter
      Print FilterFold$(a,isThreeletters,appendstring)
      \\ or we can use the FilterMap() as a parameter for FilterFold$()
      Print FilterFold$(FilterMap(a,isThreeletters, combine$(capitalize$, addbrackets$)),,appendstring)
      \\ Another folding function, to get the total length, so we need number,
      \\ so we use FilterFold and not FilterFold$
      GetLength=lambda (x$, &all)-> {
            all+=len(x$)
      }
      \\ Also we can get the maximum length from items
      GetMaxLength=lambda (x$, &max)-> {
            If len(x$)>max then max=len(x$)
      }
      \\ so now we get the length from all items with three letters
      Print FilterFold(a,isThreeletters,GetLength)=6
      \\ and we get the maximum length from all items
      Print FilterFold(a,,GetMaxLength)=4
}
FilterMapFold

}
MODULE H1 {Form 80, 66
Cursor tab(1)
Report {
	This is an example to show how the light events in a group can be used.
	The theory about light events have some standards:
		1,	A call to an Event can be done, although this maybe do not call anything id we don't have a service function to use it
		2.	A servuce function has the same scope as the module we write to it. It is like we call a subroutine. But this call happen from another module, a group module. So the event call is a call BACK to module which we tie the group with DoEvents. The stack of values in event calls is new one, sp we can't a;ter the module's stack either in group module or in target module (where we tie the group with DoEvents)
		3.	We can't use multicast call using the light events. We have to use Evemt Object which use a list of functions to call. Event Objects can alter the finction list. The light events can't alter the service funcitons, but we can alter a function as usual by defining another time using tthe same name.  This can't be happen from group module where we call the event.
		4.	We can make float groups from a group which has light events and we tie it to a module. The internal code in M2000 make a list of weaj references to servixe functions and when we call en event check if the weak reference exist and call it or drop the call if not exist.
	Prees a key
	}, width-tab(1)*2
Print
Push Key$: Drop
Class HttpStatus {
Events "trace", "err","high","low"
Private:
      myvalue
Public:
      Enum Status { NotFound=404, MethodNotAllowed=405}
      Set {
            read x ' number or enum
            \\ if number not exist in enum list Then we get an error
            Call event "trace", x
            Try ok {
                  .myvalue<=x
            }
            if not ok Then call event "err", format$("value {0} not accepted", x)
      }
      Value {
            =.myvalue
      }
      Operator "++" {
            old=.myvalue
            .myvalue++
            if old=.myvalue Then call event "high"
      }
      Operator "--" {
            old=.myvalue
            .myvalue--
            if old=.myvalue Then call event "low"
      }
      class:
      Module HttpStatus {
      .myvalue<=.NotFound
      }
}
Group WithEvents HttpStatus=HttpStatus()
Function HttpStatus_trace(New a){
      Print ">>>",a
}
Function HttpStatus_err(New a$) {
      Print a$
}
accHigh=0
Function HttpStatus_high {
      Print "high limit"
      accHigh++
}
Function HttpStatus_low {
      Print "low limit"
}
Print HttpStatus.NotFound, HttpStatus.MethodNotAllowed
Print HttpStatus=404
HttpStatus=HttpStatus.MethodNotAllowed
Print HttpStatus=405
HttpStatus=10
Print HttpStatus=405
\\ 404 is ok
HttpStatus=404
Print HttpStatus
HttpStatus--
HttpStatus++
Print HttpStatus=405
HttpStatus++
Print accHigh=1
Print Type$(HttpStatus)="Group"
Def InferType$(x)=Type$(x)
Print InferType$(HttpStatus)="Status"
\\ for enum types Status letter Case have to match the Case in definition
Module Checkit(a as Status) {
      Print type$(a) ' it is a enum type, not a group, so no events happen
      Print a
      a--
      Print a, eval$(a)="NotFound"
     
}
Checkit HttpStatus.NotFound ' 404 404
Checkit HttpStatus ' 405 404
Print Eval$(HttpStatus)="MethodNotAllowed"
Try ok {
      Checkit 405
}
If error or not ok Then Print Error$ ' Wrong type in module A.CHECKIT
Module CheckThis(a as group) {
      Print "ok", a=405
      a++ ' raise high event, add one to acchigh
}
Try ok {
      CheckThis HttpStatus
}
If Error or not ok Then Print Error$ ' Wrong type in module A.CHECKTHIS
\\ we can pass group not value of HttpStatus
CheckThis Group(HttpStatus)
Print acchigh=2
Select Case HttpStatus
Case HttpStatus.NotFound
      Print "Not Found"
Case HttpStatus.MethodNotAllowed
      Print "Method Not Allowed"
End Select
HttpStatus=HttpStatus.NotFound
Module CheckThisToo(&a as group) {
      Print "ok", a=404
      a++ ' raise high event, add one to acchigh
}
\\ pass by reference
CheckThisToo &HttpStatus
Print HttpStatus=HttpStatus.MethodNotAllowed
\\ check a copy of HttpStatus to a
a=HttpStatus
a++
a++ ' we have no events now, a has a new cleared event list
Print a =405
\\ check a pointer to HttpStatus
b->HttpStatus
Print Eval(b), b=>NotFound, Eval$(b=>NotFound)="NotFound"
b++ ' we get event because b is a pointer to HttpStatus
Try {
      \\ b is an object so we get wrongtype
      Checkit b
}
\\ now we can get the value from b
Checkit eval(b)
\\ no used & because  b is actual a reference to HttpStatus
\\ if we use & then we pass the reference of pointer, not the the reference of Httpstatus
CheckThis b
Dim a(2)
\\ this is the second type of pointer, a pointer to a copy of HttpStatus
a(1)->(Group(HttpStatus))
b->a(1)
Print Eval(a(1))=405
a(1)--
Print Eval(a(1))=404
a(1)=405
Print Type$(a(1))="Group", InferType$(Eval(a(1)))="Status"
a(1)++ ' we get high limit, because a(1) has a float group (nameless), and event list inside is the original one.
b++ ' now we get high limit because b and a(1) show the same nameless (or float) group
}
MODULE H2 {\\ The task is simple;
\\ first we make a class function to produce a group with one variable and a value
\\ then we make p as a pointer to a float group produced from alfa()
\\ then we use p=>x to get the x value, and eval(p) to get the group value

\\ Then we want a named group, m, with a variable m to merge it with a group
\\ The group is a pointer to a float group in the stack, so we push p to stack
\\ We use a function which get any group (pointer on not pointer) as m
\\ then make a z and then we return z as group (using Group(), because without we get the value of z, if z has a value)

\\ We make the same, but now we didn't use the function but we do something else.
\\ First we have to use a fresh name, say m1, and read from stack as group, so if it is a pointer we get a group from the pointer
\\ now we can append a Y variable, using Group {} or using m1=class1() 

class alfa {
	x=10
	value {
		=.x*2
	}
}
\\ we can use p=pointer(alfa())
rem
p=pointer(alfa())
rem p->alfa()
Print p=>x, eval(p)=20
push p
group m {
	y=20
}
if rnd>.5 then
	Print "using getGroup(m)"
	function getGroup(m){
		group z=m
		=group(m)
	}
else
	Print "using getGroup(m as group)"
	function getGroup(m as group){
		=group(m)
	}
end if
m=getGroup(Group)
Print m=20, m.x, m.y
Push p
Read m1 as group
if rnd>.5 then
	Print "using group {}"
	group m1 {
		y=20
	}
else
	Print "Using class"
	class class1 {y=20}
	\\ Let is like Push class1() : read m1
	\\ without Let we get error: property can't change (there isn't a set { } session in class alfa)
	Let m1=class1()
end if
Print M1
M2=Group(M1)
Print M2.y=20, M2=20
list

}
MODULE H3 {\\ Like H2 but p is a special pointer, a reference to alfa
\\ In h2 a pointer to a float group when deleted or change pointer decrement the pointers number inside the group. So when this number goes to zero (no pointer point to foat group) then the group deleted
\\ the type of pointer we use here is a reference to a named group.. Internal the pointer holds only a weak reference so if no reference exist we get error when we try to use it
\\ A named group deleted when the owner (the module or function or block with temporary definitions) end the execution. We can say that a named group is a static group, but the name static used for static variables a subset of variable types which can be used for each call in a module or function or thread with only one time intialization at the Static statement. See Help Static
\\ Also a named group may use Light Events. Here the "p" event may have or not a Function alfa_p.
Print "Run this many times, to see all variants"
counter=0
group withevents alfa {
	event "p"
	x=10
	value {
		call event "p", 1
		=.x*2
	}
}
function alfa_p(x) {
	counter+=x
}
\\ we can use p=pointer(alfa())
rem
p=pointer(alfa)
rem p->alfa
Print p=>x, eval(p)=20, counter
push p
group m {
	y=20
}
Pen 11 {Print "We have a pointer to a group in stack"}
Stack
Over
Pen 11 {Print "Now we have a pointer to a group in stack two times"}
Stack
read NewGroup
def getGroup(m as group)=group(m)
Print counter=1
if rnd>.5 then
	Pen 15 {Print "using Group reading from stack"}
	m=Group
else
	Pen 15 {Print "using getGroup(m)"}
	m=getGroup(Group)
end if
Print m=20, m.x, m.y, counter
m.x++
print m.x=11, alfa.x=10, p=>x=10
print m, counter
Push p
Read m1 as group
\\ because m1 has a copy of weak reference to alfa_p and alfa_p exist
Print counter=3, m1, counter=4
if rnd>.5 then
	Pen 12 {Print "using group {}"}
	\\we get a clear event list, the counter=5 return false
	group m1 {
		y=20
	}
	Print counter=4, m1, counter=5
	\\ we can make a group m2 {y=20} and a let m1=m2 to get the y without deleting the event list.
else
	Pen 13 {Print "Using class in a let statement"}
	class class1 {y=20}
	\\ Let is like Push class1() : read m1
	\\ without Let we get error: property can't change (there isn't a set { } session in class alfa)
	\\ the error happen if we have a value {} session which make the group as a property
	Let m1=class1()
	Print counter=4, m1, counter=5
end if
def TypeExpression$(val)=type$(val)
Print "m1 is a group and return a double as value"
Print type$(m1), TypeExpression$(m1)
\\ so we get the group not the value using group()
M2=group(m1)
oldcounter=counter
Print counter
Print M2.y=20, M2=20
Print counter
if counter=oldcounter then
	Print "counter not changed because the event list inside group is empty"
end if
\\ We can get the value from NewGroup which is a pointer to a group
\\ but has event list from the original alfa
Print Eval(NewGroup)
Print Counter
\\ we use group(alfa) to get the group, not the value
\\ now NewerGroup is a real pointer to a copy of alfa
NewerGroup->(group(alfa))
Print Eval(NewerGroup)
\\ event list also copied, and because the actual event service function exist the event served
Print Counter
list
}
MODULE INF { locale 1033
Module CheckIt {
      Form 66,40
      Cls 5
      Pen 14
      \\ Ensure True/False for Print boolean (else -1/0)
      \\ from m2000 console use statement Switches without Set.
      \\ use Monitor statement to see all switches.
      Set Switches "+SBL"
      IF version<9.8 then exit
      IF version=9.8 and revision<18 then exit
      rem {
            \\ from revision 18 there is a constant infinity
            Function Infinity(positive=True) {
                  buffer clear inf as byte*8
                  m=0x7F
                  if not positive then m+=128
                  return inf, 7:=m, 6:=0xF0
                  =eval(inf, 0 as double)
            }
            K=Infinity(false)
            L=Infinity()
      }
      K=-Infinity
      L=Infinity
      Function TestNegativeInfinity(k) {
            =str$(k, 1033) = "-1.#INF"
      }
      Function TestPositiveInfinity(k) {
            =str$(k, 1033) = "1.#INF"
      }
      Function TestInvalid {
            =str$(Number, 1033) = "-1.#IND"
      }
      Pen 11 {Print "       True       True"}    
      Print TestNegativeInfinity(K), TestPositiveInfinity(L)
      Pen 11 {Print "    -1.#INF     1.#INF    -1.#INF     1.#INF    -1.#INF     1.#INF"}
      Print K, L, K*100, L*100, K+K, L+L
      M=K/L
      Pen 11 {Print "    -1.#IND    -1.#IND       True       True" }
      Print K/L, L/K, TestInvalid(M), TestInvalid(K/L)
      M=K+L
      Pen 11 {Print "    -1.#IND    -1.#IND    -1.#IND       True       True"}
      Print M, K+L, L+K, TestInvalid(M), TestInvalid(K+L)
      Pen 11 {Print "    -1.#INF     1.#INF"}
      Print 1+K+2, 1+L+2
      Pen 11 {Print "    -1.#INF"}
      Print K-L
      Pen 11 {Print "     1.#INF"}
      Print L-K
      Pen 11 {Print "       True       True       True       True"}    
      Print L<>k, 100>K, 100>K+1, L>K
      Pen 11 {Print "       True       True          1          0"}
      Print L+10>100, 100+L>K, L<=>k, L<=>L
}
Checkit
}
MODULE CONV { Module Checkit {
      Conv2dec=lambda (n$, frombase=10, dp$=".") -> {
           neg=left$(n$,1)="-": if neg then n$=mid$(n$,2)
           if instr(n$, dp$)>0 then {
                 n2$=Piece$(n$,dp$,2)
                 n$=Piece$(n$, dp$,1)
           } else n2$=""
           n0=0
           l1=len(n$)+1
           For i=len(n$) to 1
                 dig$=Mid$(n$,l1-i,1)
                 dig=asc(dig$)-48
                 if dig$>"9" then dig-=7
                 if dig>=frombase then error "not in base:"+frombase
                 n0+=dig*frombase^(i-1)
           next i
           if n2$<>"" then {
              For i=1 to len(n2$)
                 dig$=Mid$(n2$,i,1)
                 dig=asc(dig$)-48
                 if dig$>"9" then dig-=7
                 if dig>=frombase then error "not in base:"+frombase
                 n0+=dig/frombase^i
              Next i
           }
           if neg then n0-!
           =n0
      }
      Conv2Any$=Lambda$ (dec, tobase=10, dp$=".", prec=16) -> {
           a$=""
           neg=false
           if dec<0 then neg=true
           dec=abs(dec)
           n2=frac(dec)
           if dec=0 then {
                 a$="0"
           } else {
                 do {
                        n=dec mod tobase
                        if n>=10 then n+=7
                        a$=chr$(n+48)+a$
                        dec=dec div tobase
                  } until dec==0
            }
            if n2<>0 then {
                 a$+=dp$
                 prec--
                 do {
                      prec--
                      dec=n2*tobase
                      n2=frac(dec)
                      dec-=n2
                      n2=round(n2)
                      if dec>=10 then dec+=7
                      a$+=chr$(dec+48)
                 } until n2=0 or prec<0
            }
            if neg then {="-"+a$} else =a$
      }
      Rem : Locale 1033 ' use . for all print out for decimal point
      Print Conv2dec("10111.01011",2); " => ";Conv2Any$(23.34375,2)
      Print Conv2Any$(11.90625, 2); " => "; Conv2dec("1011.11101",2)
      \\ using , for decimal point
      Print Conv2Any$(Conv2dec("1011,11101",2, ","), 10, ",")
      Print 12312321.1212
      clipboard Conv2Any$(12312321.1212, 2)
      \\ using . for 1033 locale
      Print Str$(Conv2Dec(Conv2Any$(12312321.1212, 2), 2), 1033)="12312321.1211853"
      Print Str$(Conv2Dec(Conv2Any$(12312321.1212, 2,,52), 2), 1033) ="12312321.1212"
}
Checkit
}
MODULE RAT {Report {
	Rational Numbers
	Using a class Rational() which give a group object and set operators for evaluation of rational expressions
	A rational(10,15) is 10/15
	We can make arrays of rational numbers
}
Module RationalNumbers {
      Class Rational {
            numerator as decimal, denominator as decimal
            gcd=lambda->0
            lcm=lambda->0
            operator "+" {
                 Read l
                 denom=.lcm(l.denominator, .denominator)
                 .numerator<=denom/l.denominator*l.numerator+denom/.denominator*.numerator
                 if .numerator==0 then denom=1
                 .denominator<=denom
            }
            Operator Unary {
                  .numerator-!
            }
            Operator "-" {
                  Read l
                  Call Operator "+", -l
            }
            Operator high "*" {
                  Read l
                  g1=.gcd(l.numerator,.denominator)
                  g2=.gcd(.numerator, l.denominator)
                  Push l.numerator/g1*.numerator/g2
                  Push l.denominator/g2*.denominator/g1
                  Read .denominator, .numerator

            }
            Function Inverse {
                  if .numerator==0 then Error "Division by zero"
                  ret=This
                  sign=Sgn(ret.numerator) : if sign<0 then ret.numerator-!
                  swap ret.numerator, ret.denominator
                  if sign<0 then ret.numerator-!
                  =ret
            }
            Operator high"/" {
                  Read l
                  call operator "*", l.inverse()
            }
            Function Power {
                  Read pow as long
                  ret=This
                  ret.numerator<=.numerator^pow
                  ret.denominator<=.denominator^pow
                  =ret
            }
            Operator "=" {
                  Read l
                  Def boolean T=True, F=False
                  if Abs(Sgn(l.numerator))+Abs(Sgn(.numerator))=0 then Push T: exit
                  if Sgn(l.numerator) <>Sgn(.numerator) then Push F : exit
                  pcomp=l/this
                  PUSH pcomp.numerator=1 and pcomp.denominator=1
            }
            Operator  ">" {
                  Read l
                  Def boolean F
                  if Abs(Sgn(l.numerator))+Abs(Sgn(.numerator))=0 then Push F: exit
                  if Sgn(l.numerator)=0 then {
                        PUSH .numerator>0
                  } Else {
                        pcomp=this/l
                        PUSH pcomp.real>1
                  }
            }
            Operator ">=" {
                  Read l
                  if Sgn(l.numerator)=0 then {
                        PUSH .numerator>=0
                  } Else {
                        pcomp=this/l
                        PUSH pcomp.real>=1
                  }
            }      
            Operator "<" {
                  Read l
                  Def boolean F
                  if Abs(Sgn(l.numerator))+Abs(Sgn(.numerator))=0 then Push F: exit
                  if Sgn(l.numerator)=0 then {
                        PUSH .numerator<0
                  } Else {
                        pcomp=this/l
                        PUSH pcomp.real<1
                  }
            }
            Operator "<=" {
                  Read l
                  if Sgn(l.numerator)=0 then {
                        PUSH .numerator<=0
                  } Else {
                        pcomp=this/l
                        PUSH pcomp.real<=1
                  }            
            }
            Operator "<>" {
                  Read l
                  if Sgn(l.numerator)=0 then {
                        PUSH .numerator<>0
                  } Else {
                        pcomp=this/l
                        PUSH pcomp.real<>1
                  }            
            }
            Group Real {
                  value {
                        link parent numerator, denominator to n, d
                        =n/d
                  }
            }
            Group ToString$ {
                 value {
                        link parent numerator, denominator to n, d
                        =Str$(n)+"/"+Str$(d,"")
                  }      
            }
            class:
            Module Rational (.numerator, .denominator) {
                  if .denominator=0 then Error "Zero denominator"
                  sgn=Sgn(.numerator)*Sgn(.denominator)
                  .denominator<=abs(.denominator)
                  .numerator<=abs(.numerator)*sgn
                  gcd1=lambda (a as decimal, b as decimal) -> {
                        if a<b then swap a,b
                        g=a mod b
                        while g {
                              a=b:b=g: g=a mod b
                        }
                              =abs(b)
                  }
                  gdcval=gcd1(abs(.numerator), .denominator)
                  if gdcval<.denominator and gdcval<>0 then
                        .denominator/=gdcval
                        .numerator/=gdcval
                  end if
                  .gcd<=gcd1
                  .lcm<=lambda gcd=gcd1 (a as decimal, b as decimal) -> {
                        =a/gcd(a,b)*b
                  }
            }
      }
      Print rational(-3,3)<>rational(-3,3)  ' false
      M=Rational(10, 150)
      N=Rational(2, 4)
      Print "M.real+N.real=";M.real+N.real
      Print "Z=M+N"
      Z=M+N
      Print 10/150@+2/4@
      Print "Z.real="; Z.real
      Print "(";M.numerator;"/"; M.denominator;") + (";N.numerator;"/"; N.denominator;") = (";Z.numerator;"/";Z.denominator;")"
      Print M.tostring$+ " +"+N.tostring$+" ="+Z.tostring$
      Print -10/150@+2/4@
      Z=-M+N
      Print "-"+M.tostring$+ " +"+N.tostring$+" ="+Z.tostring$
      Print Z.numerator, Z.denominator, Z.numerator/Z.denominator
      Print -10/150@+2/4@
      Print Z.real
      Z=M-N
      Print Z.numerator, Z.denominator
      Print 10/150@-2/4@
      Print Z.real
      Z=M*N
      Print Z.numerator, Z.denominator
      Print (10/150@)*(2/4@)
      Print Z.real
      Z=M/N
      Print Z.numerator, Z.denominator
      Print (10/150@)/(2/4@)
      Print z.tostring$
      Print Z.real
      Print "Z power 2 = ";
      
      Z=Z.Power(2)
      Print Z.real
      Print z.tostring$;" = ";eval(z.tostring$)   
      Print Z=Z
      Print Z=N  ' false
      Print Z=-Z  ' false
      ZZ=-Z
      Print ZZ=ZZ
      Print -Z=-Z
      Print Z.numerator, Z.denominator
      Print Z.real, Z.tostring$
      \\ Array of rational numbers
      Dim K(100)=rational(1,1)
      M=K(4)+K(3)
      Print M.real
      Print K(4).toString$

      pk->(Z)
      Print pk=>toString$+" +"
      zzz=k(4)+pk
      Print zzz.toString$+ " ="+K(4).toString$+" +"+pk=>toString$
      
      zzz=Rational(10,1)+Rational(3,1)*Rational(2,1)
      Print zzz.toString$, zzz.real=16
      zzz=Rational(10,1)*Rational(3,1)+Rational(2,1)
      Print zzz.toString$, zzz.real=32

}
RationalNumbers
}
MODULE TUPLE { Form 80, 60
\\ Tuple of items (as one dimension arrays)
A=(1,2,3,4,5)
B=("George", 10, "Bob", 5)
C=(("George", 10),("Bob", 5))
Print Len(A)=5 ' true
Print Len(B)=4 ' true
Print Len(C)=2 ' true
\\ get reference of A to A1
A1=A
B1=B
C1=C
\\ Get Shallow Copy
Dim A(), B$(), C()
A()=A
B$()=B
C()=C
A(0)=10
Print A ' 1 2 3 4 5
Print A() ' 10 2 3 4 5
Link B$() to B()
B$(0)="Hello George"
B(1)=1000
Print B ' George 10 Bob 5
Print B$() ' Hello George 1000 Bob 5
C()=C
C(0)=("New Name", 500)
Print Array(C,0), Array(C, 1) ' George 10 Bob 5
Print C(0)(), C(1)() ' New Name 500 Bob 5
\\ Test Shallow Copy
\\ we keep pointer to second array but we change values
\\ we need a pointer to C[1]
N=Array(C,1)
\\ So we can use Return to return multiple values
Return N, 0:="New Bob", 1:=5000
\\ So Array(C,1) show us new values
Print Array(C,0), Array(C, 1) ' George 10 New Bob 5000
\\ And because we get shallow copy (pointer only) we get C(1)() array with new values
Print C(0)(), C(1)() ' New Name 500 New Bob 5000
\\ Now C(1) get a new pointer
C(1)=("Another Name", 2000)
Print Array(C,0), Array(C, 1) ' George 10 New Bob 5000
Print C(0)(), C(1)() ' New Name 500 Another Name 2000
\\ we can get a copy of A using Cons() with one argument
NewArray=Cons(A) ' copy of A
Print NewArray
NewArray2=Cons(A, A) ' add A twice
Print NewArray2
\\ Get a copy of C() to a pointer
CopyC=Cons(C())
Print Array(CopyC, 0), Array(CopyC, 1)
Return CopyC, 1:=("Just Another Name", 3000)
Print Array(CopyC, 0), Array(CopyC, 1) ' New Name 500 Just Another Name 3000
Print C(0)(), C(1)() ' New Name 500 Another Name 2000

\\ Pointers for multi dimension arrays
Dim A(2 to 10, 5 to 10)=1
M=A()
Print Len(M) = 54 ' 9X6
Print array(M, 2,5)=1 \\ M point to a 2 dimension Array
\\ Return use one dimension, so 0 is the first element
Return M, 0:=1000, 6:=5000 ' 6 is the 7th item, first in second row (row, columns)
Print array(M, 2,5)=1000, array(M, 3,5)
Dim A(2 to 11, 5 to 10) ' add one row
Print Len(M) = 60 ' 10X6
Print Type$(A(11, 5))="Empty"  ' new raw has Empty as value (in calculations this is same as 0 or empty string)
\\ So now we put a value
For i=5 to 10:A(11,i)=1:Next i
\\ we can alter last item using pointer M
Return M, 59:=9999
Print A(11, 10)=9999
\\ assuming we have defalut base 0
Dim A(10,6) ' redim preserving values
Print A(9, 5)=9999, Len(A())=60
\\ we can use Base 1 or Base 0 to explicit declare base
Dim Base 1, A(10,6) ' redim preserving values
Print A(10, 6)=9999, Len(A())=60
\\ or we can use for each dimension a new base
Dim A(5 to 14, 10 to 15) ' redim preserving values
Print A(14, 15)=9999, Len(A())=60
\\ Get dimensions, width for each dimension, base (min value) for each dimension, max value for each dimension
Print Dimension(A())=2 ' 2 dimension
Print Dimension(A(),0)=5 ' first dimension base is 5
Print Dimension(A(),1)=10 ' 10 items
Print Dimension(A(),2)=6 ' 6 items, so we have 10x6 items
Print Dimension(A(),1,0)=5
Print Dimension(A(),1,1)=14
Print Dimension(A(),2,0)=10
Print Dimension(A(),2,1)=15
\\ Copy all item to stack using pointer to array (not A() but M)
Flush  ' now stack is empty stack
Push ! M ' now get 60 items
Print stack.size=60 ' true
Stack   ' now display all stack items
Flush ' now empty stack
\\ if we use Push ! M we send values in reverse
Data ! M ' now get 60 items
\\ now all item make an array and return a pointer to Z
Z=Array([])
Print stack.size=0
Link Z to Z()
Dim Z(5 to 14, 10 to 15)
Print Z()
Print Z(14,15)=9999
Z++ ' Add 1 to all items
Print Z()
Z(14,15)-- ' Subtract 1 from one item
Print Z(14,15)
}
MODULE TU {Module TestGroup {
      Group A {
            X=10
            Dim K(10)=1
      }
      Dim A(), B()
      A()=(A,)
      B()=A()
      A(0).X++
      A(0).K(0)=1000
      Print A(0).X=11, A(0).K()
      Print B(0).X=10, B(0).K()
}
TestGroup


Module TestGroup2 {
      Group A {
            X=10
            Dim K(10)=1
      }
      Dim A(), B()
      A()=(0,) ' one item
      A(0)->(A) ' now A(0) has a pointer to a copy of  A
      B()=A()
      A(0).X++
      A(0).K(0)=1000
      Print A(0).X=11, A(0).K()
      Print B(0).X=11, B(0).K()
}
TestGroup2
}
MODULE PEND {Module Pendulum {
      back()
      degree=180/pi
      THETA=Pi/2  ' +p/8
      SPEED=0
      G=9.81
      L=0.25
      Refresh 5000
      Profiler
      lasttimecount=0
      cc=50
      accold=0
      ACCEL=0 'G*SIN(THETA*degree)*L
      time=now
      timed=1/24/3600*(cc*1.5)/1000
            Thread {
            time+=timed
            ACCEL=G*SIN(THETA*degree)*L
            SPEED+=ACCEL/cc
            THETA+=SPEED
            if sgn(accold)<>sgn(ACCEL) then lasttimecount=timecount: Profiler
            accold=ACCEL
      } as M interval cc
      Main.Task 20 {
            Pendulum(THETA)
            if KeyPress(32) Then Exit
      }
      Threads Erase
      Sub back()
            If not IsWine then Smooth On
            Cls 7,0
            Pen 0
            Move 0, scale.y/4
            Draw scale.x,0
            Step -scale.x/2
            circle fill #AAAAAA, scale.x/50
            Hold ' hold this as background
      End Sub

      Sub Pendulum(x)          
            x+=pi/2
            Release ' place stored background to screen
            Width scale.x/2000 {
                  Draw Angle x, scale.y/2.5
                  Width 1 {
                        Circle Fill 14, scale.x/25
                  }
                  Step Angle x, -scale.y/2.5
            }
            cursor 0,1
            Print time$(time,,"mm:ss"), round(lasttimecount,2), "", time$(now,,"mm:ss"), round((now-time)*100000, 2)
            refresh 1000
      End Sub
}
while inkey$<>"" : end while
Set Fast!
Pendulum
Set Fast
keyboard "Info"+chr$(13)
}
MODULE LOGO {smooth off  ' can't use xor with GDI+, so we work with GDI32 (by default)
Form 80, 50
Refresh 10000
Cls 5,0
Pen 14
Cursor 0,0
Move 0,0
Fill scale.x,600,5,12
move 0, 600
Fill scale.x,800,12,5
Cursor 3
drawframeM()
drawframe2()
drawframe0()
drawframe0()
drawframe0()
Move 0, 1400
Cursor !  ' turn character cursor as near to graphic cursor 
cls, row
Refresh 50
Sub drawframeM()
      local i, n=0
      Move !
      Pen 0 {
            Step 100, 100
            For i=1 to 2 {
                  Path n {
                        Polygon 0, 1000, 0, 0,1000, -200,0, 0,-700,-200, 0, 0,700, -200,0, 0,-700,-200, 0, 0,700, -200, 0, 0,-1000
                        Step 200, 300
                  }
                  Step -300, -400
                  n=15-n
            }
      }
      Step 1400,0
      Cursor !
End Sub
Sub drawframe2()
      local i, n=0
      Move !
      Pen 0 {
            Step 100, 100
            For i=1 to 2 {
                  Path n {
                        Polygon 0, 1000, 0, 0,600, -700,0, 0,100,700,0,0,300, -1000,0,0,-600,700,0,0,-100,-700,0,0,-300
                        Step 200, 300
                  }
                  Step -300, -400
                  n=15-n
            }
      }
      Step 1400,0
      Cursor !
End Sub
Sub drawframe0()
      local i, n=0
      Move !
      Pen 0 {
            Step 100, 100
            For i=1 to 2 {
                  Path n {
                        Polygon 0, 1000, 0, 0,1000, -1000,0, 0,-1000
                        Step 200, 300
                        Polygon 0, 600, 0, 0,400, -600,0, 0,-400
                  }
                  Step -300, -400
                  n=15-n
            }
      }
      Step 1400,0
      Cursor !
End Sub
}
MODULE EN {if version< 9.9 Then 1000
If revision<19 Then 1000
\\ by default Dog=1, Cat=2
\\ we can change it: Dog=0, Cat   ' so now Cat=1
\\ we can change it: Dog=100, Cat=200
\\ we can put a new line in place of comma
\\ or after comma,
\\ we can't leave a comma as last character except new lines, in the enum block.
Enumeration Pets {
      Dog
      Cat
}
a=Dog
Print a=1 ' true
a++
Print Eval$(a)="Cat", a=2
k=Each(Pets)
While k {
      Print Eval$(k), Eval(k), k^    ' k^ from 0
      a=Eval(k)
      Print a<Cat
      Alfa(a)
}
a=Dog

AlfaByRef(&a)

Print a=Cat  ' true
Print "a value by name:";@Name$(a)
\\ k is integer type
For k=Dog to Cat
      Print "k value by name:";@Name$(k), type$(k)
Next

kk=Each(Pets)
While kk
      Print @Name2$(kk), @Name$(kk)
End While

Sub Alfa(b as Pets)
      Print b
End Sub
Sub AlfaByRef(&b as Pets)
      Print b
      b++
End Sub
\\ handle number and Pets type and iterator for Pets Type
Function Name$(a)
      local b as Pets
      b=a
      =Quote$(Eval$(b))
End Function
\\ hanlde only Pets type and iterator of Pets type
Function Name2$(b as Pets)
      =Quote$(Eval$(b))
End Function
1000  Error "From revision 19, Version 9.9"
}
MODULE FS {\\ appdir$ is the application directory. Normally we nevert use it
\\ dir$ is the current dir
\\ see Help "file operations" or Help "file "
\\ Help Files  (or one of this list BITMAPS, CLOSE, DRAWINGS, FILES, GET, LINE INPUT, MOVIES, NAME, OPEN, PUT, SEEK, SOUNDS, WRITE)

Dir user  ' set current directory to M2000 user
userdir$=dir$
Declare fs "Scripting.FileSystemObject"
show_members(fs)
Method fs, "GetFolder", dir$ as fc
Print "GetFolder members"
show_members(fc)
With fc, "SubFolders" set SubFolders
Print type$(SubFolders)
show_members(SubFolders)


With SubFolders, -4& as Folder, "count" as SF.count
Print SF.count
if SF.count>0 then
	Show_Folders(SubFolders)
else
	Try ok {
		SubDir NewFolder1
		wait 100  ' give some time to system
		if exist.dir("..\NewFolder1") then
			Print "Folder Created"
			Dir ..\     ' return
		else
			dir user
		End if
	
	}
	if error or not ok then Print "Error from SubDir:"+Error$
	Print "Total folders="; SF.count
	If SF.count> 0 then Show_Folders(SubFolders)
End If
Win Dir$  ' open explorer in M2000 user directory
Rem Win "explorer", "/select,"+dir$  ' open explorer with selected name the folder dir$
declare fs nothing


sub show_members(obj)
local mm=param(obj), i
IF LEN(mm)>1 THEN {
      For i=0 to len(mm)-1
            Report 3, mm$(i!) ' use index, not key
      Next i
}
end sub
sub Show_Folders(obj)
With obj, -4& as new Folder

	With Folder, "Name" as FolderName$
	
	While Folder {
	      Print FolderName$
	}

end sub
}
MODULE FS1 {Declare fs "Scripting.FileSystemObject"
Method fs, "GetFolder", dir$ as fc
With fc, "files" set files
\\ Produce the TypeLib
mm=param(files)
IF LEN(mm)>1 THEN {
      For i=0 to len(mm)-1
            Report 3, mm$(i!) ' use index, not key
      Next i
}
Print "Press a key ": Print Key$
With files, "count" as count
if count>0 then
      With files, "item" set myfile ("llist1.gsb")
      \\ this is a property -4 which return a IEnumVariant
      With files, -4& as EnumFile
      Print Type$(EnumFile)
      \\ Produce the TypeLib
      m=param(EnumFile)
      IF LEN(m)>1 THEN
            For i=0 to len(m)-1
                  Report 3, m$(i!) ' use index, not key
            Next i
      End If
      Print "Press a key ": Print Key$
      With EnumFile, "Name" as aName$
      While EnumFile
            Print aName$
      End While
End if
Declare fs nothing

}
MODULE GAME {Module Game2048 {
      \\ 10% 4 and 90% 2
      Def GetTlleNumber()=If(Random(1,10)=1->4, 2)
      \\ tile
      Def Tile$(x)=If$(x=0->"[    ]", format$("[{0::-4}]", x))
      \\ empty board
      BoardTileRight =lambda (x, y)->x+y*4
      BoardTileLeft=lambda (x, y)->3-x+y*4
      BoardTileUp=lambda (x, y)->x*4+y
      BoardTileDown=lambda (x, y)->(3-x)*4+y
      Dim Board(0 to 15)
      Inventory EmptyTiles
      \\ Score is a statement but we can use it as a variable too.
      Score=0
      \\ Win is also a statement but we can use it as a variable too.
      Win=False
      ExitNow=False
      BoardDirection=BoardtileRight
      Process(BoardDirection)
      \\ Split Rem lines to insert start condition to check valid moves
      Rem : board(0)=2
      Rem : board(1)=2, 2, 2 ' place to (1), (2), (3)
            While len(EmptyTiles) {
            NewTile()
            DrawBoard()
            Action=False
            do {
                  a$=key$
                  if len(a$)=2 then {
                        Action=true
                        Select case Asc(mid$(a$,2))
                        Case 72
                        BoardDirection=BoardTileUp
                        Case 75
                        BoardDirection=BoardTileRight
                        Case 77
                        BoardDirection=BoardTileLeft
                        Case 80
                        BoardDirection=BoardTileDown
                        Case 79 ' End key
                              ExitNow=True
                        Else
                        Action=false
                        end select
                  }
            } until Action
            If ExitNow then exit
            Process(BoardDirection)
      }
      If Win then {
            Print "You Win"
      } Else {
            Print "You Loose"
      }
      Refresh 30
      End
      Sub Process(Boardtile)
      Inventory EmptyTiles ' clear inventory
      local where, i, j, k
      For i=0 to 3
            Gravity()
            k=boardtile(0,i)
            For j=1 to 3
                  where=boardtile(j,i)
                  if Board(where)<>0 then {
                        if board(k)=board(where) then {
                               board(k)*=2 : score+=board(where): board(where)=0
                               if board(k)=2048 Then Win=True : ExitNow=true
                        }
                  }
                  k=where
            Next j
            Gravity()
            For j=0 to 3
                  where=boardtile(j,i)
                  if board(where)=0 then Append EmptyTiles, where
            Next j
      Next i
      End Sub
      Sub NewTile()
            local m=EmptyTiles(Random(0, len(EmptyTiles)-1)!)
            Board(m)=GetTlleNumber()
            Delete EmptyTiles, m
      End Sub
      Sub DrawBoard()
            Refresh 2000
            Cls
            Cursor 0, 10
            Local Doc$, line$
            Document Doc$
            Doc$=Format$("Game 2048 Score {0}", score)
            \\ Using Report 2 we use rendering as text, with center justify
            Report 2, Doc$
            Doc$={
            }
            Local i, j
            For i=0 to 3
                  line$=""
                  For j=0 to 3
                        line$+=Tile$(Board(BoardTileRight(j, i)))
                  Next j
                  Print Over $(2), Line$
                  Print
                  Doc$=Line$+{
                  }
            Next i
            Report 2, "Next:Use Arrows | Exit: Press End"
            Refresh
            ClipBoard Doc$
      End Sub
      Sub Gravity()
            k=-1
            for j=0 to 3 {
                  where=boardtile(j,i)
                  if k=-1 then if board(where)=0 then k=j : continue
                  if board(where)=0 then continue
                  if k=-1 then continue
                  board(boardtile(k,i))=board(where)
                  board(where)=0
                  k++
            }  
      End Sub
}
Game2048
}
MODULE FIX1 {Class fixme {
      f=lambda->1
}
fix->fixme()
next_fact=lambda fix (x)->{
     if x<=1 then =1 :exit
     =x*fix=>f(x-1)
}
fix=>f=next_fact
Print next_fact(5)
m=next_fact
Print m(5)
}
MODULE Y {op=Pen
Pen 15
Report {
	Y combinator in M2000
	Two versions for two functions 	factorial and fibonacci
	For example (the Lamnda identifier removed for now)
	(g, x)->{
		=g(g, x)
	}((g, x)->if(x=0->1, x*g(g, x-1)), 24@)
	
	We pass by value for first g this: (g, x)->if(x=0->1, x*g(g, x-1))
	and for x the value 24@ (decimal type)
	
	so we call the g function passing by value the same g (lambda functions are first citizen)
	we never call the current function g (by using lambda() for a reccursion call)
	
	so the combinator Y combinbe two functions, the first one and the internal function g which always provide.
	the result from internal g is either 1 or x*g(g, x-1) depends on value of x.
	
	We use If() statement which execute only one part after arrow.
	
	a lambda function need the Lambda identifier before and we can provide
	This is a simple lambda:
	a=lambda->0
	? a()=0   ' true
	Now with a parameter  (it is a simple form without {} and we can use it if we didn't provide a comma after)
	
	a=lambda (k)->k**2
	? a(2)=4
	Or
	a=lambda (k)->{
		' we can use many statements
		' the = statament never exit the function and is optional (without it a 0 returned)
		' the function ends with a break, or an exit, or at the end of a block, and on error
		=k**2
	}
	We can execute a lambda without assign a lambda to a variable, just use after arrow {funtion code here}():
	Print lambda (x)->{=x**2}(2)=4
	
	In the curly brackets we have a regular function with one diffrence. If we use closures that closures stay to lambda
	The closures in lambda can change state if we want. Using lambda() we can call again the same function, but closures are the same for each call
	If we want a lambda to return a string we use Lambda$ and for recursion lambda$()
	We can use lambda() and lambfa$() in any regular function.
	Also we can use &a to pass a lambda in a variable by reference, or &a() to pass the function by reference
	Passing the variable by reference we can change it and the change return back.
	Passing the function by reference only pass the code to a new function, but for lambda functions the clousres can be used
	We can define a closure in the lambda definition proviing a value, or we can just use a copy of an already defined one
	So we can make generators
	x=1
	a=lambda X -> {
		=X
		X++
	}
	Print a()=1, a()=2
	See the LambdaExample in the Y code (use Edit Y)
	
}
Module Ycombinator {
	\\ factorial  - 10@ is a decimal literal (29 digits)
	Print @(tab(2)), "factorial of 24 = ";lambda (g, x)->{=g(g, x)}(lambda (g, x)->if(x=0->1, x*g(g, x-1)), 24@)
	\\ fibonacci
	Print @(tab(2)),"fibonacci 10th = ";lambda (g, x)->{=g(g, x)}(lambda (g, x)->if(x<=1->x,g(g, x-1)+g(g, x-2)), 10)
	
	\\ Using closure in y, y() return function
	y=lambda (g)->lambda g (x) -> g(g, x)
	
	fact=y((lambda (g, x)-> if(x=0@->1@, x*g(g, x-1))))
	Print @(tab(2)), fact(6)," ", fact(24)
	
	fib=y(lambda (g, x)->if(x<=1->x,g(g, x-1)+g(g, x-2)))
	Print @(tab(2)), fib(10)
}
Pen 14
Ycombinator
Pen 15
Report {
	The lambda example
}
Pen 14
Module LambdaExample {
	x=1
	a=lambda X -> {
		=X
		X++
	}
	Print @(tab(2)), a()=1, a()=2
	b=a
	Print @(tab(2)), a()=3, a()=4
	Print @(tab(2)), b()=3, b()=4
	Module Inner(&z()) {
		Print @(tab(2)), z(), z()
	}
	Inner &b()    ' 5 6
	Print @(tab(2)), b()=7
	Module Inner2(z) {
		Print @(tab(2)), z(), z()
	}
	Inner2 b    ' 8 9
	Print @(tab(2)), b() ' 8
	Module Inner3(&m, n) {
		m=n
	}
	Inner3 &b, a
	Print @(tab(2)), b() '5
	
}
Pen 14
LambdaExample
Pen 15
Report {
	A closure isn't like a static variable. A static variable has a bond with the caller
	A closure has a bond only with the current lambda
	Exception exist for those closures which are pointers, we get a copy of pointer, so maybe two lambda share the same closure, because point to same container
	Containers maybe anything that provide a pointer
	Groups may or may not provide a pointer.
	
	The Counter function use a static variable.
	When we pass it by reference the C() called inside Inner4 create a new static x
	Next time this new static used
	But outside the Inner4 module we use the first static
	
	So static variables are not the same as closures.
	
}
Pen 14
Function Counter {
	Static x=1
	=x
	x++
}
Print @(tab(2)), Counter(), Counter()   ' 1 2
Module Inner4(&C()) {   
	Print @(tab(2)), C(), C()
} 
Inner4 &Counter()     ' 1 2
Inner4 &Counter()     ' 3 4
Print @(tab(2)), Counter(), Counter()  ' 3 4
Pen 15
report {
	Except of lambda and regular functions the latest M2000 version has the analogus to subs but as functions
	We can call these functions as Inner Functions because can exist only in a module or in a function (lammbda or regular function)
	Code for inner functions always are at the end of code, after END or after END SUB
	We can make number or string functions. The name of a function used by the subs system, with one exception: We can call an inner function if this function has different name from any of internal functions like Abs() and Sgn().  We can replace Abs() using regular function for a module, but the @Abs() always call the internal original function. So inner functions use the @ character, so first the interpreter check if it is an internal code and then call the inner function.
	An inner function has the same scope as a sub, has module scope.
	An inner function use the same stack for values as the module (regular functions and lambdas in an expresion start with a fresh stack of values, if we call them using Call like a module then we pass the module stack).
	We can't call an inner function using Call or Function() and Funcrion$().
	Interpreter search for inner function  the first time from the end in current code or from parent original code, but the code executed in the scope of current executed code.
	Goto can be used inside a Function ...End Function structure, also we can call subs or simple routines from.
	
}
\\ rules for names are like subs, but not like simple routines with Gosub to a label (which we have to use same case label)
Pen 14
Print @(tab(2)), @FACTORIAL(24) 
Print @(tab(2)), @factorial(10)
Pen 15
Report {
	Conclusion:
	For Y combinator we can use only lanbda functions which we use them as first citizens
	regular functions and inner functions can't be used.
	
	A regular function defined as the code executed. We can change the definition later or using an if before so we can select the code as we wish. Also we can pass it by reference. Also we can pass it to Event objects (which they hold list of functions)
	
	An inner function can't change
	
	
}
Pen OP
Clear \\ clear all static variables
End
Function factorial(x)
	if x<2 then =1@ : Exit Function
	=@factorial(x-1)*x
End Function

}
MODULE EV {Module CheckEvents {
      \\ we can use standard functions (not lambda functions)
      \\ we can use lambda() so we can use function with different names
      \\ We can define functions inside groups with events
     Group WithEvents Alfa {
           Event "GetIt", "PushIt"
           Function fib(n) {
                  if n<=1 then {
                        =val(n->Decimal)
                  } else {
                        if n<140 then { m=-1@} else m=-1
                        call event "Getit", n, &m
                        if m>-1 then =m : exit
                        \\ m1 may get double if a decimal can write the result
                        \\ if we use m we get overflow error
                        m1=lambda(n-1)+lambda(n-2)
                        call event "Pushit", n, m1
                        =m1
                  }            
            }
      }
      \\ we use an Inventory list to save old values
      Inventory Getit
      \\ event's service functions
      \\ if not event's functions exist, call event skipped
      Function Alfa_Getit {
            Read new key, &m
            if exist(Getit, key) then m=eval(Getit)
      }      
      Function Alfa_Pushit {
            Read new key, m
            Append Getit, key:=m
      }
      Module Inner (&fibonacci()){
            acc=0
            For i=1 to 200 ' until 139 we get decimal type, above it we get double
                  Print fibonacci(i),
            Next i
      }
      Form 80,32
      print $(4,20),	' set: proportional text, 20 characters column width
      Inner &Alfa.fib()
      print $(0,10),	' reset: no proportional text, 10 characters column width

}
CheckEvents
}
MODULE MG {oldfont$=Fontname$
Font "Arial"
Form 60,44
Escape Off
Flush
Flush Garbage
mybg=5
Cls mybg,0 : Pen 11
Bold 1
Report "Console Input Parameters Easy"
Bold 0
Cursor 0,0 : Print Under
Cls , 1

\\  ValidateValue(number, letter$)
\\  return a lambda function with closures And signature lambda(letter$), returning boolean
\\  ValidateValue( number, number)
\\  return a lambda function with closures And signature lambda(number), returning boolean

Function ValidateValue {
      IF match("NN") Then {
            Read X1, Y1
            =lambda X1, Y1 (n) ->{
                  =X1<=n And n<=Y1 ' Or n<Y1
            }
      } Else {
            Read what, x1$
            =lambda x1$, what (n$) ->{
                  IF what=0 Then {
                        =n$ ~ x1$
                  } Else.If what>0 Then {
                         =n$ >= x1$ And len(n$)>what
                  } Else = n$ >= x1$ And len(n$)>-what And n$=filter$(n$, " ")
            }      
      }
}
\\ InpValueClass make a group
\\ We can display labels, values, recording positions
\\ Using ScanRange we can use arrows To move from a range of input values, in Loop
\\ using Esc we get out from Loop
\\ we can give two more parameters
\\ the "Exit" value  And a flag, IF True Then Exit IF value changed
\\  mygroup=InpValueClass(#FF5522)  '' need a color for background
\\
\\  .Record=True  needed for recording
\\  .PrintLabel
\\  .PrintNext
\\  .PrintUp
\\  .UseLastAsList
\\ when we record we make ranges of input/print values And we can use
\\ .RenderView To print labels/values
\\ .ScanRange 
\\
Class InpValueClass {
Private:
      NoKey, LastKey$, UseInteger, drawbg, overridecolors, mybg, overfr, overbg
      Inventory Bag, EditItems
Public:
      Record=True,  item
      Property mywidth {
            Value, 
            Set {
                  IF value>width Then value=width
                  IF value<3 Then value=3
            }
       } = 10
      Property myheight {
            Value,
            Set {
                  IF value>height-1 Then value=height-1
                  IF value<1 Then value=1
            }
      }=1
      Group MaxInputItem {
            Value {
                  Link Parent EditItems To Ed
                  =Len(Ed)
            }
      }
      Group MaxItem {
            Value {
                  Link Parent Bag To Bag
                  =Len(Bag)
            }
      }
      Group ItemValue {
            Value (akey$) {
                  Link Parent Bag To Bag
                  =Bag(akey$+".value")
            }
            Set (akey$) {
                  Read mGroup
                  Link Parent Bag To Bag
                  IF exist(Bag, akey$+".value") Then {
                        Return Bag, akey$+".value":=mGroup
                  }
            }
      }
      Class Info {
            iskey, isbutton, menuitem, isnumeric
            Event CallBack { Read &What }
            ValidValue=Lambda->True
            myvalue$
            stackA=stack
            X, Y, mycolor, boldface
            W=10, H=1
            \\ only for button
            mybg
      Class:
            Module Info {
                  Read .isnumeric, .iskey, .MyValue$
                  Read .X, .Y, .W, .H, .mycolor, .boldface, .ValidValue
            }
      }
       Module PrintNext {
            Cursor 0, Row-1
            .PrintLabel
      }
      Module PrintLabel {
            ticket=False
            IF IsNum Then {
                  ticket=1-.UseInteger 
                  Read N 
                  IF ticket=2 Then { what$=Trim$(Str$(N,"0")) } Else  what$=Trim$(Str$(N))
            } Else Read what$
            Let colour=pen, spaces=0, boldface=0
            Read ?  spaces, colour, boldface
            bold Abs(boldface<>0)
            Pen colour {
                  Print @(spaces),
                  IF .Record Then RecordMe()
                  IF ticket Then  what$=Format$("{0}",N)
                  IF .drawbg Then .drawbg<=False : Print @(Pos,Row,Pos+.mywidth, Row+.myheight, .mybg);
                  IF .myheight>1 Then {
                        Legend ! what$, .mywidth, .myheight
                  } Else {
                        Legend ! what$, .mywidth, 1          
                  }
                  Print
            }
            bold 0
            Sub RecordMe()
                  Local mylambda=lambda->True
                  IF Not empty Then Read myLambda
                  IF  Not .NoKey Then {
                        Append .Bag, what$:=.Info(False, true, what$, Pos, Row, .mywidth, .myheight, colour, Abs(boldface<>0), mylambda)
                        .lastkey$<=what$+".value"
                        \\ using = And Not  <= we get Error in next call
                        \\ becaue = make a Local variable, but .lastkey$ is a group variable.
                  } Else {
                        Try ok {
                              Append .EditItems, len(.Bag)
                             Append .Bag, .lastkey$:=.Info(ticket, False, what$, Pos, Row, .mywidth, .myheight, colour, Abs(boldface<>0), mylambda)
                         }
                         \\ using of Flush Error To clean Error message first
                         IF Error Or Not ok Then Flush Error : Error "You can't record two values in same key"
                  }
            End Sub
      }
      Module PrintButtonNext {
            Cursor 0, Row-1
            .PrintButton
      }
      Module  PrintButton {
            Read .LastKey$, caption$
            Oldmybg=.mybg
            Read ? .mybg
            Push caption$
            .LastKey$<=.LastKey$+".value"
            .NoKey~
            .drawbg~
            .PrintLabel
            .NoKey~
            \\ Bag(key) Or Bag(num!) num from 0 To len(Bag)-1
            Read ? event_copy
            there=Len(.Bag)-1
            
            For .Bag(there!), this {
                 .isbutton<=True
                 .callback<=event_copy
                 .mybg<=..mybg
            }
            swap Oldmybg, .mybg
      }
      Module PrintText (Lines, TextWidth) {
            Cursor 0, Row-1
            .NoKey~
            Let oldw=.mywidth, oldH=.myHeight
             .mywidth<=TextWidth
             .myheight<=Lines
            .PrintLabel 
            swap .mywidth, oldw
            swap .myHeight, oldH
            .NoKey~
      }
      Module  UseLastAsList (ArrayA) {
            Read ? event_copy
            IF  Instr(.lastkey$,".value") Else Exit
            For .Bag(.Lastkey$)  {
                  Stack New {
                        Data !ArrayA
                        .CallBack<=event_copy
                        \\ this [] pass current stack To .StackA, and leave a new empty stack
                        \\ [] is "[" and "]" (these chars can be used in variables names too)
                        .StackA<=[]
                  }
            }
      }
      Module InpList {
            a=Each(.EditItems)
            While a {
                  \\ ! use position (form 0) And no key To walk in .bag()
                  for .bag(eval(a)!) {
                        Print .MyValue$, Len(.stackA)>0, .isbutton, .iskey
                  }
            }
      }
      Group Json$ {
            Value (x) {
                 ' quote$(string$(MyValue$ as json)) 
                 bag$=""
                 nl$={
                 }
                 if x<=0 then nl$="" : x=0
                  space$=string$(" ",x)
                  Link Parent bag To bag
                  a=Each(bag)
                  While a {
                        M= bag(a^!)
                        For M {
                              IF Not .iskey and Not .isbutton Then {
                              if bag$<>"" then bag$=bag$+", "+nl$
                                    bag$=bag$+space$+quote$(Replace$(".value","",Eval$(bag, a^-1)))+" : "+quote$(string$(.MyValue$ as json)) 
                               }
                        }
                  }
                  ="{"+nl$+bag$+nl$+"}"
            }
            Set {
                  Read bag$
                  c$=""""   \\ this is one char 34
                  nl$={
                  }
                  end$=""
                  Link Parent bag To bag
                  safety=len(bag$)
                   Stack New {
                   if left$(trim$(bag$),1)="{" then  {
                         bag$=Trim$(RightPart$(bag$,"{"))
                         end$="]"
                   } else.if left$(trim$(bag$),1)="[" then  { 
                        bag$=Trim$(RightPart$(bag$,"{"))
                        end$="}"
                   }
                        do {
                              While Left$(bag$,2)=nl$ {bag$=Trim$(Mid$(bag$, 3))}
                              bag$=Trim$(RightPart$(bag$, c$))
                              mkey$=LeftPart$(bag$, c$)+".value"
                              bag$=Trim$(RightPart$(bag$, c$))
                              if mkey$="" then exit
                              While Left$(bag$,2)=nl$ {bag$=Trim$(Mid$(bag$, 3))}
                              bag$=Trim$(RightPart$(bag$,":"))
                              While Left$(bag$,2)=nl$ {bag$=Trim$(Mid$(bag$, 3))}
                              bag$=Trim$(RightPart$(bag$, c$))
                              mval$=LeftPart$(bag$, c$)
                              bag$=Trim$(RightPart$(bag$, c$))
                              Group M
                              if exist(bag, mkey$) Then {
                                    M=eval(bag)
                                    M.myvalue$<=format$(mval$)
                                    Return bag, mkey$:=M
                              }
                              If left$(bag$, 1)="," then bag$=Trim$(Mid$(bag$, 2)) : Restart
                              if end$<>"" then if left$(bag$,1)=end$ then exit
                              if safety=len(bag$) then Error "Json parse problem"
                              safety=len(bag$)                              
                        } Until bag$=""
                        
                  }
            }
      }
      Group Serialize$ {
            value {
                  bag$=""
                  Link Parent bag To bag
                  a=Each(bag)
                  While a {
                        M= bag(a^!)
                        For M {
                              IF Not .iskey and Not .isbutton Then {
                                    IF .isnumeric Then {
                                     bag$=bag$+" "+.MyValue$
                                    } else  bag$=bag$+stack$(.MyValue$)
                               }
                        }
                  }
                  =bag$
            }
            Set {
                  Read bag$
                  Stack New {
                        Stack bag$  \\ fill stack with special format string for stack
                        Link Parent bag To bag
                        a=Each(bag)
                        Try ok {
                              While a {
                                    M= bag(a^!)
                                    For M {
                                          IF Not .iskey And Not .isbutton Then {
                                                IF .isnumeric=1 Then {
                                                      Read N
                                                      .MyValue$=Trim$(Str$(N))
                                                } Else.If  .isnumeric=2 Then {
                                                      Read N%
                                                      .MyValue$=Trim$(Str$(N%))
                                                } Else Read .MyValue$
                                           }
                                    }
                              }
                        }
                        If Error Or Not ok Then Flush Error : Error "Serialize Input Not Compatible"
                  }
            }
      }
      Module PrintUp {
            Cursor 0, Row-1
            .NoKey~
            .PrintLabel
            .NoKey~
      }
      Module PrintUpInteger {
            Read N
            Push Val(Str$(N,"0"))
            Cursor 0, Row-1
            .NoKey~
            .UseInteger~
            .PrintLabel
            .UseInteger~
            .NoKey~
      }
      Module RenderThis {
            Read M
            Read ? offsetX, offsetY
            IF .overridecolors Then {
                  mybg= .overbg
            } else {
                  mybg=.mybg
            }
            local inuse, final$
            For M {
                        IF this.overridecolors and .isbutton Then exit
                        offsetX+=.X
                        offsetY+=.Y
                        Cursor offsetX, offsetY
                        IF .isbutton Then mybg=.mybg  \\ from M.mybg
                        Print @(offsetX, offsetY, offsetX+.W, offsetY+.H, mybg);
                        IF this.overridecolors Then {inuse=this.overfr} else inuse=.mycolor
                        Pen inuse {
                              Bold .boldface
                              if .isnumeric then {
                                   final$=format$( "{0}", Val(.MyValue$) )
                              } else final$=.MyValue$
                              IF .H>1 Then {
                                    Legend ! final$, .W, .H
                              } Else Legend ! final$, .W, 1
                              Bold 0
                        }
                  }
      }
      Module RenderView {
            local fromA=1, toB=-1, offsetX, offsetY
            Read ? FromA, toB, offsetX, offsetY, .overridecolors
            IF .overridecolors Then Read .overfr, .overbg
            N=Each(.Bag, FromA, toB)
            While N {
                  .RenderThis .Bag(N^!),offsetX, offsetY
            }
            Print
            .overridecolors<=false
      }
      Module ScanRange {
            Local FromA=1, ToB=.maxitem, vert, curx, cury, mKey$
            IF ToB=0 Then Exit
            Read ? FromA, ToB
            Read ? ExitC, forever
            Local changed
            .item<=FromA
            Field New 1 ' reset To 1 the Field internal variable.
            mybg=.mybg
            {
                  GetAValue(.item, &changed)
                  IF changed Then vert=False
                  IF Field=99 Or Field=121 Then .item<=0 : Exit
                  IF Field=1000 Then Exit
                  IF .item=ExitC And (changed Or Not forever) Then Field New 1000 : Exit
                  IF vert  Then {
                        vert=False
                        IF .item>=ToB  And Field=1 Then Exit
                        IF .item<=FromA  And Field=-1 Then Exit
                        IF Field=1 Then {
                              a=Each(.EditItems, .item+1, ToB)
                        } Else  a=Each(.EditItems, .item, FromA)
                        last=.item
                        Try {
                              While a {
                                    IF Field=1 Then {
                                           for .bag(eval(a)!) {
                                                IF .x>=curx And .y>cury Then last<=a^ :Break
                                         }
                                    } Else {
                                           for .bag(eval(a)!) {
                                          IF .x>=curx And  .y<cury Then {
                                                field new 0 : last<=a^+1 
                                                IF .x>curx   else  Break
                                          }
                                          }
                                    }
                              }
                        }          
                        .item<=last      
                  } 
                  IF Field=1 Then .item++
                  IF Field=-1 Then .item--
                  IF .item<FromA Then .item<=ToB
                  IF .item>ToB Then .item<=FromA
                  CONTHERE:
                  Loop
            }
            Sub CheckOk()
                  Refresh
                  ok=-2
                  {
                        ok=inkey(100)  \\ delay 100ms IF no key pressed (return -1 IF no key pressed in 100ms)
                        IF ok=-1 Then Loop   ' any block can performe once using loop statement
                  }
                  Select Case ok
                  Case 121 ' F10
                        oldfield=121
                  Case 262162
                        oldfield=99
                  Case 38
                        { oldfield=-1 : vert=True }
                  Case 40  ' two Or more statements need a block after Case
                        { oldfield=1 : vert=True}
                  Case 39 ' left
                        oldfield=1 
                  Case 37 ' right
                        oldfield=-1  
                  Case 27, -2
                        {
                              While keypress(27) {} : oldfield=99
                        }
                  End Select
            End Sub
            Sub GetAValue(where, &changed)
                  Local N,N$, posnow=Pos, rownow=Row, StackB, k$, oldfield=Field, ok
                  IF Not Abs(oldfield)=1 Then oldfield=1
                  Try ok {
                        where=val(eval$(.EditItems, where-1))
                  }
                  IF Error Or Not ok Then Exit Sub
                  Try {
                        mKey$=Eval$(.Bag, where)
                  }
                  IF mKey$="" Then Exit Sub
                  IF  Instr(mKey$,".value") Else Exit Sub
                  temp=.Bag(mKey$)
                  For temp {
                        Let curx=.x, cury=.y
                        IF  Len(.stackA)>0 Then {
                              Print @(.X,.Y, .X+.W, .Y+.H, 7),
                              IF Not .isbutton Then  Mark 1,1, 8: Print " ";
                              Pen .myColor {
                                    Bold .boldface
                                    IF .H>1 Then {
                                          Legend ! .MyValue$, .W, .H
                                    }  Else  Legend ! .MyValue$, .W, 1
                                    Bold 0
                              }
                              CheckOk()
                              IF ok=13 Or ok=9 Or ok=32 Then {
                                    ShowMenu()   
                              }
                        } Else.If  .isnumeric Then {
                              Print @(.X,.Y, .X+.W, .Y+.H, 7);
                                          Pen .mycolor {
                                                Bold .boldface
                                                Legend ! Format$("{0}",val(.MyValue$)), .W, 1
                                                Bold 0
                                          }
                                          CheckOk()
                                          IF ok>=96 And ok<=105 Then ok=ok-48
                                          IF ok=13 Or ok=9  Or Chr$(ok) ~ "[0-9]" Then {
                                                N=Val(.MyValue$)
                                                Pen .mycolor {
                                                IF Chr$(ok) ~ "[0-9]" Then {
                                                      IF N=0 Then {N=Val(Chr$(ok))} Else N=Val(.MyValue$+Chr$(ok))
                                                }
                                                    Print @(.X,.Y,.X+.W, .Y+.H, 7);
                                                    IF .isnumeric=2 Then {
                                                            N%=N
                                                            Input ! N%, .W
                                                            N=N%
                                                    } Else Input ! N, .W
                                                }
                                                IF .ValidValue(N) Then {
                                                      changed=Not .MyValue$=Trim$(Str$(N))
                                                      .MyValue$<=Trim$(Str$(N))
                                                }
                              }
                        }  Else {
                                   Print @(.X,.Y,.X+.W, .Y+.H, 7);
                              IF .isbutton Then {
                                   Pen .mycolor {
                                          Bold .boldface
                                          IF .H>1 Then {
                                                Legend ! .MyValue$, .W, .H
                                          }  Else Legend ! .MyValue$, .W, 1
                                          Bold 0
                                    } 
                                    CheckOk()
                                    Field New oldfield
                                    IF  ok=13 Then  Call Event .callback,  &This, Replace$(".value","", mKey$) : changed=True
                                    oldfield=Field
                              } Else { 
                                    N$=.MyValue$
                                    Pen .mycolor {
                                          Bold .boldface
                                          IF .h>1 Then {
                                                Legend ! .MyValue$, .W, .H
                                                CheckOk()
                                                IF ok=13 Or ok=9  Or ok=32 Then  Input ! N$, .w, .h,"Editor"
                                          } Else {
                                                Legend ! .MyValue$, .W, 1
                                                CheckOk()
                                                IF ok=13 Or ok=9 Or ok=32 Then Print @(.X,.Y,.X+.W, .Y+.H, 7); : Input ! N$, .w
                                          }
                                          Bold 0                              
                                    }
                                    IF  .ValidValue(N$)  Then {
                                          changed=Not .MyValue$=N$
                                          .MyValue$<=N$
                                    }
                              }
                        }
                        IF .isbutton Then {
                        Print @(.X,.Y, .X+.W, .Y+.H, .mybg);
                        } Else  Print @(.X,.Y,  .X+.W, .Y+.H, mybg);
                        Pen .mycolor {
                              Bold .boldface
                              IF .H>1 Then {
                                    Legend ! .MyValue$, .W, .H
                              }  Else {
                                    IF .isnumeric Then {
                                      Legend ! Format$("{0}",val(.MyValue$)), .W, 1
                                     } Else  Legend ! .MyValue$, .W, 1 
                                }
                              Bold 0
                          }        
                  }
                  Field New oldfield
                  Cursor posnow, rownow
                 Return  .Bag, mKey$:=temp
            End Sub
            Sub ShowMenu()
                        oldfield=1
                        Print @(.X,.Y+1),
                        IF Not .isbutton Then Print @(.X,.Y), :Mark 1,1, 15 :  Print " ";
                        menu fill 7,7, .mycolor
                        menu frame off
                        menu  \\ erase menu
                        StackB=Each(.stackA)
                        While StackB {
                              Menu  + stackitem$(StackB)
                        }
                        try ok {
                              menu show .MyValue$
                        } 
                       IF Error Or Not ok Then Error flush : Menu !   \\ show menu
                       Menu fill 1  \\ reset fill colors
                       menu frame  \\ reset frame
                       IF menu>0 Then {
                             IF Not .isbutton Then {
                                    changed=Not .MyValue$=menu$(menu)
                                    .MyValue$<=menu$(menu)
                              } Else .menuitem<=menu
                              Field New oldfield
                              Call Event .callback,  &This, Replace$(".value","", mKey$)
                              oldfield=Field
                              IF Abs(oldfield)=1 Then oldfield=0
                        } Else oldfield=0
      End Sub
      }
      Class:
      module  InpValueClass (.mybg) {
            Read ? .mywidth, .myheight
      }
}

LocalVar$="New Title - Module scope variable"
exitthis=False
Function FromEvent {
      Read New &What, mykey$
      Local K
      K=Ask(what.myvalue$, LocalVar$,"*")
}
Function FromEvent2 {
      Read New &What, mkey$
      Local K
      IF what.menuitem>0 Then {
            IF instr(Menu$(what.menuitem),"---")>0 Then Break
            K=Ask(what.myvalue$+" "+Menu$(what.menuitem), "No2",,"*")
            If K<>1 then break
            IF what.menuitem=2 Then {
                  M=InpValue2.ItemValue("Exit")
                  M.myvalue$="Press me "+Time$(Now)
                  InpValue2.ItemValue("Exit")=M
                  InpValue2.RenderThis M
            }
      } Else {
             K=Ask(what.myvalue$, "No2")
      }
      IF mKey$="File" And what.menuitem=4 Then Field New 99  : exitthis=True : Exit
      Cls, -14
      InpValue2.InpList
}
Function FromEvent3 {
      \\ this is a module's variable
'     exitthis=True
'      Field New 99
      \\ We can use 1000 as default Exit
      Field New 1000
}
Event E1 { Read &A, B$}
E2=E1  ' copy of E1 To E2
FIN=E2 ' copy of E2 To FIN
\\ Using  Lazy$(&FromEvent()) And Not FromEvent() we pass code from module
\\ when run take the module name space, so all modules variables/modules/functions are visible
\\ except subrutines.
Event E1 New Lazy$(&FromEvent())
Event E2 New Lazy$(&FromEvent2())
Event FIN New Lazy$(&FromEvent3())
\\ Now we have
 InpValue=InpValueClass(mybg)
 InpValue2=InpValueClass(mybg)
middlepoint=0
For InpValue {
      .mywidth=6
      .PrintButton "File","File [F10]",,,8,1,,E2
      .UseLastAsList ("Menu1","Menu2","Menu3","Exit")
      .PrintButtonNext "Edit","Edit",,6,8,1,,E2
      .UseLastAsList ("Help","Update","--------","About")
      }
For InpValue2 {      
      .mywidth=10
      .PrintLabel "Element",,15,1
      .PrintLabel "Type", 4
      .PrintUp "Combo", 10, 14
      .UseLastAsList ("ListBox","Combo", "TextBox", "EditBox"), E1
      .PrintLabel "Name", 4
      .PrintUp "Combo1", 10, 14,,ValidateValue(-3, "A")
      .PrintLabel "Text Field",4
      Document AA$={aaaaaaaaaaaaa
                                          bbbbbbbbbbbbb
                                          cccccccccc
                                          }
      .PrintText 3, 30, AA$, 10,14
      middlepoint=.maxitem
      Cursor 0, Row+4
      .PrintLabel "Attributes",,15,1
      .PrintLabel "Title", 4
      .PrintUp "Form1", 10, 14
      .PrintLabel "Top", 4
      .PrintUpInteger 0, 10, 14
      .PrintNext "Left",24
      .PrintUpInteger 0, 30, 14
      .PrintLabel "Width",4
      .PrintUpInteger 4000, 10, 14, ,ValidateValue(3000, 12000)
      .PrintNext "Height",4+20
      .PrintUpInteger 6000, 10+20, 14
      .PrintLabel "Double",4
      .PrintUp pi, 10, 14
      .PrintNext "Double1",24
      .PrintUp 2*pi, 30, 14
      .PrintNext "Double2",44
      .PrintUp 4*pi, 50, 14
      .PrintButton "Exit","For Exit Come Here", 8, 10, 15, 1,,FIN
       Print "Press Esc Key"
      THERE:
     Cls, Row
   \\    .RenderView
}
\\Exit
maxInputitem=InpValue2.maxInputItem
do {
      do {
      InpValue.ScanRange
      } until Field<>121
      IF exitthis Then Exit
      InpValue2.ScanRange 1, maxInputitem, maxInputitem-1, True
} until exitthis Or Field=1000

\\ Part 2
Cls 15, 1
Pen 0
Report "Print to Paper <Demo on Screen>"
\\ export without buttons, black color on white paper
InpValue2.RenderView 1,7, 5, 5, true, 0, 15
\\ -1 is the maxitem in bag
Cursor 0,15
Report "We can move a group by offset X and Y"
\\ using -1 for end mark
\\ 5 chars right, 10 char lines down
InpValue2.RenderView 8, -1, 5, 10, true, 0, 15

Print InpValue2.maxitem
A$=InpValue2.Serialize$
Print A$
InpValue2.Serialize$=A$
A$=key$
cls mybg,1
Pen 15
Report "RenderView"
InpValue2.RenderView 
Report "Json 2 chars indent"
Pen 14
Report InpValue2.Json$(2)
A$=InpValue2.Json$(0)
Pen 15 {
      Report "Json 0 chars indent"
}
Report A$
Pen 15 {
      Report "Len json$ vs Serialize$"
}
Print  Len(A$), Len(InpValue2.Serialize$)  '' 216, 123
InpValue2.Json$=A$
Pen 15 {
      Report {InpValue2.Json$={"Left" : "1000", "Top" : "500"}}
}

InpValue2.Json$={"Left" : "1000", "Top" : "500"}
Report InpValue2.Json$(0)
Escape on
bold true
Font OldFont$
}
MODULE QSORT3 {Module Checkit3 {
      Class Quick {
      Private:
            partition=lambda-> {
                  Read &A(), p, r : i = p-1 : x=A(r)
                  For j=p to r-1 : If .LE(A(j), x) Then i++:Swap A(i),A(j)
                  Next j : Swap A(i+1), A(r) :  Push  i+2, i 
            }
      Public:
            LE=Lambda->Number<=Number
            Module ForStrings {
                  .partition<=lambda-> {
                        Read &A$(), p, r : i = p-1 : x$=A$(r)
                        For j=p to r-1 : If A$(j)<= x$ Then i++ : Swap A$(i),A$(j)
                        Next j : Swap A$(i+1), A$(r) : Push i+2, i
                  }
            }
            Function quicksort {
                  Read ref$
                  do 
                        loop : If Stackitem() >= Stackitem(2) Then 
                        Drop 2  
                        \\ if  empty then Break else continue  
                                           \\ because is hidden  if empty then {Break} else continue
                         \\ but here 
                         if  empty then
                               exit 
                        else
                              continue
                        end if
                        end if
                        over 2,2 : call .partition(ref$) :shift 3 
                  always
            }
      }
      Quick=Quick()
      Dim A(10)<<Random(50, 100)
      Print A()
      Call Quick.quicksort(&A(), 0, Len(A())-1)
      Print A()
      Quick=Quick()
      Function join$(a$()) {
            n=each(a$(), 1, -2)
            k$=""
            while n {
                  overwrite k$, ".", n^:=array$(n)
            }
            =k$
      }
      Stack New {
                  Data "1.3.6.1.4.1.11.2.17.19.3.4.0.4" , "1.3.6.1.4.1.11.2.17.19.3.4.0.1", "1.3.6.1.4.1.11150.3.4.0.1"
                  Data "1.3.6.1.4.1.11.2.17.19.3.4.0.10", "1.3.6.1.4.1.11.2.17.5.2.0.79", "1.3.6.1.4.1.11150.3.4.0"
                  Dim Base 0, arr(Stack.Size)
                  i=0 : While not Empty {Let arr(i)=piece$(letter$+".", ".") : i++ }
      }
      \\ change comparison function
      Quick.LE=lambda (a, b)->{
            Link a, b to a$(), b$()
             def i=-1
             do {
                   i++
             } until a$(i)="" or b$(i)="" or a$(i)<>b$(i)
             If b$(i)="" Then =a$(i)="":Exit
             If a$(i)="" Then =true:Exit
             =val(a$(i))<=val(b$(i))
      }
      Call Quick.quicksort(&arr(), 0, Len(arr())-1)
      For i=0 to len(arr())-1 {
            Print join$(arr(i))
      }
      \\ Fresh load
      Quick=Quick()
      Quick.ForStrings
      Dim A$()
      A$()=("one","two", "three","four", "five")
      Print A$()
      Call Quick.quicksort(&A$(), 0, Len(A$())-1)
      Print A$()
}
Checkit3
}
MODULE CONC {Thread.Plan Concurrent
Module CheckIt {
      Flush  \\ empty stack of values
      Data "Enjoy", "Rosetta", "Code"
      For i=1 to 3 {
            Thread {
                  Print A$
                  Thread This Erase
            } As K
            Read M$
            Thread K Execute Static A$=M$
            Thread K Interval Random(500,1000)
            Threads
      }
      Rem : Wait 3000   ' we can use just a wait loop, or the main.task loop
      \\ main.task exit if all threads erased
      Main.Task 30 {
      }
\\ when module exit all threads from this module get a signal to stop.
\\ we can use Threads Erase to erase all threads.
\\ Also if we press Esc we do the same
}
CheckIt
 
\\ we can define again the module, and now we get three time each name, but not every time three same names.
\\ if we change to Threads.Plan Sequential we get always the three same names
\\ Also in concurrent plan we can use a block to ensure that statements run without other thread executed in parallel.
\\ Also there is another statement (not used here): Part { code block} As Variable  Look Help Part 
Module CheckIt {
      Flush  \\ empty stack of values
      Data "Enjoy", "Rosetta", "Code"
      For i=1 to 3 {
            Thread {
                  Print A$
                  Print A$
                  Print A$
                  Thread This Erase
            } As K
            Read M$
            Thread K Execute Static A$=M$
            Thread K Interval Random(500,530)
            Threads
      }
      Rem : Wait 3000   ' we can use just a wait loop, or the main.task loop
      \\ main.task exit if all threads erased
      Main.Task 30 {
      }
\\ when module exit all threads from this module get a signal to stop.
\\ we can use Threads Erase to erase all threads.
\\ Also if we press Esc we do the same
}
CheckIt
Thread.Plan Sequential
}
MODULE LISP {Profiler
EntryLevel =0
Module forall {  \\ For all subs - reusable code use Call ! Local forall
      Local MyAcc$
      Document MyAcc$
      Clear Buffer$  \\ delete command - need Clear /  = is For append
      Call Local Parser(level,  &MyAcc$)
}
Module Comm {
      Read proc$
      Call ! Local forall
      Local dummy$=paragraph$(MyAcc$,-1,-1)
      Local a, d, acc
      Long a, d=forward(MyAcc$, a)  \\ there is a  backward() function too
      If d<>0 Then {
      Select Case proc$
      Case "+"
      { While a<>0 { acc+=Val(paragraph$(MyAcc$, (a))) }}
      Case "-"
            {         If a<>0 Then   acc=Val(paragraph$(MyAcc$, (a))) 
                       While a<>0 { acc-=Val(paragraph$(MyAcc$, (a)))  }}
      Case "*"
            { acc=1: While a<>0 { acc*=Val(paragraph$(MyAcc$, (a))) }}
      Else  '  Case "/"
            { acc=1
                  If a<>0 Then  acc=Val(paragraph$(MyAcc$, (a))) 
                  While a<>0 { acc/=Val(paragraph$(MyAcc$, (a))) }}
      End Select    
       Accum$=Format$("{0}", acc)+nl$
      } 
}
Module CommWrite {
      Call ! Local forall
      Print "Lisp:";
      Local i, f=Doc.Par(MyAcc$)
      If f>1 Then {
      f--  : If f>1 Then Print "(";
      For i=1 to f
            Print paragraph$(MyAcc$, i); : If i<f Then  Print " ";
      Next i
      }
      If f>1 Then { Print ")" } Else Print
}
Module LoopLisp {
      Local dummy$ : Clear Buffer$
      cnt++ : Local backhere=cnt
      Local mylevel=level
      {
            Call Local Parser(myLevel, &Accum$)
            dummy$=paragraph$(Accum$,-1,-1)     \\ throw  last nl$
            dummy$= paragraph$(Accum$,-1,-1)
            Accum$=nl$  \\ insert  last nl$
            If dummy$="t" Then Exit
            cnt=backhere
            level=mylevel
            loop   
      }          
}
Module MyList {
      Local MyAcc$
      Document MyAcc$ : Clear Buffer$
      Call Local Parser(level, &MyAcc$)
      Accum$="("+Trim$(Replace$(nl$," ", MyAcc$))+")"+nl$       
}
Module Myif {
      Call ! Local forall
      If paragraph$(MyAcc$, 1)="t" Then {
            Accum$=paragraph$(MyAcc$, 2)+nl$
      } else {
            Accum$=paragraph$(MyAcc$, 3)+nl$
      }
}
Module DefVar {
      Local MyAcc$, Iddoc$
      Document MyAcc$, Iddoc$ : Clear Buffer$
      cnt++
      Call Local Parser(level,  &Iddoc$, True)
      Call Local Parser(level,  &MyAcc$)
      Local id$=paragraph$(Iddoc$, 1,-1)  \\ third parameter If is -1 Then delete the paragraph 
      If id$="" Then Error "No name For variable"
      While Doc.Par(iddoc$)>0 {
            Call Local PrintNewLine "Var :"+id$
            If not exist(Mem,id$) Then {
                  Append Mem, id$:=MyAcc$
            } Else Error "Variable "+id$+" already defined"
           id$=paragraph$(Iddoc$, 1,-1)
      }
}
Module SetVar {
      Local MyAcc$, Iddoc$
      Document MyAcc$, Iddoc$ : Clear Buffer$
      cnt++
      Call Local Parser(level, &Iddoc$, True)
      cnt--
      Call Local Parser(level, &MyAcc$)
      Local id$=paragraph$(Iddoc$, 1,-1)  \\ third parameter If is -1 Then delete the paragraph 
      If id$="" Then Error "No name For variable"
      While Doc.Par(iddoc$)>0 {
            Call Local PrintNewLine "Var :"+id$
            If exist(Mem,id$) Then {
                  Return Mem, id$:=MyAcc$
            } Else Error "No such variable"
           id$=paragraph$(Iddoc$, 1,-1)
      }
}
Module Cons {
      Call ! Local forall
      Accum$=MyAcc$
}
Module Remark {
     while cnt<=tmproof {
           cnt++
           If mid$(a$, cnt,2)=nl$ Then cnt++ : exit
     }
}
Module String {
     Local check=cnt
     Clear Buffer$ : numeric=false
     while cnt<=tmproof {
           cnt++
           If mid$(a$, cnt,1)=qu$ Then exit
     }
     if cnt-check>1 Then { Buffer$=Mid$(a$,check, cnt-check+1)} Else Buffer$={""}
}
Module  PrintBuffer {
      If Doc.Len(Buffer$)>0 Then {
                  If exist(Mem, Buffer$) and not GetQuote Then {
                       Accum$=Mem$(Buffer$)
                  } else   Accum$=Buffer$+nl$
            Call Local PrintNewLine Buffer$
            Clear Buffer$ : prints++
      }
}
Module PrintNewLine {
      Read New What$
     If mess Then Print what$
}
Module StopChar {
      Read New val    
      com = val=1
      level+=val
      If GetQuote And level<=EntryLevel Then Call Local PrintBuffer : GetQuote=false: tmproof=cnt : Exit
      If val<>0 Then Local oldprints=prints : prints=0
      Call Local PrintBuffer
      If profil=1 And val=-1 Then If prints=0 Then If oldprints=prints Then Buffer$="()" : Call Local PrintBuffer
      profil=val
}
Module StopCharZero {
      If GetQuote And level=EntryLevel Then Call Local PrintBuffer:GetQuote=false: tmproof=cnt : Exit
      If com Then Call Local CheckCommand
      If not com Then Call Local PrintBuffer : Exit
}
Module StorePeriod {
      If Doc.Len(Buffer$)=0 Then Call Local StoreNumeric : Exit
      If numeric Else Call Local StoreLabel : Exit  \\ see Else, same as If not numeric Then
      If Instr(Buffer$,".")>0 Then Call Local PrintBuffer
      Call Local StoreNumeric
}
Module StoreSign {
      If Doc.Len(Buffer$)>0 And numeric Then Call Local PrintBuffer : Call Local  StoreNumeric : Exit
      Call Local StoreNumeric  \\ maybe numeric=False so this is like storelabel...
}
Module StoreNumeric {
      If Doc.Len(Buffer$)=0 Then  numeric=True 
      buffer$=one$
}
Module StoreLabel {
      numeric=False
      buffer$=one$
}
Module CheckCommand {
      com=false
      If GetQuote Then Exit
      If numeric Then {
            If Doc.Len(Buffer$)=1 Then If Instr("*/+-",Buffer$)>0 Then Exit
            Exit
      }
      If Exist(commands, Buffer$) Then  push eval$(commands) : Call Local letter$
}
Module Sym {
      Read new w$
      Call ! Local forall
      If Evall(quote$(paragraph$(MyAcc$, 1) )+ w$+ Quote$(paragraph$(MyAcc$, 2) )) Then {
       Accum$=t$  } Else  Accum$=nil$
}
Module Quote {
      Clear Buffer$
      cnt++
      Call Local Parser(level, &Accum$, True)
      cnt--
}
Module Car {
      Call ! Local forall     
      Accum$=paragraph$(MyAcc$, 1)+nl$
}
Module Cdr {
      Call ! Local forall     
      Local drop$=paragraph$(MyAcc$, 1,-1)
      Accum$=MyAcc$
}
Module Eq {
      Call ! Local forall
      If paragraph$(MyAcc$, 1)=paragraph$(MyAcc$, 2) Then {
            Accum$=t$
      } Else  Accum$=nil$
}
Function Parser {
      Read New EntryLevel,  &Back$
      Local GetQuote  
      Read ? GetQuote  \\ this is an optional argument For Parser
      Local tmproof=roof, Accum$
      Document Accum$
      Repeat  {
      If level<EntryLevel Then cnt-- : Back$=Accum$ : Exit
      one$=mid$(a$,cnt,1)
      \\ warning in each Case one command in one line or use { } For multiple commands/lines
      \\ no empty lines allowed. 
      Select Case one$
      Case  qu$
            Call Local String
      Case ";"  \\ remark
            Call Local Remark
      Case "'"  \\ quote
            Call Local Quote
      Case "("
            Call Local StopChar, 1 ''StopChar(1)
      Case ")"
            Call Local StopChar, -1 ''StopChar(-1)
      Case " ", Ch10$, Ch13$  ' white space too
            Call Local StopCharZero
      Case "0" to "9"
            Call Local StoreNumeric
      Case "."
            Call Local StorePeriod
      Case "-", "+"
            Call Local StoreNumeric
      Else Case
            Call Local StoreLabel
      End Select
      cnt++
      } Until cnt>tmproof 
      if cnt>tmproof  then  Back$=Accum$

}
\\ Mini lisp ver 0.01
Clear \\ clear variables
Flush \\ empty stack
Form ! 60,48

Print "MiniLisp Ver 0.01"
Scroll Split  Row  \\ make this row start of scrolling screen
\\ A simple lisp interpreter written in M2000 by George Karras
\\For Documents "=" is For append text. Clear a$, give a new object Document.
Document a$={
                        "hello there this is a string"  ; this is going to result
                        (write 1223345.788)(defvar Hello "M2000")(write Hello)
                        (write 121 "Hello again...")
                        (eq 7 7)(write (list 1 2 4 5))(defvar A (+ 7 9 13 1 5 7) ) (write A  (- A 10) (* A 3) (/ 5 2))
                        (defvar (a b c d) 100)(write a b c d)(setq a (+ a 1))(write '(a =) a)(write (car '(a b c))(cdr '(a b c))) ; remark
                        (write (cons 'a '(b c)))(write George 'Karras)(write (eq a 101))
                        (this is written as result)(write '(This written before results) (+ a 1))
                        (quote (Hello 1 There a b))  '(Hello 2 There a b)(eq 5 5)
                        (loop (write a) (eq a 107) (setq a (+ a 1))) (write (list 1 A (+ A 1) 3 4 5))
                        (write 1 A (+ A 1) 3 4 5)
                        (write (If t 5 6))  (write ok)
                        (write (If nil (list 1 2 3) (list 4 5 6)))
                        (write (If nil 5 6))
                        (write (If t (list 1 2 3) (list 4 5 6)))
                        ; A form which calls the + function with 1,2 and 3 as arguments.
                        ; It returns 6.
                        (write (+ 1 2 3))
                        }                    
Print "Parse:";
Report a$
Print
nl$={
} \\ nl$ is new line
Let level=0, one$="", numeric=False, prints=0, com=False, profil=1, ch10$=chr$(10),ch13$=chr$(13), qu$=chr$(34)
Let mess=false '\\true   \\ For messages
Let cnt=1, roof=len(a$), comlevel=-1 
' no command
Document Buffer$, Result$
\\ Inventory is a hash table.
Inventory commands="+":="Comm {+}",  "-":="Comm {-}" , "*":="Comm {*}", "/":="Comm {/}", "write":="CommWrite", "car":="Car", "cdr":="Cdr", "cons":="Cons",  "defvar":="DefVar", "eq":="Eq", "setq":="SetVar", "quote":="Quote", "loop":="loopLisp",">":="Sym {>}" ,"<":="Sym {<}", ">=":="Sym{>=}","<=":="Sym{<=}", "<>":="Sym{<>}", "list":="MyList","If":="Myif"
Clear t$, nil$
\\ we want a paragraph only - with new line
Inventory mem  \\ For variables
t$="t"+nl$
nil$="nil"+nl$
Append Mem, "t":=t$,"nil":=nil$
Try ok {  Call Local Parser(level,  &Result$)}
If Error or Not Ok Then Print Error$
If level>0 Then Error "more ("
If Not Mess Then {
      Report 2, "Results" 
      Report Replace$(nl$," ", Result$)
}
Print Timecount
}
MODULE P {\\ this is not a game is an example for how we make a game using threads and sprites. Images are simple for this example.

SET FAST !
PEN #fff9aa
\\ BLOCK ESCAPE KEY
ESCAPE OFF
\\thread.plan sequential \\WE CAN USE THREAD plan sequential also.
THREAD.PLAN CONCURRENT
ox=scale.x*1.2
oy=scale.y*1.2
REFRESH  500 
Layer 1 {
	Window Mode, ox, oy
	CLS 1 ,0   ' COLOR BLUE AND  RESET SPLIT SCREEN SETTING TO TOP LINE
	MOVE 1500,1000
	polygon 13, 1000,-500,300,1000, -2000, -500,0, -1000
	PRINT "This is first line"    ' WE CAN'T SEE THE FOUR PRINTS 
	PRINT "This is second line"   'BECAUSE WE SET A HIGH REFRESH RATE
	PRINT "This is third line"
	PRINT "This is forth line"
	PRINT $(1)  \\ NOT allowed  a PRINT of an item to exceed a column (1,2,3,5,6,7,8,9)
	MOVE 0,0
	A$=""
	COPY 3000,2000 TO A$
	GRADIENT 1, 9   ' CLEAR SCREEN WITH GRADIENT
	PEN 14 {
	FOR i=1 TO 100 {
	      MOVE RANDOM(SCALE.X),RANDOM(SCALE.Y)
	      CIRCLE FILL 14, RANDOM(3)*TWIPSX
	}
	}
	\\COPY 6000,6000 TOP A$, 10, 200
	\\COPY 6000,6000 TOP A$, 45
	\\COPY 2000,2000 USE A$, 45
	h$="	"
	Move 0,0
	copy scale.x, scale.y to h$
}
MOVE 6000,6000
I=1
LET X=MOUSE.X, Y=MOUSE.Y
LET range=6000, ANGLE=0
LET canfire= true, fireX=0, fireY=0, firesize=0
Let sX=SCALE.X/2, sY=SCALE.Y/2
THREAD {
IF abs(fireX-sx)>500 THEN {
      fireX=(fireX*4+SX)/5
      fireY=(fireY*4+SY)/5
} ELSE {
THREAD L HOLD
canfire=true
}
} AS L
e1x=6000 : e1y=6000 : e1z=20
enemy1=true 
THREAD {
      e1z+=5
      IF e1z>180 OR NOT enemy1 THEN enemy1=FALSE : THREAD this HOLD
} AS E1 INTERVAL 30
THREAD {
      e2z+=5
      IF e2z>180 OR NOT  enemy2 THEN enemy2=FALSE : THREAD this HOLD
} AS E2
e2x=SCALE.X*.8 : e2y=6000 : e2z=20
enemy2=FALSE : THREAD e2 HOLD :  THREAD E2 INTERVAL 30
THREAD {
      e3z-=10
      IF e3z<30 OR NOT  enemy3 THEN enemy3=FALSE : THREAD this HOLD
} AS E3
e3x=SCALE.X*.8 : e3y=SCALE.Y: e3z=180
enemy3=FALSE : THREAD e3 HOLD :  THREAD E3 INTERVAL 50

enemy4=FALSE
pp=.02
X=MOUSE.X
Y=MOUSE.Y
\\ simple routine name is case sensitive
GOSUB basicpart
\\MOVE x,y
\\GOSUB ship
SHOW

TASK.MAIN 20 { 
      I++
      IF KEYPRESS(49) THEN EXIT
      ' YOU CAN MAKE THE SECOND ROTATED OBJECT TO HAVE FLICKERING
      ' IF YOU DO THAT:
      ' COMMENT THE LINE BELOW AND PUT REFRESH TO 10 IN THE FIRST LINE
      {
            Move -(scale.x/2-x)/scale.x*300,-(scale.y/2-y)/scale.y*300 : Image h$
            \\ PART USE $(4) (PROPORTIONAL TEXT), AND WRITE ONLY IN ONE LINE WITH NO WRAP
            PRINT PART $(0),@(0,0),"SPACE BAR TO FIRE OR KEY 1 TO QUIT"

            PRINT PART @(0,1),STR$(NOW,"HH:MM:SS"), e1z   \\, $(0),format$("({0},{1})", sX, sY)
            
            GOSUB basicpart
            IF enemy1 THEN {
                  MOVE e1x, e1y
                  STEP sx*e1z/100-SCALE.X/2, sy*e1z/100-SCALE.Y/2
                  SPRITE A$, 1, ANGLE/10, e1z,30+e1z/4
            }
            IF enemy2 THEN {
                  MOVE e2x, e2y
                  STEP sx*e2z/50-SCALE.X/2, sy*e2z/50-SCALE.Y/2
                  SPRITE A$, 1, ANGLE/10, e2z,30+e2z/4
            }
            IF enemy3 THEN {
                  MOVE e3x, e3y
                  STEP -( sx*e2z/100-SCALE.X/2), -(sy*e2z/50-SCALE.Y/2)
                  SPRITE A$, 1, ANGLE/10, e3z,30+e3z/4
            }
            IF enemy4 THEN {
                  MOVE 8000,4000
                  STEP sx-SCALE.X/2, sy-SCALE.Y/2
                  SPRITE A$, -1, I, 100,30
            }
            IF canfire AND KEYPRESS(32) THEN {
                  SCORE 2, 100,"c"  ' SET A MIDI MUSIC SCORE
                  canfire~ : fireX=x : fireY=y
                  firesize= (SQRT((SCALE.X/2)**2+(SCALE.Y/2)**2)-SQRT((x-SCALE.X/2)**2+(y-SCALE.Y/2)**2))/10
                  THREAD L RESTART
                  THREAD L INTERVAL 10
                  PLAY 2, 10  ' PLAY THE SCORE 2 USING ORGAN 10
            } else.if NOT canfire THEN {
                  MOVE fireX, fireY
                  TRY { PEN 4{CIRCLE FILL 4, firesize}}
            }
            MOVE X, Y   
            GOSUB ship
      }
       IF NOT enemy1 and RANDOM(100)>95 THEN GOSUB enshow1
       IF NOT enemy2 and RANDOM(100)>95 THEN GOSUB enshow2
       IF NOT enemy3 and RANDOM(100)>97 THEN GOSUB enshow3
              
      REFRESH 5000   ' DO NOW A SCREEN REFRESH ONLY
      IF MOUSE=1 THEN {
            X=MOUSE.X
            Y=MOUSE.Y
      }     
}
\\ UNBLOCK ESCAPE KEY
ESCAPE ON
REFRESH 30
THREADS ERASE
THREAD.PLAN SEQUENTIAL
EXIT
enshow1:
      e1x=6000+RANDOM(2000) : e1y=6000+RANDOM(2000) : e1z=20
      enemy1=true : THREAD E1 RESTART
RETURN
enshow2:
      e2x=SCALE.X*.8-RANDOM(2000) : e2y=6000-RANDOM(2000) : e2z=20
      enemy2=true : THREAD E2 RESTART
RETURN
enshow3:
      e3x=SCALE.X*.8 +RANDOM(2000): e3y=SCALE.Y: e3z=180
      enemy3=true : THREAD E3 RESTART
RETURN
basicpart:
      range = SQRT((x-SCALE.X/2)**2+(y-SCALE.Y/2)**2)
      ANGLE =(360*(SCALE.Y-y)/SCALE.Y/2)*(SCALE.X/2-x)/SCALE.X
      sx=SCALE.X/2-(x-SCALE.X/2)/4
      sy=SCALE.Y/2-(y-SCALE.Y/2)/4
      MOVE sx, sy
      CIRCLE 300
      MOVE 0,SCALE.Y-range/2
      PEN 2 { polygon 2, 0,0,SCALE.X, 0,0, range/2,-SCALE.X,0,0,-range/2 }
      STEP SCALE.X/2,0
      PEN 0 {
            DRAW to SCALE.X/2+(x-SCALE.X/2)/4, SCALE.Y
            IF 1.1-PP<1 THEN {
                  MOVE 0, SCALE.Y-range/2*(1.1-PP)
                  DRAW SCALE.X,0 
            }
            MOVE 0, SCALE.Y-range/1.9*(.9-PP)
            DRAW SCALE.X,0
            MOVE 0, SCALE.Y-range/1.8*(.7-PP)
            DRAW SCALE.X,0
            IF NOT 1.1-PP<1 THEN {
                  MOVE 0, SCALE.Y-range/1.75*(.5-PP)
                  DRAW SCALE.X,0
            }
            pp+=.04
            IF pp>.20 THEN pp=.02
      }
RETURN
ship:
TRY {
      CIRCLE  300 *(12000-range)/5000    
      SPRITE A$, 1, ANGLE, (12000-range)/50, 100-range/200 
}
RETURN
}
MODULE MEDITOR {\\ notepad for M2000 programs (gsb files)
\\ Use F1 in editor to change to no wrap<->wrap
Clear \\ Clear all variables/objects
Global aLL$
Document aLL$
if exist(appdir$+"help2000utf8.dat") then
	Global aa, bb, where, no_par
	Load.doc aLL$, appdir$+"help2000utf8.dat"
	aa<=Val(paragraph$(aLL$, 1))
	bb<=Val(paragraph$(aLL$, 2+aa))
	find aLL$, paragraph$(aLL$,2+aa+1+2*bb)
	where<=number : no_par<=number: flush
end if
Flush \\ Empty the stack
CurDir$=Dir$
Title$="M2000 Pad"
Title "", 0   ' hide the console - 0
\\ Gui Elements
Declare NotePad Form
Declare Pad EditBox Form NotePad
Declare HelpPad EditBox Form NotePad
Declare File1 Combobox Form NotePad
Declare Edit1 Combobox Form NotePad
Declare Run1 Combobox Form NotePad
Declare Help1 Combobox Form NotePad
Declare Inform1 Button Form NotePad

\\ we can display an icon (the M2000 by default)
\\ Normal the icon is in the rright side, the control icon for close is in the left side. Here we do the oposite
\\ Also we get the Quit property. Is a property which a Document read when do a busy work of loading to quit it.
With NotePad,"UseIcon", True, "UseReverse", True, "Quit" as Quit

\\ We nead then title height after title displayed toget the height where we place the elements, in resize event
\\ we set the form to produce resize event by grabing the low right corner of form
With NotePad, "Title" as Caption$, "Visible" as Visible, "TitleHeight" as tHeight, "Sizable", True


\\ setting form, to show control box icon using english labels (use 0 for greek)
\\ we have to place afrer "Sizable", true to have "maximeze" enabled from the start.
Method NotePad,"MakeStandardInfo", 1


\\ Elements Properties (some of them changed using Methods, to pass more than one value)
\\ Change bavkground to M2000 Orange
Method Inform1, "Colors", 15, #FFA000

\\ We want the Button to act as a label only
With Inform1, "Locked", true

\\ Set the font for Pad, and for HelpPad, the two EditBoxes
Method Pad, "FontAttr", "Verdana", 12, true   '  size=12, bold=true
Method HelpPad,"FontAttr","Verdana", 10, true 

\\ We call a method to setup EditBox for Text View (we can use keys to move the text)
Method HelpPad, "TextViewOnly"


\\ ShowAlways prevent changing color when HelpPad is inactive
\\ We make some variables bound to properties
With HelpPad, "visible" as helpshow, "ShowAlways", True, "Text" as HelpText$, "enabled" as HelpEnabled
With HelpPad, "NoCenterLineEdit", True, "SetM2000", True, "EditDoc" as HelpEdit ' predifined for word picking
\\ we want HelpPad not shown from beginning, so we disable it
HelpEnabled=false

With Pad, "NoWrap", True, "SetM2000", True, "SelLength" as SelLength, "HighlightParagraph", True

\\ Set labels for menu's headers. and thecolor for check mark/ disable items,  in menus which we have those
With File1,"label","File"
With Edit1,"label","Edit",  "Mark", Color(255,100,0)
With Run1,"label","Run",  "Mark", Color(255,100,0)
With Help1,"label","Help",  "Mark", Color(255,100,0), "Id" as Id$()

\\ set a property variable to read/write text to pad, also we can use Tab
With Pad, "Text" as Pad.Text$, "NoColor", False, "ShowAlways", True, "UseTab", True, "tabwidth", 6

\\ we want to control by menu  these two properties (they can change by keystroke also)
\\ F10 tongle to hidden/no hidden characters, and Ctrl+F9 change the edit style in EditBox
With Pad, "showparagraph" as par_Status, "NoCenterLineEdit" as style_status
\\ they are false by default
par_Status=False
style_status=True

\\ Just for beginnig we make a function to alter the first letter of a name, to be a title
Def TitleStr$(a$)=ucase$(left$(a$,1))+mid$(a$,2)
Filename$=Dir$+"Untitled.gsb"
\\ Caption$ is the Title property of form. This is the formula to display proper the filename$ (excluding path)
Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
\\ The form is hidden, but we can move it
Method NotePad,"move", 2000, 4000, 8000, 4000
\\ Also we like to give M2000 Orange to layer unter the title
Layer NotePad {Cls #FFA000}

\\ Now we make the menu. We set 4000 twips for each dropdown list (height calculated automatic)
With File1,"MenuStyle", True, "MenuWidth", 4000 
With Edit1,"MenuStyle", True, "MenuWidth", 4000 
With Run1,"MenuStyle", True, "MenuWidth", 4000 
With Help1,"MenuStyle", True, "MenuWidth", 4000 

\\ the for This block used for erasing temporary variables, here the mi$ and mr$
\\ we have to give a Group name (anything, so here we pick "This")
\\ A Menuitem without name is a line separator
\\ Menuradio used in Edit1, all other are Menuitems
\\ the last two items in Edit1 have a third parameter to True, which means they are checkboxes
\\ Internal
\\ MenuItem(a$, Optional enabledthis As Boolean = True, Optional checked As Boolean = False, Optional radiobutton As Boolean = False, Optional firstate As Boolean = False, Optional IdD)

For This {
	const mi$="MenuItem"  \\ is a temporary variable only for For This Block
	const mr$="MenuRadio"
	Method File1, mi$,"Open",True
	Method File1, mi$,"Save",True
	Method File1, mi$,""    \\  only  a line here
	Method File1, mi$,"Close",True
	Method File1, mi$,"Quit",True

	
	With File1, "MenuGroup","This"
	
	Method Edit1, mi$,"Cut",True
	Method Edit1, mi$,"Copy",True
	Method Edit1, mi$,"Paste",True
	Method Edit1, mi$,""
	Method Edit1, mi$,"Less Indent",True
	Method Edit1, mi$,"More Indent",True
	Method Edit1, mi$,""
	Method Edit1, mr$,"Tabs for Indent",True,True
	Method Edit1, mr$,"Spaces for Indent",True,false
	Method Edit1, mi$,""
	Method Edit1, mi$,"Show Hidden Characters", True, True
	Method Edit1, mi$,"Free Style Edit Shift+F9", True, True
	

	
	With Edit1, "MenuGroup","This"

	Method Run1, mi$,"Debug",True
	Method Run1, mi$,""
	Method Run1, mi$,"Test Slow",True
	Method Run1, mi$,"Test Normal", True
	Method Run1, mi$,""
	Method Run1, mi$,"Settings"

	With Run1, "MenuGroup","This"
	Method Help1, mi$,"About",True,,,,"ABOUT"
	Method Help1, mi$,""
	Method Help1, mi$,"Find Topic",True,,,,"FIND"
	Method Help1, mi$,"Open Topic",HelpShow,,,,"OPEN"
	Method Help1, mi$,""
	Method Help1, mi$,"Close Help",HelpShow,,,,"CLOSE"
	

	With Help1, "MenuGroup","This"
}

\\ Some variable for program. We can ue Def for a variable once, if we do that a second time the we get error.
\\ always Def make local variables. We can set a type before for all non typed names after
\\ or we can use as type and give a first value (not an expression here).
\\ by defailt false is the va;ue for boolean type, so the =false not needed
Def boolean LoadState=false,  old_status=false

 \\ We need some properties with inexes, so we make these as arrays 
 \\ They look as arrays but they are objects (PropReference)
 \\ We can give names with dot, isn't a problem. Dot can be used for any name
With Edit1,"ListSelected" as Edit1.Selected(), "MenuEnabled" as Edit1.Enabled()
With Help1, "MenuEnabled" as Help1.Enabled()

\\ Some variables for specific task.
\\ Document make or change a local string variable (or global using <=)  to a Document type object (a linked list of paragraphs)
\\ we have to use Clear Name$ to erase the document's paragraphs.
\\ Using = or <= for globals we append text to it
Document BackUp$="\\Write something...", LoadFile$
Def ok as boolean
Const nl$=chr$(13)+chr$(10)
Pad.Text$=BackUp$
Def what$, lastcommand$, mod2run$

\\ function to retrieve info from help database, help2000.mdb in appdir$
Def boolean HelpView


if doc.par(aLL$)=0 then
	\\ Old for HelpM2000.mdb
	Function GetHelp$(&word$, findit) {
		word$=ucase$(word$)
		Eng=chrcode(word$)<128
		If  findit Then
			Retrieve appdir$+"HELP2000", "Select * FROM [COMMANDS] WHERE "+If$(Eng-> "ENGLISH","DESCRIPTION")+" Like '"+word$+"%'",1,"",""
		Else
			Retrieve appdir$+"HELP2000", "COMMANDS",1,If$(Eng->"ENGLISH","DESCRIPTION"),word$
		End If
		If number>0 Then
			read new word1$, hlp$, word2$
			=If$(Eng->RightPart$(hlp$,"__<ENG>__"), LeftPart$(hlp$,"__<ENG>__")) :	word$=If$(Eng->word2$, word1$)
		End If
	}
Else
	Function GetHelp$(&word$, findit) {
		Local Nword$=ucase$(word$)
		
		select case Nword$
		case "ΓΕΝΙΚΑ"
		Nword$="ΟΛΑ"
		case "GENERAL"
		Nword$="ALL"
		End Select
		if findit then
			find aLL$, "\"+Nword$, where
		else
			find aLL$, "\"+Nword$+"!", where
		end if
		Read Where1
		if Where1>0 then
			Read  There : drop
			Ret$=mid$( Paragraph$(aLL$, There), 2)
			Word$=leftpart$(Ret$,"!")
			lbl=Val(Rightpart$(Ret$,"!"))
			info=Val(Rightpart$(Ret$,"-"))
			if info=0 then
				="["+LeftPart$(Paragraph$(aLL$,lbl+1), ", ")+"] "+format$(paragraph$(aLL$, 2+aa+1+There-no_par))
			else
				="["+RightPart$(Paragraph$(aLL$,lbl+1), ", ")+"] "+format$(paragraph$(aLL$, 2+aa+bb+info))
			end if
		end if
	}
End If



\\ this call using Call Local (otherwise we get error because GetHepl$() isn't a global, or a local to FindWord)
Function FindWord {
	read new word$, find=false
	Local hlp$=GetHelp$(&Word$, find)
	If len(hlp$) Else Exit
	HelpText$=word$+nl$+hlp$
	If not helpview Then helpview=true : helpenabled=true
	Call Local Notepad.Resize()
}

\\this call using Call Local too, because inform1 is in this module scope
\\ we use letter$ to pop a string (so we don't have to make a variable first)
Function InformNow {
	With Inform1, "Caption",  letter$
}



\\ so now we have to make some event service functions.
\\ all these functions call local, means they use the same namespace as the one which the object defined
\\ we have to use Read New  or place a new in parameter list () like in NotePad.Unload
\\ this prevents to use a same local variable. Events may be called again, while still executed
\\ to prove that we have to open a big file (rename a big txt file as gsb, say bigger than 10Mbytes)
\\ then open it, and before actual placed in Pad, we can use he same service function to close the NotePad

\\ Form's Events  (NotePad is the object)
\\ The NotePad.Unload event get an argument by reference. If this change to true the unload canceled

Function NotePad.Unload(New &Ok) {
	If LoadState Then Quit=true : Call Local InformNow("Quit Loading..") : Exit
	If Pad.Text$<>BackUp$ Then
		After 50 {Call Local File1.DblClick(4)}
		Ok=True
	End If
}
\\ we can change this in code if we change the font of title (because a new TitleHeight  prodced), or if we remove the header (make it invinsible)
def onetime=true
Function Notepad.Resize {
	Layer NotePad { Cls Color(255, 160, 0) ,0}
	With NotePad, "Width" as NP.Width, "Height" as NP.Height, "TitleHeight" as tHeight
	tHeight1=theight*2
	if onetime then
		Method File1,"move", twipsX*2, tHeight,  twipsX*80, tHeight
		Method Edit1,"move", twipsX*2+twipsX*80, tHeight,  twipsX*80, tHeight
		Method Run1,"move",  twipsX*2+twipsX*160, tHeight,  twipsX*80, tHeight
		Method Help1,"move", twipsX*2+twipsX*240, tHeight,  twipsX*80, tHeight
		Method Inform1,"move", twipsX*2+twipsX*320, tHeight,  twipsX*160, tHeight
		onetime=false
	End if
	If NP.height>1800 Then {
		If helpview Then
			local free=NP.Height-tHeight1-twipsX*3
			local third=free/3
			free=free-third-twipsX*3
			Method Pad,"move", twipsX*2, tHeight1,  NP.Width-twipsX*5, free
			Method HelpPad,"move", twipsX*2, tHeight1+free+twipsX*3,  NP.Width-twipsX*5,third
			helpshow=true
		Else
			helpshow=false
			Method Pad,"move", twipsX*2, tHeight1,  NP.Width-twipsX*5, NP.Height-tHeight1-twipsX*3
		End If
		With Pad, "NoWrap" as NoWrap
		If Not NoWrap Then Method Pad,"Resize"
		Method HelpPad, "resize"
	}
}

ms$={Find Topic
Use ALL to get a list of all topics}
Function HelpPad.click1 {
	Method  HelpPad, "EditTextView", false
	If ask(ms$,,,,, what$)=1 Then Read New what$ :Call Local FindWord(what$, true)
}


\\ this is the event to do something with a word clicking on heplPad
Function HelpPad.word {
	Call Local FindWord(letter$, false)
}


\\ From Pad we want to intercept the Ctrl+F5, to call the the first menu item in Run1
\\ We can use a After {} thread (a M2000 Thread), to make the call asyncronus
\\ also we make the key and shift zeroes, to not used by Pad (normaly F5 open the Replace Input Box, if we mark a word )
Function Pad.KeyDown {
	Read New &kc, &Shf
	If kc=116 and shf=2 Then
		kc=0 : shf=0
		After 20{
			Call Local Run1.DblClick(0)
		}
	End If
}


\\Also we want from Pad to get a word, and open/change HelpPad

\???

\\ Also Local can be used if we didn't use &, for by reference variables
\\ PopUpMenu is the standard menu for EditBox, but we can change it
\\ using this event
\\ This event fires when we use right mouse button  or Ctrl+F10, or Contex Menu Key.
Function Pad.PopUp {
      Read Local X, Y
      Method Pad,"PopUpMenu", "",X , Y
}

\\ Each time we change SelStart or SelWidth of Pad, we get an Inform event
Function Pad.Inform {
	Read New L, P
	If old_status<>par_status Then
	With Inform1, "Caption",If$(par_status->"Hidden", "No Hidden")
	old_status=par_status
	Else
	With Inform1, "Caption", format$("{0}-{1}", L,P)
	End If
	\\ set focus to Pad - refresh if not scheduled
	Method Pad,"Show"
}

\\ Helper functions for Edit1
Function SetTabs {
	With Pad, "UseTab", True,"tabwidth",6
	With Inform1, "Caption","Set Tabs"
	Method Pad,"Show"	
}
Function SetSpaces {
	With Pad, "SpaceIndent", 6
	With Inform1, "Caption","Set Spaces"
	Method Pad,"Show"
}
Function ChangeHidden {
	Edit1.Selected(10)=not par_Status
	Method Pad,"PressKey", 121, 0   ' 121=vbkeyF10
	old_status=par_status
	With Inform1, "Caption",If$(Edit1.Selected(10)->"Hidden", "No Hidden")
	Method Pad,"Show"      
}
Function ChangeStyle {
	Edit1.Selected(11)=not style_status
	Method Pad,"PressKey", 120, 1
	\\ no need to refresh, the effect is internal, and we see the cursor
	\\ to leave the center line if free style used, not only in top or bottom page
}

\\ Befor Edit1 opened
Function Edit1.OpenMenu {
	Local X
	X=SelLength>0
	Edit1.Enabled(0)=X
	Edit1.Enabled(1)=X
	Edit1.Selected(10)= par_Status
	Edit1.Selected(11)= style_status
}
\\ We can check in checkboxes and radiobutton withou closing the menu
\\ if we click on checks - (not on names)
\\ here we use If Else.If Else End If

Function Edit1.MenuChecked {
	Read New RadioIndex 
	If RadioIndex=7 Then
		Call Local SetTabs()
	Else.If RadioIndex=8 Then
		Call Local SetSpaces()
	Else.If RadioIndex=10 Then
		Call Local ChangeHidden()
	Else.If RadioIndex=11 Then
		Call Local ChangeStyle()
	Else
		With Inform1, "Caption","??"
		Method Pad,"Show"	
	End If
}

\\ When we double click on a menu item
\\ We use Select Case
\\ In M2000 after a Case can be one line of commands, or a block of commands {}
\\ but no two or more lines of commands
Function Edit1.DblClick {
	Read New Edit1index
	Select Case Edit1index
	Case 0
		Method Pad,"mn1sub" : Method Pad,"Resize"
	Case 1
		Method Pad,"mn2sub"
	Case 2
		Method Pad, "mn3sub" : Method Pad,"GetFocus" : Method Pad,"Resize"
	Case 4
		Method Pad,"PressKey", 9, 1
	Case 5
		Method Pad,"PressKey", 9, 0
	Case 7
		Call Local SetTabs()
	Case 8
		Call Local SetSpaces()
	Case 10
		Call Local ChangeHidden()
	Case 11
		Call Local ChangeStyle()
	End Select
}

\\ Prepare the Run part
Document TestFile$
UseShow$={
	Use statement Show to select when console open. Use { END } to skip waiting for key before end
	}
	
\\ 0,2,3 menuitems call the same 
\\ 1 is the line separator
Function Run1.DblClick {
	Read New Run1index
	if Run1index=1 then
		exit
	else.if Run1index=5 then
		Clear TestFile$
		Prototype {
		Module A {
			Title "Settings", 0
			Settings
			Wait 2000
			While Control$="SETTINGS"
				Wait 500
			End while
		}
		A : End
		} as TestFile$
		Save.Doc TestFile$, "Test1235.gsb"
		Win appdir$+"m2000.exe", dir$+"Test1235.gsb"
	else.If ask(if$(Run1index=0->"Module to run","Command(s) to execute"	+UseShow$),,,,,mod2run$)=1 Then
		Read mod2run$
		Clear TestFile$
		TestFile$=If$(Run1index=2->"Set Slow"+nl$,"")
		TestFile$="Module TestThis {"+Pad.Text$+nl$+"}"+nl$
		TestFile$="Title "+quote$(LeftPart$(Caption$," -"))+nl$
		TestFile$="Script TestThis :"+If$(Run1index=0->"Test ","")+mod2run$+": Push Key$: Drop: End"
		Save.Doc TestFile$, "Test1234.gsb"
		Win appdir$+"m2000.exe", dir$+"Test1234.gsb"

	End If
}

\\ This is the File1 DblCkick event
\\ We use On Goto who start from 1, so we add one to File1index
\\ We use labels and goto because the logic is a kind of spagheti
\\ From Open1: may we go to Save1:
\\ From Unload: we go to Save2:
\\ From Save2: may we go to Save1:
\\ There several cases to exit
\\ the code use If with blocks {}  ' not updated yet
\\ The Break statement stopped only from a Try {},
\\ so Break make exit from all blocks, and exit from function.

Function File1.DblClick {
	Read New File1index
	Local cont, cont2, f$, nl$={
	}
	File1index++
	\\ Because we want some jumps..we use  On Goto
	\\ on Goto need here a block
	{
		On File1index Goto Open1, Save1, ExitNow, Save2, Unload
Exitnow:
		Exit
Open1:
		If Pad.Text$<>BackUp$ Then {
			If ask("Save Changes first?",Title$)=1 Then Goto Save1
		}
		Layer NotePad {
			\\Using "**" we can go up to drives.
			Try ok {
				Open.file filename$,"**","Load M2000 (Gsb) File","gsb"
			}
			If not ok Then push "" : Dir User
		}
		Method Pad,"GetFocus"
		Read f$
		If f$<>"" Then
			If exist(F$) Then {
				Clear LoadFile$
				Method Pad,"PressKey", 0, 0
				LoadState=true
				Call Local InformNow("Loading...")
				layer NotePad {
					Load.Doc LoadFile$, f$
				}
				\\ set the current directory
				If quit Then break
				Filename$=f$
				dir file.path$(Filename$)
				If not quit Then 
					Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
					Clear Backup$
					BackUp$=LoadFile$
					Clear LoadFile$
					Pad.Text$=BackUp$
				End If
			} Else Pad.text$="": Clear BackUp$
			Call Local InformNow("Rendering...")
			Method Pad, "Resize"
			Call Local InformNow("Ready...")
			LoadState=false
		End If
		Exit
Save1:
		Layer NotePad {
			try ok {
				Save.As Filename$,"**","Save M2000 File","gsb"
			}
			If not ok Then Push "" : Dir User
		}
		If not cont2 Then Method Pad,"GetFocus"
		Read f$
		If f$="" Then Exit 
		If lcase$(file.type$(f$))<>"gsb" Then f$=f$+".gsb"
		If Exist(f$) Then  If Ask(nl$+"Overwrite"+nl$+f$,Title$)<>1 Then Exit
		Try ok {
			Clear BackUp$
			BackUp$=Pad.Text$
			Save.Doc BackUp$, f$
			filename$=f$
			dir file.path$(Filename$)
			Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
		}
		If ok Else beep
		If not cont Then Exit
Save2:
		cont=True
		If Pad.Text$<>BackUp$ Then {
			If ask("Save Changes?",Title$)=1 Then Goto Save1
		}
		Clear BackUp$
		Pad.Text$=""
		If Cont2 Then
			Dir CurDir$
			Method NotePad, "CloseNow"
		Else
			FileName$=Dir$+"Untitled.gsb"
			Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
			Method Pad, "Resize"
			Method Pad,"GetFocus"
		End If
		Exit
Unload:
		Cont2=True : Goto Save2
	}
}

\\ These are the Help1 events
\\ We want to enable/disable 3 and 5 menuitems
GetIndex=lambda Help1 (id$) ->{
	ret=-1&
	Method Help1, "GetMenuId", id$, &ret as ok
	if ok then =ret else =-1&
}

Function Help1.OpenMenu {
	Help1.Enabled(GetIndex("OPEN"))=HelpShow  and not HelpEdit
	Help1.Enabled(GetIndex("CLOSE"))=HelpShow
}

Function Help1.DblClick {
	read new  Help1.index
	call local InformNow(id$(Help1.index))
	Select Case id$(Help1.index)
	Case "ABOUT"
	{
		Local A, info$
		Info$={
			This is an example
			of a notepad for M2000 Programs
			written in M2000
			and run in M2000 Environment
			}
		A=Ask(info$,Title$,"","")
	}
	Case "FIND"
		Call Local HelpPad.click1()
	Case "OPEN"
		Method  HelpPad, "EditTextView", True: Call Local Notepad.Resize()
	Case "CLOSE"
		Method  HelpPad, "EditTextView", false : HelpView=false: Call Local Notepad.Resize()
	End Select
	
}
\\ This is for clicking a word
Rem {
	Function Pad.Word() {
		Call Local FindWord(letter$, false)
	}
}
Function HelpPad.Word() {
	Call Local FindWord(letter$, false)
}
\\ this work with help
Function Pad.Help {
	Read New what$ :Call Local FindWord(what$, true)
}
Function Pad.About {
	Call Local FindWord("ALL", true)
}
Function Notepad.InfoClick {
	Read New X
	If X=0 Then Call Local Help1.DblClick(0)  ' 0 for first menu item
}
Call Local Notepad.Resize()
\\ make this as the default control (get focus)
With Pad,"Default",True
\\ open as modal
With NotePad,  "Blink", 50, "BlinkTimes", 20
Method NotePad,"Show", 1
Declare Pad Nothing
Declare NotePad Nothing 
If Module(Info) Then
	Title "Info"
	keyboard "INFOBasic"+chr$(13)
end if
}
MODULE INFOBASIC {Set Edit !4   ' 4 chars fpr tabs in edit
\\
\\ Press Esc to exit this editor - look the context drop down menu too (ctrl+F10 also open context dropdown menu)
\\
\\
refresh 10000
if scale.Y<8000 then window 8, window
Form 80, 66
BackGround {height.pixels=ceil(scale.y / twipsY) : width.pixels=ceil(scale.x / twipsX)}
Print height.pixels
if height.pixels=1024 or height.pixels/width.pixels>0.70 then
      Form  80,66
else
     Form   120,80
  end if
backcolor=5   'point
oldpen=14  ' pen
Pen 0 {
	cls 7
	ico 1   ' draw icon (a png image, loaded as text as BASE64 encoded)
	Double
	Print Part  "  M2000 Interpreter"+str$(version)+if$(revision>0->" ("+str$(revision,0)+")","")
	Print
	Normal
	Report " A collection of modules for tests version 15 for ver 9.9 rev 33 and newer"
	
	Pen 5{
		cursor 0, row-1
		Report 1, "George Karras 2020"
	}
}
cls backcolor, row
Scroll split 0  ' reset the row+1 which given in cls
pen oldpen
Clear ' clear local variables
title("Modules ?")
Report {
	Modules ?    (or control+N, display all loaded modules, If nothing loaded display files)
	Modules ? "","Print"  (search all loaded modules for those who have Print in any case like PrINt)
	You can call any module by name, try Info
	Modules (Show every loaded module, plus files on user folder)
	}
Pen 15 {
	Modules ?
	Print
}
title("List")
Report {
	You can see the global variables, If any exist, defined in console  (write A=10 then press F3 )
	Use statement Clear to clear all variables (including static variables if any)
	}
List
title("Stack")
Report {
	You can see the stack of values, If has any value
	Use statement Flush to empty the stack
	}
Stack
title("Useful Statements")
Report {
	Help All, Help Print, Help  |	Monitor  (to see switches), shitches
	(some staments can be used from a module using the Set statement)
	(Set Monitor - because Monitor is known to Console Interpreter)
	Edit info  (press esc to exit editor) | Edit "disk_file.gsb"  (to edit from disk - saved at exit)
	Edit  (no argument) open command editor (we pick in console line using up/down arrows)
	Save filename   (without quotes, except If we want spaces) | load filename  (filename without "" and type)
	Settings (open dialog for setting environment) |	Start  ' restart console
	Use filename  (use info open another info in another console)  | Dir to show current directory or Dir user to set current dir to user folder
	Files "GSB","PRINT|FOR" (search files *.gsb for words PRINT and FOR) | Win Dir$ | Win Calc | Win Appdir$ | End (to exit from console)  
	}
Fkey Clear
FKey 1,"Saveme ' save all loaded modules"
FKey 2,"Logo : Edit InfoBasic : hide : InfoBasic ' edit this"
FKey 3,"InfoBasic ' this page"
FKey 4,"M2000_Editor_Information  ' about editor"
FKey 5,"Demo1  ' 3d Drawing in a Window"
\\FKey 6,"Edit M2000_editor_information"
FKey 6,"icons ' an example using sprites of type png"
Fkey 7,"Tr 'Three Oscilloscopes"
Fkey 8,"mEditor ' A window based M2000 Editor"
Fkey 9,"kb ' A keyboard to play music"
FKey 10,"Settings"
FKey 11,"Dijkstra"
Fkey 24, {chessgame "rnb2rk1/ppp1q1pp/5n2/2bpp3/2Q1p3/1B3P2/PPPP1NPP/RNB2RK1 w - - 0 10"}
Fkey 12, "chessgame"
FKey 19,"List33  ' Listbox control Example"
FKey 18,"Form44  ' Muliple Windows Example"
FKey 17,"Maze2  ' Maze Drawing in console"
FKey 16,"Cal  ' Snoopy Calendar"
FKey 15,"OOP1  ' EventHandler Class"
FKey 14,"Pend  ' Pendulum Animation"
FKey 20,"Pong  ' SoloPong - for one player"
Fkey 21, "minesweeper  ' edit the code to change the game board size"
Title("Fkey")
Fkey
\\title("M2000 Writer")
\\Keyboard "Writer"+chr$(13)
show
End
Sub title(a$)
Pen #ffeeff {
	cursor 0
	Italic 1
	Report a$
	Italic 0
	cursor 6, row-1
}
End Sub
}
MODULE SAVEME {Print "Wait..."
Title "Info"
dir user
save info, {UseThis : InfoBasic : Pen 15 {Print "Press F3 now"}}
Print "Done"

}
MODULE M2000_EDITOR_INFORMATION {\\if width<>80 and height<>66 then window 10, window : form !80,66
thread.plan sequential   ' can run as concurrent too
linespace twipsY*2
' Mode as read only value return the height of layer form in pt. Using Mode we set to the same Mode but we cut extra space (use linespace also)
Mode Mode   
'Cls,0
backcolor=point
oldpen=pen
Refresh 500
Pen 0 {
	cls 7
	call ico, 1
	Double
	Print part  "  M2000 Interpreter"+str$(version)+" ("+str$(revision,0)+")"
	Print
	Normal
	Report " Internal M2000 Editor"
	Pen 5{
		cursor 0, row-1
		Report 1, "George Karras 2019"
	}
}
cls backcolor, row
pen oldpen
title("Define a Module")
Report {
	Edit Alfa   (open editor to edit Alfa Module, and all modules/functions inside of it)
	}, width-12
title("Define a Function")
\\ we can't put a left parenthesis without a match right parenthesis (including for strings) in a { } string literal
Report {
	}+"Edit Alfa() or Alfa("+{  (open editor to edit Alfa() Function, and all modules/functions inside of it)
	}
title("Open for edit at specific position")
Report {
	Edit Alfa, 100
	}
title("Indent a line")
Report {
	just press tab before any letter, to delete indentation mark the text shift +End and then press shift tab
	You can start a indentation with spaces (Default is tab - characrer 9), using shift tab in a clear line, or a line without leading tabs.
	}, width-12
title("Indent multiple lines")Report {
	Mark a block and then press tab or shif tab to move text right or left
	}, width-12
title("Functions Keys for Editor")
Report {
	F1 - Toggle Wrapping setting (on or off)
	F2 - search marked or last searched word/characters up
		using shift  to search characters using  ctrl to search words (both open a messabox)
	F3 - search marked or last searched word/characters down
		using shift  to search characters using  ctrl to search words (both open a messabox)
	F4 - change the letters case using the marked word (no undo for this)
	F5 - Replace marked word with one we provide in inputbox (multiple undo) - using shift replace characters - Ctr-Z undo the action
	F6, F7, F8 Bookmarks. One press for Set, Delete, Goto Bookmark. Messages displayed
	F9 - Count words  - Shift F9 change Editor Style
	F10 - Show hidden characters (paragraph, spaces as dot, nbsp as space, figure space, tab)
	F10 & Shift - Open Popup Menu
	F11 - Change Syntax Color On, Language Width Normal, Syntax color Off, Language Width Small
	F12 - Open a form displaying all names of loaded modules, we can click on any to read or copy part of source
	Shift F12 Exit without changes (useful if Editor get crazy...)
	}, width-12
title("Holding Ctrl")
Report {
	Ctrl+X Cut	Ctrl+C Copy   (copy Html and Simple Text, Html has <pre></pre> if tabs exist in copied text)
	Ctrl+V Paste	Ctrl+A Select all
	Ctrl+Z Undo (unlimited, but we loose it if we press Esc to leave from editor)		Ctrl+Y Redo (unlimited too)
	}, width-12
title("Using TAB")	
Report {
	Shift+Tab Insert spaces not tab
		we can change the tab width using a commmand: Edit ! Number. We can set spaces as tab using Switches "-TAB"
	Tab  insert a tab in umarked text, apply indentation in marked text
	Tab + Shift remove indentation in marked text,  Insert spaces as tab if no leading tab exist
	}, width-12
title("Special Key Combinations")
Report {
	Ctrl+Shift Enter place Braces and a line inside with proper indentation
		We can mark text and place braces and indentation for all marked text
	Ctrl+Shift+Space insert a non break space
	Alt+Shift+Space insert a figure space
	Alt + 5 + 9 return ANSI 0x59 (;)  (we can give any number - the number is in decimal Unicode format)
	a Alt "+" 3 0 2 a give â (Combining Diacritical Mark 0x302)  - we can use Ins if no Number Keypad exist (lfor aptos)
		We can use  numbers above 0x10000 . Hold Alt and press Ins 1 0 4 3 7 on keypad or number keys and release Alt to get 𐐷
	Pairs:() {} "" []  we press the first and we get the other and cursor set inside them
		Also we can mark text and press one of above to place makred text inside
	}, width-12
Press()
Cls
title("PopUp Menu")
Report {
	Open with Shift+F10, Key Context Menu if exist, left mouse button in edit area, right mouse button in header area
	We can move the menu (stay open until lost focus)
	We can resize the menu to get bigger text (also this operation resize other interpreter forms)
	
	First line show line number, character position and can input a line number to move this line to center vertical as possible
	Cut
	Copy
	Paste
	Save and Exit
	Discard Changes
	Search up
	Search down
	Make same All
	Replace word
	Word Wrap
	Drag Enabled (by default drop is enabled, to allow drag operation we have to set this)
		(drag start when we give a double click inside marked text. By default for inside drop is a cut and paste procedure)
		(Shift/Ctrl works also)
	Color/Short Language
	Paragraph Mark (show hidden characters, we can edit in this mode)
	Word Count
	Help  (if we makred a word - just click on it- we get a form with information about it).
	Modules/Functions.
	Insert File  (this is a macro which insert a file as Base64 encoded in text, for a string variable).
	Load Resource (this is a macro which insert a binary file to a buffer type variable).
	}, width-12
title("View code without moving the cursor from position")
Report {
	We can scroll up or down using vertical scroll bar. Press left or right or up or down or an key to return to previous view
	Use F1 to change wrap (this also has no affect to cursor).
	Move some lines up or down holding down right mouse button. There is a timer which enable quick move.
	The same timer enabled when we click the top or bottom areas of the scroll bar control.
	}, width-12
title("View/Select code as you change the cursor from position")
Report {
	Use arrows, Home (change from position 1 to first non space  in row, each time we use it).
	End to end of line.
	Page Up, Page Down  (Page is the  half page of view).
	Clicking with right mouse button.
	Shift with all above mark text.
	**New**	Ctrl+Left or Right arrow make long jump based on context, can be used with Shift to mark text also
			Ctrl+Delete, Ctrl+Backspace delete multiple characters base on the jump system.
	Using mouse wheel we change half pages (moving the cursor too), shift has no effect.
	Using F6 to F8 (Bookmarks) to jump to a bookmark.

	When we edit a line editor keep the line in the middle of view if it is possible.
	If no warp enabled then the horizontal moving is automated, when we type, or when we move text to drop it,
	depending of the position of the "running cursor" (if we miss the drop, the cursor return to starting position).
	}, width-12
Press()
cls, -2
Keyboard "infoBasic"+chr$(13)
End  ' we can omit this
Sub title(a$)
Pen #ffeeff {
	cursor 0
	Italic 1
	a$=replace$(chr$(9),"      ", a$)
	Report a$
	Italic 0
	cursor 6, row-1
}
End Sub
Sub Press()
	wait 200
	local col=15,  col2=backcolor, threadid
	Input End  ' empty buffer too
	Print @(0,Height);
	Thread {
		Pen col {
		Print Over $(3), "Press space bar or mouse key" 
		}
		swap col, col2
	} as threadid interval 250
	Main.Task 10 {
		if keypress(1) or keypress(32) then exit
	rem		if mouse>0 or inkey$<>"" then exit
	}
	Threads Erase
End Sub
}
MODULE FORM44 {Module TryIt {
	Rem : Set slow
	Set fast
	Thread.Plan  Concurrent  ' Sequential
	Refresh 40
	SMOOTH on
	Cls,0
	\\ using ,0 we switch console to minimize state
	\\ any value else or no value restore to normal state
	title "Start Up" ', 0
	N=3
	\\ we choose to use automatic event object
	\\ this event object expect to find Form1() function
	\\ using automatic object we can't disable it
	\\ also events which expect changes to variables
	\\ bypass the stantard callback and resolve to a function
	\\ like  Form1.Unload() which get back the Nook value
	
	Declare Form1(N) Form
	
	\\ Buttons can be clicked or shifted right (same as clicked)
	
	Class Buttons { 
	      Dim Butt() 
	      Module SetCaption { With .Butt(Number), "Caption",Letter$}
	      Function ReadCaption$ { With .Butt(Number), "Caption" as Result$ : = Result$}
	}  
	Dim Controls(N)=Buttons()  \\ an array of arrays
	\\ 
	For i=0 to N-1 {
	      For Controls(i) {
	            \\ need to be a new name for array
	            \\ a For object { } delete any new name
	            \\ so each time this block run, starts with no Button1() array
	            \\ then make one, then we get a copy (and references to actual objects)
	            \\ and then Button1() erased
	            \\ but Controls(i).Butt() can't erased because exist before we enter the loop
	            Declare Button1(2) button Form Form1(i)
	            For j=0 To 1 {
	                  Method Button1(j), "move", 1000+4000*j, 2000,3000,1000
	                  if j=1 then {
	                        Method Button1(j), "curve",3
	                  } else Method Button1(j), "transparent"
	                 
	            }
	            .Butt()=Button1()
	      }
	     Layer Form1(i) {
	            Cls 4, 0
	            Gradient 1,4
	            Cursor 0,3
	            Report 2, "Hello There"
	     }
	      Method Form1(i), "Show"
	}
	\\ check this. After 6 second we can unload two forms
	\\ Ttry to close anything. You can without a problem
	\\ and after 3 seconds one more
	\\ just press enter after Rem 1: to make lines ready for execution
	Rem 1: Wait 6000 : PrintAndRefresh("CloseNow") : For i=1 to 2 : Method Form1(i), "CloseNow" : Next i
	Rem 2: Wait 3000 : PrintAndRefresh("Unload") : Refresh  : Declare Form1() Nothing
	Rem 3: Show \\ get the focus back
	Rem 4: Print "ok" : Exit
	
	Form1_1=true
	Controls(1).SetCaption 0, "Click Me"
	Controls(1).SetCaption 1, "ok"
	Controls(2).SetCaption 1, "Test Me"
	\\ we make a variable bound to a property
	With form1(0), "Visible" As visible
	CloseThisForm=0
	CloseThisTitle$=""
	Function CloseAfter {
	
	      If Ask("Close Form?", CloseThisTitle$)=1 Then {
	      If CloseThisForm=1 Then Form1_1=false
	      Method Form1(CloseThisForm), "CloseNow"
	      }
	}
	Function Form1.Unload {
	      Read New index, &Nook
	      Nook=True  \\ no unload now
	      \\ After make an unamed thread
	      \\ we use this of async waiting for user to
	      \\ provide feedback from a message box
	      with Form1(index), "title" as title$
	      CloseThisTitle$=title$
	      CloseThisForm=Index
	      After 50  { Call Local CloseAfter() }
	}
	Function Button1.Click {
	      Read New K, L
	      Print "Form:";L,"Button:";K
	      Print Controls(L).ReadCaption$(K)
	      if k=1 and l=2 then after 20 {test}
	}
	Function Form1.MouseMove {
	      Read New K, Button, Shft, X, Y
	      If Button=1 Then {
	           Layer Form1(K) {    
	                  move X, Y
	                  circle 500, 1, 14-K
	            }
	      }
	}
	Function Form1.MouseDown {
	      Read New K, Button, Shft, X, Y
	      If Button=2 Then {
	            Method Form1(K), "Control", 1 As UserControl
	            \\ we have to use new names if we "call local" a function
	            With UserControl, "Visible" As uVisible
	            uVisible=Not uVisible  \\ we can't use X~ as X = Not X     
	      }
	}
	'goto aaa
	For i=0 to N-1 {
	\\ Threads get current layer as starting layer
	      Layer Form1(i) {
	            \\ so we make the thread inside Form Layer 
	            Thread {
	            part {
	                  If Form1_1 Then {    
	                              if not scale.x then  thread this erase
	                            \\ third parameter is for color, we can use Color(r,g,b) or Colour(r,g,b) 
	                            \\ for rgb value, or we can give an Html number like #FF0000	                            \\ another way is by using hex 0X80000012 for system colors
	                            \\ Here we use values from the range 0 to 15 (here from 7 to 15)
	                            \\ and these are the standard colors.
	                           Draw To Random(Scale.x), Random(Scale.y), Random(7,15)
	                           \\ sub PrintAndRefresh can be run because all threads are in the same module
	                           \\ Threads have their execution object and an object to draw, here the form1
	                           \\ When thread call sub, sub run on same execution object.
	                           \\ modules and functions have own execution object
	                           \\ so subs are light and interest because the see every variable as local
	                           \\ but we can make temporary anything
	                           \\ we can also create threads in a sub, without erase them. 
	                           \\ Threads erased when parent object erased, or when we send erase command
	                           \\ or when we exit Task.Main
	                           \\ for the situation of a thread created on a thread we can use Threads Erase
	                           \\ too remove all, including these. This we need it because, the second level of thread may
	                           \\ end after the erasing of module, where we create it, so can run code with variables which
	                           \\ are cleared. So With Threads Erase before exit module we are sure that Threading Pool is empty.
	                           \\ But this in not an every day situation.
	                           \\  (an after {}  thread creation in a thread execution is an example for a second level thread)
	                           Rem 100 :
	                          If random(100)<4 then  PrintAndRefresh("draw lines")
	                          refresh
	                  } Else Thread This Erase
	                  } as mine
	            } As OneMore   Interval 30
	            thread OneMore  execute  static me=i
	            \\ OneMore is a handler, so we lost first and second handler
	            \\ but we dont care, we close thread inside using This
	            \\ or we can let the Main Task erase it at the exit 
	      }
	}
	
	Thread {     
	      PrintAndRefresh(Str$(Now,"hh:mm:ss"))
	} As Inform Interval 1000
	\\ Inform is the Thread Handler, we don't use it here
	aaa:
	\\ Need a thread to run a Main.Task
	Main.Task 100 {
	'Every 100 {
	      \\ using property  \\ 
	      
	            
	            Rem 1 :       Print Type$(Visible), Type$(Form1_1)
	            If Not visible Then break
	            threads
	      
	}
	
	\\  Cleaning;
	\\ A control has two objects, one in form (a UserControl, one type for all),
	\\ and the other is the wrapper, which serve as an event publisher,
	\\ and we can use propertiers and methods
	\\ When a Form unloaded not only erase UserControls but becaue hold referencse to wrappers
	\\ send deconstruct command to each one, to break any reference to form
	\\ and  erase internal collection - just throw references to actual objects
	\\ So our last references to wrappers are in Controls(i)
	\\ We can let M2000 to destroy the arrays, so the referecses, or we can do the job
	\\ and we can reuse it
	\\ so we check this with a jump to there
	Goto there
	For i=0 to N-1 {
	      For Controls(i) {
	            Dim .Butt()
	      }
	}
	there:
	\\ this command unload forms
	Declare Form1() Nothing
	'title "End"
	'Show
	Threads Erase
	Smooth off
	Thread.Plan Sequential  ' set the default again (can be set if no thread exist)
	Refresh 30
	Sub PrintAndRefresh(A$)
	            Print A$
	            Refresh
	End Sub
}
While inkey$<>"" {}
Cls ,0
Report {Form44
You can:
      1. draw on Windows using right mouse button.
      2. slide or click a button to see the response in console.
      3. hide title using left mouse button.
      4. click on Test button on Window 2, to open test dialog.
      5. move the windows
      6. Use Shif + F4 to close a form (even with hidden title)
      
      Closing form 2 stop threads for line drawing.
      Closing form 1 close all forms, program exit
      
      Enjoy
      George Karras
      
      (press any key)

}
push key$ : drop
TryIt
test !
Keyboard "info"+chr$(13)
}
MODULE LIST33 {Declare Simple Form
With Simple, "Title" As myTitle$
\\ make window, not show yet
Layer Simple {
      Linespace 60
      Font "Arial Black"
      Window 16, 8000,6000
      Cls 7,0 
      Cursor 0, height div 2
      Report 2,"Hello World"
}
\\ now put a ListBox
Declare Listbox1 Listbox Form Simple
Method Listbox1, "move", 1000,1000,6000,4000
\\ and fill with some data
With ListBox1,"Text",{London
                                    Paris
                                    Athens
                                    Rome
                                    Tirana
                                    Nicosia
                                    Brussels
                                    Copenhagen
                                    Berlin
                                    Dublin
                                    Luxembourg
                                    London2
                                    Paris2
                                    Athens2
                                    Rome2
                                    Tirana2
                                    Nicosia2
                                    Brussels2
                                    Copenhagen2
                                    Berlin2
                                    Dublin2
                                    Luxembourg2
                                    }
\\ and set some properties, and some of them are bind to objects that are properties to objects.
\\ also when we call a method, internal a resolved done in first time, so next time a method call will be faster.
With Listbox1, "transparent", True , "ListIndex" As ListIndex, "ListCount" As  ListCount
With Listbox1, "Find" As Find(),  "List" As List$(), "maychange", true
\\ make simple sizable form (units for forms are in twips)
With Simple,"Sizable", True,"SizerWidth",90
\\ now these are the event handlers
\\ event handlers can see anything defined in parent module
\\ for this reason for &rgb we need a Read New (so a new rgb prepared before a reference assign to it)
\\ any variable can get a reference to other variable once, at defining stage.
Inventory Blocked= "Rome", "Rome2", "Berlin"
Function Simple.Unload {
      Keyboard "!"   \\ like press !
}
Function listbox1.Color {
      Read New &rgb
            rgb=#FF7700
}
Function listbox1.Sep {
      Read New &D
		if exist(Blocked, List$(d)) then d=-1
		
}
Function Listbox1.DblClick {
            Read Where 
            if Right$(List$(Where),1)="✓" then {
                  List$(Where)=leftPart$(List$(Where)+" "," ")
            } else {
                  List$(Where)=leftPart$(List$(Where)+" "," ")+" ✓"
            }
            Mytitle$= List$(Where) 
'            Method Simple,"RefreshAll"
            Method Listbox1,"Refresh"

}
Function simple.click {
            If ListIndex>=0 Then {
                  local K$=List$(ListIndex), i
                  Method listbox1,"Sort"
                  ListIndex=Find(K$)
                  Layer {
                        \\ we print to standard cosnole layer
                        Print ">>", control$
                  }
            } Else Method Listbox1,"Sort"
}
Function Simple.Resize {
      Layer Simple {
            Mode 16
            Cls 7,0
            Cursor 0, height div 2
            Report 2,"Hello World"
            Method Listbox1,"Refresh"
      }
      \\ we put a refresh to console because
      \\ when this handler run, can't run thread k.
      Layer { Refresh}
}
\\ now we want to show (without modal showing)
Method Simple, "Show"
\\ We can put a background task (a thread), triggering each 100 mSec
Thread {
      Print tick  \\ tick is thread manager timer
      refresh
} as K interval 100
a$=Key$ \\ no loop just wait a key, in console only
Threads Erase
Declare Simple Nothing
}
MODULE TEXTOUT {Module UsingEvents {
      rem Form ! 80,66
      \\ from version 9.9 we have to get the byvalue parameters to variables without & (which used for byref read)
      Declare WithEvents sp "SAPI.SpVoice"
      That$={Rosetta Code is a programming chrestomathy site.
      The idea is to present solutions to the same task in as many different languages as possible, to demonstrate how languages are similar and different, and to aid a person with a grounding in one approach to a problem in learning another. Rosetta Code currently has 913 tasks, 214 draft tasks, and is aware of 707 languages, though we do not (and cannot) have solutions to every task in every language.}
      EndStream=False
      LastPosition=-1
      TxtWidth=0
      Function sp_Word {
            Read New StreamNumber, StreamPosition, CharacterPosition, Length
            Rem:  Print StreamNumber, StreamPosition , CharacterPosition, Length
            If  LastPosition=CharacterPosition Then exit
            LastPosition=CharacterPosition
            Local f$=" "
            If TxtWidth=CharacterPosition+length Then f$=". "
            If length+pos+2>width then Print
            Print Mid$(That$, CharacterPosition+1, Length);f$;
            If f$=". " Then Print
            Refresh
      }
      Function sp_EndStream {
            Refresh
            EndStream=True
      }
      Function sp_Sentence {
            Read New StreamNumber, StreamPosition, CharacterPosition, Length
            if Length>0 and not CharacterPosition=0 then Print
            Print "  ";
            TxtWidth=CharacterPosition+Length-1
      }
      Const  SVEEndInputStream = 4
      Const  SVEWordBoundary = 32
      Const  SVESentenceBoundary = 128
      Const SVSFlagsAsync = 1&
 
      With sp, "EventInterests", SVEWordBoundary+SVEEndInputStream+SVESentenceBoundary
      Method sp, "Speak", That$, SVSFlagsAsync
      While Not EndStream {Wait 10}
      Wait 100
}
oldVolume=Volume
Volume 100
UsingEvents
Volume oldVolume
}
MODULE MOVEBUTTON {Declare Form1 Form
Declare Button1 Button Form Form1
Declare TextBox1 TextBox Form Form1
Bx=4
Layer Form1 {
      Linespace 0
      Window 8, 10000, 6000
      Cls 1,0
      Form 30, 10
      Print @(0,4),"123456789012345678901234567890"
      Cursor Bx, 5
      Move !
      Button1_Xpos=Pos.x
      Button1_Ypos=Pos.y
      Xt=Button1_Xpos div Bx
      Yt=Button1_Ypos div 5
}
Method Textbox1,"Move", 1000,1000, 6000,600
Method Button1,"Move", Button1_Xpos, Button1_Ypos, Xt*5, Yt*2
Method Button1,"Curve",1 \\ 2 - 3 (single float)
Method Form1, "Show"
Function Form1.Unload {
      Keyboard "!"
}
Function Button1.Click {
      \\ print to console
      layer Form1 {            
            motion.w 0 ;
            
      }
      Print "Hello"
}
Function Form1.MouseDown {
      Drop 2 ' no need now (keycode and shift)
      Read New X, Y
      Layer Form1 {
            Move X, Y
            Cursor ! \\ transform to char coordinates
            Move ! \\ transform to graphic, at the up left corner of a char
            Method Button1,"Move", Pos.x, Pos.y
      }
}

A$=key$
Declare Button1 Nothing
Declare Form1 Nothing
}
MODULE DR {Module RomanNumbers {
      flush  ' empty current stack
      gosub Initialize
      document Doc$
      while not empty
            read rom$
            print rom$;"=";RomanEval$(rom$)
            Doc$=rom$+"="+RomanEval$(rom$)+{
            }
      end while
      Clipboard Doc$
      end
Initialize:
      function RomanEval$(rom$) {
            Flush
            ="invalid"
            if filter$(rom$,"MDCLXVI")<>"" Then Exit
            \\ "Y" is in top of stack
            Push "CM", "MD", "Q"
            Push "CD", "MD","W"
            Push "XC", "DL", "E"
            Push "XL", "X","R"
            Push "IX","V","T"
            Push  "IV","I","Y"
            \\ stack flush to doublerom
            doublerom=[]
            \\  "M" is in top of stack
            Data "M", 1000, "Q",900
            Data "D", 500,"W", 400
            Data "C",100,"E",90
            Data "L",50,"R", 40
            Data "X", 10, "T", 9
            Data "V", 5, "Y", 4, "I",1
            \\ stack flush to singlerom
            singlerom=[]
            acc=0
            value=0
            count=0
            stack doublerom {
                  if empty then exit
                  read rep$,exclude$,cc$
                  i=instr(rom$,cc$)
                  if i >0 then
                        tmp$=mid$(rom$,i+2)
                        L=Len(tmp$)
                        if L>0 then if Len(filter$(tmp$, exclude$))<>L then rom$="A": exit
                        if Instr(rom$,mid$(rom$,i,1))<i then rom$="A": exit
                        insert i,2 rom$=rep$  ' replace at pos i with rep$ and place a space to i+1
                  end if
                  loop
            }
            rom$=filter$(rom$," ") ' remove spaces if exist
 
            stack singlerom {
                  if empty then exit
                  read cc$, value
                  count=0
                  while left$(rom$,1)=cc$
                         insert 1, 1 rom$=""
                         count++
                         acc+=value            
                  end while
                  if count>3 then exit
                  loop
            }
            if len(rom$)>0  or count>3 Else
                  =Str$(acc,1033)
            end if      
      }
      data "MMMCMXCIX", "LXXIIX", "MMXVII", "LXXIX", "CXCIX","MCMXCIX","MMMDCCCLXXXVIII"
      data "CMXI","M","MCDXLIV","CCCC","IXV", "XLIXL","LXXIIX","IVM"
      data "XXXIX", "XXXX", "XIXX","IVI", "XLIX","XCIX","XCIV","XLVIII"
      return
}
RomanNumbers
}
MODULE G1 {t=0
{
'loop
t++
on t goto 100, 101

end
Print 0100
Print "fault"
0100 Print "ok1"
Restart
10100 Print "ok2"
exit
101 Print "ok"
}
}
MODULE G2 {goto 100

end
Print 0100
Print "fault"
0100 Print "ok1"
}
MODULE G3 {goto 100

end
Print 100
Print "fault"
100 Print "ok1"
}
MODULE G11 {t=0
again:
t++
on t goto 100, alfa
end
Print 0100
Print "fault"
0100 Print "ok1" : Print "100"
goto again
10100 Print "fault"
exit
alfa:
101 Print "ok2", t

}
MODULE G12 {alfa:
101  static a=10
110 a--
120 print a
130 if a>1 then goto alfa
140 Clear
}
MODULE G4 {Module beta {
      print "i am beta"    
}
X=4
beta: Print "ok"  \\ call beta then print ok
beta: \\ only rem
Print x
x--
If x<1 Else Goto beta
k=false
x=100

}
MODULE M2 {a=(1,2,3,4,5)
fold1=lambda (a, b)-> {
      push a+b
}
fold2=lambda (a, b$) -> {
      if len(b$) Then {push b$+","+str$(a,"")} else push str$(a,"")
}
'? a#fold(fold1, 0)=a#sum()
odd=lambda (x) ->x mod 2=1
even=lambda (x)->x mod 2=0
add2=lambda (x)-> {
      push x+2
}
square=lambda (x)-> {
      push x*x
}
combine=lambda  -> {
      a=Array([])
      if len(a)=0 then =lambda->{} : exit
      =lambda  a ->{
            for i=0 to len(A)-1 { 
                  m=array(a,i)
                  call m()
            }
      }
}
? "["+a#filter(odd)#fold$(fold2, "")+"]"
? "["+a#filter(even)#map(add2)#fold$(fold2, "")+"]"
a=(,)
z=a#filter(even,(0,))#map(add2)
Print z, type$(z)
a=(1,2,3,4,5)
? a#map(add2, square)
? "["+a#map(add2, square)#fold$(fold2, "")+"]"
}
MODULE FS2 {Form ! 60,40
linespace twipsY*4
Form ! 60
refresh
\\ using M2000 commands
Menu   ' clear Menu list
Files !  + "gsb|txt"   ' ! sorted by name, + add to menu
Print Len(menu$())

a=menu$()

\\ we can use Print a
\\ but get refresh after the last item
\\ so we can use code to diplay names in columns (expand if name is bigger for one column)
k=each(a)
mp=width/tab
mc=mp*height*3/5
m=mc
Print $(6, 15)  ' use numbers from 0 to 9  - colum width 15
While k {
	Print array$(k),
	m--
	if pos>=width then m--
	if m<mp and pos=0 and row=height-1 then
	m=mc
	Pen 15 {
		Print Part "Press a key on keyboard or mouse (except Esc/Break)"
		While mouse=0 and inkey$="" {Refresh}
		Print Over @(0),
	}
	end if
}
}
MODULE DEMO1 {set Fast !
smooth on
Rem :
 Thread.plan sequential : ComputeInterval=20: Rate=60
\\ we can set Thread.plan before any thread created
Rem : Thread.plan concurrent : ComputeInterval=30 :Rate=120
\\ concurrent execute one by one statements
\\ except those in { }
\\ also from Revision 52 Part {} as variable works fine with it
local counter1, counter2
Title "", 0 ' 0  to hide console
Set FAST !
\\ by api
Structure VecType {
          x As Double
          y As Double
          z As Double
}
\\ Program
Structure Variables {
      vRot1 As VecType
      vRot2 As VecType
      vRot3 As VecType
      vRot4 As VecType
      vBase As VecType
      vAxis As VecType
}
Buffer Clear Var As Variables
\\ utility function
VecAdr=Lambda Var (a$) -> {
      =Var(0,a$)
}
VecOff=Lambda Var, VecType (a$, b$) -> {
      =Var(0, a$, VecType(b$)!)
}
Class cLine {
      X1, Y1, X2, Y2, color
      Module Render {
            ' read Number from stack
            z=Round(Number,4)
            z1=Round(Number, 4)
            If z>=z1 Then {
                  Move .X1, .Y1
                  Width 3 {Draw to .X2, .Y2, .color}
                  Circle Fill #aa33cc, z/40+200
            } Else {
                  Move .X2, .Y2
                  Circle Fill #aa33cc, z/40+200
                  Width 3 {Draw to .X1, .Y1, .color}
            }
      }
Class:
      Module cLine (.color){
            If Match("NNNN") Then Read .X1, .Y1, .X2, .Y2
      }     
}

\\ find address
vBase=VecAdr("vBase")
vBase.x=VecOff("vBase","x")
vBase.y=VecOff("vBase","y")
vBase.z=VecOff("vBase","z")
vRot1=VecAdr("vRot1")
vRot1.x=VecOff("vRot1","x")
vRot1.y=VecOff("vRot1","y")
vRot1.z=VecOff("vRot1","z")
vRot2=VecAdr("vRot2")
vRot2.x=VecOff("vRot2","x")
vRot2.y=VecOff("vRot2","y")
vRot2.z=VecOff("vRot2","z")
vRot3=VecAdr("vRot3")
vRot3.x=VecOff("vRot3","x")
vRot3.y=VecOff("vRot3","y")
vRot3.z=VecOff("vRot3","z")
vRot4=VecAdr("vRot4")
vRot4.x=VecOff("vRot4","x")
vRot4.y=VecOff("vRot4","y")
vRot4.z=VecOff("vRot4","z")
vAxis=VecAdr("vAxis")
Refresh 100
Declare Alfa Form
With Alfa, "Title", "Demo1", "UseIcon", True, "UseReverse", True  ' icon now is in the left side
Method Alfa,"MakeStandardInfo", 1   ' 1 for English
Def  info$, AskRet
Function Alfa.InfoClick {
	Read New X
	If X=0 then
	after 100 {
			Info$={
				This is an example
				of  using MATH object
				(included in M2000 Interpreter)
				}
			AskRet=Ask(info$,"About Demo1","","")	
	}
	end if
}
\\ a string to hold static background
screen$=""
disp=False
Inventory Depth
aLine=Each(Depth)
once=False
Function DepthSort() {
                   Inventory Queue Depth ' clear Depth, Then make keys As numbers
                   Append Depth, Eval(Var, vRot1.z As double):=1, Eval(Var, vRot2.z As double):=2, Eval(Var, vRot3.z As double):=3
                   Sort Depth As number
}
Thread {
      part {
                  Method Math, "RotVectMult", 4, vRot1, vAxis, vRot1, dAngle
                  Push Eval(Var, vBase.y As double), Eval(Var, vBase.x As double)
                  \\ x is in top, y is after x
                  Over 2, 2 \\  copy two times from second, so double two top
                  Push Eval(Var, vRot4.x As double)+Number : Over 1, 2 \\ copy 2 times top only
                        Read Line1.X1, Line2.X1, Line3.X1
                        Push Eval(Var, vRot4.y As double)+Number : Over 1, 2
                        Read Line1.Y1, Line2.Y1, Line3.Y1
                        Over 2, 4 \\ now original 2 values copied 4 times
                        Line1.X2 = Eval(Var, vRot1.x As double)+Number
                        Line1.Y2 = Eval(Var, vRot1.y As double)+Number
                        Line2.X2 = Eval(Var, vRot2.x As double)+Number
                        Line2.Y2 = Eval(Var, vRot2.y As double)+Number
                        Line3.X2 = Eval(Var, vRot3.x As double)+Number
                        Line3.Y2 = Eval(Var, vRot3.y As double)+Number
                        call local depthsort()
                        counter1++
                        if random(20)>1 then exit
                        Method Math, "Vector", vAxis,.4 -.8*rnd, 1.6, .2-.3*rnd
                        Method Math, "UnitVect", vAxis
      }  As once
} As Compute
dim All(1 to 3)
Layer Alfa {
      Window 12, 10000, 8000;
      Form 40, 20
      Line1=cline(#0000FF, scale.x/2, scale.y/2, scale.x/2, scale.y/2-2220 )
      Line2=cline(#FF0000, scale.x/2, scale.y/2, scale.x/2-2340, scale.y/2-60 )
      Line3=cline(#00FF00, scale.x/2, scale.y/2, scale.x/2-780, scale.y/2-1200 )
      All(1)->Line1
      All(2)->line2
      All(3)->line3
      Declare Math Math
      Method Math, "Vector", vBase,scale.x/2-1500, scale.y/2+1500, 1500 '  -1000
      Method Math, "Vector", vRot1, Line1.X2, Line1.Y2, -1000
      Method Math, "Vector", vRot2, Line2.X2, Line2.Y2, -1200
      Method Math, "Vector", vRot3, Line3.X2, Line3.Y2, 1700
      Method Math, "Vector", vRot4, Line1.X1, Line1.Y1, 0
      Method Math,  "VecDiffMult", 4, vRot1, vBase, vRot1
      Inventory Depth=Eval(Var, vRot1.z As double):=1, Eval(Var, vRot2.z As double):=2, Eval(Var, vRot3.z As double):=3
      Sort Depth As number
      Method Math, "Vector", vAxis, -.8, 1.6, .3
      Method Math, "UnitVect", vAxis
      Rad2Deg =Lambda pidivby180=pi/180 (RadAngle)->RadAngle / pidivby180
      dAngle =5
      Pen 0
      Cls 7
      Gradient 11, 13
      Move 0,0
      Cursor 0, Height-1
      Cls 7, Height-1
      Copy scale.x, scale.y to screen$
      Cursor 0,Height
      together=False
      ok1=true
      Thread {
            ok1~
      } as mm interval 1000/50
      tm=0
      Thread {
            static internal=1
            Move 0,0
            Copy 0,0 use screen$
            Part {
                  tm=timecount
            } as ok1
            Print @(3,3); format$("{0:2:-5}",tm)
                  Cursor 0,height-1

            Part {
                       Part {
                        aLine=Each(Depth)
                        push  Eval(Var, vRot4.z As double) : Over 1, 2
                        while aline {
                                    pp=all(eval(aLine))
                                    pp=>render  Val(eval$(Depth, aLine^))
                        }
                        counter2++
                        } As disp
                   Print Part $(5,Width/4), counter1, counter2,internal, $(7),Str$(Now , "hh:mm:ss" ) 
                  Refresh 5000' execute together
            }  As together
            internal++
            Profiler
      } As PlayThis
}
\\ we set variables outside threads
State=False
blinking=False
Thread {
       If state Then disp~
 } As blink
Thread blink Hold
ExitNow=False
Function Alfa.Unload {
      ExitNow=True
      threads erase
}
Function Alfa.Click {
                  State~
                  If State Then {
                         Thread compute Hold
                         Thread blink interval 1000/4
                         Thread blink Restart
                         blinking=true
                  } Else {
                        disp=False
                        If blinking Then Thread blink  Hold : blinking~
                        Thread compute Restart
                  }
}
if IsWine then
      Thread PlayThis interval 1000/30
else
      Thread PlayThis interval 1000/Rate
end if  
Thread compute interval ComputeInterval
Wait 200
Method Alfa, "Show"
\\ Change Task.Main with Every
\\ Task.Main is a Thread
\\ ExitNow needed If we have Every in place of Task.Main
Task.Main 50 {
\\      If counter1>1000 Then Threads Erase : Exit
      If ExitNow Then Exit
}
Threads Erase
Thread.plan sequential   ' to default plan
Wait 100  \ some delay here
Method Alfa, "CloseNow"
Declare Alfa Nothing
Declare Math Nothing
Print counter1, counter2
Title "Demo Complete"
smooth off
Set Fast   ' return to normal
}
MODULE UPDATE {beep
Title "Info"
dir appdir$
save info, {UseThis : InfoBasic : Pen 15 {Print "Press F3 now"}}
if isnum then {
	drop
	open "info.bck" for output as #N
	close #N
}
dir user
save info, {UseThis : InfoBasic : Pen 15 {Print "Press F3 now"}}
}
MODULE BJ { Escape Off
 Flush  \\empty Stack, we use optional arguments in Modules
 NoPlayers=4
\\ Dealer get one hidden And one open Card
\\ Player's get two open cards, one at a time
\\ Options for Split and Double Down
\\ If Player has a BlackJack Then dealer play for 21, changing cards for other players/splits
\\ Standard Bet 100 credits.  Each player start with 10000 credits
MakeLayer()

Print $(4)
Inventory Suits = "♠":=0, "♥":=4, "♦":=4, "♣":=0 'suit -> color
Inventory Cards = "two":=2, "three":=3, "four":=4, "five":=5
Append Cards, "six":=6, "seven":=7, "eight":=8, "nine":=9
Append Cards, "ten":=10, "jack":=10, "queen":=10, "king":=10, "ace":=1
Global CardsView
\\ use <= to feed CardsView
Inventory CardsView <= 2, 3, 4, 5, 6, 7, 8, 9,10, "jack", "queen", "king","ace"

\\ We use Module because each module has own use of dots..
\\ And we call it inside a For Object {} And outside of it
DealerMoney=0
Module PrintCardOnly (k, Suits, Cards, x=0) {
          For k {
                Pen Suits(.suit!) {
                        Print Part @(10+x,row,15+x,row+1,#FFE4E1,0), Eval$(Suits, .suit)+" "+CardsView$(.card!)
                        Print
                   }
        }
}
' Using a Stack object
StackPack = Stack
Module AppendArray (N, A) {
      Stack N {Data !A}
}
Class OneCard {
      suit=-1, Card
Class:
     Module OneCard {
           \\ ? for optional reading
           read ? .suit, .card
     }
}
\\ 3X52 cards
Dim Pack(Len(Cards)*Len(Suits)*(NoPlayers+1)) \\ Not used here =OneCard()
Pen 14
Double
Pen 14 {Report 2, "BlackJack"}
Normal
Cls, 2
k=0
\\ fill cards to Pack()
For times=NoPlayers+1 To 1 {
      N=each(Suits)
      While N {
            M=each(Cards)
            While M {
                  Pack(k)=OneCard(N^, M^)
                  k++
            }
      }     
}
Layer 1 {
	Report 2, "Prepare Cards"
}
Rem : DisplayAll() ' in order
Suffle()
Rem : DisplayAll() ' at random positions
Print
' first cut for player
layer 1{
	Print "Make a Cut: 0-51:";
	Repeat {
	      N1=Random(0,51)
	      Try {
	            Input ! N1, 10
	      }
	      Stack StackPack {
	            Drop N1
	      }
	} Until N1>=0 And N1<=51
	Print N1
}
\\ used to pass the Dealer's hidden Card
Hidden=OneCard()
DealerHidden=OneCard()
Class PlayerJB {
      Class PlayerGame {
            \\ Class is a Group Factory - a function whuch return Group
            \\ Class Definition in a Group is local else is Global
            \\ until erased when Definition Holder exit or end (a Module/Function where we define a class)
            Playervalue, Bet
            \\ we can define groups using class like this If class constructor work without parammeters
            OneCard LastCard
            Class:
            \\ Class: means that this module exist only at construction stage
            Module PlayerGame {
                  ' This module as part of constructor
                  ' so has own Stack when called as constructor
                 Read .Playervalue, .Bet
                 If Not Empty Then Read .LastCard
            }
      }
      Inventory queue PlayerCards
      OneCard PlayerFaceUp2nd, SplitCard
      Bet=100, PlayerMoney
      Playervalue
      OldPlayerValues=Stack
      Done=false
Class:
      Module PlayerJb (.PlayerMoney) {}
}
Dim Base 1, Players(NoPlayers)=PlayerJB(10000)
Def Val$(x)=If$(x=-1 -> "Black Jack", Str$(x,""))
Card=OneCard()
Function ClearCards {
      Inventory queue ClearCards
      =ClearCards
}
Function PlayerHasNoBlackJack(HasTheDealer) {
      ' we get two parameters
      If Not HasTheDealer Then Exit ' the second parameter droped from Stack
      ' now we read 2nd
      Read k
      Def Range(X, X1, X2)=X>=X1 and X<=X2
      m=false
      If k.PlayerCards(0!).card=12 And Range(k.PlayerFaceUp2nd.card,8 ,11) Then m=m or true
      If k.PlayerFaceUp2nd.card=12 And Range(k.PlayerCards(0!).card,8 ,11) Then m=m or true
      =Not m
}
DealerRow=0
Repeat {
      layer 1 {cls}
      donecount=0
      For i=1 to NoPlayers {
            For Players(i) {
                  .SplitCard=OneCard()
                  .OldPlayerValues=Stack
                  If .done Then donecount++ :  Exit
                  If .PlayerMoney<.Bet Then {
                      Layer 1{
                          Print Format$("Player({0}), you run out of money...Bye Bye", i)
                      }
                        .done=true
                         donecount++
                  } Else {
                     Layer 1{
                           Print format$("Player({0}) Money:",i), .PlayerMoney
                              Print "Play Game ?(Y/N)"
                              If Key$ ~ "[NnΝν]" Then .done=true :  donecount++
                    }
                  }
            }
      }
      if donecount<NoPlayers Then Print "Press space to deal cards" : while Key$<>" " {}
      cls,2
      AllPlayers=NoPlayers
      BlackJack=false
      PlayersBurst=0
      Clear dealervalue
      DealerCards=ClearCards()
      For i=1 to NoPlayers {
            For Players(i) {
                  If .done Then AllPlayers-- : Exit
                  Clear .playervalue
                   .PlayerCards=ClearCards()
                  Print Format$("Player {0} Hand: 1st Card", i)
                  PlayerCard(&.playervalue, .PlayerCards)
            }
      }
      If AllPlayers=0 Then Print "No More Players" : Exit
      Print "Dealer Hand: 1st Card"
      DealerRow=row
      DealerCard(&dealervalue)
      cursor 0,2
      For i=1 to NoPlayers {
            If Not Players(i).done Then {
                  Print @(18),Format$("2nd Card", i)
                  For Players(i) {
                        NextCard()
                        .PlayerFaceUp2nd<=Card
                        PrintCardOnly Card, Suits, Cards, 18
                  }
            }
      }
      Print @(18), "2nd Card"
      NextCard()
      Print @(18), "Face Down Card"
      cls , row+1 
      DealerHidden=Card
      ' now If dealer face up Card is Ace or 10 or Figure can see If has a black jack
      N2=Cards(Card.card!)
      If N2=10 And Cards(DealerCards(0!).card!)=1 Then DealerBlackJack()
      If N2=1 And Cards(DealerCards(0!).card!)=10 Then DealerBlackJack()
      For i=1 to NoPlayers {
           If Not Players(i).done Then
                  If PlayerHasNoBlackJack(BlackJack, Players(i)) Then
                  cls, 2
                  For Players(i) {.PlayerMoney-=.Bet : DealerMoney+=.Bet} 
                  Exit
                  end If
                   For Players(i) {
                         Bet=.Bet
                         Again:
                              Print format$("Player {0} Play", i)
                              If .PlayerCards(0!).card=.PlayerFaceUp2nd.card Then {
                                    If .PlayerMoney<2*.Bet Then exit
                                    Print "Split Cards ?(Y/N)"
                                    If Key$ ~ "[NnΝν]" Then Exit
                                    AllPlayers++
                                    .SplitCard<=.PlayerFaceUp2nd
                                    NextCard()
                                    .PlayerFaceUp2nd<=Card
                                    Stack .OldPlayerValues {Push .PlayerGame(.playervalue, Bet)}
                              }
                              Print "Player Hand:"
                              Hidden=.PlayerFaceUp2nd : .PlayerFaceUp2nd<=OneCard()
                              PrintCardOnly .PlayerCards(0!), Suits, Cards ' show first Card
                              PlayHand(.PlayerCards,&.playervalue, False, False, .PlayerMoney)
                              ' first we get Bet
                              .PlayerMoney-=Bet
                              DealerMoney+=Bet
                              Print
                              If .playervalue>21 Then {
                                    PlayersBurst++
                                    Print "Dealer Win"
                              } else.if .playervalue=-1 Then {
                                    ' dealer has to play with player now
                                    PlayersBurst++
                                    Print Format$("Dealer play against Player({0})",i)
                                    PrintCardOnly DealerCards(0!), Suits, Cards
                                    Hidden=DealerHidden : DealerHidden=OneCard()
                                    \\ ? means undefined value
                                    PlayHand(DealerCards,&dealervalue, true, true, ?)
                                    If dealervalue<>21 Then {
                                            Print "Player Win", Bet*3/2 : .PlayerMoney+=Bet*5/2 ' one we get before
                                            DealerMoney-=Bet*5/2
                                    } Else {
                                          Print "Dealer Win"  
                                    }
                                    If PlayersBurst<AllPlayers Then {
                                          Clear dealervalue, DealerCards
                                          ' dealer take two cards to play with others
                                          Print "Dealer Hand: 1st Card"
                                          DealerCard(&dealervalue, DealerRow)
                                          Print "Dealer Hand: 2nd Card"
                                          NextCard()
                                          Print @(10), "Face Down Card"
                                          DealerHidden=Card
                                          ' now If dealer face up Card is Ace or 10 or Figure can see If has a black jack
                                          N2=Cards(Card.card!)
                                          If N2=10 And Cards(DealerCards(0!).card!)=1 Then DealerBlackJack()
                                          If N2=1 And Cards(DealerCards(0!).card!)=10 Then DealerBlackJack()
                                    }
                              }
                              ' Data push to end of Stack
                              ' Push push to top of Stack
                              ' Read read always from top
                                    If .SplitCard.suit<>-1 Then {
                                    Card=If(Bet>.Bet -> .PlayerCards((Len(.PlayerCards)-1)!), OneCard())
                                    Stack .OldPlayerValues {Data .PlayerGame(.playervalue, Bet, Card) : Read NextGame}
                                    Bet=NextGame.Bet
                                    Drop .PlayerCards Len(.PlayerCards) ' erase all cards
                                    Append .PlayerCards, "Split":=.SplitCard
                                    '.playervalue=Cards(.SplitCard.Card!)  ' this is the same
                                    .playervalue=NextGame.playervalue
                                    NextCard()
                                    .PlayerFaceUp2nd<=Card
                                    .SplitCard.Suit=-1
                                    Goto Again
                              }
                        Card=If(Bet>.Bet -> .PlayerCards((Len(.PlayerCards)-1)!), OneCard())
                        Stack .OldPlayerValues {Data .PlayerGame(.playervalue, Bet, Card)}
                  }
           end If      
      }
      If PlayersBurst<AllPlayers And Not BlackJack Then {
            Print "Dealer Play"
            PrintCardOnly DealerCards(0!), Suits, Cards
            Hidden=DealerHidden : DealerHidden=OneCard()
            PlayHand(DealerCards,&dealervalue, true, false, ?)
            Layer 1 {
                  Pen 3 {
                        Report 2, "Table Results"
                        For i=1 to NoPlayers {
                              For Players(i) {
                                    Repeat {
                                          If .done Then exit
                                          Stack .OldPlayerValues { Read NextGame }
                                          playervalue=NextGame.playervalue
                                          Bet=NextGame.Bet
                                          If Not playervalue=-1 Then {
                                                If Bet>.Bet Then {
                                                      Print "Face Up Card"
                                                      PrintCardOnly NextGame.LastCard, Suits, Cards
                                                }
                                                If playervalue>21 Then {
                                                     Print Format$("Dealer Win Player({0})", i)
                                                } Else.If dealervalue>playervalue And dealervalue<22 Then {
                                                     Print Format$("Dealer Win Player({0})", i)
                                                } Else.If dealervalue>21 Or dealervalue<playervalue Then {
                                                      Print Format$("Player({0}) Win Dealer", i)
                                                      .PlayerMoney+=Bet*2
                                                      DealerMoney-=Bet*2
                                                } Else {
                                                      Print Format$("Player({0}) keep bet for next time", i)
                                                       .PlayerMoney+=Bet
                                                      DealerMoney-=Bet
                                                }
                                                Print format$("Player({0}): {1}  Dealer: {2}", i, Val$(playervalue), Val$(dealervalue))
                                          }
                                    } Until Len(.OldPlayerValues)=0
                                    Refresh
                              }
                        }
                  }
                  Print "Press space to continue" : while Key$<>" " {}
            }
            Cls ,2
      }
} Always
Print "Dealer Money:", DealerMoney
Print "Press space to exit" : while Key$<>" " {}
Player 0
cls,0
Escape On
If module(info) then Keyboard "info"+chr$(13)
End
Sub Suffle()
      Layer 1 {
            Print
            Local N=Len(Pack())-1, N2, i, j, total=N*4+4, cur=1
            For j=1 To 4 {
                  For i=0 To N {
                        If cur Mod 4=3 Then Print Over format$("Suffle {0:0}%",cur/total*100)
                        N2=random(0, N)
                        While N2=i {N2=random(0, N)}
                        Swap Pack(i), Pack(N2)
                        cur++
                  }
            }
            AppendArray StackPack, Pack()
            Print
      }
End Sub
Sub DisplayAll()
      For k=0 To Len(Pack())-1 {
            PrintCard(k)
      }
End Sub
Sub PrintCard(k)
      For Pack(k) {
            Pen Suits(.suit!) {
                  Print Eval$(Suits, .suit)+Eval$(Cards, .card),
            }
       }
End Sub
Sub DealCard()
      Layer 1 {
            Print "PRESS A KEY TO DEAL CARD"
            If Key$="9" Then  Stack STACKPACK {Flush}
      }
End Sub
Sub NextCard()
          Rem :  DealCard()
            If Len(StackPack)=0 Then {
                  Suffle()
                  Stack StackPack {
                        Drop Random(0, 51)
                  }
            }
            Stack StackPack {
                  Read Card
            }
End Sub
Sub PlayerCard(&acc, MyCards)
      NextCard()
      PrintCardOnly Card, Suits, Cards
      acc+=Cards(Card.Card!)
      Append MyCards, len(MyCards):=Card
End Sub
Sub DealerCard(&acc, thisrowtoo=-1)
      NextCard()
      PrintCardOnly Card, Suits, Cards
      local oldrow=row
      If thisrowtoo>=0 Then
      cursor 0, thisrowtoo
      PrintCardOnly Card, Suits, Cards
      cursor 0, oldrow
      end If
      acc+=Cards(Card.Card!)
      Append DealerCards, len(DealerCards):=Card
End Sub
Sub PlayHand(MyCards, &acc, nomessage, sorryblackjack)
      ' Optional - We have to pass a ? If we have module or Sub
      Read ? MyMoney
      Local N2, morevalues=0, ok, Card=OneCard(), DoublingDown
      If MyCards(0!).card=12 Then morevalues=10
      Repeat {
            If Hidden.suit>=0 Then {
                  N2=Hidden.card
                  PrintCardOnly Hidden, Suits, Cards
                  Append MyCards, Len(MyCards):=Hidden
                  Hidden=OneCard()
            } Else {
                  NextCard()
                  If DoublingDown Then {
                        Print @(10), "Face Down Card"
                  } Else {
                        PrintCardOnly Card, Suits, Cards
                  }
                  N2=Card.Card
                  Append MyCards, Len(MyCards):=Card
            }
            If N2=12 Then {
                  If morevalues=0 Then {
                        morevalues=10
                  } Else N2=13 : morevalues=-50
            }
            If acc=10 And N2=12 And Len(MyCards)=2 Then acc=-1: Pen 15 {Print "BlackJack" }: Exit
            If morevalues>0 And Cards(if(N2<13 -> N2, 1)!)=10 And Len(MyCards)=2 Then acc=-1: pen 15 {Print "BlackJack" } : Exit
            If N2<=12 Then {
                  acc+=Cards(N2!)
            } Else acc+=11
            If acc>21 And Not DoublingDown Then Print "Busting" : Exit
            If acc=21 Then Exit
            If nomessage Then {
                  If sorryblackjack Then {
                              ok=acc>20 Or acc+morevalues=21
                  }  Else  ok=acc>16 Or (acc+morevalues<22 And acc+morevalues>16)
            } Else {
                  If DoublingDown Then ok=True : Exit
                  If Len(MyCards)=2 Then If acc=9 or acc=10 or acc=11 And acc+morevalues<>21 Then DoublingDown=true
                  If DoublingDown Then {
                        If MyMoney>=2*Bet Then {
                              Print "Doubling Down ?(Y/N)"
                              DoublingDown=Not Key$ ~ "[NnΝν]"
                        } Else DoublingDown=False
                  }
                  If DoublingDown Then {
                        ' get a card Face Down
                        Bet*=2
                        ok=false
                  } Else {
                        Print Part "Stand or Hit ?(S/H)"
                        ok=Key$ ~ "[SsΣσ]"
                  }
            }
      } Until ok
      If acc=-1 Then morevalues=0
      While morevalues>0 {
            If acc+morevalues<22 Then Exit
            morevalues-=10
      }
      If morevalues<0 Then Exit Sub
      acc+=morevalues
End Sub
Sub DealerBlackJack()
      Pen 15 {Print "BlackJack" }
      PrintCardOnly Card, Suits, Cards
      Print "Face Up Card"
      Print "Dealer Win All"
      Print "Press space to continue" : while Key$<>" " {}
      BlackJack=True
End Sub
Sub MakeLayer()
      Font "Arial"
      back {
            Cls #477148,0
            Local k=if( scale.x*4/3<scale.y->40, 60)
      }
      Form ! k, 30
      linespace twipsY*4
      Mode Mode*.8;
      
      Cls #477148,0    ' Poker Green Color
      cursor width/2, 2
      Move !   ' move graphic cursor to cursor
      myMode=Mode
      x1=scale.x/2
      y1=scale.y-pos.y
      y2=pos.y+motion.y
      x2=x1+motion.x
      player 0
      Layer 1 {
            window myMode, x1, y1
            motion x2,y2
            Cls #FFE4C4,0
            Pen 0
            show
            bold 1
            Print $(4)
      }
      Cursor 0,0

End Sub
}
MODULE JSON {Pen 15 {
      Report {
            Press any key or mouse button to continue the report
            
      }
      Wait 200
      Report {
            This is the module list. Look at the end of list. We have the new created modules/functions. These will be erased at the exit of the current modu.le.
            
      }
}
' Process data in json format

' we can load from external file with Inline "libName"
' or multiple files Inline "file1" && "file2"
' but here we have the library in a module
Inline Code Lib3
' So now we make a Parser object (a group type in M2000)
Parser=ParserClass()
' We can display any function, module that is public and known list
Modules ?
' And this are all known variables (or and objects)
List !
'exit
Document json$
' We can load from file
'Load.Doc json$, "alfa.json"
json$={{
      "zero": 0,
      "alfa":-0.11221e+12,
      "array" : [
            -0.67,
            "alfa1",
            [
                  10,
                  20 
            ],
            "beta1",
            1.21e12,
            [
            ],
            21.12145,
            "ok"
      ],
      "delta": false, "epsilon" : true, "Null Value" : null
}}
Save.Doc json$, "json2.json"    \\ by default in Utf-8 with BOM
' just show multiline text
' Report display lines and stop after 3/4 of console height lines
' just press a key or click mouse button
Report json$
' so now we get text to a new object
alfa=Parser.Eval(json$)
' check t
Print Type$(alfa)  ' it is a group
Print "alfa.type$=";alfa.type$  \\ this is a read only property

Report "as one line"
Report Parser.Ser$(alfa, 0)

Report "as multiline"
Report Parser.Ser$(alfa, 1)

Print "Using Print"
Print Parser.ReadAnyString$(alfa)

Print "Value for alfa, id alfa"
Print Parser.ReadAnyString$(alfa,"alfa")
Report "as multiline"
Report Parser.Ser$(Parser.Eval(Parser.ReadAnyString$(alfa,"array", 2)), 1)
' We get a copy of an array as a Group (a group which return an array)
Alfa3=Parser.Eval(Parser.ReadAnyString$(alfa,"array", 2))
' First value is for actual object, second value is a reafonly property of this object
Print type$(Alfa3),  Alfa3.type$
Dim B()
' Now Alfa3 run Value part and pass a pointer of array
' B()  is an array and here take a pointer to Alfa3 array (as value of Alfa3)
B()=Alfa3
' each() make an iterator for B()
N=each(B())
While N {
      \\ Using B() we get values always. but if we have "object" or "array" then Print prints items **
      Print B(N^)
}
' ** Print show here nothing because if value is object then "print" just leave a column and continue to next one
Print B()
' we have to use Group() to get group not value of group (if any).
' Group() works for "named" group, not for stored in an array or an inventory or a stack
Print Parser.StringValue$(Group(Alfa3),  0)
Print Parser.StringValue$(Group(Alfa3),  1)
' Now we want to pass a new value
' Interpreter want to match type of expression from left side to right side
' Because Parser.StringValue$ is actuall a Group (As property),
' we have a second linked name:  Parser.StringValue
' we have to use Parser.StringValue()
' and all values must be groups, as those provided by Parser
Parser.StringValue(Group(Alfa3),  1)=Parser.Numeric(1234)
Print Parser.StringValue$(Group(Alfa3),  1)
Print Parser.StringValue$(Group(Alfa), "array", 2, 0)
' we have to use Parser.StringValue$()
Parser.StringValue$(Group(Alfa), "array", 2, 0)=Parser.JString$("Changed to String")
Print Parser.StringValue$(Group(Alfa), "array", 2,0)
Try ok {
      Print Parser.StringValue$(Group(Alfa), "array", 2)
}
If  Error or not ok Then Print Error$
Parser.StringValue.Add = True
Parser.StringValue$(Group(Alfa), "array", 2, 10)=Parser.JString$("Changed to String 2")
Parser.StringValue(Group(Alfa), "Last value")=Parser.Boolean(true)
Report "as multiline"
Report Parser.Ser$(alfa3, 1)
Report Parser.Ser$(alfa, 1)
Parser.StringValue.Add = False
Parser.StringValue.Del = True
Parser.StringValue(Group(Alfa), "array", 0)=Parser.Null()
Parser.StringValue(Group(Alfa), "delta")=Parser.Null()
Parser.StringValue.Del = False
For Parser {
      .StringValue(Group(Alfa), "array", 1,5)=.Arr((.Numeric(10), .Jstring$("ok 20"), .Boolean(true)))
}
Report Parser.Ser$(alfa, 1)
}
MODULE LIB3 {      Class ParserClass {
      Private:
            Class bStream {
                  Private:
                  cnt, Buffer A
                  Public:
                  Value (&c) {Try { c=eval(.A, .cnt) : .cnt++:=true}}
                  Class:
                  Module final bStream (a$){
                        Buffer .A as Integer*Len(a$)
                        Return .A, 0:=a$           
                  }
            }
            Func=Lambda->false
            char=0
            ' using obj as pointer to  Stack 
            obj=Stack
            Function final IsId {
                  If .char=34 Then =.IsString(false)
            }
            Function final IsTrue {
                  ' U+0074 U+0072 U+0075 U+0065
                  If .char=0x74 Then If .func() Then If .char=0x72 Then If .func() Then If .char=0x75 Then If .func() Then If .char=0x65 Then PushIt() : =True
                  Sub PushIt()
                        Stack .obj {
                              Push .Boolean(True)
                        }
                  End Sub
            }
            Function final IsFalse {
                  ' U+0066 U+0061 U+006c U+0073 U+0065
                  If .char=0x66 Then If .func() Then If .char=0x61 Then If .func() Then If .char=0x6c Then If .func() Then If .char=0x73 Then If .func() Then If .char=0x65 Then PushIt() : =True
                  Sub PushIt()
                        Stack .obj {
                              Push .Boolean(False)
                        }
                  End Sub
            }
            Function final IsNull {
                  ' U+006E U+0075 U+006C U+006C
                  If .char=0x6e Then If .func() Then If  .char=0x75 Then If .func() Then If .char=0x6c Then If .func() Then If .char=0x6c Then PushIt() : =True
                  Sub PushIt()
                        Stack .obj {
                              Push .Null()
                        }
                  End Sub
            }
            Function final IsSemiCol {
                    If .char=0x3a Then =true 
            }
            Function final IsComma {
                    If .char=0x2c Then =true 
            }
            Function final IsObject {
                  If  .char=123 Else exit
                  inventory objinv
                 ' we push object with a pointer to objinv
                 Stack .obj { Push .Object(objinv)}
                 .Trim
                 While .IsId() 
                       .Trim
                       If  .IsSemiCol() Then
                             .Trim
                             If .IsValue() Then
                                   Stack .obj {
                                          Shift 2   ' move top as second
                                          ' letter$ is ok If top is string, and throw it
                                          Append objinv, Letter$:=Group
                                    }
                              End If
                       Else
                             Exit
                       End If
                       .Trim
                        If not .IsComma() Then exit
                       .Trim
                  End While
                  If .char=125 Then =true  Else .obj<=Stack : .func<=lambda->0 
            }
            Function final IsValue {
                  If .IsString(True) Then
                         =True    
                  Else.if .IsNumber() Then
                        =True
                  Else.if .IsTrue() Then
                        =True
                  Else.if .IsFalse() Then
                        =True
                  Else.if .IsNull() Then
                        =True
                  Else.if .IsArray() Then
                        =True
                  Else.if .IsObject() Then
                        =True
                  Else
                        ? "what", .char
                        Stack .obj { Stack}
                        .func<=lambda->0
                  End If
            }
            Function final Digits (private_stack){
                  While .func()
                        Select Case .char
                        Case 48 to 57
                        {
                              =true
                             Stack private_stack { Data .char}
                        }
                        Else Case
                             break
                        End Select
                  End While    
            }
            Function final IsNumber {
                  a=Stack
                  Select Case .char
                  Case 45 ' -
                  {
                              oldfunc=.func            
                              Stack a { Data .char}
                              If .Func() Then
                                    Select Case .char
                                    Case 48 
                                    {
                                            Stack a { Data .char}
                                            If  .func() Then
                                                If .char=46 Then
                                                      Fraction()
                                                      Exponent()
                                                End If
                                          End If
                                    }
                                    Case 49 to 57
                                    {
                                          Stack a { Data .char}
                                          If .Digits(a) Then {}
                                          Fraction()    
                                          Exponent()
                                    }
                                    Else Case
                                          a=stack
                                    End Select
                              End If
                  }
                  Case 48  ' 0
                  {
                        oldfunc=.func
                        Stack a { Data .char}
                        If  .func() Then
                            If .char=46 Then
                                  Fraction()
                                  Exponent()
                            End If
                      End If
                  }
                  Case 49 to 57
                  {
                              oldfunc=.func
                              Stack a { Data .char} 
                              If .Digits(a) Then {}
                              Fraction()
                              Exponent()
                  }
                  End Select
                  
                  If len(a)>0 Then {
                        b=each(a)
                        Document D$
                        While b
                              D$=chrcode$(StackItem(b))
                        End While
                        .func<=oldfunc
                        If len(D$)>1 Then For i=2 to len(D$) { .Trim}
                        Stack .obj { Push .Numeric(D$) }
                        =True
                  }
                  '  here is an auto exit from function. Sub as command is an exit
                  Sub Fraction()
                        If .char=46 Then Stack a { Data .char}
                        If .Digits(a) Then { }
                  End Sub
                  Sub Exponent()
                        If .char=101 or .char=61 Then
                              Stack a { Data .char}
                              If .func() Then
                                    If .char=43 or .char=45  Then
                                          Stack a { Data .char }
                                          If .Digits(a) Else
                                                a=Stack  ' cleat by point to new Stack
                                          End if
                                    Else.if  .char>47 and .char<58  Then
                                          Stack a { Data .char}
                                          If .Digits(a) Then {}
                                    Else 
                                           a=Stack
                                    End If
                              End If
                        End If
                  End Sub
            }
            Function final IsString (as_object){
            If .char=34 Else exit
                  Document D$
                  While  .func()
                        If .char=34 Then 2000
                        If .char=92 Then
                              ' special care
                              If .func() Then
                                    Select Case .Char
                                    Case 117 'u
                                    GetHex()
                                    Case 114 ' r
                                    .char<=0x0d
                                    Case 110 ' n
                                    .char<=0x0a
                                    Case 116 ' t
                                    .char<=0x09
                                    Case 98 ' b
                                    .char<=0x08
                                    Case 102 ' f
                                    .char<=0x0c
                                    Case 0x22, 0x2f , 0x5c 
                                    Else
                                    Exit   ' not normal
                                    End Select
                              End If
                        End If
                        D$=chrcode$(.char)
                  End While
                  Exit
      02000    Stack .obj { 
                        If as_object Then Push .JString$(D$) Else Push D$
                  } : =True 
                  Sub GetHex()
                        Local D$
                        Document D$="0x"
                        For i=1 to 4
                              If .func() Then End If
                                    If  Chrcode(.char) ~ "[0123456789ABCDEFabcdef]"  Then
                                          D$=Chrcode(.char)
                                    Else
                                          Goto 3000
                                   End If
                              End If
                        Next I
                        If i<>5 Then 3000
                        .Char=Eval(D$)
      03000    End Sub
            }
            Function final IsArray {
                
                  If  .char=91 Else exit
                  Dim Gr()
                  ' We place a pointer ro Array
                  .Trim
                  If .char=93 Then  =true : Stack .obj { Push .Arr(Gr())}  : exit
                        While .IsValue()
                              Stack .obj {
                                    Dim Gr(Len(Gr())+1)
                                    Gr(len(Gr())-1)=Group
                              }
                              .Trim
                              If not .IsComma() Then exit
                              .Trim
                        End While
                  ' Push later pointer to array (maybe altered in redimension)
                  If .char=93 Then  =true :  Stack .obj { Push .Arr(Gr())}  Else .Func<=lambda->false
            }
            Module final Trim  {
                  While  .func()
                         If  .char<33 or .char=160 Else exit      
                  End While
            }
            Function final  IsContainer {
                 .Trim
                 Select Case chrcode$(.char)
                 Case "{"
                        =.IsObject() 
                 Case "["
                        =.IsArray()
                 end select
            }
      ' merge a foreign group here
            Module final ReadArrayItem (temp, object){
                   Select Case temp.type$
                        Case "String","Boolean","Number", "Null"
                        {
                              If object Then Error "No object "+quote$(temp.type$)
                              Push temp.str$
                        }
                        Case "Object"
                        {
                              If not Empty Then
                                 Call .ReadObject temp, object, letter$
                              Else
                                    If object Then Push Temp : exit
                                    Push .ser$(group(temp),0)
                              End If
                        }
                        Case "Array"
                        {
                              If not Empty Then
                                    ' recursion only with Call statement for modules
                                    Call .ReadArrayItem, Array(temp, number), object
                              Else
                                    If object Then Push Temp : exit
                                    Push .ser$(group(temp),0)
                              End If
                        }
                        End Select
            }
            Module final ReadObject (json, object){
                  If type$(json)="Inventory" Then
                        If exist(json, Letter$) Then
                              temp=eval(json)
                        Else
                             push "none"
                             Break  ' exit Module final  (Break do something Else in Select End Select)
                        End If
                  Else
                        temp=json
                  End If
                        Select Case temp.type$
                        Case "String","Boolean","Number", "Null"
                        {
                              If object Then Error "No object "+quote$(temp.type$)
                              Push temp.str$
                        }
                        Case "Object"
                        {
                              If not Empty Then
                                    Call .ReadObject temp, object ', letter$
                              Else
                                    If object Then Push Temp : exit                              
                                    Push .ser$(group(temp),0)
                              End If
                        }
                        Case "Array"
                        {
                              If not Empty Then
                                    Call .ReadArrayItem array(temp, number), object
                              Else
                                    If object Then Push Temp : exit
                                    Push .ser$(group(temp),0)
                              End If
                        }
                        End Select
            }
            Module final Worker (object){                        
                         If match("IN") Or match("IS") Then   ' inventory & number or inventory and string
                         '    maybe we have more items in Stack
                               Push object : ShiftBack 2
                              .ReadObject
                         Else
                              read Temp  ' get  a group which returns Iventoty or an mArray
                              If Type$(Temp)="mArray" Then
                                    If not Empty Then
                                          Call .ReadArrayItem, Array(Temp, number), object
                                    Else
                                          If object Then Push Temp : exit
                                          Push .ser$(Temp,0)
                                    End If
                              Else
                                    If not Empty Then
                                                Call .ReadObject Temp, object
                                    Else
                                          If not Empty Then
                                                Call .ReadObject Temp, object
                                          Else
                                                If object Then Push Temp : exit
                                                If Type$(Temp)="Inventory" Then
                                                      Push .ser$(.Object(Temp),0)
                                                Else
                                                      Push .ser$(group(Temp),0)
                                                End If
                                          End if
                                   End If
                              End If
                        End If
            }
      Public:
      \\ This is the Public part
      \\ First we set Public some class for later use
      \\ Using Pointer to Array in Class Arr
            Class Arr {
            Private:
                  MyValue
            Public:
                  Property Type$ {Value} ="Array"
                  Value {
                        =.MyValue
                  }
            Class:
                  Module final Arr (.MyValue) {}
            }
            Class Null {
                 Property Type$ {Value} ="Null"
                 Property Str$ {Value}="null"
                 Value { =0}
            }
            Class JString$ {
            Private:
                  MyValue$=""
            Public:
                  Property Type$ {Value} ="String"
                  Property Str$ {
                        Value{
                              Link parent MyValue$ to MyValue$
                              value$=quote$(string$(MyValue$ as json))
                        }
                  }
                  Value {
                        =.MyValue$
                  }
            Class:
                  Module final JString (.MyValue$) {}
            }
            Class Numeric {
            Private:
                  MyValue$=""
            Public:
                  Property Type$ {Value} ="Number"
                  Property Str$ {
                        Value{
                              Link parent MyValue$ to MyValue$
                              value$=MyValue$
                        }
                  }
                  Value {
                        =Val(.MyValue$)
                  }
            Class:
                  Module final Numeric {
                  If match("S") Then
                        Read .MyValue$
                  Else
                        value$=trim$(str$(Number))
                        ' M2000 return -.3 for -0.35
                        ' using ? str$(MyValue, "0.#############")
                        ' we get locale decimal char - maybe is comma
                        ' so using str$(MyValue) we get integer or float with char "." for decimal always
                        ' so we have to add 0
                        If left$(value$, 1)="." Then
                              value$="0"+value$
                        Else
                               If  value$ ~ "-.*" Then value$=replace$("-.","-0.", value$)
                         End If
                        .Myvalue$<=value$
                  End If
                  }
            }
            Class Boolean {
            Private:
                  MyValue=false
            Public:
                  Property Type$ {Value} ="Boolean"
                  Property Str$ {
                        Value{
                              Link parent MyValue to MyValue
                              If MyValue Then {
                                    value$="true"
                              } Else value$="false"
                        }
                  }
                  Value {
                        =.MyValue
                  }
            Class:
                  Module final Boolean (.MyValue) {}
            }
            Class Object {
            Private:
                  Inventory MyValue
            Public:
                  Property Type$ {Value} ="Object"
                  Value {
                        =.MyValue
                  }
            Class:
                  Module final Object (.MyValue) {}
            }
      \\ Empty group, with $, so we get two vars, Ser and Ser$ ( Ser$ we want to return a value type String)
            Group Ser$
            Module final SetSpace (.ser.space) { ' set space for values - 6 by default
            }
            Function final UseDecimalPoint$ {
                  ' use this to change standard decimal point to local decimal point character
                  =str$(val(letter$),"")
            }
            Function final ReadNumber$ {
                        .Worker false   'modules get caller Stack
                        =.UseDecimalPoint$( Letter$)
            }           
            Function final ReadAnyString$ {
                        \\ read an inventory
                        .Worker false
                        =Letter$
            }
            Function final ReadAny {
                        \\ read an inventory
                        .Worker true
                        Read A
                        =A
            }
            Function final Eval {
                  ' Letter$  pop a string ftom Stack Else give error
                   .func<=Lambda z=.bStream(Letter$) -> {
                         link .char to c
                         ' we can't pass reference in a private member
                         =z(&c)
                   }
                  ' In this Parser we use a dedicated Stack
                  ' for use from recuirsive memberts
                  ' .obj is a pointer to Stack
                  ' we can delete it simply setting a new Stack
                  ' .obj<=Stack 
                  ' or we can flush all elements Using a command Flush
                  ' .obj,  char and .func() are visible from group members
                  ' test
                  Stack .obj { Flush}
                  .char<=0
                  If   .IsContainer()  Then
                        ' we get the pointer
                        =StackItem(.obj)
                        .obj<=Stack
                  Else
                        ' return an Empty object
                        inventory emptinv
                        =.Object(emptinv)
                  End If
            }
            Group StringValue$ {
                  Add=false
                  Del=false
                  ' from revision 12 we can place temp in parameter block
                  Set (temp) {
                        ' always first read is for the assigned value to Group
                        Read temp1
                        If type$(temp)<>"Group" Then error "Need a group"
                        If not valid(temp.type$="") Then error "not a proper group"
                        If not valid(temp1.type$="") Then error "not a proper group for value"
                        ' because Null() is out of this scope we have to link
                        Link parent Null() to MyNull()
                        Null=MyNull()
                        ' or we can hard code the Null object
'                        Group Null {
'                                  Property Type$ {Value} ="Null"
'                                  Property Str$ {Value}="null"
'                                  Value { =0}
'                       }
                        Dim Base 1, A(1)
                        \\ now we get the second interface for arrays
                        \\ bb() has a reference to b (one reference allowed)
                        \\ but b is pointer to array and can change to point to other arrrays
                        \\ we need ths to perform some tasks which belong to standard arrray interface
                        b=(,) : Link b to bb()  
                        A(1)=Group(temp)
                        Do
                              again=false
                              Select Case A(1).type$
                              Case "Array"
                              {
                                    If match("N") Then
                                          Read where
                                          If len(A(1))<=where and Empty Then
                                          ' only the last array we can redimension
                                                If .add and not .del Then
                                                      cursize=Len(A(1))
                                                      b=A(1) ' A(1) has a pointer so now b has the same pointer
                                                      ' dim preserve values
                                                      Dim bb(where+1)  ' need one more because all "automatic arrays" have base 0
                                                      Stock bb(cursize) sweep Len(b)-cursize, Group(Null)
                                                Else
                                                      Error "Index out of limits"+str$(where)
                                                End If
                                          Else
                                                If where<0 Then Error "Index out of limits "+str$(where)
                                          End If
                                          If Empty Then
                                                If .del Then
                                                      cursize=Len(A(1))
                                                      b=A(1) ' A(1) has a pointer so now b has the same pointer
                                                      If where<cursize-1 Then
                                                            Stock bb(where+1) Keep cursize-where, bb(where)
                                                      End If
                                                      Dim bb(cursize-1)   ' bb(0) is an empty array
                                                Else
                                                      Return A(1), where:=Group(temp1)
                                                End If
                                          Else
                                                A(1)=Array(A(1),where)
                                                again=True
                                          End If
                                    Else
                                          Error "No Index Found"
                                    End If
                              }
                              Case "Object"
                              {
                                    If match("S") Then
                                          Read k$
                                          If Exist(A(1), k$)   Then
                                                If Empty Then
                                                      If .del Then
                                                           Delete A(1) , k$
                                                      Else
                                                            Return A(1), k$:=Group(temp1)
                                                      End If
                                                Else
                                                      A(1)=Eval(A(1))  ' Eval(inventory_pointer) return  object pointer
                                                      again=True
                                                End If
                                        Else.if .add and not .del Then
                                                 If Empty Then
                                                            Append A(1), k$:=Group(temp1)
                                                Else
                                                      Error "No such Tag "+k$
                                                End If
                                         Else
                                               Error "No such Tag "+k$
                                         End If
                                    Else
                                          Error "No Tag Found"
                                    End If
                              }
                              End Select
                         until not again
                  }
                  Value (temp) {
                        If type$(temp)<>"Group" Then error "Need a group"
                        If not valid(temp.type$="") Then error "not a proper group"
                        Dim Base 1, A(1)
                        A(1)=Group(temp)
                        Do
                              again=false
                              Select Case A(1).type$ 
                              Case "String", "Number", "Null", "Boolean"
                                    Exit
                              Case "Array"
                              {
                                    If match("N") Then
                                          A(1)=Array(A(1), Number)
                                    Else
                                          Error "No Index Found"
                                    End If
                                    again=True
                              }
                              Case "Object"
                              {
                                    If match("S") Then
                                          If Exist(A(1), Letter$)   Then
                                                A(1)=Eval(A(1))  ' Eval(inventory_pointer) return  object pointer
                                          Else
                                                Error "No such Tag"
                                          End If
                                    Else
                                          Error "No Tag Found"
                                     End If     
                                    again=True
                              }
                              End Select
                        until not again
                         =A(1).str$
                  }
            }
      Class:
      \ one time definitions
            Class CreatSerialize$ {
            Private:
                  usen=0
                  n=0
                  nl1$={
                  }
                  Function final Jarray$ (json1, n){
                        \\ json1 is group type Array
                                 A=json1
                              \\ A is mArray (pointer to Array)
                              nl$=.nl1$
                              If .usen>0 Then
                                    nl$=nl$+string$(" ",  n+.space)
                              End If
                              document a$
                              a$="["
                              If Len(A)>0 Then
                                    If .usen>0 Then a$=nl$
                                     k=each(A)
                                     M=len(A)-1
                                     while k
                                          For This {
                                                \\ temporary group
                                                Temp=array(k)
                                                select Case temp.type$
                                                Case "Number", "Null","Boolean", "String"
                                                a$=temp.str$
                                                Case "Array"
                                                {
                                                      nn=0
                                                      If .usen>0 Then
                                                            nn=n +.space
                                                      End If
                                                      a$=.Jarray$(Temp, nn, "")
                                                }
                                                Case "Object"
                                                {
                                                     nn=0
                                                      If .usen>0 Then
                                                            nn=n +.space
                                                      End If
                                                      a$=.Jobject$(Temp, nn,"")
                                                }
                                                Else Case
                                                      a$=" "+temp.type$
                                                end select
                                                 If k^<M Then
                                                     a$=", "
                                                      If .usen>0 Then a$=nl$
                                                Else
                                                      If .usen>0 Then a$=.nl1$
                                                End If
                                          }
                                    End While
                               Else
                                     If .usen>0 Then  a$=.nl1$
                               End If
                               If .usen>0 Then a$=string$(" ", n)
                        a$="]"
                           =a$+letter$
                  }
                  Function final Jobject$ (json1, n){
                                    json=json1
                                    \\ json has to be an object inventory
                                    nl$=.nl1$
                                    If .usen>0 Then
                                          nl$=nl$+string$(" ",  n+.space)
                                    End If
                                    document a$
                                    a$="{"
                                    If .usen>0 Then a$=nl$
                                     k=each(json)
                                     M=len(json)-1
                                     while k
                                          a$=quote$(eval$(json, k^)) +" : "
                                          select Case json(k^!).type$
                                          Case "Array"
                                          {
                                                nn=0
                                                If .usen>0 Then
                                                      nn=n +.space
                                                End If
                                                a$=.Jarray$(eval(k), nn, "")
                                          }
                                          Case  "Boolean", "Null", "Number", "String"
                                                a$=json(k^!).str$
                                          Case "Object"
                                          {
                                                nn=0
                                                If .usen>0 Then
                                                      nn=n +.space
                                                End If
                                                a$=.Jobject$(eval(k), nn, "")
                                          }
                                          Else Case
                                                a$=" "+json( k^!).type$
                                          end select
                                          If k^<M Then
                                               a$=", "
                                                If .usen>0 Then a$=nl$
                                          Else
                                                If .usen>0 Then a$=.nl1$
                                          End If
                                    End While
                               If .usen>0 Then a$=string$(" ", n)
                              a$="}"
                              =a$+letter$
                  }
                  Class Object {
                  Private:
                        Inventory MyValue
                  Public:
                        Property Type$ {Value} ="Object"
                        Value {
                              =.MyValue
                        }
                  Class:
                        Module final Object (.MyValue) {}
                  }
            Public:
                  space=10
                  Value (json, n) {
                              a$=.nl1$
                              b$=""
                              .usen<=n
                              n--
                              If n<=0 Then  a$="" : n=0 Else b$=string$(" ", n)
                              If type$(json)<>"Group" Then
                                    If type$(json)="Inventory" Then
                                          =b$+.Jobject$(.Object(json),n, a$)
                                    Else.if type$(json)="mArray" Then
                                          =b$+.Jarray$(json, n, a$)
                                    End If
                              Else
                                    If json.type$="Object" Then
                                          =b$+.Jobject$(json, n,a$)
                                    Else.if json.type$="Array" Then
                                          =b$+.Jarray$(json, n, a$)
                                    End If
                              End If
                  }
            }
            Module final ParserClass {
                  \ constructor
                  \ Let work as Push .CreatSerialize$() : Read .Ser
                  \ So now Group Ser loaded from CreatSerialize$()
                  \ Class CreatSerialize$ is a Function final, and because it is after Class:
                  \ Deleted before ParserClass return Group
                  Let .Ser=.CreatSerialize$()
            }
      }
}
MODULE R2 {\\ we can change mid$(), only for this sub
\\ integer has value 3 (as a M2000 read only value)
\\ also control$ is a string read only value
function mid$(a$, x) {
	=string$(a$, x)
}
Module Inside {
	Print mid$("aaa",2), "from inside module"
}
see_work()
inside
print mid$("aaa",2), integer, control$="MAIN"

sub see_work()
	Local integer=10, control$="Hello"
	\\ we can redifine functions, but using New, we make a new one, without erasing an other
	\\ if you change new with global you get error because mid$() defined as local in this module
	\\ so a local function has priority over a global one
	\\ We get error because the local one expect string first, not a number
	function new mid$(x) {
		read x
		=str$(x,"0.00")
	}
	'inside
	Print mid$(10), integer, control$
end sub
}
MODULE FL {\\ Slow,  Fast and Fast !
\\ Normal is Fast
Smooth off
Set Fast !
Rem Try To unhide this line : Test "flowers"
N=Random(!123567)
N=7
Dim Px(N+1), Py(N+1), Pz(N+1)
For i=1 To N {      \\ x.twips and y.twips are the resolution of the displayed form in twips.
      Px(i)=random(50,1100)*15
      Py(i)=random(50, 800)*15
      Pz(i)=random(2,6)*500
}
Dim Dx(100),Dy(100)
For i=0 To 99 {
      Dx(i)=COS(i*36)*150
      Dy(i)=SIN(I*27)*150
}
Let mx=Mouse.X, my=Mouse.Y
Let kk=Pi/5, kkk=kk, mx1=mx, my1=my, nnn=100, m=0
Refresh 1000
Cls #1155AA, 0
j=0
Repeat {
      Cls
      j++
      nnn= nnn Mod 64
      For i=1 To N {      \\ x.twips and y.twips are the resolution of the displayed form in twips.
            Px(i)+=Dx((j+3*i) Mod 100) +mx1-mx
            Py(i)+=Dy((j+i) Mod 100) +my1-my
            Let mx1=mx, my1=my
            Move Px(i),Py(i)
            Width 5 {    \\ setting line width
                  Pen #AA6600  {  \\using colors like html hex values
                        nnn+=kk    
                       kkk=Pi-nnn/Pi
                       For q=Pi/8 To 2*Pi-Pi/8 Step Pi/4 {
                              Move Px(i), Py(i)
                              Path #FF66FF, abs(m) { curve angle Pi/3+q-kkk, Pz(i)/6,Pi/4+q-kkk,Pz(i),Pi+q-kkk,Pz(i)*2/3 }
                        }
                        Move Px(i),Py(i)
                        Circle Fill #FFAA20, Pz(i)/3
                  }
            }
            m=Keypress(1)
            If m then {
                  px(i)=Mouse.X
                  py(i)=Mouse.Y
            }
            mx=Mouse.X
            my=Mouse.Y
      }
      Refresh 1000
 }  Until Keypress(2)

Hold   \\ save screen to memory
Move Scale.X/2, Scale.Y/2
def speed(i)=1.45*i
i=8
While i<120 {
      Legend  "Game Over","ARIAL BLACK", speed(i), i/180,2,0
      Refresh 1000
      Wait 30
      release  \\ copy from memory
      i*=1.05
}
SET FAST
CLS
}
MODULE FB {Cls , 0
Report {
	Fibonacci sequence
	
	The Fibonacci sequence is a sequence   Fn   of natural numbers defined recursively: 
				F0 = 0 
				F1 = 1 
				Fn = Fn-1 + Fn-2, if n>1 

	We use a BigNum class to get the first 2000 Fibonacci numbers.

}
Cls, row
Class BigNum {
      a=stack
      Function Digits {
            =len(.a)*14-(14-len(str$(stackitem(.a,len(.a)) ,"")))
      }
      Operator "+" (n) {
            \\ we get a copy, but .a is pointer
             \\ we make a copy, and get a new pointer
            .a<=stack(.a)
           
            acc=0
            carry=0
            const d=100000000000000@
                  k=min.data(Len(.a), len(n.a))
                  i=each(.a, 1,k )
                  j=each(n.a, 1,k)
                  while  i, j {
                        acc=stackitem(i)+stackitem(j)+carry
                        carry= acc div d
                        return .a, i^+1:=acc mod d
                  } 
                  if len(.a)<len(n.a) Then  {
                        i=each(n.a, k+1, -1)
                        while i {
                              acc=stackitem(i)+carry
                              carry= acc div d
                              stack .a  {data acc mod d}
                        }
                  } ELse.if len(.a)>len(n.a) Then  {
                        i=each(.a, k+1, -1)
                        while i {
                              acc=stackitem(i)+carry
                              carry= acc div d
                              Return .a, i^+1:=acc mod d
                              if carry else exit
                        }     
                  }
                  if carry then stack .a { data carry}
      }
      Function tostring$ {
            if len(.a)=0 then ="0" : Exit
            if len(.a)=1 then =str$(Stackitem(.a),"") : Exit
            document buf$=str$(Stackitem(.a, len(.a)),"")
            for i=len(.a)-1 to  1 {
                  Stack .a {
                        buf$=str$(StackItem(i), "00000000000000")
                  }
            }
            =buf$
      }
      class:
      Module BigNum (s$) {
            s$=filter$(s$,"+-.,")
            if s$<>""  Then {
                  repeat {
                        If len(s$)<14 then Stack .a { Data  val(s$) }: Exit
                        Stack .a { Data  val(Right$(s$, 14)) }
                        S$=Left$(S$, len(S$)-14)
                  } Until S$=""
            }
      }
} 

Inventory K=0:=BigNum("0"),1:=BigNum("1")
fib=Lambda K (x as decimal)-> {
      If Exist(K, x) Then =Eval(K) :Exit
      Ret=If(x>1->Lambda(x-1)+Lambda(x-2), bignum(str$(x,"")))
      Append K, x:=Ret
      =Ret
}
Set Fast!
For i=1 to 2000 {
      N=Fib(i)
      Print i
      Print N.tostring$()
      Refresh
}
Set Fast
}
MODULE BN {Dim Mod$(0 to 99), Mul(0 to 9,0 to 9)
for j=0 to 9 : For i=0 to 9:Mod$(i+j*10)=str$(i mod 10,0): Mul(i,j)=i*j : Next i :Next j
profiler
a$="1231231231231231231231231231232132131213130989802139080120931920389"
\\ a$ x n
n1$="1234567767765675576765234324243122131213122113123120898031238910823"
Print val(n1$)*val(a$)
k=0
acc=0
a$=strrev$(a$)
inventory num
rev3$=""
n1=len(n1$)
while n1>0 
n=val(mid$(n1$,n1,1))
n1--
rev2$=string$("0", k)
rev1$=""
k++

if n>0 then
      if not exist(num, n) then
      digit=0&
      For i=1 to len(a$)
      digit+=n*val(mid$(a$,i,1))
      rev1$+=str$(digit mod 10,0)
      digit/=10&
      Next i
      if digit then rev1$+=str$(digit mod 10,0)
            Append num, n:=rev1$
      else
            rev1$=num$(n)
      End if
      rev2$+=rev1$
      if len(rev3$)=0 then
            swap rev2$, rev3$
      else
            swap rev1$, rev3$
            rev3$=""
            if rev2$<rev1$ then swap rev1$, rev2$
            digit=0
            For i=1 to len(rev1$)
            digit+=val(mid$(rev1$, i, 1))+val(mid$(rev2$, i, 1))
            rev3$+=str$(digit mod 10,0)
            digit/=10&
            next i
            if digit>0 then rev3$+=str$(digit mod 10,0)
      end  if
      End if
End While
Print strrev$(rev3$)
print timecount
}
MODULE DI {inline code libdiv
op=Pen
Def ExpStr$(x)= str$(X,"0.00000000000000E-00")
\\ using old style subs - no local variables
a$="57645834674367349573945793457359374512154545412313137868768787874738942834756234896582946937658926582565"
b$="3224241711"
Gosub calc
a$="1"
b$="3224241711"
Gosub calc
a$="23200"
b$="58"
Gosub calc
a$="1"
b$="58"
Gosub calc
a$="1"
b$="3"
Gosub calc
a$="100"
b$="30"
Gosub calc2
Gosub calc
a$="57645834674367349573945793457359374512154545412313137868768787874738942834756234896582946937658926582565"
b$="5235"
Gosub calc2
b$="17"
Gosub calc2
Gosub calc
end

calc:
      Print
      Pen 11 {
            Print "Calculation for ";
      }
      Print a$;~(12);"/";~(op);b$
      Print ExpStr$(val(a$)/val(b$))
      Print
      Print "Expanded:", ProDiv$(a$, b$, 100)
Return
calc2:
      Print
      Pen 11 {
            Print "Calculation for ";
      }
      Print a$;~(13);" div ";~(op);b$
      Print val(a$) div val(b$)
      Print
      Print "Expanded:", ProDiv$(a$, b$,0)
Return
}
MODULE HU {Module Huffman {
      comp=lambda (a, b) ->{
            =array(a, 0)<array(b, 0)
      }
      module InsertPQ (a, n, &comp) {
            if len(a)=0 then stack a {data n} : exit
            if comp(n, stackitem(a)) then stack a {push n} : exit
             stack a {
                  push n
                  t=2: b=len(a)
                   m=b
                   While t<=b {
                         t1=m
                        m=(b+t) div 2
                        if m=0 then  m=t1 : exit 
                        If comp(stackitem(m),n) then t=m+1:  continue
                        b=m-1
                        m=b
                  }
                  if m>1 then shiftback m
            }
      }
 
      a$="this is an example for huffman encoding"
 
      inventory queue freq
      For i=1 to len(a$)   {
            b$=mid$(a$,i,1)
            if exist(freq, b$) then Return freq, b$:=freq(b$)+1 : continue
            append freq, b$:=1
      }
      sort ascending freq
      b=stack
      K=each(freq)
      LenA=len(a$)
      While k {
            InsertPQ b, (Round(Eval(k)/lenA, 4), eval$(k, k^)), &comp
      }
      While len(b)>1 {
            Stack b {
                 Read m1, m2
                 InsertPQ b, (Array(m1)+Array(m2), (m1, m2) ), &comp
            }
      }
      Print  "Size of stack object (has only the Root):"; len(b)
      Print "Root probability:";Round(Array(Stackitem(b)), 3)
      inventory encode, decode
 
      Traverse(stackitem(b), "")
      message$=""
      For i=1 to len(a$)
      message$+=encode$(mid$(a$, i, 1))
      Next i
 
      Print  message$
      j=1
      check$=""
      For i=1 to len(a$)
            d=each(encode, -1,1)  ' from last to first - works  d=each(encode)  from start
            While d {
                  code$=eval$(d)
                  if mid$(message$, j, len(code$))=code$ then {
                        check$+=decode$(code$)
                        Print decode$(code$); : j+=len(code$)
                  }
            }
      Next i
      Print
      Print len(message$);" bits ", if$(a$=check$->"Encoding/decoding done", "Encoding/Decoding failed")
 
 
      Sub Traverse(a, a$)
            local b=array(a,1)      
            if type$(b)="mArray"  Else {
                  Print  @(10); quote$(array$(a, 1));" "; a$,@(20),array(a)
                  Append decode, a$ :=array$(a, 1)
                  Append encode, array$(a, 1):=a$
                  Exit Sub   
            }
            traverse(array(b), a$+"0")
            traverse(array(b,1), a$+"1")
      End Sub
}
Huffman
 
}
MODULE RE {Module CheckIt {
      declare global ObjRegEx "VBscript.RegExp"
      Function RegEx.Replace$(from$, what$) {
            Method ObjRegEx, "Replace", from$, what$ as response$
            =response$
      }
      Function RegEx.Test(what$) {
            Method ObjRegEx, "Test", what$ as response
            =response
      }
      Print Type$(ObjRegEx)
      With ObjRegEx, "Global", True, "Pattern" as pattern$
      pattern$="Mona Lisa"
      Print RegEx.Test("The Mona Lisa is in the Louvre.")=true
      Print RegEx.Replace$("The Mona Lisa is in the Louvre.", "La Gioconda")
      Pattern$ = " {2,}"
      Print "Myer Ken,  Vice President,  Sales and Services"
      \\ Removing some spaces
      Print RegEx.Replace$("Myer Ken,  Vice President,  Sales and Services", " ")
      pattern$="(\d{3})-(\d{3})-(\d{4})"
 
      Method ObjRegEx, "Execute", "555-123-4567, 555-943-6717" as MyMatches
      Print Type$(MyMatches)  ' it is a IMatchCollection2
      With MyMatches, "Count" as count, "Item" as List$()
      For i=0 to Count-1 : Print List$(i) : Next i
 
 
      Print RegEx.Replace$("555-123-4567, 555-943-6717", "($1) $2-$3")
      Pattern$ = "(\S+), (\S+)"
      Print RegEx.Replace$("Myer, Ken", "$2 $1")
      Method ObjRegEx, "Execute", "Myer, Ken" as MyMatches
      Rem : DisplayFunctions(MyMatches)
      \\ we can use Enumerator
      Print "Using _NewEnum"
      With MyMatches, "_NewEnum" as New Matches
      Rem : DisplayFunctions(Matches)
      With Matches, "Value" as New item$
      While Matches {
           Print Item$
      }
      \\ Or just using the list$()
      Print "Using Count and Item properties"
      For i=0 to Count-1 : Print List$(i) : Next i
      declare ObjRegEx Nothing
      End
      Sub DisplayFunctions(x)
            Local cc=param(x),  ec=each(cc)
            while ec {
                  Print eval$(ec)   ' print every function/property of object x
            }
      End Sub
}
Checkit
}
MODULE RE1 {Module Internal {
      what$="Mona Lisa"
      Document a$="The Mona Lisa is in the Louvre."
      Find a$, what$
      Read FindWhere
      If FindWhere<>0 then Read parNo, parlocation
      \\ replace in place
      Insert  FindWhere, Len(what$)  a$="La Gioconda"
      Report a$
 
      n$="The Mona Lisa is in the Louvre, not the Mona Lisa"
      Report Replace$("Mona Lisa", "La Gioconda", n$, 1, 1)  ' replace from start only one
      dim a$()
      a$()=Piece$("Myer, Ken",", ")
      Print a$(1)+", "+a$(0)="Ken, Myer"
}
Internal
}
MODULE RO {Module RankLanguages {
      Const Part1$="<a href="+""""+ "/wiki/Category", Part2$="member"
      Const langHttp$="http://rosettacode.org/wiki/Category:Programming_Languages"
      Const categoriesHttp$="http://www.rosettacode.org/mw/index.php?title=Special:Categories&limit=5000"
      Def long m, i,j, tasks, counter, limit, T, t1
      Def string LastLang$, job$
 
      Document final$, languages$, categories$
      httpGet$=lambda$  (url$, timeout=1000)->{
            Declare htmldoc "Msxml2.ServerXMLHTTP"
            With htmldoc , "readyState" as ready
            Report "Download:"+url$
            Method htmldoc "open","get", url$, True
            Method htmldoc "send"
            Profiler
            While Ready<>4 {
                  Wait 20
                  Print Over format$("Wait: {0:3} sec", timecount/1000)
                  If timecount>timeout then Exit
            }
            If ready=4 Then  With  htmldoc, "responseText" as ready$ : =ready$
            Declare htmldoc Nothing
            print
      }
 
      languages$=httpGet$(langHttp$, 30000)
      If Doc.Len(languages$)=0 then  Error "File download failed (languages)"
 
      Inventory Lang
 
      m=Paragraph(languages$, 0) 
      If Forward(languages$,m) then {
            While m {
                  job$=Paragraph$(languages$,(m))
                  If Instr(job$, part1$) Else Continue
                  i = Instr(job$, "</a>")
                  If i Else Continue   ' same as If i=0 Then Continue
                  j = i
                   i=Rinstr(job$, ">", -i)
                  If i Else Continue
                  LastLang$=MID$(job$, i+1, j-i-1)
                  if Instr(job$, "Category:"+lastlang$) then Append lang, lastlang$:=0  :  Print Over format$("Languages: {0}", len(lang))
            }
      }
      Print
      Document categories$=httpGet$(categoriesHttp$, 30000)
      If Doc.Len(categories$)=0 then  Error "File download failed (categories)"
      limit=Doc.Par(categories$)
      If limit<Len(Lang) then Error "Invalid data"
      Refresh
      set slow
      m=Paragraph(categories$, 0) 
      counter=0
      If Forward(categories$,m) then {
            While m {
                  job$=Paragraph$(categories$,(m))
                  counter++
                  Print Over format$("{0:2:-6}%", counter/limit*100)
                  i=Instr(job$, part2$) 
                  If  i Else Continue          
                  i=Rinstr(job$, "(", -i)
                  If  i Else Continue
                  tasks=Val(Filter$(Mid$(job$, i+1),","))
                  If tasks Else Continue
                  i=Rinstr(job$, "<", -i)
                  If i Else Continue
                  j = i
                  i=Rinstr(job$, ">", -i)
                  If i Else Continue
                  LastLang$=MID$(job$, i+1, j-i-1)
                  If Exist(Lang, LastLang$) Then {
                         Return Lang, LastLang$:=Lang(LastLang$)+tasks
                  }
            }
      }
      Print
      \\ this type of iventory can get same keys
      \\ also has stable sort
      Report "Make Inventory list by Task"
      Inventory queue ByTask
      t1=Len(Lang)
      T=Each(Lang)
      While T {
            Append ByTask, Eval(T):=Eval$(T!)
            Print Over format$("Complete: {0} of {1}", T^+1, t1 )
      }
      Print
      Report "Sort by task (stable sort, sort keys as numbers)"
      Sort descending ByTask as number
      Report "Make List"
      T=Each(ByTask)
      final$="Sample output on "+Date$(Today, 1033, "long date")+{:
 
      }
      While T {
            final$=format$("rank:{0::-4}. {1:-5} entries - {2}", T^+1, Eval$(T!), Eval$(T))+{
            }
      }
      Report "Copy to Clipboard"
      clipboard final$
      \\ present to console with 3/4 fill lines then stop for space bar or mouse click to continue
      Report final$     
}
RankLanguages
}
MODULE CE {a$="THIS IS MY TEXT TO ENCODE WITH CAESAR CIPHER"
Function Cipher$(a$, N) {
      If Len(a$)=0 Then Exit
      a$=Ucase$(a$)
      N=N mod 25 +1
      \\ Integer in Mem is unsigned number
      Buffer Mem as Integer*Len(a$)
      Return Mem, 0:=a$
      For i=0 to Len(a$)-1 {
            If Eval(mem, i)>=65 and Eval(mem, i)<=90 then Return Mem, i:=(Eval(mem, i)-65+N) mod 26+65
       }
       =Eval$(Mem)
}
B$=Cipher$(a$, 12)
Print B$
Print Cipher$(B$,12)
}
MODULE CO {Module Check {
      \\ we use an internal object for Math functions (here for Atan2)
      Declare Math Math
      Const tau=2*Pi, Center=2
      \\ change console size,  and center it ( using ;) to current monitor      
      Window 12, 800*twipsX,600*twipsY;
      \\ actual size maybe less (so can fit text exactly)
      Double  ' Double height characters
      Report Center, "Color wheel"
      Normal  ' restore to normal
      Atan2=Lambda Math (a, b) ->{
            Method Math, "Atan2", a, b As ret
            =ret
      }
      \\ brightness=1 for this program
      hsb2rgb=Lambda (hue, sat) ->{
            If sat == 0 Then {
                = 255, 255, 255
           } Else {
                  h=frac(hue+1)*6
                  f = frac(h)  
                  p = Int((1-sat)*255 + 0.5)
                  q = Int((1-sat*f)*255 + 0.5)
                  t = Int((1-sat*(1-f))*255 + 0.5)
                  Select Case Int(h)
                  Case 1
                      = q, 255, p
                  Case 2
                      = p, 255, t
                  Case 3
                     = p, q, 255
                  Case 4
                      = t, p, 255
                  Case 5
                      = 255, p, q
                  Else Case
                      = 255, t, p
                  End Select
          }
      }
      Let OffsetX=X.twips/2-128*TwipsX, OffsetY=Y.twips/2-128*TwipsY
      \\ a pixel has a size of TwipsX x TwipsY
      OffsetX=(OffsetX div TwipsX)*TwipsX
      OffsetY=(OffsetY div TwipsY)*TwipsY
      \\ We set hsb2rgb, OffsetX, OffsetY as closures to PrintPixel
      \\ We send to stack the R G B values using Stack ! array
      \\ hsb2rgb() return an array of values
      \\ we pop these values using Number
      PrintPixel = Lambda  hsb2rgb, OffsetX, OffsetY (x,y, theta, sat)  -> {
            Stack ! hsb2rgb(theta,sat)  
            PSet Color(number, number, number), x*TwipsX+offsetX, y*TwipsY+offsetY
      }
      \\ set Atan2, tau as closures to HueCircle
      \\ we can rotate/flip the wheel by changing signs in Atan2() and
      \\ by changing order of arguments (dx,dy) or (dy,dx). 8 combinations
      HueCircle= Lambda Atan2, tau (PrintPixel) -> {
            Let  c_width=256, c_height=256
            Let  cx=c_width/2, cy=c_height/2
            Let  radius=If(cx<=cy->cx, cy)
            c_width--
            c_height--
            dy=-cy
            For y=0 To c_height {
                  dy++ : dy2=dy*dy : dx=-cx
                  For x=0 To c_width {
                        dx++ : dist=Sqrt(dx^2+dy2)
                        If dist>radius Then continue
                        Call PrintPixel(x,y, Atan2(dx, -dy)/tau, dist/radius)
                  }
            }
      }
      Call HueCircle(PrintPixel)
      Scr$=""  ' we use this string  to load an image
      Move 0,0
      \\ scale.x, scale.y are twips height and width, of current layer
      Copy scale.x, scale.y to Scr$
      Clipboard Scr$  ' save window to clipboard
}
Check
a$=KEY$
\\ CALL INFO NOW \\ DELETE THIS LINE IF INFO NOT EXIST IN MODULE'S LIST
Keyboard "info"+chr$(13)
}
MODULE SH {hide
wait 100
Desktop  ' copy desktop to background
BackGround {
	img$=""
	move 0,0
	copy scale.x, scale.y to img$
}
wait 1000
show
Title "Shift Console"
cx=pos
cy=row
Escape off
x=motion.x
y=motion.y
t=1000/25
for i=1 to 200 step 5
motion x+i*twipsy, y+i*twipsx
wait t
Next i
wait 1000
motion x, y
Escape on
Form  ' cut border
x=motion.xw
y=motion.yw
t=1000/25
for i=1 to 200 step 5
motion.w x+i*twipsy, y+i*twipsx
wait t
Next i
wait 1000
motion.w x, y
Bmp$=""
Move 0,0
Copy scale.x, scale.y to Bmp$
form ;    ' clear screan and restore border
image bmp$
refresh
cursor cx,cy
Move scale.x/2, scale.y/2
Image img$, scale.x/3
sprite img$,5 ,45,30,40
clipboard img$
Title "Shift Console.. complete"
}
MODULE GR {Report {
	Gray Code
	
}
Module GrayCode {
      Function bin$(a) {
            a$=""
            do {
                  n= a mod 2
                  a$=if$(n=1->"1", "0")+a$
                  a=a div 2
            } until a==0
            =a$
      }
      Function GrayEncode(a) {
            =binary.xor(a, binary.shift(a,-1))
      }
      Function GrayDecode(a) {
            b=0
            do {b=binary.xor(a, b) : a=binary.shift(a,-1) } until a=0
            =b
      }
      For i=0 to 32 {
            g=GrayEncode(i)
            b=GrayDecode(g)
            Print format$("{0::-2} {1:-6} {2:-6} {3:-6} {4::-2}", i, bin$(i), bin$(g), bin$(b), b)
      }
}
GrayCode
}
MODULE AC {\\ M2000 Interpreter
report {
	 Accumulator factory
	 
}
foo=lambda acc=0 (n as double=0) -> {
      if n=0 then =acc : exit 
      acc+=n
      =lambda n=acc (x) -> {
            \\ x has no type here, can be any numeric type (also can be an object too)       
            \\ accumulator is double, and is a closure (a copy of n in foo)
            n+=x
            \\ any variable in M2000 hold  first type
            \\ if x is an object then we get error, except if object use this operator
            x=n
            \\ so we return x type
            =x
      }
}
x=foo(1)
call void x(5)
call void foo(3)   ' void tell to interpreter to throw result
print x(2.3) ' prints 8.3
print foo()=4

}
MODULE TR {\\ goto no_random_mode
m=random(700,1100)/1000
mode 8, scale.x*m, scale.y*m

no_random_mode:
\\ Version 2 we make the drawing to scale based to height
let sc=scale.y/14000, yoffset=100
mode 11*scale.y/14000
Escape Off
Flush
Global alfa=60*4
\\ check for linux (there is no smooth function, we can give the command but we get not the proper results)
if not iswine then Smooth On  \\ use Gdi+
Cls 5,0
Pen 14
Gradient 5,1

\\ set refresh to 1500 msec
Refresh 1500 
\\ temporary we use double heigt characters
Double
Report 2, {Example three oscilloscopes},8000*sc
Normal
Gosub put_a_title
Gosub define_module_b
Gosub make_classes

Triangle=drw(4000*sc,2500*sc+yoffset)
Tk=Display(8000*sc,500*sc+yoffset,8000*sc,4000*sc,45, sc)
b 2000*sc,3, &Triangle.a(), 0
Hexagon=drw(4000*sc,6750*sc+yoffset)
Hk=Display(8000*sc,4750*sc+yoffset,8000*sc,4000*sc,15, sc)
b 2000*sc,6, &Hexagon.a(), 0
My_Circle=drw(4000*sc,11000*sc+yoffset)
Ck=Display(8000*sc,9000*sc+yoffset,8000*sc,4000*sc,30, sc)
b 2000*sc,alfa div 2, &My_Circle.a(), 0
flash=true
introtime=0
timeinterval=600
Dim Fcol(-1 to 0)
Fcol(-1)=#ff3322, #773300
thread {
	flash~
	introtime++
	if flash then
		timeinterval*=.9
		Thread this interval timeinterval
	else 
		Thread this interval 200
	end if
} as t1 interval timeinterval
Hold
i=0
k=1
tipstop=8000*sc
Every 10 { 
      Pen 15 {
            Refresh 1500
            Release  ' we get the background using Hold.
            if t1>0  then Print.Info(flash) : if introtime>50  then Thread t1 Erase : t1=0        

            Triangle.draw_to (i+alfa/6) mod alfa
                  Draw to tipstop, pos.y
                  Tk.tip
                       
            Hexagon.draw_to (i+alfa/12) mod alfa
                  Draw to tipstop, pos.y
                  Hk.tip
                       
            My_Circle.draw_to i
                  Draw to tipstop, pos.y
                  Ck.tip
            If keypress(1) Then
                  k++
            Else.If keypress(2) Then
                  k--
            End If
            i+=k
            i=i mod# alfa
      }
      If inkey$<>"" Then Exit
}
Threads Erase
Escape off
\\ call info again
Keyboard "info"+chr$(13)
smooth off
Exit
put_a_title:
      Move -320*sc, scale.y
      Path { 
          legend "Μ2000","Arial Black", 90*sc,pi/2,0,0,100 
      } ;
      Move -320*sc, scale.y-10000*sc
      Fill 2300*sc, 10000*sc, #221133, #AA8566,1,1
      Path { } ;
      Move -320*sc, scale.y
      Pen 0 {
            \\ transparent background color
            Color { 
                legend "Μ2000","Arial Black", 90*sc,pi/2,0,0,100 
            }
      }
Return
define_module_b:
Module b {
      Read a, n, &ar(), cir
      Dim ar(alfa,2)
      z=pi/2
      km=0
      x=pos.x
      y=pos.y
      If cir Then Circle a
      g=n/2
      kk=alfa/n
      Step Angle -(pi/2+pi/n),a
      b=(x-pos.x)*2/kk
      d=Abs(y-pos.y)
      Step Angle -(pi/2+pi/n),-a
      If cir Then If d>0 Then Circle d
      Step Angle -(pi/2+pi/n)+z,a
      Step Angle 0,0
      For i=0 to 2*pi Step pi/g
            x1=pos.x
            y1=pos.y
            For L=1 to kk
                  Move x1, y1
                  Draw Angle i+z, b*L
                  ar(km,0)=pos.x
                  ar(km,1)=pos.y
                  km++ 
                  km=km mod alfa
                  If cir Then Circle Fill 11,30,1,11
            Next L
      Next i
      Step Angle -(pi/2+pi/n)+z,-a
}
Return
make_classes:
Class drw {
      Dim a(0)
      x, y
      Module drw {
            Read .x, .y
            Move .x, .y
      }
      Module draw_to {
            If Match("N") Then
                  Read i
                  i=Abs(int(i)) mod alfa
                  Move .x,.y
                  Draw to .a(i,0), .a(i,1)
            Else
                  For i=0 to alfa-1
                        Move .x,.y
                        Draw to .a(i,0), .a(i,1)
                  Next i
            End If
      }
}
Class Display {
      x, y, wi, he, stp, tp=-1
      dscr$, counter, sc
      Module Display {
            Read .x,.y,.wi,.he, .stp, .sc
            .y-=30
            .he+=60
            .tp<=1
            x1=pos.x
            y1=pos.y
            Move .x, .y
            Fill .wi, .he, 1,7
            Move .x+100, .y+.he-100
            Pen 11 {
                  Legend "Osc 2000", "Verdana", 8,pi/2,0,0
            }
            Move x1, y1
      }
      Module Tip {
            If .tp=-1 Then Exit
            tp1=pos.y
            If .dscr$<>"" Then { copy .x+.stp, .y use .dscr$ } Else .tp=tp1
            .counter++
            If .counter mod (alfa div 4)=1 Then Move .x+.stp/2, .y : Width 1,3 { Draw 0 ,.he,14 } 
            Move .x, tp1
            Draw to .x+.stp, .tp
            .tp<=tp1
            Move .x,.y
            copy .wi-.stp/2, .he To .dscr$
            Move .x, .y+.he/2
            Pen 14 { Draw .wi }
            Move .x+.wi/2,.y+200
            Pen 12 {
                  Legend Format$("Oscilloscope: {0}sec",str$(.counter/10,"000000.0")), "Lucida Console", 11*.sc, 0, 2, 1, 20
            }
      }
}
Return
Sub Print.Info(x)
	Cursor 0,12
	Pen Fcol(x) {
		Report 2, {
			Press
			Keyboard
			any key - exit
			Mouse buttons
			left - Acc. left
			right - Acc. right
			}, 3000*sc   \\ width 
	}
End Sub
}
MODULE HT {text alfa.html {
<!doctype html>
<html>
<head>
<title>Hello There</title>
<meta name="GENERATOR" content="M2000">
<meta name="FORMATTER" content="M2000">
<meta content="this, other, that" name=keywords>
<meta content=All name=robots> 
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1253">
<meta NAME="Author" CONTENT="GEORGE KARRAS">
<style type="text/css">
body {
    overflow:hidden;
}
</style>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#800080" alink="#ff0000" >
<h2>My First JavaScript</h2>

<button type="button"
onclick="document.getElementById('demo').innerHTML = Date()">
Click me to display Date and Time.</button>

<p id="demo"></p>

</body>
}
browser "alfa.html",motion.xw+motion.x,motion.yw+motion.y, scale.x,6000
Print {click, and pres Esc, or use statement Browser ""}
}
MODULE KB {Function CallMe {
     \\  Fkey Clear  - not used
      \\ Keyboard - can play two or more notes at once
      \\ some keybards can play max 6 notes, some other max 4
            refresh 5000
      Thread.Plan Sequential
      Play 0 \\ clear music threads
          
      dim note1$(10,3), note2$(10,3)
      FillArray()
      \\Form ! 60,30      
      back$=""
      \\ hold previous screen, then draw new one, then copy to back$, then release the old one
      \\ then call FadeInScreen passing a dummy function as call back, to use the Back$
      hold
      Refresh 5000
      Move 0,0
      Pen 14
      Gradient 5,5
      Cursor 0,0
      Double
      Report 2, "Keyboard 005"   
      Normal
      Report 2,{Menu
      1-Exit  3-Xylophone 4-Piano 5-Saxophone  8-Show Keys/Notes 9-Rythm Yes 0-Rythm No
      
      Space bar - set higher the volume for each note
      -- George Karras --
      
      }
      Global kb$=" ", dur=300, org=5, f=0, vol$="V90", voi(18), use(17) ' 0 ..17,
      n=1
      For i=1 to 16 { use(i)=True }
      use(10)= false \\ For drum machine
      \\ compute virtual clavie position
      mm=2*(scale.x div 14)
      mm2= mm div 2
      kk=scale.y/5
      kk1=scale.y/4
      gram=scale.y/20
      '      Scroll Split -Height/2
      DisplayNoRefresh(mm, kk, mm2, kk1)
      Move 0,0
      Copy scale.x, scale.y to back$
      start.at=scale.x*.9
      Function Dummy1 {
            move start.at, 0
            Image back$
            start.at-=scale.x/10
            if start.at<0 then start.at=0
      }
      Function Dummy0 {
            move 0, 0
            Image back$
      }
      Release
       if random(10)<6 then
            FadeInScreen2 Lazy$(&Dummy1()),1.3
      else
            FadeInScreen Lazy$(&Dummy0()),1.3
      end if
      call local Dummy0()
      refresh 5000
      Scroll Split  Height/2+1
      Cursor 0, Height/2+1
      Module ClKey {
            Read a$, press, sel
            If press Then {
            If Instr(kb$,a$+"-")>0 Then Exit
            Next()
            voi(sel)=f
            Print a$, f
            Score f, dur, a$+vol$ : kb$<=kb$+a$+"-": Play f, org
            } else {
                  kb$<=Replace$(a$+"-","", kb$)
                  If voi(sel)>0 Then {
                   Play voi(sel), 0 
                   use(voi(sel))~
                   voi(sel)=0
                   }
            }
            Sub Next()
            Local i
            For i=1 to 16 {
                  If use(i) Then Exit
            }
            If i<17 Then { f<=i : use(i)~ } else f<=1: use(1)=True : Print "!!!!!!!!"
            End Sub
      }
      \\ 10 for drum machine
      Thread { Score 10,400,"CV90CC  ab Cd eCC" : Play 10,1 } as L Interval 60
      Thread {
            ClKey "A#2", KeyPress(asc("A")), 1
            ClKey "B2", KeyPress(asc("Z")), 2
            ClKey "C3", KeyPress(asc("X")), 3
            ClKey "C#3", KeyPress(asc("D")), 4
            ClKey "D3", KeyPress(asc("C")), 5
            ClKey "D#3", KeyPress(asc("F")), 6
            ClKey "E3", KeyPress(asc("V")), 7
            ClKey "F3", KeyPress(asc("B")), 8
            ClKey "F#3", KeyPress(asc("H")), 9
            ClKey "G3", KeyPress(asc("N")), 10
            ClKey "G#3", KeyPress(asc("J")), 11
            ClKey "A3", KeyPress(asc("M")), 12
            ClKey "A#3", KeyPress(asc("K")), 13
            \\ https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
            ClKey "B3", KeyPress(0xBC), 14 \\ VK_OEM_COMMA
            ClKey "C4", KeyPress(0xBE), 15 \\ VK_OEM_PERIOD
            ClKey "C#4", KeyPress(0xBA), 16 \\ VK_OEM_1
            ClKey "D4", KeyPress(0xBF), 17 \\VK_OEM_2  
      } as al Interval 50
      Print "οκ"
      Threads
      Thread L Interval 6000
      Main.Task 10 {
            Display(mm, kk, mm2, kk1)
            Refresh 1000
            If KeyPress(asc("1")) Then Exit
            If KeyPress(asc("3")) Then org<=14 : dur<=100 
            If KeyPress(asc("4")) Then org<=5 : dur<=300
            If KeyPress(asc("5")) Then org<=65 : dur<=5000
            If KeyPress(asc("8")) Then n=1-n
            If KeyPress(asc("9")) Then Thread L Restart
            If KeyPress(asc("0")) Then Thread L Hold
            If KeyPress(32) Then { vol$ <= "V127"  } else vol$ <=if$(dur=300->"V100", "V110")
            Print "--------"
      }
      Threads Erase
      Print "End"
      \\ delete this line
      \\Keyboard "Info"+chr$(13)
      Scroll Split  0
     
      Exit
      Sub DisplayNoRefresh(p0,y0, p1, y1)
            Clavie(p0, y0, p1, y1, 0, &note1$())
            Clavie(p0-p1/2,y0,p1,y1*2/3, -1, &note2$())
      End Sub
      Sub Display(p0,y0, p1, y1)
            Clavie(p0, y0, p1, y1, 0, &note1$())
            Clavie(p0-p1/2,y0,p1,y1*2/3, -1, &note2$())
            Refresh 1000
      End Sub
      Sub Clavie(p0, y0,p1, y1, p3, &n$())
            Link n$() to n()
            p3-!
            Local k=-1, i
            For i=p0 to 9*p1+p0 step p1
            k++
            If n$(k,0)<>"" Then {
                  Move i+p3*p1/6, y0
                  If p3 Then {
                        Fill p1-p3*p1/3-15,y1-15, 7* (1-(voi(n(k,2))>0))+1, 0,1
                  } else {
                        Fill p1-15,y1-15,15,7* (1-(voi(n(k,2))=0))+1,1
                  }
                  Move i+p3*p1/6, y0
                  Fill @ p1-p3*p1/3,y1,2,1
                  Move i+p3*p1/6, y0+y1-gram
                  Pen p3*15 { Fill @ p1-p3*p1/3,gram,5,n$(k,n)}
            }
            Next i
      End Sub
      Sub FillArray()
      Local n,p, n$, k$, no
      Stack New {
            Data "A#2", "A", 1, 1, 2
            Data "B2", "Z", 2, 1, 1
            Data "C3", "X", 3, 2, 1
            Data "C#3", "D", 4, 3, 2
            Data "D3", "C", 5, 3, 1
            Data "D#3", "F", 6, 4, 2
            Data "E3", "V", 7, 4, 1
            Data "F3", "B", 8, 5, 1
            Data "F#3", "H", 9, 6, 2
            Data "G3", "N", 10, 6, 1
            Data "G#3", "J", 11, 7, 2
            Data "A3", "M", 12, 7, 1
            Data "A#3", "K", 13, 8, 2
            Data "B3", ",", 14, 8, 1
            Data "C4", ".", 15, 9, 1
            Data "C#4",";", 16 , 10, 2
            Data "D4", "/", 17, 10, 1 
            While Not Empty {
            Read n$, k$, no, n, p
                  If p=1 Then {
                      note1$(n-1,0):= n$, k$, no  \\ feed a row
                  } else {
                        note2$(n-1,0):= n$, k$, no
                  }
            }
      }
      End Sub
}
Inline code LibFade
FadeScreen Lazy$(&CallMe()), 1.7
}
MODULE AU {Declare form1 Form
Declare combo1 combobox Form form1
Declare text1 textbox Form form1
With form1,"Title" As title$
With combo1,"Edit", True,"UseOnlyTheList", false,"autocomplete", True, "listIndex" As ListIndex,"ShowAlways", True
With combo1,"label","Combo1", "ListText" As item$, "list" As list$(), "text" As combo1$
item$={alfa
            delta
            gamma
            beta
            }
With combo1,"Find" As Find()
Method combo1,"Sort"
combo1$=list$(find("gam*"))

Method combo1,"Move", 1000,1000,6000,600
Method text1, "Move", 1000,2900,6000,600

With text1, "left" As left, "text" As text1.text$ , "ShowAlways", True
Print left
Method form1, "show"
Method text1,"GetFocus"
Function form1.unload {
      Keyboard "!"
      show
}
Function combo1.dblclick {
        text1.text$=combo1$
        title$=combo1$
        If find(title$)= -1 Then {
            Method combo1,"additem",title$
            Method combo1,"Sort"
            listindex=find(title$)
      }
}
Function combo1.click {
      If listindex>=0 Then text1.text$=list$(listindex)
}
Function combo1.scroll {
      If listindex>=0 Then text1.text$=list$(listindex)
}
a$=key$
Declare Text1 nothing
Declare combo1 nothing
Declare form1 nothing
}
MODULE ICO {\\$ ..........\appdata\roaming\m2000\m2000png.png
Binary {
      iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA+vAAAP
      1wExQtGTAAAADXRFWHRDb21tZW50ACSZhQMALhdS/QAAAUZJREFUeJzFlosNwyAM
      RNl/A2bJcK6S1MT4D5QUdCpSif04O7QFyn/nOYDK2ZjaNwVwHMclHlgkhVu/hGkA
      QIJpSS2tQpT74dIArMS12uKOeBIAeOKuDMpJr0SrigDAsbwB4KzsE9h3VVl7AFiG
      EGCXA2cCLEPKAX56zQm+NwNgufCKA14ZOgcyp9UccnsA/DJsd4ACaC6oPWCd1uoR
      D+C5KOSl1GRZS9cWUKU5NAcCNYDaB1vRHADQIOFjjr4xOgAckQNGcmxgqhBiGAB8
      AA7zKgAmxhB7AJQS0EROiD0OxKeUPWIDOLIcGAGQEDMAigMRBO2LHnoUoNNTtQiC
      VnatBNcaCgdAiJFSCAAPgt/h/C2Yh6A/CqrN8u7WADgEB7HBCEAEIffZtdauZB2C
      AWSndxNqYxOADZGu/yxAtmfS/wf+AYExPhJPvgsIMdG8AAAAAElFTkSuQmCC
} As ico
read com
if com=1 then 
	Move 0,0
	Image ico, scale.x/width*2  ' (twips/character)
else
	push ico
end if


}
MODULE ICONS {function dummy {
	if isWine then sp=10 : r=30 else sp=40 : r=60
	Escape off
	Def a,b,c
	call ico, 2
	read ico
	\\gradient 5,0
	\\ call global
	Fade 5, 0
	useM200sprites=random(1,2)=1
	move scale.x/2, scale.y/2
	legend str$(sp,0)+If$(useM200sprites->" M2000"," GDI+")+{ Sprites
	rotating,resizing
	changing opacity
	}, "Arial Black", 22,0,2,1,150
	hold
	Wait 500
	mouse.icon hide
	n=0
	p=false
	if useM200sprites then
		spr$=""
		image ico (5) to spr$    ' use 5 (magenta) as transparent color
		every 1000/r {
			release
			if p then 
			move mouse.x, mouse.y
			sprite spr$,5,n-29,200,50
			hold
			p=false
			end if
			
			For i=1 to sp {
				move Random(14000)+1000, Random(10000)+1000
				let  a=random(90), b=random(50)+150, c=random(50)-50*(random(10)=1)
				sprite spr$,5, a,b,c
			}
			move mouse.x, mouse.y
			sprite spr$,5,n,200
			n+=29
			refresh 1500
			if keypress(2) then exit
			p= keypress(1)
		}
	else
		Set Fast !
		every 1000/r {
			release
			if p then 
			move mouse.x, mouse.y
			sprite ico,,n-29,200,50
			hold
			p=false
			end if
			
			For i=1 to sp {
				move Random(14000)+1000, Random(10000)+1000
				let  a=random(90), b=random(50)+150, c=random(50)-50*(random(10)=1)
				sprite ico, , a,b,c
			}
			move mouse.x, mouse.y
			sprite ico,,n,200
			n+=29
			if keypress(2) then exit
			p= keypress(1)
			refresh 1500

		}
		Set Fast
	end if
	release
	all$=""
	move 0,0
	copy scale.x, scale.y to all$
	mouse.icon show
	Refresh 30
	If Ask("Save the file","icons","Save it","No", all$)=1 then
	Menu  ' erase menu list
	files + "screen*.bmp"
	copy "screen"+str$(menuitems+1,"000")+".bmp"
	End if
	cls,0
	
	\\ In console M2000 has no events, except for this:,  an old variant of Menu can get the finish event in a global menu.
	\\ so giving the globalmenu Menu statement open the menu end leave it there to be used in a loop or something.
	Menu
	Menu title "MOVE ME" 
	Menu fill #F377FF, 7, 0
	files + "screen*.bmp"
	if menuitems=0 then exit
	global ex=false, loadnow=0
	Module Global globalmenu {
	\\ unhide this to exit menu if get a double click
	\\	ex<=true  \\ we can use this to exit on double click or enter.
		if menu=0 then ex<=true : Print "You press Esc" else loadnow<=menu
	}
	Print @(0,0), "Select Image or End:";
	Menu @ "globalmenu" !
	wait 200
	menu1=0
	do {
		wait 100
		refresh
		if keypress(2) or ex then exit
		menu1=menu
		if menu1=0 then continue
	\\ using this line we open one if double click or press enter
	Rem	if  loadnow=0 then continue
	\\using this we get response also as we move the menu caret
	 	if loadnow=0 then loadnow<=menu1
		move 0,0
		image menu$(loadnow), scale.x
		Print @(0,0), "Image:";menu$(loadnow)
		loadnow<=0
	} always
	Menu
	Escape On
}
Inline Code LibFade
function dummy1 {
	gradient 1, 5
	a$=key$
}
FadeScreen &Dummy(), 1.7
}
MODULE COMPILER {Module CompilerExample {
	Set Fast !
	Module lexical_analyzer (a$){
		lim=Len(a$)
		LineNo=1
		ColumnNo=1
		Document Output$
		Buffer Scanner as Integer*lim
		Return Scanner, 0:=a$
		offset=0
		buffer1$=""
		flag_rem=true
		Ahead=lambda Scanner (a$, offset)->{
			=false
			Try {
				\\ second parameter is the offset in buffer units
				\\ third parameter is length in bytes
				=Eval$(Scanner, offset,2*len(a$))=a$
			}
		}
		Ahead2=lambda Scanner (a$, offset)->{
			=false
			Try {
				=Eval$(Scanner, offset,2) ~ a$
			}
		}
		const nl$=chr$(13)+chr$(10), quo$="""", er$="@", Ansi=3
		Try {
			Do
			If Ahead("/*", offset) Then {
				offset+=2 : ColumnNo+=2
				While not Ahead("*/", offset)
					If Ahead(nl$, offset) Then
						lineNo++: ColumnNo=1 : offset+=2
					Else
						offset++ : ColumnNo++
					End If
					if offset>lim then
						Error "End-of-file in comment. Closing comment characters not found"+er$
					End if
				End While
				offset+=2 : ColumnNo+=2
			} Else.if Ahead(nl$, offset) Then{
				LineNo++: ColumnNo=1
				offset+=2
			} Else.if Ahead(quo$, offset) Then {
				Output$=format$("{0::-10}{1::-10} ", LineNo, ColumnNo)
				offset++ : ColumnNo++
				strin=offset
				While not Ahead(quo$, offset)
					If Ahead("/", offset) Then
						offset+=2 : ColumnNo+=2
					else
						offset++ : ColumnNo++
					End if
					checkerror()
				End While
				Output$="String "+quote$(Eval$(Scanner, strin, (offset-strin)*2))+nl$
				offset++ : ColumnNo++
			} Else.if Ahead("'", offset) Then {
				Output$=format$("{0::-10}{1::-10} ", LineNo, ColumnNo)
				offset++ : ColumnNo++
				strin=offset
				While not Ahead("'", offset)
					If Ahead("/", offset) Then
						offset+=2 : ColumnNo+=2
					else
						offset++ : ColumnNo++
					End if
					checkerror()
				End While
				lit$=format$(Eval$(Scanner, strin, (offset-strin)*2))
				select case len(lit$)
				case 1
					Output$="Integer "+str$(asc(lit$),0)+nl$
				case >1
					{Error "Multi-character constant."+er$}
				case 0
					{Error "Empty character constant."+er$}
				end select
				offset++ : ColumnNo++
			} Else.if Ahead2("[a-z]", offset) Then {
				strin=offset
				Output$=format$("{0::-10}{1::-10} ", LineNo, ColumnNo)
				offset++ : ColumnNo++
				While Ahead2("[a-zA-Z0-9_]", offset)
					offset++ : ColumnNo++
				End While
				Keywords(Eval$(Scanner, strin, (offset-strin)*2))
			} Else.if Ahead2("[0-9]", offset) Then {
				strin=offset
				Output$=format$("{0::-10}{1::-10} Integer ", LineNo, ColumnNo)
				offset++ : ColumnNo++
				While Ahead2("[0-9]", offset)
					offset++ : ColumnNo++
				End While
				if Ahead2("[a-zA-Z_]", offset) then  
					{Error " Invalid number. Starts like a number, but ends in non-numeric characters."+er$}
				else
					Output$=Eval$(Scanner, strin, (offset-strin)*2)+nl$
				end if
			} Else {
				Symbols(Eval$(Scanner, Offset, 2))	      
				offset++ : ColumnNo++
			}
			Until offset>=lim
		}
		er1$=leftpart$(error$,er$)
		if er1$<>"" then
			Print
			Report "Error:"+er1$
			Output$="(Error)"+nl$+"Error:"+er1$
		else
			Output$=format$("{0::-10}{1::-10}", LineNo, ColumnNo)+" End_of_Input"+nl$
		end if
		Push Output$
		Exit
		Clipboard Output$
		Save.Doc Output$, "lex.t", Ansi
		document lex$
		Load.Doc lex$,"lex.t", Ansi
		Report lex$
 
		Sub Keywords(a$)
			select case a$
			case "if"
				a$="Keyword_if"
			case "else"
				a$="Keyword_else"
			case "while"
				a$="Keyword_while"
			case "print"
				a$="Keyword_print"
			case "putc"
				a$="Keyword_putc"
			else case
				a$="Identifier "+a$
			end select
			Output$=a$+nl$
		End sub
		Sub Symbols(a$)
			select case a$
			case " ", chr$(9)
				a$=""
			case "("
				a$="LeftParen"
			case ")"
				a$="RightParen"
			case "{"
				a$="LeftBrace"
			case "}"
				a$="RightBrace"
			case ";"
				a$="Semicolon"
			case ","
				a$="Comma"
			case "*"
				a$="Op_multiply"
			case "/"
				a$="Op_divide"
			case "+"
				a$="Op_add"
			case "-"
				a$="Op_subtract"
			case "%"
				a$="Op_mod"
			case "<"
			{	if Ahead("=", offset+1) Then
					offset++
					a$="Op_lessequal"
					ColumnNo++
				else
					a$="Op_less"
				end if
			}
			case ">"
			{	if Ahead("=", offset+1) Then
					offset++
					ColumnNo++
					a$="Op_greaterequal"
				else
					a$="Op_greater"
				end if
			}
			case "="
			{	if Ahead("=", offset+1) Then
					offset++
					ColumnNo++
					a$="Op_equal"
				else
					a$="Op_assign"
				end if
			}
			case "!"
			{	if Ahead("=", offset+1) Then
					offset++
					ColumnNo++
					a$="Op_notequal"
				else
					a$="Op_not"
				end if
			}
			case "&"
			{	if Ahead("&", offset+1) Then
					offset++
					ColumnNo++
					a$="Op_and"
				else
					a$=""
				end if
			}
			case "|"
			{	if Ahead("|", offset+1) Then
					offset++
					ColumnNo++
					a$="Op_or"
				else
					a$=""
				end if
			}
			else case
				{Error "Unrecognized character."+er$}
			end select
			if a$<>"" then
			Output$=format$("{0::-10}{1::-10} ", LineNo, ColumnNo)+a$+nl$
			end if
		End Sub
		Sub checkerror()
			if offset>lim then {
				Error "End-of-line while scanning string literal. Closing string character not found before end-of-line."+er$
			} else.if  Ahead(nl$,offset) then {
				Error "End-of-file while scanning string literal. Closing string character not found."+er$
			}
		End Sub
	}
	Module syntax_analyzer (b$){
		enum tokens {
			Op_add, Op_subtract, Op_not=5, Op_multiply=10, Op_divide, Op_mod, 
			Op_negate,  Op_less, Op_lessequal, Op_greater, Op_greaterequal,
			Op_equal, Op_notequal, Op_and, Op_or, Op_assign=100, Keyword_if=110,
			Keyword_else, Keyword_while, Keyword_print, Keyword_putc, LeftParen, RightParen,
			LeftBrace, RightBrace, Semicolon, Comma, Identifier, Integer, String, End_of_input
		}
 
		Inventory precedence=Op_multiply:=13, Op_divide:=13, Op_mod:=13, Op_add:=12, Op_subtract:=12
		Append  precedence, Op_negate:=14, Op_not:=14, Op_less:=10, Op_lessequal:=10, Op_greater:=10 
		Append  precedence, Op_greaterequal:=10, Op_equal:=9, Op_notequal:=9, Op_assign:=-1, Op_and:=5
		Append  precedence, Op_or:=4
 
		Inventory symbols=Op_multiply:="Multiply", Op_divide:="Divide", Op_mod:="Mod", Op_add:="Add"
		Append  symbols, Op_negate:="Negate", Op_not:="Not", Op_less:="Less", Op_subtract:="Subtract"
		Append  symbols, Op_lessequal:="LessEqual", Op_greater:="Greater", Op_greaterequal:="GreaterEqual"
		Append  symbols, Op_equal:="Equal", Op_notequal:="NotEqual",  Op_and:="And", Op_or:="Or" 
 
		def lineNo, ColumnNo, m, line$, a, lim, cur=-1
		const nl$=chr$(13)+chr$(10), Ansi=3
		Dim lex$()
		lex$()=piece$(b$,chr$(13)+chr$(10)) 
		lim=dimension(lex$(),1)-1
		op=End_of_input
		flush
		k=0
		Try {
			push (,)   ' Null
			getone(&op)
			repeat
			stmt(&op)
			shift 2  ' swap two top items
			push ("Sequence", array, array)
			k++
			until op=End_of_Input
		}
		er$=error$
		if er$<>"" then print er$ : flush: break
		Print "Ast"
		Document Output$
		prt_ast()
		Push Output$
		exit
		clipboard Output$
		Save.Doc Output$, "parse.t", Ansi
		document parse$
		Load.Doc parse$,"parse.t", Ansi
		Report parse$
 
		sub prt_ast(t)
			if len(t)<1 then
				Output$=";"+nl$
			else.if len(t)=3 then
				Output$=t#val$(0) +nl$
				prt_ast(t#val(1)) : prt_ast(t#val(2))
			else
				Output$=t#val$(0) +nl$
			end if
		end sub
		sub expr(p)   ' only a number
			local x=(,), prev=op
			if  op>=Identifier then
				x=(line$,)
				getone(&op)
			else.if op=LeftParen then
				paren_exp()
				x=array
			else.if op<10 then
				getone(&op)
				expr(precedence(int(Op_negate)))
				read local y
				if prev=Op_add then
					x=y
				else
					if prev=Op_subtract then prev=Op_negate
					x=(symbols(prev), y,(,))
				End if
			else
				 {error "??? "+eval$(op)}
			end if
			local prec
			while exist(precedence, int(op))
				prev=op : prec=eval(precedence)
				if prec<14 and prec>=p else exit
				getone(&op)
				expr(prec+1)  ' all operators are left associative (use prec for right a.)
				x=(symbols(int(prev)), x, array)
			End While
			Push x
		end sub
		sub paren_exp()
			expected(LeftParen)
			getone(&op)
			expr(0)
			expected(RightParen)
			getone(&op)
		end sub
		sub stmt(&op)
			local t=(,)
			if op=Identifier then
				t=(line$)
				getone(&op)
				expected(Op_assign)
				getone(&op) 
				expr(0)
				read local rightnode
				Push ("Assign",t,rightnode)
				expected(Semicolon)
				getone(&op)
			else.if op=Semicolon then
				getone(&op)
				Push (";",)
			else.if op=Keyword_print then
				getone(&op)
				expected(LeftParen)
				repeat
					getone(&op)
					if op=String then
						Push ("Prts",(line$,),(,))
						getone(&op)
					else
						expr(0)
						Push ("Prti", array,(,))
					end if
					t=("Sequence", t, array)
				until op<>Comma
				expected(RightParen)
				getone(&op)
				expected(Semicolon)
				getone(&op)
				push t
			else.if op=Keyword_while then
				getone(&op)
				paren_exp()
				stmt(&op)
				shift 2
				Push ("While",array, array)
			else.if op=Keyword_if then
				getone(&op)
				paren_exp()
				stmt(&op)
				local s2=(,)
				if op=Keyword_else then
					getone(&op)
					stmt(&op)
					read s2
				end if
				shift 2
				Push ("If",array ,("If",array,s2))
			else.if op=Keyword_putc then
				getone(&op)
				paren_exp()
				Push ("Prtc",array,t)
				expected(Semicolon)
				getone(&op)
			else.if op=LeftBrace then
				Brace()
			else
				error "Unkown Op"
			end if
		end sub
		Sub Brace()
				getone(&op)
				while op<>RightBrace and op<>End_of_input
					stmt(&op)
					t=("Sequence", t, array)
				end while
				expected(RightBrace)
				getone(&op)
				push t
		End Sub
		Sub expected(what)
			if not op=what then {Error "Expected "+eval$(what)+str$(LineNo)+","+Str$(ColumnNo)}
		End Sub
		sub getone(&op)
			op=End_of_input
			while cur<lim
			cur++
			line$=trim$(lex$(cur))
			if line$<>"" then exit
			end while
			if cur=lim then exit sub
			LineNo=Val(line$,"int",m)
			line$=mid$(line$, m)
			ColumnNo=Val(line$,"int",m)
			line$=trim$(mid$(line$, m))
			Rem : Print LineNo, ColumnNo
			m=instr(line$," ")
			if m>0 then op=Eval("."+leftpart$(line$, " ")) else op=Eval("."+line$)
		end sub
	}
	Module CodeGenerator (s$){
		Function code$(op$) {
			=format$("{0::-6} {1}", pc, op$)
			pc++
		}
		Function code2$(op$, n$) {
			=format$("{0::-6} {1} {2}", pc, op$, n$)
			pc+=5
		}
		Function code3$(op$,pc, st, ed) {
			=format$("{0::-6} {1} ({2}) {3}", pc, op$, ed-st-1, ed)
		}
 
		Enum tok {
			gneg, gnot, gmul, gdiv, gmod, gadd, gle, gsub, glt
			gle, ggt, gge, geq, gne, gand, gor, gprtc, gprti, gprts,
			gif, gwhile, gAssign, gSeq, gstring, gidentifier, gint, gnone
		}
 
		\\ Inventories are lists with keys, or keys/data (key must be unique)
		\\ there is one type more the Invetory Queue which get same keys.
		\\ But here not used.
		Inventory symb="Multiply":=gmul, "Divide":=gdiv, "Mod":=gmod, "Add":=gadd
		Append  symb, "Negate":=gneg, "Not":=gnot,"Less":=glt,"Subtract":=gsub
		Append  symb, "LessEqual":=gle, "Greater":=ggt, "GreaterEqual":=gge, "Sequence":=gSeq
		Append  symb, "Equal":=geq, "NotEqual":=gne,  "And":=gand, "Or":=gor, "While":=gwhile
		Append  symb, "Prtc":=gprtc,"Prti":=gprti,"Prts":=gprts, "Assign":=gAssign, "If":=gif
		Append  symb, "String":=gstring, "Identifier":=gidentifier, "Integer":=gint, ";", gnone
 
		Inventory DataSet
		\\ We set string as key. key maybe an empty string, a string or a number.
		\\ so we want eash string to saved one time only.
		Inventory Strings
 
		Const nl$=chr$(13)+chr$(10), Ansi=3
		Def z$, lim, line$, newvar_ok, i=0
		Document message$=nl$
		Global pc     \\ functions have own scope, so we make it global, for this module, and childs.
 
		Dim lines$()
		s$=filter$(s$,chr$(9))   \\ exclude tabs
		Lines$()=piece$(s$,nl$) \\ break to lines
		lim=len(Lines$())
		Flush ' empty stack (there is a current stack of values which we use here)
 
		Load_Ast()
		If not stack.size=1 Then Flush : Error "Ast not loaded"
		AST=array   \\ pop the array from stack
		Document Assembly$, Header$
 
		\\ all lines of assembly goes to stack. Maybe not in right order.
		\\ Push statement push to top, Data statement push to bottom of stack
 
		CodeGenerator(Ast)
		Data  code$("halt") ' append to end of stack
		\\ So now we get all data (letters) from stack
		While not empty
			Assembly$=letter$+nl$
		end while
		\\ So now we have to place them in order
		Sort Assembly$
 
		\\ Let's make the header
		Header$=format$("Datasize: {0} Strings: {1}", Len(Dataset),Len(strings))
		\\ we use an iterator object, str^ is the counter, readonly, but Eval$() use it from object.
		str=each(strings)    
		While str
			Header$=nl$+Eval$(str)
		End while
		Assembly$=nl$
		\\ insert to line 1 the Header
		Insert 1 Assembly$=Header$
		\\ Also we check for warnings
		If len(message$)>2 then Assembly$="Warnings: "+nl$+message$
		\\ So now we get a report
		\\ (at each 3/4 of window's lines, the printing stop and wait for user response, any key)
		Push Assembly$
		Exit
		Report Assembly$
		Clipboard Assembly$
		Save.Doc Assembly$, "code.t", Ansi
		End
		\\ subs have 10000 limit for recursion but can be extended to 1000000 or more.
		Sub CodeGenerator(t)
 
			If len(t)=3 then
				select case  t#val(0)
				Case gSeq
					CodeGenerator(t#val(1)) : CodeGenerator(t#val(2))
				Case gwhile
				{
					local spc=pc
					CodeGenerator(t#val(1)) 
					local pc1=pc
					pc+=5 ' room for jz
					CodeGenerator(t#val(2))
					data code3$("jz",pc1, pc1, pc+5)
					data code3$("jmp",pc,  pc, spc)
					pc+=5  ' room for jmp
				}
				Case gif
				{
					CodeGenerator(t#val(1)) 
					local pc1=pc, pc2
					pc+=5
					CodeGenerator(t#val(2)#val(1)) 
					If len(t#val(2)#val(2))>0 then
						pc2=pc
						pc+=5
						data code3$("jz",pc1, pc1, pc)
						CodeGenerator(t#val(2)#val(2))
						data code3$("jmp",pc2, pc2, pc)
					else
						data code3$("jz",pc1, pc1, pc)
					end If	  
				}
				Case gAssign
				{
					CodeGenerator(t#val(2))
					local newvar_ok=true
					CodeGenerator(t#val(1))
				}
				case gneg to gnot, gprtc to gprts
					CodeGenerator(t#val(1)) : data code$(mid$(eval$(t#val(0)),2))
				case gmul to gor
				{
					CodeGenerator(t#val(1))
					CodeGenerator(t#val(2))
					data code$(mid$(eval$(t#val(0)),2))
				}
				End select
			Else.if len(t)=2 then
				select case  t#val(0)
				Case gString
				{
					local spos
					If exist(strings,t#val$(1)) then
						spos=eval(strings!)
					else
						append strings, t#val$(1)	       
						spos=len(strings)-1
					end If
					Push code2$("push",str$(spos,0))
				}
				Case gInt
					Push code2$("push",t#val$(1), pc)
				Case gIdentifier
				{
					local ipos
					If exist(dataset,t#val$(1)) then
						ipos=Eval(dataset!)  ' return position
					else.if newvar_ok then
						Append dataset, t#val$(1)
						ipos=len(dataset)-1
					else
						message$="Variable "+t#val$(1)+" not initialized"+nl$
 
					end If
					If newvar_ok then
						Push code2$("store","["+str$(ipos, 0)+"]")
					else
						Push code2$("fetch","["+str$(ipos, 0)+"]")
					end If
				}
				end select
			End If
		End Sub
		Sub Load_Ast()
				If i>=lim then Push (,) : exit sub
				do
				line$=Trim$(lines$(i))
				I++
				tok$=piece$(line$," ")(0)
				until line$<>"" or i>=lim
				If tok$="Identifier" then
					Push (gidentifier,trim$(Mid$(line$,11)))
				else.if tok$="Integer" then
					long n=Val(Mid$(line$,8))  ' check overflow
					Push (gint, Trim$(Mid$(line$,8)))
				else.if tok$="String" then
					Push (gstring,Trim$(Mid$(line$,7)))
				else.if tok$=";" then
					Push (,)
				Else
					local otok=symb(tok$)
					Load_Ast() 
					Load_Ast()
					Shift 2
					Push (otok,array, array)
				End If
		End Sub
	}
	Module Virtual_Machine_Interpreter (a$){
		\\ function to extract string, replacing escape codes.
		Function GetString$(a$) {
			s=instr(a$, chr$(34))
			m=rinstr(a$,chr$(34))-s
			if m>1 then
				\\ process escape codes
				=format$(mid$(a$, s+1, m-1))
			else
				=""
			end if
		}
 		const nl$=chr$(13)+chr$(10)
		\\ we can set starting value to any number  n where 0<=n<=232
		enum op {	halt_=232, add_, sub_, mul_, div_, mod_, not_, neg_, and_, or_, lt_,
			    	gt_, le_, ge_, ne_, eq_, prts_, prti_, prtc_, store_, fetch_, push_,
				jmp_, jz_
	    	}
	     	exit_now=false
		Inventory  func=halt_:=lambda->{exit_now=true}
		Append  func, push_:=lambda->{sp--:return stack_, sp:=eval(code_, pc as long):pc+=4}
		Append  func, jz_:=lambda->{
			sp++: if eval(stack_, sp-1)=0 then pc=eval(code_, pc as long) else pc+=4
		}
		Append  func, jmp_:=lambda->{pc=eval(code_, pc as long)}
		Append  func, fetch_:=lambda->{sp--:Return stack_, sp:=eval(stack_, eval(code_, pc as long)):pc+=4}
		Append  func, store_:=lambda->{Return stack_, eval(code_, pc as long):=eval(stack_, sp):sp++:pc+=4}
		Append  func, add_:=lambda->{Return stack_, sp+1:=uint(sint(eval(stack_, sp+1))+sint(eval(stack_, sp))):sp++}
		Append  func, sub_:=lambda->{Return stack_, sp+1:=uint(sint(eval(stack_, sp+1))-sint(eval(stack_, sp))):sp++}
		Append  func, mul_:=lambda->{Return stack_, sp+1:=uint(sint(eval(stack_, sp+1))*sint(eval(stack_, sp))):sp++}
		Append  func, div_:=lambda->{Return stack_, sp+1:=uint(sint(eval(stack_, sp+1)) div sint(eval(stack_, sp))):sp++}
		Append  func, mod_:=lambda->{Return stack_, sp+1:=uint(sint(eval(stack_, sp+1)) mod sint(eval(stack_, sp))) :sp++}
		Append  func, not_:=lambda->{Return stack_, sp:=if(eval(stack_, sp)=0->uint(-1),0)}
		Append  func, neg_:=lambda->{Return stack_, sp:=uint(-sint(eval(stack_, sp)))}
		Append  func, and_:=lambda->{Return stack_, sp+1:=binary.and(eval(stack_, sp+1),eval(stack_, sp)):sp++	}
		Append  func, or_:=lambda->{Return stack_, sp+1:=binary.or(eval(stack_, sp+1),eval(stack_, sp)):sp++	}
		Append  func, lt_:=lambda->{Return stack_, sp+1:=uint(if(sint(eval(stack_, sp+1))<sint(eval(stack_, sp))->-1, 0)):sp++}
		Append  func, gt_:=lambda->{Return stack_, sp+1:=uint(if(sint(eval(stack_, sp+1))>sint(eval(stack_, sp))->-1, 0)):sp++}
		Append  func, le_:=lambda->{Return stack_, sp+1:=uint(if(sint(eval(stack_, sp+1))<=sint(eval(stack_, sp))->-1, 0)):sp++}
		Append  func, ge_:=lambda->{Return stack_, sp+1:=uint(if(sint(eval(stack_, sp+1))>=sint(eval(stack_, sp))->-1, 0)):sp++}
		Append  func, ne_:=lambda->{Return stack_, sp+1:=uint(if(eval(stack_, sp+1)<>eval(stack_, sp)->-1, 0)):sp++}
		Append  func, eq_:=lambda->{Return stack_, sp+1:=uint(if(eval(stack_, sp+1)=eval(stack_, sp)->-1, 0)):sp++}
		Append  func, prts_:=lambda->{Print #-2, string$(eval(stack_,sp));: Refresh:sp++}
		Append  func, prti_:=lambda->{Print #-2, str$(sint(eval(stack_,sp)),0);: Refresh:sp++}
		Append  func, prtc_:=lambda->{Print #-2, chrcode$(eval(stack_,sp));: Refresh:sp++}
		Rem : Form 120, 60 ' change console width X height to run Ascii Mandlebrot example
		\\ change Report with Print #-2,   (report stop when scrolling 3/4 of height of console, waiting key or mouse key to continue)
		Print #-2,  "Virtual Assembly Code:"+{
		}+a$
		Print "Prepare Byte Code"
 
		\\ get datasize
		a$=rightpart$(a$, "Datasize:")
		m=0
		data_size=val(a$, "int", m)
		a$=mid$(a$, m)
		\\ make stack
		if data_size>0 then Buffer Clear stack_ as long*data_size
		\\ dim or redim buffer append 1000 long as is.
		Buffer stack_ as long*(1000+data_size)
		\\ get strings
		a$=rightpart$(a$, "Strings:")
		m=0
		strings=val(a$, "int", m)
		a$=rightpart$(a$, nl$)
 
		if strings>0 then
			Dim strings$(strings)
			for i=0 to strings-1
				strings$(i)=GetString$(leftpart$(a$, nl$))
				a$=rightpart$(a$, nl$)
			Next i
		End if
		buffer clear code_ as byte*1000
		do
			m=0
			offset=val(a$,"int", m)
			if m<0 then exit
			a$=mid$(a$,m)
			line$=trim$(leftpart$(a$,nl$))
			if line$="" then line$=trim$(a$) else a$=trim$(rightpart$(a$, nl$))
			op$=if$(instr(line$," ")>0->leftpart$(line$," "), line$)
			if not valid(eval(op$+"_")) then exit
			opc=eval(op$+"_")
			Return code_, offset:=opc
			if opc>=store_ then
				line$=rightpart$(line$," ")
				select case opc
				case store_, fetch_
					Return code_, offset+1:=val(rightpart$(leftpart$(line$,"]"),"[")) as long : offset+=4
				case push_
					Return code_, offset+1:=uint(val(line$)) as long : offset+=4
				case jz_, jmp_
					Return code_, offset+1:=val(rightpart$(line$,")")) as long : offset+=4
				end select 
			end if
		Always
		Print "Press any key" : Push key$ : Drop
		\\ Prepare VM
		let pc=0, sp=len(stack_) div 4
		do
			b=func(eval(code_, pc))
			pc++
			call local b()
		until exit_now
		Print "done"
	}
	Push {
	{
		/*
		This is an integer ascii Mandelbrot generator
		*/
		left_edge= -420;
		right_edge=300;
		top_edge=300;
		bottom_edge = -300;
		x_step=7;
		y_step=15;
 
		max_iter=200;
 
		y0 = top_edge;
		while (y0 > bottom_edge) {
			x0 = left_edge;
			while (x0 < right_edge) {
				y = 0;
				x = 0;
				the_char = ' ';
				i = 0;
				while (i < max_iter) {
					x_x = (x * x) / 200;
					y_y = (y * y) / 200;
					if (x_x + y_y > 800 ) {
						the_char = '0' + i;
						if (i > 9) {
							the_char = '@';
						}
						i = max_iter;
					}
					y = x * y / 100 + y0;
					x = x_x - y_y + x0;
					i = i + 1;
				}
				putc(the_char);
				x0 = x0 + x_step;
			}
			putc('\n');
			y0 = y0 - y_step;
		}
	}
	} 
 
	Form ! 120, 60
	Refresh
	Print "Lexical Analyzer" : Refresh
	lexical_analyzer
	Print "Syntaxl Analyzer" : Refresh
	syntax_analyzer
	Print "Code Generator" : Refresh
	CodeGenerator
	Virtual_Machine_Interpreter
	Set Fast 'restore speed setting
}
CompilerExample

}
MODULE CC {move scale.x/2, scale.y/2
legend "This is centered", "Arial", 22,pi/6,2 , 0
}
MODULE FADE {If not match("NN") then
	Print "Missing two numbers as colors"
	Exit
End If
Read X, Y
Module FadeScreen (&Paint(), tempo) {
      tempo=abs(tempo)
      move 0,0 
      if tempo==0 or tempo<1.3 then tempo=2
      Function GetBack2Buffer  {
            def b$
            def pic(x)=(x div twipsx)*twipsx
            copy pic(scale.x), pic(scale.y) to b$
            move pic(scale.x) div 2, pic(scale.y) div 2
            =image(b$)  ' return Buffer
      }
      Img1=GetBack2Buffer()
      refresh 200
      i=100
      Call Paint()
      Hold
      Repeat {
            Release
            sprite Img1,,,,i-1,1
            refresh 100
            wait (100-i) div 40
            i-=i / tempo
      } until i<1
}
Function PaintBack {
      Gradient X, Y
}

FadeScreen Lazy$(&PaintBack()), 1.7

}
MODULE LIBFADE {Module FadeScreen (&Paint(), tempo) {
      tempo=abs(tempo)
      move 0,0 
      if tempo==0 or tempo<1.3 then tempo=2
      Function GetBack2Buffer  {
            def b$
            def pic(x)=(x div twipsx)*twipsx
            copy pic(scale.x), pic(scale.y) to b$
            move pic(scale.x) div 2, pic(scale.y) div 2
            =image(b$)  ' return Buffer
      }
      Img1=GetBack2Buffer()
      refresh 200
      i=100
      t$=""
      oldrow=row      
      Call Paint()
      move scale.x/2, scale.y/2
      Hold
      Repeat {
            Release
            sprite Img1,1,,,101-i-1,1
            refresh 100
            wait (100-i) div 40
            i-=i / tempo
      } until i<1
      sprite img1
      cls ,oldrow-1
      scroll split 0  ' no split
      
}
Module FadeInScreen (&Paint(), tempo) {
      tempo=abs(tempo)
      move 0,0 
      if tempo==0 or tempo<1.2 then tempo=2
      Function GetBack2Buffer  {
            def b$
            def pic(x)=(x div twipsx)*twipsx
            copy pic(scale.x), pic(scale.y) to b$
            move pic(scale.x) div 2, pic(scale.y) div 2
            =image(b$)  ' return Buffer
      }
      Img1=GetBack2Buffer()
      refresh 200
      i=100
      Call Paint()
      move scale.x/2, scale.y/2
      Hold
      Repeat {
            Release
            sprite Img1,,,,i-1,1
            refresh 100
            wait (100-i) div 40
            i-=i / tempo/2
      } until i<1
}
Module FadeInScreen2 (&Paint(), tempo) {
      tempo=abs(tempo)
      move 0,0 
      if tempo==0 or tempo<1.2 then tempo=2
      Function GetBack2Buffer  {
            def b$
            def pic(x)=(x div twipsx)*twipsx
            copy pic(scale.x), pic(scale.y) to b$
            move pic(scale.x) div 2, pic(scale.y) div 2
            =image(b$)  ' return Buffer
      }
      Img1=GetBack2Buffer()
      release
      refresh 2000
      i=400
      Repeat {
            Call Paint()
            move scale.x/2, scale.y/2
            sprite Img1,,,,min.data(i-1,100),1
            refresh 1000
            wait (100-i) div 40
            i-=i / tempo/4
      } until i<1
}
}
MODULE PP {function dummy {
	ro=row
	p
	cls 5, row-1
	Pen 14
}
Inline Code LibFade
FadeScreen &Dummy(), 1.7
Set Fast
}
MODULE COMP {\\ compose lambda functions
\\ We can put closures (as copy of values, or copy of pointers if a variable is a pointer)

\\ In M2000, there are: Values, Pointers, Refereneces.  Pointers hold Objects. Values maybe objects too. References are just names with no own value or poiner, but refer to another variable
\\ We can use reference to array items, with an internal copy in copy out, method. First interpreter make a hidden variable, copy the item to that variable, then pass the variable to function or module by reference, and at return copy back the variable to the array item (checking if it can be done, maybe the array has change). We can't pass values to references, except of a string. A reference passed as week reference, a string with the a proper name for the variable, to stack of values (as a value), so a Read statement which has & before a name, search for a string, and then resolve it or not. If not raise error. We can read the string (the weakr reference) and read it any other time (a copy of it), if we know that this variable exist. Also there are "string pointer"\\Arrays can passed by reference without copy in copy out (by using a weak reference too)

X=10
k$=weak$(x)
k$.++
Print Eval(k$.)=11
Print x=11
Dim a(10)=100
k$=Weak$(a(5))
k$.++
Print Eval(k$.)=101
Print a(5)=101

Module ByRefArrItemOrVariable(&x) {
	x++
}
ByRefArrItemOrVariable &a(5)
Print a(5)=102
\\ we can add space between name and parameter list
Module ByRefArray1 (&b()) {
	b(5)++
}

ByRefArray1 &a()
Print a(5)=103


\\ we can send the pointer (array is an object)
\\ Interpreter know that we wish to use the pointer, because we choose a name without parenthesis

Module ByRefArray2 (b) {
	Return b, 5:=Array(b,5)+1
	link  b to a()
	a(5)++
}

ByRefArray2 a()
Print a(5)=105

Function ByCopyArray(b()) {
	For i=Dimension(b(), 1,0) to Dimension(b(), 1,1)
		b(i)+=1
	Next i
	=b()
}
Print Dimension(a(), 1,0), Dimension(a(), 1,1)
Dim z()
z()=ByCopyArray(a())
Print z()

\\ We can pass an expression for late evalution:
x=10 
z=3
Module DoSomething(&s()) {
	Print s()
}
DoSomething Lazy$(x**z)   'return 1000
function dummy {
	x++
	=x**z
}
DoSomething Lazy$(&dummy())   'return 1331

function dummy2 {
	Read New k
	x++
	=x**z+k
}
a$=Lazy$(&dummy2())   'return 1331
\\ so now expression is function body in a$
\\ Unremark this to see the definition of function
Rem : Report a$
Module DoSomething2(&s()) {
	Print s(100)
}
DoSomething2 a$
Print Function(a$, 200)


\\ Normally a function can be passed by reference
\\ the reference is the actual code
Def OneLine(X)=X**2+5*x+6
DoSomething2 &OnelIne()    ' 10506
\\ for groups including the reference of group
Group {
	x=100
	Function InGroup {		
	}
	
}

Module CheckFirst {
      RAD = lambda -> number/180*pi
      ASIN = lambda RAD -> {
          Read x : x=Round(x,10)
            If x>=0 and X<1 Then {
                  =RAD(abs(2*Round(ATN(x/(1+SQRT(1-x**2))))))
            } Else.if x==1 Then {
                  =RAD(90)
            } Else error "asin exit limit"
      }
      ACOS=lambda ASIN (x) -> PI/2 - ASIN(x)
      POW3 = Lambda ->number**3
      POW3INV =Lambda ->number**(1/3)
      COSRAD =lambda ->Cos(number*180/pi)
      SINRAD=lambda ->Sin(number*180/pi)
      Composed=lambda (f1, f2) -> {
            =lambda f1, f2 (x)->{
                  =f1(f2(x))
            }
      }
      Dim Base 0, A(3), B(3), C(3)
      A(0)=ACOS, ASIN, POW3INV
      B(0)=COSRAD, SINRAD, POW3
      C(0)=Composed(ACOS, COSRAD), Composed(ASIN, SINRAD), Composed(POW3INV, POW3)
      Print $("0.00")
      For i=0 To 2 {
            Print A(i)(B(i)(.5)), C(i)(.5)
      }
            Print $("")
}
CheckFirst
 
}
MODULE COMP2 {Report {in this example we pass an array A() to function b()
	but instead we have a c() or something we have m so interpreter pass the pointer of array
	we link the pointer to c() so we can use c() as a by reference (but by pointer) pass
		
		Dim A(10)=1000, Z()
		Function b(m) {
			link m to c()
			c(3)=10
			=m
		}
		Z()=b(A())
		Print Z(3), A(3)	
	
	}

Dim A(10)=1000, Z()
Function b(m) {
	link m to c()
	c(3)=10
	=m
}
Z()=b(A())
Print Z(3), A(3)
Report {
	Z() is a copy because this array interface works as a variable, we assign a new value always
	
		Z(3)++
		Print Z(3)<>A(3)
	
	}
Z(3)++
Print Z(3)<>A(3)

Report {We do the same for passing by reference. We can redefine b() at run time. When we return the c() only a pointer returned. The Z() get a copy of array from that pointer.
		
		Function b(&c()) {
			c(3)=100
			=c()
		}
		
		Z()=b(&A())
		Print Z(3), A(3)
		Z(3)++
		Print Z(3)<>A(3)
	}
Function b(&c()) {
	c(3)=100
	=c()
}

Z()=b(&A())
Print Z(3), A(3)
Z(3)++
Print Z(3)<>A(3)
Report {
	Now we do some magic. We make an empty array and put a pointer of it to m. Next we make a reference to m in Z1(). We can't change in Z1() the reference. But reference is not a pointer. Z1() reference to the place which m save the pointer. In fact the interpreter see both identifiers to share common memory for the pointer to array. Now we call the b()
		
		m=(,)
		Link m to Z1()
		m=b(&A())
		Print Z1(3), A(3)
		Z1(3)+=100
		Print Z1(3)<>A(3)
	
	}
m=(,)
Link m to Z1()
m=b(&A())
Print Z1(3), A(3)
Z1(3)+=100
Print Z1(3)<>A(3)
Report {
	 So we get false, because we get a pointer from C() which points to A(), and m now point to A() and Z1()  is a reference of m, so a reference of A(). We can check the objects using IS.
	
		Print Z1() is A(), Z() is A() 
		Print m is A() 
	
	}
Print Z1() is A(), Z() is A()  ' true false
Print m is A()  ' true
}
MODULE CL {Class zz {
      module bb {
            Superclass A {
                  unique:
                  counter
            }
            Superclass B1 {
                  unique:
                  counter
            }
            Superclass B2 {
                  unique:
                  counter
            }
            \\ We can make a group Alfa with a member, another group Beta
            \\ Group Beta can't see parent group, but can see own member groups
            \\ Group Alfa can see everything in nested groups, in any level,
            \\ but can't see inside modules/functions/operator/value/set
            Group Alfa {
                  Group Beta { }
            }
            Alfa=A
            Alfa.Beta=B1
            \\ we make 3 groups for marshaling counters
            \\ each group get a superclass
            Marshal1=A
            Marshal2=B1
            Marshal3=B2
            \\ Now we want to add functionality7
            \\ Inc module to add 1 to counter
            \\ a Value function to return counter
            \\ Without Value a group return a copy
            \\ If a group has a value then we can get copy using Group(nameofgroup)
            \\ just delete Group Marshal1 and remove Rem when we make Marshal1 using a class function
            Group Marshal1 {
                  Module Inc {
                        For SuperClass {.counter++}
                  }
                  Value {
                        For SuperClass {=.counter}
                  }
            }
            Class AnyMarshal {
                  Module Inc {
                        For SuperClass {.counter++}
                  }
                  Value {
                        For SuperClass {=.counter}
                  }
            }
            \\ here we merge groups
            Rem : Marshal1=AnyMarshal()
            Marshal2=AnyMarshal()
            Marshal3=AnyMarshal()
 
            \\ So now we see counters (three zero)
            Print Marshal1, Marshal2, Marshal3 \\ 0, 0, 0
            \\ Now we prepare Alfa and Alfa.Beta groups
            Group Alfa {
                  Group Beta {
                        Function SuperClass.Counter {
                              For SuperClass {
                                    =.counter
                              }           
                        }      
                  }
                  Module PrintData {
                        For SuperClass {
                              Print .counter, This.Beta.SuperClass.Counter()
                        }
                  }
            }
            \\ some marshaling to counters
            Marshal1.inc
            Marshal2.inc
            Marshal2.inc
            Marshal3.inc
            \\ lets print results
            Print Marshal1, Marshal2, Marshal3 \\ 1   2   1
            \\ Calling Alfa.PrintData
            Alfa.PrintData  \\ 1   2
            \\ Merging a group in a group make a change to superclass pointer inside group
            Alfa.Beta=B2 \\ change supeclass
            Alfa.PrintData  \\ 1   1
            For i=1 to 10 : Marshal3.inc : Next i
            Alfa.PrintData  \\ 1   11
            Alfa.Beta=B1 \\ change supeclass
            Alfa.PrintData  \\ 1   2
            Epsilon=Alfa
            Print Valid(@alfa as epsilon), Valid(@alfa.beta as epsilon.beta) \\ -1   -1
            Epsilon.PrintData \\ 1 2
            Alfa.Beta=B2 \\ change supeclass
            Alfa.PrintData  \\ 1   11
            Epsilon.PrintData \\ 1 2
            \\ validation being for top group superclass and all members if are same
            \\ but not for inner superclasses. This maybe change in later revisions of language.
            Print Valid(@alfa as epsilon), Valid(@alfa.beta as epsilon.beta) \\ -1  0
 
      }
}
Dim A(10)
A(3)=zz()
A(3).bb
}
MODULE OOP1 {\\ events without using Event objects
\\ We use weak reference to register events in eventhandler
\\ if A is a variable a &A is a string contain the actuall name of A, and this is a weak reference
\\ Normally when we do a Read &B the read instruction get the string as a name for  a variable  and check if exist as variable
\\ so Read make references from weak references
\\ M2000 has also the pointer. A pointer is different from the reference, because has nothing to do with name of entities
\\ For example  a=(1,2,3,4) set a as a pointer to array. Passing by value a we pass the object by a pointer.
\\ We can pass &a so if we change the array inside a module or funcion, then we get the change back
\\ A weak reference can be stored as string, and maybe later be invalid, if the storage, an array, passed back as return value,
\\ or pushed to stack of values, and the module where we defined the refered entitites, terminate, and clear all own variables.

\\for this example we make "static" groups (as named the user objects in M2000).
\\The word static used for static variables which stay in every call of a module or function, from the same execution object.
\\ (perhaps a thread which is a separate execution object call a module with specific for the thread static variables)
\\ Here we don't use threads. We have one loop, which call one function of the EventHandler, the observe()
\\ if this functions return true then the loop exit, and the program terminate


\\we have three classes (they are global functions, which construct groups)
\\ The mouseListene and the keylistener, and the EventHandler
\\ Inside EventListener we have one more class (this isn't global)
\\ The Widdget class
\\ This class has the state for an event, and used from button function, a member of EventHandler
\\ So with this EventHandler we can make buttons, with a name. The function button() return a Group
\\ So for the example we make three buttons to three named groups, B1, B2 and B3
\\ Each widget has a weak reference to EventHandler and a name, when constructed,
\\ but has no listeners.
\\ Also the listeners have to link to EventHandler, and this is the work of EventList() function
\\ The Eventlist() is a member of EventHandler and get a listener class, and return a handler
\\ To register an event we have to use register method passing the handler and the weak reference and a  button (widget)
\\ So buttons and handlers are entities from EventHandler
\\ The actual events are not part of the EventHandler. They are inside the listeners classes.
\\ Each listener has a contruction member (same name as the class name),
\\ a register member to add more widgets to same listener,
\\ and the  CheckEvent(), which return true if event happen.

\\The EventHandler pass &this  as own weak reference to each new wigdet.
\\The Listeners added to an array inside the EventHandler with a list of weak references to widgets.
\\The observe() function cehck all stored listeners, calling the CheckEcent() on listener.
\\ if an event happen then all subscribers (all widgets) get a call in callback()  function with the name of the event
\\ each widget then using the weak refrence to EventHandler do a query passig an id, an iinfo string (what$) and a reference of it
\\ The query method (module in M2000) use id and what$ to display information, and use reference to read the caption of widget
\\ perhaps the caption may change, so we can't stored this in listener's list in EventHandler.

\\ So from observe(), pressing 1 or 2 keys or mouse key, we can call  one or more  widget's callback(),
\\ which all  call back the query method, which the later read the widget caption.
\\ B1 listen 1 and 2 keys, B2 listen 1 key, B3 listen a mouse key (right key)



Module OOP {
	Set Fast
	cls 1, 0
	pen 14
	report 2, "Event Listener"
	report "Use keys 1, 2 and mouse left, and for exit mouse right"
	cls, 2
	class mouselistener {
	      name$="MousePress",  yourkey,  auto
	      dim ref$()
	      module mouselistener {
	            read .yourkey
	            .name$<=format$("{0}({1})",.name$,.yourkey)
	      }
	      module register {
	            .auto++
	            dim .ref$(.auto)
	            read .ref$(.auto-1)   \\ weak reference
	      }
	      function CheckEvent {
	            =Mouse=.yourkey
	      }
	}
	class keylistener {
	      name$="KeyPress", yourkey, auto
	      dim ref$()
	      module keylistener {
	            read .yourkey
	            .name$<=format$("{0}({1})",.name$,.yourkey)
	      }
	      module register {
	            .auto++
	            dim .ref$(.auto)
	            read .ref$(.auto-1)   \\ weak reference
	      }
	      function CheckEvent {
	            =keypress(.yourkey)
	      }
	}
	class EventHandler {
	      auto, autoevents, EnableEvents
	      Dim Events()
	      class widget {
	            \\ in classes we can define variables without value
	            ref$  \\ weak reference
	            id, caption$, Enabled=True
	            module linkme {
	                  read .ref$
	            }
	            module widget {  \\ this is used as construction function, but is a module
	                  read .id
	                  read .caption$
	            }
	            function Callback {
	                  read some$
	                  push .ref$ : read &ref  \\ this is the link
	                  =ref.query(.id, some$, &this)
	            }
	      }
	      function button {    \\ this is the button construction
	         .auto++
	         read txt$
	         makeme =.widget(.auto,txt$)  
	         makeme.linkme &this
	         =makeme   \\ we make a group a floating group to export
	      }
	      function EventList {
	            handle=.autoevents  \\ we execute some commands..
	            .autoevents++
	            dim .Events(.autoevents)
	            read .Events(handle)   \\ .. and then we can read function parameter
	            =handle
	      }
	      module register {
	           read handler, ref$
	            .Events(handler).register  ref$
	      }
	     function observe {
	     if not .EnableEvents then =true : exit
	           print "observe for events"
	           for i=0 to .autoevents-1 {
	                 for .Events(i) {
	                        if  .checkevent() then {
	                              for j=0 to .auto-1 {
	                                    for this {     \\ we use a for this {} to make temporary variables
	                                                           \\ because we can't relink a link.  so we make a fresh here
	\\              the link statement to this:    push  .ref$(j) : read &Link
	                                          link weak .ref$(j) to &link
	                                          call link.callback(.name$)
	                                     }
	                                }
	                        }
	                 }
	           }
	     }
	      function query {
	            read id, what$, &nicesmallgroup
	            print under "Inside EventHandler";
	            print under
	            print  part "I get a query from a widget object ";id
	            print
	            print part "Say:";what$
	            print
	            for nicesmallgroup {
	                  Print part "I get the caption:";.caption$
	                  print
	                  =0
	            }
	      }
	}
	EventHandler=EventHandler()  \\ create handler
	B1=EventHandler.button("Button1")  \\ create subjects
	B2=EventHandler.button("Button2") 
	B3=EventHandler.button("Button3") 
	
	for EventHandler {
	      PressKeyOne=.Eventlist(keylistener(49))
	      .Register  PressKeyOne, &B1  \\register event to subject
	      .Register  PressKeyOne, &B2 
	      .Register .Eventlist(keylistener(50)) , &B1 
	      .Register .Eventlist(Mouselistener(1)) , &B3 
	      .EnableEvents=True  
	}
	every 150 {
	      if EventHandler.observe() then exit
	      if mouse=2 then exit
	} 
}
OOP
Keyboard "info"+chr$(13)
}
MODULE OOP1GR {
Φορμα 80,40
Οθόνη 1, 0
Πένα 14
Αναφορά 2, "Χειριστής Γεγονότων"
Αναφορά "Χρησιμοποίησε πλήκρα 1, 2 και Δείκτης (ποντίκι) Αριστερά, και για έξοδο Δείκτης Δεξιά"
Οθόνη, 2
Κλάση Υπηρεσία_Δείκτη {
Ιδιωτικό:
      αθροιστής,  το_κουμπί_μου
Δημόσιο:      
      όνομα$="Πλήκτρο_Δείκτη"
      Πίνακας αναφ$()
      Τμήμα Υπηρεσία_Δείκτη {
            Διάβασε .το_κουμπί_μου
            .όνομα$<=μορφή$("{0}({1})", .όνομα$, .το_κουμπί_μου)
      }
      Τμήμα καταχώρησε {
            .αθροιστής++
            Πίνακας .αναφ$(.αθροιστής)
            Διάβασε .αναφ$(.αθροιστής-1) 
      }
      Συνάρτηση Επιβεβαίωση {
            =Δείκτης=.το_κουμπί_μου
      }
      Συνάρτηση αθροιστής {
            =.αθροιστής-1
      }
}
Κλάση Υπηρεσία_Πλήκτρου {
Ιδιωτικό:
      αθροιστής,  το_κουμπί_μου
Δημόσιο:      
      όνομα$="Πλήκτρο",
      Πίνακας αναφ$()
      Τμήμα Υπηρεσία_Πλήκτρου {
            Διάβασε .το_κουμπί_μου
            .όνομα$<=μορφή$("{0}({1})", .όνομα$, .το_κουμπί_μου)
      }
      Τμήμα καταχώρησε {
            .αθροιστής++
            Πίνακας .αναφ$(.αθροιστής)
            Διάβασε .αναφ$(.αθροιστής-1) 
      }
      Συνάρτηση Επιβεβαίωση {
            =Πατημένο(.το_κουμπί_μου)
      }
      Συνάρτηση αθροιστής {
            =.αθροιστής-1
      }
}
Κλάση Χειριστής_Γεγονότων {
Ιδιωτικό:
      αθροιστής, αθροιστής_γεγονότων
      Πίνακας Γεγονότα()      
      Κλάση Στοιχείο_Ελέγχου {
      Ιδιωτικό:
            αναφ$, 
            αναγνωριστικό, ονομασία$, Επιτρέπεται=Αληθής
       Δημόσιο:
            Τμήμα Σύνδεσε {
                  Διάβασε .αναφ$
            }
            Τμήμα Στοιχείο_Ελέγχου { 
                  Διάβασε .αναγνωριστικό
                  Διάβασε .ονομασία$
            }
            Συνάρτηση Ονομασία$ {
                  =.ονομασία$
            }
            Συνάρτηση Κάλεσε_Πίσω {
                  Διάβασε περιγραφή$
                  Ένωσε Ισχνή .αναφ$  Στη αναφ 
                  =αναφ.Ερώτημα(.αναγνωριστικό, περιγραφή$, &Αυτό)
            }
      }
Δημόσιο:     
      Επιτρέπω_Γεγονότα 
      Συνάρτηση Στοιχείο_Πλήκτρο {   
         .αθροιστής++
         Διάβασε περιγραφή$
         φτιάξε_με =.Στοιχείο_Ελέγχου(.αθροιστής,περιγραφή$)  
         φτιάξε_με.Σύνδεσε &Αυτό
         =φτιάξε_με
      }
      Συνάρτηση Λίστα_Γεγονότων {
            χειριστής=.αθροιστής_γεγονότων 
            .αθροιστής_γεγονότων++
            Πίνακας .Γεγονότα(.αθροιστής_γεγονότων)
            Διάβασε .Γεγονότα(χειριστής)
            =χειριστής
      }
      Τμήμα καταχώρησε {
           Διάβασε χειριστής, αναφ$
            .Γεγονότα(χειριστής).καταχώρησε  αναφ$
      }
     Συνάρτηση Παρατήρησε {
     Αν Δεν .Επιτρέπω_Γεγονότα Τότε =Αληθής : Έξοδος
     Τύπωσε "Παρατηρώ για Γεγονότα"
           Για ν=0 Έως .αθροιστής_γεγονότων-1 {
                 Για .Γεγονότα(ν) {
                        Αν  .Επιβεβαίωση() Τότε {
                              Για μ=0 Έως .αθροιστής() {
                                    Για Αυτό {
                                          Ένωσε Ισχνή .αναφ$(μ) στη Σύνδεση
                                          Κάλεσε Σύνδεση.Κάλεσε_Πίσω(.όνομα$)
                                     }
                                }
                        }
                 }
           }
     }
      Συνάρτηση Ερώτημα {
            Διάβασε αναγνωριστικό, περιγραφή$, &Στοιχείο_Ελέγχου
            Τύπωσε υπό "Μέσα στο Χειριστής_Γεγονότων";
            Τύπωσε υπό
            Τύπωσε  μέρος "Έλαβα ένα ερώτημα από το Στοιχείο_Ελέγχου με αριθμό "; αναγνωριστικό
            Τύπωσε
            Τύπωσε μέρος "Λέει:"; περιγραφή$
            Τύπωσε
            Για Στοιχείο_Ελέγχου {
                  Τύπωσε μέρος "Πήρα αυτή την ονομασία:";.ονομασία$()
                  Τύπωσε
                  =0
            }          
      }
}
Χειριστής_Γεγονότων=Χειριστής_Γεγονότων()  \\ δημιουργούμε τον χειριστή
β1=Χειριστής_Γεγονότων.Στοιχείο_Πλήκτρο("Πλήκτρο 1")  \\ δημιουργούμε υποκείμενα
β2=Χειριστής_Γεγονότων.Στοιχείο_Πλήκτρο("Πλήκτρο 2") 
β3=Χειριστής_Γεγονότων.Στοιχείο_Πλήκτρο("Πλήκτρο 3") 

Για Χειριστής_Γεγονότων {
      Πάτα_πλήκτρο_ένα=.Λίστα_Γεγονότων(Υπηρεσία_Πλήκτρου(49))
      .καταχώρησε  Πάτα_πλήκτρο_ένα, ισχνη$(β1)  \\καταχώρησε γεγονός στο υποκείμενο
      .καταχώρησε  Πάτα_πλήκτρο_ένα, ισχνη$(β2)
      .καταχώρησε .Λίστα_Γεγονότων(Υπηρεσία_Πλήκτρου(50)) , ισχνή$(β1) 
      .καταχώρησε  .Λίστα_Γεγονότων(Υπηρεσία_Δείκτη(1)) , ισχνη$(β3)
      .Επιτρέπω_Γεγονότα=Αληθής  
}
Κάθε 150 {
      Αν Χειριστής_Γεγονότων.Παρατήρησε() Τότε Έξοδος
      Αν Δείκτης=2 Τότε Έξοδος
} 

}
MODULE OOP2 {\\ LIKE OOP1
\\ MOUSELISENER IS A CLASS WICH USE NOW CLASS LISTENER
\\ ANY PART AFTER CLASS: IS FOR CINSTRUCTION ONLY, AND NEVER SAVED TO FINAL OBJECT
\\ SO LISTENER CONSTRUCTOR AND MOUSELISTENER CONSTRUCTOR NOT SAVED, JUS USED ONCE
\\ THE SAME HOLD FOR KEYLISTENER



Module OOP {
	Set Fast
	cls 1, 0
	pen 14
	report 2, "Event Listener"
	report "Use keys 1, 2 and mouse left, and for exit mouse right"
	cls, 2
	class listener {
	      name$,  yourkey, auto
	      dim ref$()
	      module final register {
	            .auto++
	            dim .ref$(.auto)
	            read .ref$(.auto-1)   \\ weak reference
	      }
	      function CheckEvent {
	            =false
	      }
	class:
	      module listener {
	            read .yourkey
	            .name$<=format$("{0}({1})", letter$,.yourkey)
	      }
	}
	\\ one way is to make final before adding the listener
	class mouselistener {
                  function final CheckEvent {
                                 =Mouse=.yourkey	                        
                  }
	class:
	      module mouselistener (x) {
	            this=listener(x, "MousePress")
	      }
	}
	\\ the other way is to add definitions to a group after adding listener
	\\ also ![] add stack of the call to the next call
	\\ so we didn't use x variable
	class keylistener {
	class:
	      module keylistener {
	            a=listener(![], "KeyPress")
	            group a {
	                  function final CheckEvent {
	                        =keypress(.yourkey)
	                  }
	            }
	            this=a
	      }
	}
	class EventHandler {
	      auto, autoevents, EnableEvents
	      Dim Events()
	      class widget {
	            \\ in classes we can define variables without value
	            ref$  \\ weak reference
	            id, caption$, Enabled=True
	            module linkme {
	                  read .ref$
	            }
	            module widget {  \\ this is used as construction function, but is a module
	                  read .id
	                  read .caption$
	            }
	            function Callback {
	                  read some$
	                  push .ref$ : read &ref  \\ this is the link
	                  =ref.query(.id, some$, &this)
	            }
	      }
	      function button {    \\ this is the button construction
	         .auto++
	         read txt$
	         makeme =.widget(.auto,txt$)  
	         makeme.linkme &this
	         =makeme   \\ we make a group a floating group to export
	      }
	      function EventList {
	            handle=.autoevents  \\ we execute some commands..
	            .autoevents++
	            dim .Events(.autoevents)
	            read .Events(handle)   \\ .. and then we can read function parameter
	            =handle
	      }
	      module register {
	           read handler, ref$
	            .Events(handler).register  ref$
	      }
	     function observe {
	     if not .EnableEvents then =true : exit
	           print "observe for events"
	           for i=0 to .autoevents-1 {
	                 for .Events(i) {
	                        if  .checkevent() then {
	                              for j=0 to .auto-1 {
	                                    for this {     \\ we use a for this {} to make temporary variables
	                                                           \\ because we can't relink a link.  so we make a fresh here
	\\              the link statement to this:    push  .ref$(j) : read &Link
	                                          link weak .ref$(j) to &link
	                                          call link.callback(.name$)
	                                     }
	                                }
	                        }
	                 }
	           }
	     }
	      function query {
	            read id, what$, &nicesmallgroup
	            print under "Inside EventHandler";
	            print under
	            print  part "I get a query from a widget object ";id
	            print
	            print part "Say:";what$
	            print
	            for nicesmallgroup {
	                  Print part "I get the caption:";.caption$
	                  print
	                  =0
	            }          
	      }
	}
	EventHandler=EventHandler()  \\ create handler
	B1=EventHandler.button("Button1")  \\ create subjects
	B2=EventHandler.button("Button2") 
	B3=EventHandler.button("Button3") 
	
	for EventHandler {
	      PressKeyOne=.Eventlist(keylistener(49))
	      .Register  PressKeyOne, &B1  \\register event to subject
	      .Register  PressKeyOne, &B2 
	      .Register .Eventlist(keylistener(50)) , &B1 
	      .Register .Eventlist(Mouselistener(1)) , &B3 
	      .EnableEvents=True  
	}
	every 150 {
	      if EventHandler.observe() then exit
	      if mouse=2 then exit
	} 
}
OOP
Keyboard "info"+chr$(13)
}
MODULE EM {Module Checkit {
      ' erase stack of values, so we can add data
      Flush
      Report "Top rank per group"
      Report "Find the top   N   salaries in each department,   where   N   is provided as a parameter. "
10  Input "N%=",N%
      if N%<1 then 10
      Enum Departments {D050,D101,D190,D202}

      \\ Inventroy Department need unique keys
      Inventory Department
      \\ each item in this inventory should be an inventory too
      Class Empl {
            name$, id$, salary
            Class:
            Module Empl(.name$, .id$, .salary) {}
      }
      Data "Tyler Bennett",		"E10297", 32000, D101
      Data "John Rappl",		"E21437", 47000, D050
      Data "George Woltman",	"E00127", 53500, D101
      Data "Adam Smith",		"E63535", 18000, D202
      Data "Claire Buckman",		"E39876", 27800, D202
      Data "David McClellan",		"E04242", 41500, D101
      Data "Rich Holcomb",		"E01234", 49500, D202
      Data "Nathan Adams",		"E41298", 21900, D050
      Data "Richard Potter",		"E43128", 15900, D101
      Data "David Motsinger",	"E27002", 19250, D202
      Data "Tim Sampair",		"E03033", 27000, D101
      Data "Kim Arlich",			"E10001", 57000, D190
      Data "Timothy Grove",		"E16398", 29900, D190
      Data ""
      Read name$
      While name$<>""  {
            Read id$, salary, dep
            Rem : Print name$, id$, salary, dep
            If Exist(Department, dep) Then {
                  z=Eval(Department)    ' get pointer to inventory
                  AppendOne()            
            } Else {
                  z=queue
                  AppendDep()            
                  AppendOne()
            }
            Read name$
      }
      Sort Department as number
      i=each(Department)
      \\ make depname as type of Departments
      depname=D050
      oldtab=tab
      Print $(4),
      Print over ~(1, 7),@(10), $(4,6),"Dep." ,@(16), $(4,20), "Employee Name",$(6,8), "Emp. ID", "Salary"
      Print Under
      Print $(4),
      While i {
            \\ when we pass a number to a enum variable
            \\ if the number exist, get that enum item else raise error
            depname=val(eval$(i, i^))
            \\ z is a pointer to inventory 
            z=Eval(i)
            Sort descending z as number
            k=each(z,1,N%)
            While k {
                  Empl=Eval(k)
                  For Empl {
                        \\ eval$(depname) return the name of enum variable (like D050)
'                        Print Format$("{0:6}{1:20}{2:8}{3::-8}",Eval$(depname), .name$, .id$, .salary)
			Print Part $(4,10),"", $(4,6),~(15,2), Eval$(depname),@(16), $(4,20), ~(14), .name$,$(6, 8), ~(pen,2),.id$, ~(14),.salary
			Print under
                  }
            }
      }
      Print $(4),"Done", $(0)
      Sub AppendDep()
            Append Department, dep:=z
      End Sub
      Sub AppendOne()
                  Append z, salary:=Empl(name$, id$, salary)
      End Sub
}
Checkit 
}
MODULE TRAVERSAL {Report {
          Tree traversal
                   1
                  / \
                 /   \
                /     \
               2       3
              / \     /
             4   5   6
            /       / \
           7       8   9

} 
Pen 15 {Print "Using tuple (arrays)"}
Print
Module CheckIt {
      Null=(,)
      Tree=((((Null,7,Null),4,Null),2,(Null,5,Null)),1,(((Null,8,Null),6,(Null,9,Null)),3,Null))
      
      Module preorder (T) {
            Print "preorder:    ";
            printtree(T)
            Print
            sub printtree(T)
                  Print T#val(1);" ";      
                  If len(T#val(0))>0 then printtree(T#val(0))
                  If len(T#val(2))>0 then printtree(T#val(2))
            end sub
      }
      preorder Tree
      
      Module inorder (T) {
            Print "inorder:     ";
            printtree(T)
            Print
            sub printtree(T)
                  If len(T#val(0))>0 then printtree(T#val(0))
                  Print T#val(1);" ";
                  If len(T#val(2))>0 then printtree(T#val(2))
            end sub
      }
      inorder Tree
      
      Module postorder (T) {
            Print "postorder:   ";
            printtree(T)
            Print
            sub printtree(T)
                  If len(T#val(0))>0 then printtree(T#val(0))
                  If len(T#val(2))>0 then printtree(T#val(2))
                  Print T#val(1);" ";
            end sub
      }
      postorder Tree
      
      Module level_order (T) {
            Print "level-order: ";
            Stack New {
                  printtree(T)
                  if empty then exit
                  Read T
                  Loop
            }
            Print
            sub printtree(T)
                  If Len(T)>0 then
                        Print T#val(1);" ";
                        Data T#val(0), T#val(2)
                  end if
            end sub
      }
      level_order Tree
      Print
}
CheckIt
Pen 15 {Print "Using OOP - passing objects to modules"}
Print
Module OOP {
      \\ Class is a global function (until this module end)
      Class Null {
      }
      \\ Null is a pointer to an object returned from class Null()
      Global Null->Null()
      Class Node {
      Public:
            x, Group LeftNode, Group RightNode
      Class:
            \\ after class:  anything exist one time,
            \\ not included in final object
            Module Node {
                  .LeftNode<=Null
                  .RightNode<=Null
                  Read .x
                  \\ read ? for optional values
                  Read ? .LeftNode, .RightNode
            }
      }
      \\ NodeTree return a pointer to a new Node
      Function NodeTree {
            \\ ![] pass currrent stack to Node()
            ->Node(![])
      }
 
      Tree=NodeTree(1, NodeTree(2,NodeTree(4, NodeTree(7)), NodeTree(5)), NodeTree(3, NodeTree(6, NodeTree(8), NodeTree(9))))
 
      Module preorder (T) {
            Print "preorder:    ";
            printtree(T)
            Print
            sub printtree(T as pointer)
                  If T is Null then Exit sub
                  Print T=>x;" ";
                  printtree(T=>LeftNode)
                  printtree(T=>RightNode)
            end sub
      }
      preorder Tree
      Module inorder (T) {
            Print "inorder:     ";
            printtree(T)
            Print
            sub printtree(T as pointer)
                  If T is Null then Exit sub
                  printtree(T=>LeftNode)
                  Print T=>x;" ";
                  printtree(T=>RightNode)
            end sub
      }
      inorder Tree
      Module postorder (T) {
            Print "postorder:   ";
            printtree(T)
            Print
            sub printtree(T as pointer)
                  If T is Null then Exit sub
                  printtree(T=>LeftNode)
                  printtree(T=>RightNode)            
                  Print T=>x;" ";
            end sub
      }
      postorder Tree
      Module level_order (T) {
            Print "level-order: ";
            Stack New {
                  printtree(T)
                  if empty then exit
                  Read T
                  Loop
            }
            Print
            sub printtree(T as pointer)
                  If T is Null else
                        Print T=>x;" ";
                        Data T=>LeftNode, T=>RightNode
                  end if
            end sub
      }
      level_order Tree
      Print
}
OOP
Pen 15 {Print "Using OOP - modules are members of objects "}
Module OOP {
      \\ Class is a global function (until this module end)
      Class Null {
      }
      \\ Null is a pointer to an object returned from class Null()
      Global Null->Null()
      Class Node {
      Public:
            x, Group LeftNode, Group RightNode
            Module preorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T as pointer)
                        If T is Null then Exit sub
                        call visitor(T=>x)
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)
                  end sub
            }
            Module inorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T as pointer)
                        If T is Null then Exit sub
                        printtree(T=>LeftNode)
                        call visitor(T=>x)
                        printtree(T=>RightNode)
                  end sub
            }
            Module postorder (visitor) {
                  T->This
                  printtree(T)
                  sub printtree(T as pointer)
                        If T is Null then Exit sub
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)            
                        call visitor(T=>x)
                  end sub
            }
            Module level_order (visitor){
                  T->This
                  Stack New {
                        printtree(T)
                        if empty then exit
                        Read T
                        Loop
                  }
                  sub printtree(T as pointer)
                        If T is Null else
                              call visitor(T=>x)
                              Data T=>LeftNode, T=>RightNode
                        end if
                  end sub
            }
      Class:
            \\ after class:  anything exist one time,
            \\ not included in final object
            Module Node {
                  .LeftNode<=Null
                  .RightNode<=Null
                  Read .x
                  \\ read ? for optional values
                  Read ? .LeftNode, .RightNode
            }
      }
      \\ NodeTree return a pointer to a new Node
      Function NodeTree {
            \\ ![] pass currrent stack to Node()
            ->Node(![])
      }
 
      Tree=NodeTree(1, NodeTree(2,NodeTree(4, NodeTree(7)), NodeTree(5)), NodeTree(3, NodeTree(6, NodeTree(8), NodeTree(9))))
 
      printnum=lambda (title$) -> {
            Print
            Print title$;
            =lambda (x)-> {
                  Print x;" ";
            }
      }
      Tree=>preorder printnum("preorder:    ")
      Tree=>inorder printnum("inorder:     ")
      Tree=>postorder printnum("postorder:   ")
      Tree=>level_order printnum("level-order: ")
      Print
      Print
}
OOP
Pen 15 {Print "OOP - Event object as visitor"}
Module OOP {
      \\ Class is a global function (until this module end)
      Class Null {
      }
      \\ Null is a pointer to an object returned from class Null()
      Global Null->Null()
      Class Node {
      Public:
            x, Group LeftNode, Group RightNode
            Module preorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T as pointer)
                        If T is Null then Exit sub
                        call event visitor, T=>x
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)
                  end sub
            }
            Module inorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T as pointer)
                        If T is Null then Exit sub
                        printtree(T=>LeftNode)
                        call event visitor, T=>x
                        printtree(T=>RightNode)
                  end sub
            }
            Module postorder (visitor) {
                  T->This
                  printtree(T)
                  sub printtree(T as pointer)
                        If T is Null then Exit sub
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)            
                        call event visitor, T=>x
                  end sub
            }
            Module level_order (visitor){
                  T->This
                  Stack New {
                        printtree(T)
                        if empty then exit
                        Read T
                        Loop
                  }
                  sub printtree(T as pointer)
                        If T is Null else
                              call event visitor, T=>x
                              Data T=>LeftNode, T=>RightNode
                        end if
                  end sub
            }
      Class:
            \\ after class:  anything exist one time,
            \\ not included in final object
            Module Node {
                  .LeftNode<=Null
                  .RightNode<=Null
                  Read .x
                  \\ read ? for optional values
                  Read ? .LeftNode, .RightNode
            }
      }
      \\ NodeTree return a pointer to a new Node
      Function NodeTree {
            \\ ![] pass currrent stack to Node()
            ->Node(![])
      }
 
      Tree=NodeTree(1, NodeTree(2,NodeTree(4, NodeTree(7)), NodeTree(5)), NodeTree(3, NodeTree(6, NodeTree(8), NodeTree(9))))
      Event PrintAnum {
            read x
      }
      Function PrintThis(x) {
                Print x;" ";      
      }
      Event PrintAnum New PrintThis()
      printnum=lambda PrintAnum (title$) -> {
            Print
            Print title$;
            =PrintAnum
      }
      Tree=>preorder printnum("preorder:    ")
      Tree=>inorder printnum("inorder:     ")
      Tree=>postorder printnum("postorder:   ")
      Tree=>level_order printnum("level-order: ")
}
OOP
}
MODULE PERM1 {Report "A program that performs a permutation test to judge whether the treatment had a significantly stronger effect than the placebo. "
Print "Treatment group "
Print 85, 88, 75, 66, 25, 29, 83, 39, 97
Print "Control group"
Print 68, 41, 10, 49, 16, 65, 32, 92, 28, 98
Print "Please wait about 4.5 minutes  - Use ctrl-C to exit any time"
Refresh
Module Checkit {
      Global data(), treat=0
      data()=(85, 88, 75, 66, 25, 29, 83, 39, 97,68, 41, 10, 49, 16, 65, 32, 92, 28, 98)
      total=1
      For i=0 to 8 {treat+=data(i)}
      For i=19 to 11 {total*=i}
      For i=9 to 1 {total/=i}
      Profiler
      gt=@pick(19,9,0)
      Print "Minutes:";Timecount/1000/60
      le=total-gt
      Print Format$("<= : {0:1}% {1}", 100*le/total, le)
      Print Format$(" > : {0:1}% {1}", 100*gt/total, gt)
      End
      Function pick(at, remain, accu)
            If remain Else =If(accu>treat->1,0):Exit Function
            =@pick(at-1,remain-1,accu+data(at-1))+If(at>remain->@pick(at-1, remain, accu),0)
      End Function
}
Checkit
}
MODULE ITER {Print "Associative array/Iteration"
Module checkit {
      \\ Inventories are objects with keys and values, or keys (used as read only values)
      \\ They use hash function.
      \\ Function TwoKeys return Inventory object (as a pointer to object)
      Function TwoKeys {
            Inventory Alfa="key1":=100, "key2":=200
            =Alfa
      }
      M=TwoKeys()
      Print Type$(M)="Inventory"
      \\ Normal Use:
            \\ Inventories Keys are case sensitive
            \\ M2000 identifiers are not case sensitive
      Print M("key1"), m("key2")
      \\ numeric values can convert to strings
      Print M$("key1"), m$("key2")
      \\ Iteration
      N=Each(M)
      While N {
            Print Eval(N)  ' prints 100, 200 as number
            Print M(N^!)  ' The same using index N^
      }
      N=Each(M)
      While N {
            Print Eval$(N)  ' prints  100, 200 as strings
            Print M$(N^!)  ' The same using index N^
      }
      N=Each(M)
      While N {
            Print Eval$(N, N^)  ' Prints Keys
      }
      \\ double iteration
      Append M, "key3":=500
      N=Each(M, 1, -1)  ' start to end
      N1=Each(M, -1, 1) ' end to start
      \\ 3x3 prints
      While N {
            While N1 {
                  Print format$("{0}*{1}={2}", Eval(N1), Eval(N), Eval(N1)*Eval(N))
            }
      }
      \\ sort results from lower product to greater product (3+2+1, 6 prints only)
      N=Each(M, 1, -1)  
      While N {
            N1=Each(M, N^+1, -1) 
            While N1 {
                  Print format$("{0}*{1}={2}", Eval(N1), Eval(N), Eval(N1)*Eval(N))
            }
      }
      N=Each(M)
      N1=Each(M,-2, 1)  ' from second from end to start
      \\ print only 2 values. While block ends when one iterator finish
      While N, N1 {
            Print Eval(N1)*Eval(N)
      }         
}
Checkit
}
MODULE ST {Print "A stack object"
Module Checkit {
      a=Stack
      Stack a {
            Push 100, 200, 300
      }
      Print StackItem(a, 1)=300
      Stack a {
            Print StackItem(1)=300
            While not empty {
                  Read N
                  Print N
            }
      }
}
Checkit
}
MODULE ST1 {Print "Current Stack"
Module Checkit {
      Read a, b
      Print a, b
}
\\ add parameters in a FIFO, and this FIFO merged to current stack
Push 100
Checkit 10, 20
Print StackItem(1)=100
Module Checkit {
      Read a, b
      Print a=20, b=100
}
Checkit 20
 
Function alfa {
      k=0
      n=0
      while not empty {
            k+=number
            n++
      }
      if n=0 then Error "No parameters found"
      =k/n
}
 
Print alfa(1,2,3,4)=2.5
}
MODULE MAZE2 {Module Maze2 {
      \\ depth-first search
      While Inkey$<>"" {}  ' drop keys
      Const View as boolean=True
      Def tc

      Form 80,50
again:
      Gradient 5,6
      Cursor 0,0
      let w=random(2,6)*10, h=random(1,4)*10, slice=w*h div 30
      let  slice=if(slice=0->1, slice) : counter =1 
      Double
      \\center proportional text double size
      Report 2, Format$("Maze {0}x{1}",w,h)
      Normal
      Hold
      Refresh
      Set Fast !
      stack new {
            Profiler
            Dim maze$(1 to w+1, 1 to h+1)="#"
            Include=Lambda w,h (a,b) ->a>=1 and a<=w and b>=1 and b<=h
            Flush ' empty stack
            if random(1,2)=1 then
                  entry=(if(random(1,2)=1->2, w),Random(1, h/2)*2)
            else
                  entry=(random(1,w/2)*2,If(Random(1,2)=1->2,h))
            end if
            maze$(entry#val(0), entry#val(1))=" "
            forchoose=(,)
            Push Entry
            do
                  do
                        NewForChoose(!entry)
                        status=len(forchoose)
                        if status>0 then
                              status--
                              forchoose=forchoose#val(random(0,status))
                              Push forchoose
                              OpenDoor(!Entry, !forchoose)
                              if view then counter=if(counter=0->slice, counter-1) : if counter=0 then ShowMaze()      
                        else
                              exit
                        end if
                        entry=forchoose
                  Always
                  if empty then exit
                  Read entry
            Always
            tc= timecount/1000
      }
       ShowMaze()
      Cursor 0,Height-1
      Print Part $(6,width), ~(15,0,0),"Press a key o rmouse button after any drawing of the maze to exit  - "+format$("{0:3}",tc)
      Refresh
      counter=10
      every 200 {
            counter--
            if inkey$<>"" or mouse<>0 then counter=-1 : exit
            if counter<1 then exit
      }
      if counter=0 then Release : goto again
      End
      Sub NewForChoose(x,y)
            Local x1=x-2, x2=x+2, y1=y-2, y2=y+2, arr=(,)
            Stack New {
                  if include(x1,y) then if Maze$(x1,y)<>" " Then push (x1, y) 
                  if include(x2,y) then if Maze$(x2,y)<>" " Then push (x2, y)
                  if include(x,y1) then if Maze$(x,y1)<>" " Then push (x, y1)
                  if include(x,y2) then if Maze$(x,y2)<>" " Then push (x, y2)
                  forchoose= Array([])
            }
      End Sub
      Sub OpenDoor(x1,y1, x2,y2)
            Local i
            if x1=x2 then
                  y1+=y2<=>y1
                  for i=y1 to y2 {maze$(x1, i)=" " } 
            Else
                  x1+=x2<=>x1
                  for i=x1 to x2 {maze$(i, y1)=" "}                   
            End if
      End Sub
      Sub ShowMaze()
            Refresh 5000
Rem            cls ,4  ' split screen - preserve lines form 0 to 3
            Release
            cursor 0,(height-h) div 2
            Local i, j, t=40-w div 2
            For j=1 to h+1 { Print @(t) : for i=1 to w+1 {Print maze$(i,j);}:Print}
            Print
            Refresh 100
      End Sub     
}
Maze2
Cursor 0,0
keyboard "info"+chr$(13)

}
MODULE MAZE {Module Maze {
      width% = 40
      height% = 20
      \\ we can use DIM maze$(0 to width%,0 to  height%)="#"
      \\ so we can delete the two For loops
      DIM maze$(0 to width%,0 to  height%)
      FOR x% = 0 TO width%
          FOR y% = 0 TO height%
              maze$(x%, y%) = "#"
          NEXT y%
      NEXT x%
 
      currentx% = INT(RND * (width% - 1))
      currenty% = INT(RND * (height% - 1))
 
      IF currentx% MOD 2 = 0 THEN currentx%++
      IF currenty% MOD 2 = 0 THEN currenty%++
      maze$(currentx%, currenty%) = " "
 
      done% = 0
      WHILE done% = 0 {
          FOR i% = 0 TO 99
              oldx% = currentx%
              oldy% = currenty%
              SELECT CASE INT(RND * 4)
                  CASE 0
                      IF currentx% + 2 < width% THEN currentx%+=2
                  CASE 1
                      IF currenty% + 2 < height% THEN currenty%+=2
                  CASE 2
                      IF currentx% - 2 > 0 THEN currentx%-=2
                  CASE 3
                      IF currenty% - 2 > 0 THEN currenty%-=2
              END SELECT
              IF maze$(currentx%, currenty%) = "#"  Then {
                  maze$(currentx%, currenty%) = " "
                  maze$(INT((currentx% + oldx%) / 2), ((currenty% + oldy%) / 2)) = " "
             }
          NEXT i%
          done% = 1
          FOR x% = 1 TO width% - 1 STEP 2
              FOR y% = 1 TO height% - 1 STEP 2
                  IF maze$(x%, y%) = "#" THEN done% = 0
              NEXT y%
          NEXT x%
      }
 
 
      FOR y% = 0 TO height%
          FOR x% = 0 TO width%
              PRINT maze$(x%, y%);
          NEXT x%
          PRINT
      NEXT y%
}
Maze
}
MODULE MINESWEEPER {Module Minesweeper {
      Font "Arial Black"
      Bold 0
      Form 60,40
      Refresh 1000
      Def com$, com_label$
      Def x, b_row, b_col, where, top_where
      Def rows=6, columns=8, swap_first%
      Def boolean skiptest, end_game, cheat
      Dim Board$(0 to rows+1, 0 to columns+1)="? "
      Def mines%, i%, j%, used%, acc%, n%, m%
      mines%=max.data(random(int(columns*rows*.1),int(columns*rows*.2)-1), 1)
      For i%=1 to rows:For j%=1 to columns
            Board$(i%,j%)=". "
      Next j%:Next i%
      used%=mines%
      While used%
            used%--
            Do
                  i%=random(1,rows)
                  j%=random(1, columns)
            Until right$(Board$(i%,j%),1)=" "
            Board$(i%,j%)=".*"
      End While
      used%=rows*columns-mines%
      \\ remove rem so to never loose from first open
      Rem : 
      swap_first%=used%
      \\ when mines%=0 or used%=0 then player win
      Report {Minesweeper - rosettacode task
            Commands:
            -  ? 1 2  flag/unflag 1 2
            -  1 2   open 1 2
            -  q  to quit
            You can pass multiple commands in a line, but q erase all before execute
      } 
      top_where=Row
      While not End_Game {GameLoop()}
      End
      Sub PrintBoard()
      Cls, top_where
      Print
      Print "   X  ";
      For j%=1 to columns {
            Print format$("{0::-3}  ", j%);
      }
      Print
      For i%=1 to rows {
            Print format$(" {0::-3}  ", i%);
            For j%=1 to columns {
                  Print "  ";Left$(Board$(i%,j%),1);"  ";
                  \\ rem above and unrem follow line to display mines
                  Rem: Print "  ";Board$(i%,j%)+" ";
            }
            Print
      }      
      End Sub
      Sub PrintMines()
      Cls, top_where
      Print
      Print "   X  ";
      For j%=1 to columns {
            Print format$("{0::-3}  ", j%);
      }
      Print
      For i%=1 to rows {
            Print format$(" {0::-3}  ", i%);
            For j%=1 to columns {
                  Print "  ";Right$(Board$(i%,j%),1);"  ";
            }
            Print
      }      
      End Sub
      Sub GameLoop()
            Local com$, loopagain as boolean
            PrintBoard()
            InputCommand()
            do 
                  loopagain=true
                  while not empty
                              \\ process game command
                        Read com$
                        if com$="q " Then
                              Print "Quit" : end_game=True : exit
                        Else.if com$="o " Then
                              OpenCell()
                        Else.if com$="n " Then
                              OpenCell2()
                        Else.if com$="? " Then
                              SwapCell()
                        Else.if com$="c " Then
                              Exit Sub                        
                        End if
                  End While
                  If mines%=0 or used%=0 then
                        PrintBoard(): Print "Player Win": end_game=True: Exit Sub
                  End if
                  If mines%=-1 then
                        if swap_first%=used% then
                              mines%=rows*columns-used%
                              Local n%, m%
                              While mines%
                                    Let n%=random(1,rows), m%=random(1, columns)
                                    If Board$(n%, m%)=". " then  Board$(n%, m%)=".*" : mines%=0
                              End While
                              Board$(i%, j%)=". "
                              mines%=rows*columns-used%
                              swap_first%=-100
                              Push i%, j%, "o "
                              loopagain=false
                        else
                              PrintMines(): Print "Player Loose": end_game=True : Exit Sub
                        end if
                  End If
            Until loopagain
            Flush
            Refresh if(End_Game->10,1000)
      End Sub
      Sub InputCommand()
            where=row
            While com$=""
                  cls, where
                  Print "x x | ? x x | q >";
                  Refresh 10
                  Try {
                        Input "", com$
                  }
            End While
            x=1
            Flush 
            While com$<>""
                  com_label$=""
                  ParseCommand()
                  if len(com_label$)<>2 then
                        com$="" : Print com_label$ : Flush
                        Refresh 10
                        push key$ : drop
                  else
                        Data com_label$, b_col, b_row
                  End if
            End While
            Refresh 1000
      End Sub
      Sub ParseCommand()
            com_label$="o "
            skiptest=true
            ReadColumn()
            if len(com_label$)<>2 then
                  com$=""     
            Else.if x=-1 then
                  com_label$=lcase$(Left$(com$,1))+" "
                  com$=mid$(com$, 2)
                  x=1
                  if len(com_label$)<>2 then
                        com_label$="no command found"
                  else.if com_label$="? " then
                        ReadColumn()
                        if x>-1 then ReadRow()
                  else.if com_label$="c " then
                        cheat=true  
                  else.if com_label$="q " then
                        flush
                        com$=""                  
                  else
                        com_label$="Use q or ? for commands"
                        com$=""
                  End if      
            else
                  ReadRow()
                  if x>-1 then com_label$="o "
            End if 
      End Sub
      Sub ReadRow()
            com$=mid$(com$,x)
            b_row=val(com$, "??", x)
            if x=-1 then
                  com_label$="Need a row"
            else.if b_row<1 or b_row>rows then
                  com_label$="Need a row from 1 to "+str$(rows)
                  x=-1 
            else
                  com$=mid$(com$,x+1)
                  x=1
            End if
      End Sub
      Sub ReadColumn()
            com$=mid$(com$,x)
            b_col=val(com$, "??", x)
            if x=-1 then
                  if not skiptest then com_label$="Need a column"
            else.if b_col<1 or b_col>columns then
                  com_label$="Need a column from 1 to"+str$(columns)
            else
                  com$=mid$(com$,x+1)
                  x=1
            End if
            skiptest=false
      End Sub
      Sub SwapCell()
            Read j%, i%
            If left$(Board$(i%,j%),1)="?" then
                  Board$(i%,j%) ="."+Right$(Board$(i%,j%),1)
                  If cheat Then if Right$(Board$(i%,j%),1)="*" then mines%++
            Else.If left$(Board$(i%,j%),1)="." then
                  Board$(i%,j%) ="?"+Right$(Board$(i%,j%),1)
                  If cheat Then if Right$(Board$(i%,j%),1)="*" then mines%--
            End if
      End Sub
      Sub OpenCell()
            Read j%, i%
            If left$(Board$(i%,j%),1)="." then {
                  if Right$(Board$(i%,j%),1)="*" then mines%=-1 : flush : exit
                  acc%=0
                  used%--
                  Local n%, m%
                  For n%=i%-1 to i%+1 {
                        For m%=j%-1 to j%+1 {
                                If Right$(Board$(n%,m%),1)="*" then acc%++
                        }
                  }
                  For n%=i%-1 to i%+1 {
                        For m%=j%-1 to j%+1 {
                             if not (n%=i% and m%=j%) then
                                   if not Right$(Board$(n%,m%),1)="*" then
                                         If left$(Board$(n%,m%),1)="." then
                                              Push n%, m%, "n "  ' reverse to stack
                                              Rem : Print stack.size : Refresh
                                         End If
                                   End If
                             End If
                        }
                  }
                  Board$(i%,j%)=if$(acc%=0->"  ",str$(acc%, "# "))
            }
      End Sub
      Sub OpenCell2()
            Read J%, i%
            If left$(Board$(i%,j%),1)="." then {
                  if Right$(Board$(i%,j%),1)="*" then exit
                  acc%=0
                  used%--
                  For n%=i%-1 to i%+1 {
                        For m%=j%-1 to j%+1 {
                                If Right$(Board$(n%,m%),1)="*" then acc%++
                        }
                  }
                  \\ if cell has no mines around then we check all
                  if acc%=0 then
                        Local n%, m%
                        For n%=i%-1 to i%+1
                              For m%=j%-1 to j%+1
                                   if not (n%=i% and m%=j%) then
                                         if not Right$(Board$(n%,m%),1)="*" then
                                               If left$(Board$(n%,m%),1)="." then
                                                    Push n%, m%, "o "  ' reverse to stack
                                                    Rem : Print stack.size : Refresh
                                               End If
                                         End If
                                   End If
                              Next m%
                        Next n%
                  End If
                  Board$(i%,j%)=if$(acc%=0->"  ",str$(acc%, "# "))
            }
      End Sub     
}
Minesweeper
Report 2, "Press a Key"
Push Key$ : Drop
Keyboard "info"+chr$(13)   ' call the info module
}
MODULE IBAN {\\ IBAN checker
Function MakeIBANfun$ {
      Inventory countrylength = "AL" := 28, "AD" := 24, "AT" := 20, "AZ" := 28, "BE" := 16, "BH" := 22, "BA" := 20, "BR" := 29
      Append  countrylength, "BG" := 22, "CR" := 21, "HR" := 21, "CY" := 28, "CZ" := 24, "DK" := 18, "DO" := 28, "EE" := 20
      Append  countrylength, "FO" := 18, "FI" := 18, "FR" := 27, "GE" := 22, "DE" := 22, "GI" := 23, "GR" := 27, "GL" := 18
      Append  countrylength, "GT" := 28, "HU" := 28, "IS" := 26, "IE" := 22, "IL" := 23, "IT" := 27, "KZ" := 20, "KW" := 30
      Append  countrylength, "LV" := 21, "LB" := 28, "LI" := 21, "LT" := 20, "LU" := 20, "MK" := 19, "MT" := 31, "MR" := 27
      Append  countrylength, "MU" := 30, "MC" := 27, "MD" := 24, "ME" := 22, "NL" := 18, "NO" := 15, "PK" := 24, "PS" := 29
      Append  countrylength, "PL" := 28, "PT" := 25, "RO" := 24, "SM" := 27, "SA" := 24, "RS" := 22, "SK" := 24, "SI" := 19
      Append  countrylength, "ES" := 24, "SE" := 24, "CH" := 21, "TN" := 24, "TR" := 26, "AE" := 23, "GB" := 22, "VG" := 24
 
     =Lambda$ countrylength (Iban0$)->{
            Iban$=Filter$(Ucase$(Iban0$), " ")
            Iban$=Filter$(Iban$, Filter$(Iban$,"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"))
            Def Decimal ch, c
            {            
                  If Not Exist(countrylength, Left$(Iban$,2)) Then Exit
                  length=Eval(countrylength)
                  If Not Len(Iban$)=length Then exit
                  Buffer ScanChar as Integer*length
                  Return ScanChar, 0:=Mid$(Iban$,5), length-4:=Mid$(Iban$,1,4)
 
                  For i=0 to length-1 {
                        ch=Eval(ScanChar, i)
                        if ch>=48 and ch<=57 then {
                              c = c*10+ch-48    
                        } else.if ch>=65 and ch<=90 then {
                              c = c*100+ch-55
                        } else c=-1: exit
                  }
                  c = c mod 97
            }
            =Iban0$ + If$(c=1 ->" (Valid)", " (Invalid)")
      }
}
IbanCheck$=MakeIBANfun$()
Print IbanCheck$("GB82 WEST 1234 5698 7654 32")    ' valid
Print IbanCheck$("GB82 TEST 1234 5698 7654 32")
Print IbanCheck$("SA03 8000 0000 6080 1016 7519")   ' valid
Print IbanCheck$("GR16 0110 1250 0000 0001 2300 695X")
Print IbanCheck$("MK11 2222 3333 4444 555")
}
MODULE HTTP {Module CheckIt  {
      Declare  xml "Microsoft.XMLHTTP"
      const testUrl$ = "http://www.rosettacode.org"
      With  xml, "readyState" as ReadyState
      Method xml "Open", "Get", testUrl$, True  ' True means Async
      Method xml "send"
      \\ We set a thread to count time
      k=0
      Thread {
            k++
      }  as TimeOut interval 300   ' change thread interval to give more time to collect
      \\ In main thread we can check ReadyState and Mouse button
      Task.Main 100 {
            Report 2, Str$(ReadyState)
            If ReadyState=4 then exit
            if k>20 then exit   ' 20*100= 2 sec
            if mouse then exit ' exit if mouse click
      }
      \\ So now we can read
      if ReadyState=4 then {
            With  xml, "responseText" AS AA$
            \\ break AA$ to lines
            Document BB$=AA$
            \\ using line breaks as CRLF
            Print "Press space or mouse to change page"
            Report BB$
      }
      Declare xml Nothing
}
Report 2, "Using the Microsoft.XMLHTTP with threads - see Down4 where we use an internal object for download with events. Use space bar or mouse click to advance the scroll"
CheckIt
}
MODULE CAL {\\ Calendar - for "REAL" programmers
\\ All statements in UPPERCASE
\\ Output to 132 characters console - as a line printer
\\ USE COURIER NEW  (FONT "COURIER NEW")

\\ CHANGE THE 
GLOBAL CONST PRINT_IT AS BOOLEAN=FALSE
MODULE GLOBAL SNOOPY  {
IF NOT PRINT_IT THEN CURSOR 0,ROW ELSE IF ROW>0 THEN PAGE 1 
PRINT $(,8)
PRINT #-2, {
					   XXXX
					  X    XX
					 X  ***  X		  XXXXX
					X  *****  X	       XXX     XX
				     XXXX ******* XXX	   XXXX 	 XX
				   XX	X ******  XXXXXXXXX    El@	   XX XXX
				 XX	 X ****  X			     X** X
				X	 XX    XX     X 		     X***X
			       X	 //XXXX       X 		     XXXX
			      X 	//   X				   XX
			     X	       //    X		XXXXXXXXXXXXXXXXXX/
			     X	   XXX//    X	       X
			     X	  X   X     X	      X
			     X	  X    X    X	     X
			      X   X    X    X	     X			  XX
			      X    X   X    X	     X		       XXX  XX
			       X    XXX      X	      X 	      X  X X  X
			       X	     X	       X	      XX X  XXXX
				X	      X 	XXXXXXXX\     XX   XX  X
				 XX	       XX	       X     X	 @X  XX
				   XX		 XXXX	XXXXXX/     X	  XXXX
				     XXX	     XX***	   X	 X
					XXXXXXXXXXXXX *   *	  X	X
						     *---* X	 X     X
						    *-* *   XXX X     X
						    *- *       XXX   X
						   *- *X	  XXX
						   *- *X  X	     XXX
						  *- *X    X		XX
						  *- *XX    X		  X
						 *  *X* X    X		   X
						 *  *X * X    X 	    X
						*  * X**  X   XXXX	    X
						*  * X**  XX	 X	    X
					       *  ** X** X     XX	   X
					       *  **  X*  XXX	X	  X
					      *  **    XX   XXXX       XXX
					     *	* *	 XXXX	   X	 X
					    *	* *	     X	   X	 X
			      =======*******   * *	     X	   X	  XXXXXXXX\
				     *	       * *	/XXXXX	    XXXXXXXX\	   )
				=====**********  *     X		     )	\  )
				  ====* 	*     X 	      \  \   )XXXXX
			     =========**********       XXXXXXXXXXXXXXXXXXXXXX

}
}
MODULE CALENDAR (YEAR, LOCALEID) {
      FUNCTION GETMAX(YEAR, MONTH) {
            A=DATE(STR$(YEAR)+"-"+STR$(MONTH)+"-1")
            MAX=32
            DO {
                  MAX--
                  M=VAL(STR$(CDATE(A,0,0,MAX), "M"))  
            } UNTIL M=MONTH
             =MAX+1    
      }
      FUNCTION SKIPMO(YEAR, MONTH) {
            A=DATE(STR$(YEAR)+"-"+STR$(MONTH)+"-1")
            =(VAL(STR$(A, "W"))-8) MOD 7 +7
      }
      FUNCTION TITLE$(A$) {
            =UCASE$(LEFT$(A$,1))+LCASE$(MID$(A$, 2))
      }
      LOCALE LOCALEID
      IF NOT PRINT_IT THEN CURSOR 0,HEIGHT-1  ' LAST LINE, SO EACH NEW LINE SCROLL ALL LINES UP
      SNOOPY
      
      PRINT UNDER  ' PRINT UNDERLINE
      PRINT OVER $(2), YEAR
      PRINT
      FOR J=0 TO 1 {
            PRINT
            FOR I=1 TO 6 {
                  MONTH=I+J*6
                  PRINT  PART @((I-1)*22), $(2,21), UCASE$(LOCALE$(55+MONTH))
            }
            PRINT
            DIM SKIP(1 TO 6), COUNT(1 TO 6), D(1 TO 6)=1
            FOR I=1 TO 6 {
                  MONTH=I+J*6
                  IF I>1 THEN PRINT " ";
                  FOR K=42 TO 48 :PRINT " ";UCASE$(LEFT$(LOCALE$(K),2));:NEXT K 
                  SKIP(I)=SKIPMO(YEAR, MONTH)
                  COUNT(I)=GETMAX(YEAR, MONTH)
            }
            PRINT
            IF PRINT_IT ELSE REFRESH 1000
            FOR I=1 TO 6 {
                      IF I>1 THEN PRINT " ";
                      FOR K=1 TO 7 {
                        SKIP(I)--
                        IF  SKIP(I)>0 THEN PRINT "   "; :CONTINUE
                        COUNT(I)--
                        PRINT FORMAT$(" {0::-2}", D(I));
                        D(I)++
                  }
            }
            PRINT
            IF PRINT_IT ELSE REFRESH 1000
            PRINT @(0)
            FOR M=1 TO 5 {
                  FOR I=1 TO 6 {
                        IF I>1 THEN PRINT " ";
                        FOR K=1 TO 7 {
                              COUNT(I)--
                              IF COUNT(I)<0 THEN PRINT "   "; : CONTINUE
                              PRINT FORMAT$(" {0::-2}", D(I));
                              D(I)++
                        }
                  }
            PRINT
            IF PRINT_IT ELSE REFRESH 1000 
            }
      }     
}
WHILE INKEY$<>"" :  END WHILE
IF PRINT_IT THEN PRINTING ON ELSE REFRESH 1000
FONT "COURIER NEW"
PEN 0
CLS 15, 0
FORM 132,68      
CALENDAR 1966, 1032 ' GREEK
GOSUB WAITKEY_OR_MOUSE
FOR I=2020 TO 2026
CALENDAR I, 1033  ' ENGLISH
GOSUB WAITKEY_OR_MOUSE
NEXT I
IF PRINT_IT THEN PRINTING OFF ELSE REFRESH 50
CLEAR  ' CLEAR VARIABLES FROM THIS MODULE
KEYBOARD "INFO"+CHR$(13)
END
WAITKEY_OR_MOUSE:
IF PRINT_IT THEN RETURN
WHILE INKEY$="" AND MOUSE=0
END WHILE
RETURN
}
MODULE LINKED_LIST {\\ This example use pointers to groups.
\\ Class Node
\\ Node type has two pointers to groups: pred and succ
\\ Class 

Module Checkit {
      Form 80, 50
      Class Null {}
      Global Null->Null()
      Class Node {
            group pred, succ
            dat=0
            Remove {
                  Print "destroyed", .dat
            }
            class: 
            module Node {
                  .pred->Null
                  .succ->Null
                  if match("N") Then Read .dat
            }
      }
      Class LList {
            Group Head, Tail
            Module PushTail(k as pointer) {
                  if .Tail is Null then {
                        .Head<=k
                        .Tail<=k
                  } else {
                        n=.Tail
                        .Tail<=k
                        k=>pred=n=>pred
                        n=>pred=k
                        k=>succ=n
                  }
            }
            Function RemoveTail {
                  n=.Tail
                  if n is .Head then {
                        .Head->Null
                        .Tail->Null
                  } Else { 
                        .Tail<=n=>succ
                        .Tail=>pred=n=>pred
                        n=>pred->Null
                  }
                  for n {
                        .succ->Null
                        .pred->Null
                  }
                  =n
            }
            Module PushHead(k as pointer) {
                  if .head is Null then {
                        .Head<=k
                        .Tail<=k
                  } else {
                        n=.head
                        .head<=k
                        k=>succ=n=>succ
                        n=>succ=k
                        k=>pred=n
                  }
            }
            Function RemoveHead {
                  n=.Head
                  if n is .Tail then {
                        .Head->Null
                        .Tail->Null
                  } Else { 
                      .Head<=n=>pred
                      .Head=>succ=n=>succ
                       n=>succ->Null    
                   }
                  for n {
                        .succ->Null
                        .pred->Null
                  }
                  =n
            }
            Module RemoveNode(k as pointer) {
                  pred=k=>pred
                  succ=k=>succ
                  if pred is succ then {
                        if .head is k else Error "Can't remove this node"
                        k=.RemoveHead()
                        clear k
                  } else {
                       pred=>succ=succ
                       succ=>pred=pred 
                  }
            }
            Module InsertAfter(k as pointer, n as pointer) {
                  pred=k=>pred
                  n=>pred=pred
                  n=>succ=k
                  pred=>succ=n
                  k=>pred=n
            }
            Function IsEmpty {
                  = .Head is null or .tail is null
            }
      class:
            Module LList {
                  .Head->Null
                  .Tail->Null
            }
      }
      m->Node(100)
 
      L=LList()
      L.PushTail m
      If not L.Head is Null then Print L.Head=>dat=100
      for i=101 to 103 {
            m->Node(i)
            L.PushTail m
            Print "ok....", i
      }
      for i=104 to 106 {
            m->Node(i)
            L.PushHead m
            Print "ok....", i
      }
 
      Print "Use Head to display from last to first"
      m=L.Head
      do {
            Print m=>dat
            m=m=>pred
      } Until m is null
      Print "ok, now find 3rd and remove it"
      m1=L.Head
      i=1 
      Index=3
      While i<Index {
            if m1 is null then exit
            m1=m1=>pred
            i++
      }
      If i<>Index then {
            Print "List has less than "; Index;" Items"
      } Else {
            Print "First add one new node"
                  newNode->Node(1000)
                  L.InsertAfter m1, newNode
                  L.RemoveNode m1
                  clear m1  ' last time m1 used here
                  newNode=Null
            Print "ok.............."
      }
      Print "Use Tail to display from first to last"
      m=L.Tail
      do {
            Print m=>dat
            m=m=>succ
      } Until m is null
 
 
      useother=True
      While not L.IsEmpty(){
            For This {
                  \\ we have to use a temporary variable name, here A
                         A=If(useother->L.RemoveTail(),L.RemoveHead())
                         ? A=>dat
                        useother~
                        \\ now we can try to perform removing
                        clear A
             }
      }
      Print "list is empty:"; L.IsEmpty()    
}
Checkit
}
MODULE LINKED_LIST1 {\\ Second Version
\\ This example use pointers to groups.
\\ One class which make Node and Null class inside
\ \ Head and Tail are private

Module Checkit {
      Form 80, 50
      Class LList {
      Private:
            Group Head, Tail
            Class Null {}
      Public:
            Property Null {Value}
            Group GetHead {
                  Value {
                        link parent Head to Head
                        ->Head
                  }
            }
            Group GetTail {
                  Value {
                        link parent Tail to Tail
                        ->Tail
                  }
            }
            Function Node {
                  Group Ret {
                        group pred, succ
                        dat=0
                        Remove {
                              Print "destroyed", .dat
                        }
                  }
                  Ret.pred->.[Null]
                  Ret.succ->.[Null]
                  if match("N") Then Read Ret.dat
                   ->(Ret)
            }
            Module PushTail(k as pointer) {
                  if .Tail is .[Null] then {
                        .Head<=k
                        .Tail<=k
                  } else {
                        n=.Tail
                        .Tail<=k
                        k=>pred=n=>pred
                        n=>pred=k
                        k=>succ=n
                  }
            }
            Function RemoveTail {
                  n=.Tail
                  if n is .Head then {
                        .Head->.[Null]
                        .Tail->.[Null]
                  } Else { 
                        .Tail<=n=>succ
                        .Tail=>pred=n=>pred
                        n=>pred->.[Null]
                  }
                  for n, This {
                        .succ->..[Null]
                        .pred->..[Null]
                  }
                  =n
            }
            Module PushHead(k as pointer) {
                  if .head is .[Null] then {
                        .Head<=k
                        .Tail<=k
                  } else {
                        n=.head
                        .head<=k
                        k=>succ=n=>succ
                        n=>succ=k
                        k=>pred=n
                  }
            }
            Function RemoveHead {
                  n=.Head
                  if n is .Tail then {
                        .Head->.[Null]
                        .Tail->.[Null]
                  } Else { 
                      .Head<=n=>pred
                      .Head=>succ=n=>succ
                       n=>succ->.[Null]
                   }
                  for n, This {
                        .succ->..[Null]
                        .pred->..[Null]
                  }
                  =n
            }
            Module RemoveNode(k as pointer) {
                  pred=k=>pred
                  succ=k=>succ
                  if pred is succ then {
                        if .head is k else Error "Can't remove this node"
                        k=.RemoveHead()
                        clear k
                  } else {
                       pred=>succ=succ
                       succ=>pred=pred 
                  }
            }
            Module InsertAfter(k as pointer, n as pointer) {
                  pred=k=>pred
                  n=>pred=pred
                  n=>succ=k
                  pred=>succ=n
                  k=>pred=n
            }
            Module DeleteAll {
                  While not .IsEmpty(){
                        For This {
                              A=.RemoveTail()
                              clear A
                         }
                  }                  
            }
            Remove {
                  .DeleteAll
            }
            Function IsEmpty {
                  = .Head is .[Null] or .tail is .[Null]
            }
      class:
            Module LList {
                  .[Null]->.Null()
                  .Head->.[Null]
                  .Tail->.[Null]
            }
      }

      L=LList()
      Null=L.Null
      m->L.Node(100)      
      L.PushTail m
      If not L.GetHead is Null then Print L.GetHead=>dat=100
      for i=101 to 103 {
            m->L.Node(i)
            L.PushTail m
            Print "ok....", i
      }
      for i=104 to 106 {
            m->L.Node(i)
            L.PushHead m
            Print "ok....", i
      }
 
      Print "Use Head to display from last to first"
      m=L.GetHead
      do {
            Print m=>dat
            m=m=>pred
      } Until m is Null
      Print "ok, now find 3rd and remove it"
      m1=L.GetHead
      i=1 
      Index=3
      While i<Index {
            if m1 is Null then exit
            m1=m1=>pred
            i++
      }
      If i<>Index then {
            Print "List has less than "; Index;" Items"
      } Else {
            Print "First add one new node"
                  newNode->L.Node(1000)
                  L.InsertAfter m1, newNode
                  L.RemoveNode m1
                  clear m1  ' last time m1 used here
                  newNode=Null
            Print "ok.............."
      }
      Print "Use Tail to display from first to last"
      m=L.GetTail
      do {
            Print m=>dat
            m=m=>succ
      } Until m is Null
 
      If rnd<.5 Then 
      useother=True
      While not L.IsEmpty(){
            For This {
                  \\ we have to use a temporary variable name, here A
                         A=If(useother->L.RemoveTail(),L.RemoveHead())
                         ? A=>dat
                        useother~
                        \\ now we can try to perform removing
                        clear A
             }
      }
      Else
      L.deleteAll
      End if
      Print "list is empty:"; If$(L.IsEmpty()->"Yes","No")
      mm=0
      for i=50 to 80 {
            m->L.Node(i)
            L.PushTail m
           mm++
      }
      m->Null
      Print "Added ";mm; " nodes"
      Push Pointer((L))
}
Checkit
Stack
Print "Press a key for phase 2"
Print "now Linked_list is a pointer to a group object"
Push key$ : Drop
Read Linked_List
Null=Linked_List=>Null
m=Linked_List=>GetHead
While not m is Null
	Print m=>dat
	m=m=>pred
End While
List
\\ we have to use Clear. Clear act only if the pointer is the last one.
\\ Then Linlked_List Remove do a Clear for each node. If we didn't use any extenal pointer for these we get all destroyed.
Clear Linked_list, Null, m
Print " now all variables aren't pointers. They have an empty group"
List
}
MODULE LINKED_LIST2 {
\\ Greek Version for Linked_list1
Τμήμα ΔεςΤο {
      Φόρμα 80, 50
      Κλάση Συνδεδεμένη_Λίστα {
      Ιδιωτικό:
            Ομάδα Κεφαλή, Ουρά
            Κλαση Κανένα {}
      Δημόσιο:
      ιδιότητα  Κανένα {Αξία}
            Συνάρτηση Κόμβος {
                  Ομάδα Επ {
                        Ομάδα πίσω, μπροστά
                        δεδομένο=0
                        Διαγραφή {
                              Τύπωσε "καταστράφηκε", .δεδομένο
                        }
                  }
                 επ.πίσω->.[Κανένα]
                 επ.μπροστά->.[Κανένα]
                 Αν Ταύτιση("ν") Τότε Διάβασε επ.δεδομένο
                 ->(επ)
            }
            Ομάδα Κόμβος_Κεφαλής {
                  Αξία {
                     Ένωσε γονικό Κεφαλή στη Κεφαλή
                     =Κεφαλή
                  }
            }
            Ομάδα Κόμβος_Ουράς {
                  Αξία {
                        Ένωσε γονικό Ουρά στη Ουρά
                        =Ουρά
                  }
            }
            Τμήμα ΒάλεΣτηνΟυρά (κ ως δείκτης) {
                  Αν .Ουρά Είναι .[Κανένα] Τότε {
                        .Κεφαλή<=κ
                        .Ουρά<=κ
                  } Αλλιώς {
                        ν=.Ουρά
                        .Ουρά<=κ
                        κ=>πίσω=ν=>πίσω
                        ν=>πίσω=κ
                        κ=>μπροστά=ν
                  }
            }
            Συνάρτηση ΑφαίρεσηΟυράς {
                  ν=.Ουρά
                  Κανένα=.[Κανένα]
                  Αν ν Είναι .Κεφαλή Τότε {
                        .Κεφαλή->Κανένα
                        .Ουρά->Κανένα
                  } Αλλιώς { 
                        .Ουρά<=ν=>μπροστά
                        .Ουρά=>πίσω=ν=>πίσω
                        ν=>πίσω->Κανένα
                  }
                  Για ν {
                        .μπροστά->Κανένα
                        .πίσω->Κανένα
                  }
                  =ν
            }
            Τμήμα ΒάλεΣτηΚεφαλή (κ ως δείκτης) {
                  Αν .Κεφαλή Είναι .[Κανένα] Τότε {
                        .Κεφαλή<=κ
                        .Ουρά<=κ
                  } Αλλιώς {
                        ν=.Κεφαλή
                        .Κεφαλή<=κ
                        κ=>μπροστά=ν=>μπροστά
                        ν=>μπροστά=κ
                        κ=>πίσω=ν
                  }
            }
            Συνάρτηση ΑφαίρεσηΚεφαλής {
                  ν=.Κεφαλή
                  Κανένα=.[Κανένα]
                  Αν ν Είναι .Ουρά Τότε {
                        .Κεφαλή->Κανένα
                        .Ουρά->Κανένα
                  } Αλλιώς { 
                      .Κεφαλή<=ν=>πίσω
                      .Κεφαλή=>μπροστά=ν=>μπροστά
                       ν=>μπροστά->Κανένα
                   }
                  Για ν, Αυτο {
                        .μπροστά->Κανένα
                        .πίσω->Κανένα
                  }
                  =ν
            }
            Τμήμα ΑφαίρεσηΚόμβου(κ ως δείκτης) {
                  πίσω=κ=>πίσω
                  μπροστά=κ=>μπροστά
                  Αν πίσω Είναι μπροστά Τότε {
                        Αν .Κεφαλή Είναι κ Αλλιώς Λάθος "Δεν μπορώ να διαγράψω αυτό το Κόμβο"
                        κ=.ΑφαίρεσηΚεφαλής()
                        Καθαρό κ
                  } Αλλιώς {
                       πίσω=>μπροστά=μπροστά
                       μπροστά=>πίσω=πίσω 
                  }
            }
            Τμήμα ΒάλεΕδώ (κ ως δείκτης, ν ως δείκτης) {
                  πίσω=κ=>πίσω
                  ν=>πίσω=πίσω
                  ν=>μπροστά=κ
                  πίσω=>μπροστά=ν
                  κ=>πίσω=ν
            }
            Συνάρτηση Είναι_Άδειο {
                  = .Κεφαλή Είναι .[Κανένα] ή .Ουρά Είναι .[Κανένα]
            }
            Τμήμα ΔιέγραψεΛίστα {
                   Ενώ Όχι .Είναι_Άδειο(){
                        Για Αυτό {
                               Α=.ΑφαίρεσηΚεφαλής()
                               Καθαρό Α
                        }
                  }
            }
            Διαγραφή {
                  .ΔιέγραψεΛίστα
            }
      Κλάση:
            Τμήμα Συνδεδεμένη_Λίστα {
                  .[Κανένα]->.Κανένα()
                  .Κεφαλή->.[Κανένα]
                  .Ουρά->.[Κανένα]
            }
      }
      Λ=Συνδεδεμένη_Λίστα()
      Κανένα=Λ.Κανένα
      π->Λ.Κόμβος(100)
      Λ.ΒάλεΣτηνΟυρά π
      Αν Όχι Λ.Κόμβος_Κεφαλής Είναι Κανένα Τότε Τύπωσε Λ.Κόμβος_Κεφαλής=>δεδομένο=100
      Για Ι=101 Έως 103 {
            π->Λ.Κόμβος(Ι)
            Λ.ΒάλεΣτηνΟυρά π
            Τύπωσε "Στην Ουρά.....", Ι
      }
      Για Ι=104 Έως 106 {
            π->Λ.Κόμβος(Ι)
            Λ.ΒάλεΣτηΚεφαλή π
            Τύπωσε "Στη Κεφαλή....", Ι
      }
      Τύπωσε "Χρήση του Λ.Κόμβος_Κεφαλής για να δείξουμε από τη Κεφαλή ως την Ουρά"
      π=Λ.Κόμβος_Κεφαλής
      ΜΜ=1
      Επανέλαβε {
            Τύπωσε ΜΜ, π=>δεδομένο
            ΜΜ++
            π=π=>πίσω
      } Μέχρι π Είναι Κανένα
      Τύπωσε "εντάει, τώρα βρές το τρίτο και διέγραψέ το"
      μ1=Λ.Κόμβος_Κεφαλής
      Ι=1 
      δεικτ1=3
      Ενώ Ι<δεικτ1 {
            Αν μ1 Είναι Κανένα Τότε Έξοδος
            μ1=μ1=>πίσω
            Ι++
      }
      Αν Ι<>δεικτ1 Τότε {
            Τύπωσε "Η λίστα έχει λιγότερα από "; δεικτ1;" στοιχεία"
      } Αλλιώς {
            Τύπωσε "Πρώτα θα βάλουμε ένα νέο Κόμβο"
                 Νέος_Κόμβος->Λ.Κόμβος(1000)
                  Λ.ΒάλεΕδώ μ1, Νέος_Κόμβος
                  Λ.ΑφαίρεσηΚόμβου μ1
                  Καθαρό μ1
                  Νέος_Κόμβος=Κανένα
      }
      Τύπωσε "Χρήση του Λ.Κόμβος_Κεφαλής για να δείξουμε από τη Κεφαλή ως την Ουρά"
      ΜΜ=1
      π=Λ.Κόμβος_Κεφαλής
      Επανέλαβε {
            Τύπωσε ΜΜ, π=>δεδομένο
            ΜΜ++
            π=π=>πίσω
      } Μέχρι π Είναι Κανένα
      Τύπωσε "Χρήση του Λ.Κόμβος_Ουράς για να δείξουμε από την Ουρά ως τη Κεφαλή"
      π=Λ.Κόμβος_Ουράς
      Επανέλαβε {
            ΜΜ--
            Τύπωσε ΜΜ, π=>δεδομένο
            π=π=>μπροστά
      } Μέχρι π Είναι Κανένα
      Λ.ΔιέγραψεΛίστα
      Για Ι=50 Έως 80 {
            π->Λ.Κόμβος(Ι)
            Λ.ΒάλεΣτηΚεφαλή π
      }
      Βάλε Δείκτης((Λ))
}
ΔεςΤο
Σωρός
Τύπωσε "Φάση 2, η Λίστα έχει παραδοθεί με 30 κόμβους"
Τύπωσε "Πάτα ένα πλήκτρο"
Βάλε ΚΟΜ$ : Πέτα
Διάβασε Κ
Κανένα=Κ=>Κανένα
π=Κ=>Κόμβος_Ουράς
Επανέλαβε
      Τύπωσε π=>δεδομένο
      π=π=>μπροστά
Μέχρι π Είναι Κανένα
Λίστα
Καθαρό Κ, π, Κανένα
Λίστα
Τύπωσε "Οι τρεις μεταβλητές τώρα δείχνουν μια κενή ομαδα (Group), ενώ πριν είχαν δείκτες σε ομάδες"

}
MODULE LZW {Module FastM2000 {
      plaintext$="TOBEORNOTTOBEORTOBEORNOT"
      Function encodeLZW$(i$) {
            Def long c, d, i, l, o$, w$
            Inventory dict
            For i = 0 to 255 {Append dict , Chr$(i):=i}
            l = i
            i = 1
            w$ = LEFT$(i$,1)
            Repeat{
                  d = 0
                  Repeat {
                        c = d
                        IF i > Len(i$) Then Exit
                        if exist(dict, w$) Then { 
                              d=eval(dict)
                        } Else  Append dict, w$:=l: Exit
                        if d<l Then i += 1 : w$ += Mid$(i$, i, 1)  
                  } Until d >= l
                  l += 1 : w$ = Right$(w$, 1)
                  o$ += Chr$(c Mod 256) + Chr$(c div 256)
            } Until i > Len(i$)
            = o$
      }
      encodeLZW$ = encodeLZW$(plaintext$)
      
      Document Doc$={ Lempel-Ziv-Welch (LZW) compression
      }
      For i = 1 to Len(encodeLZW$) STEP 2
              Doc$= Str$(Asc(Mid$(encodeLZW$,i)) + 256*Asc(Mid$(encodeLZW$,i+1)))
      Next i
      insert to 2,1  Doc$=""  ' remove first space
      
      Doc$={
      }+"Compression ration:"+str$((len(encodeLZW$) div 2)/len(encodeLZW$)*100, " ##")+{%
      }
      Function decodeLZW$(i$) {
            Def c, i, l, o$, t$, w$
            Inventory Dict
            For i = 0 to 255 {Append dict , i:=chr$(i)}
            l = i
            c = Asc(i$) + 256*Asc(Mid$(i$,2))
            w$ = dict$(c)
            o$ = w$
            IF Len(i$) < 4 Then = o$
            For i = 3 to Len(i$) STEP 2 {
                  c = Asc(Mid$(i$,i)) + 256*Asc(Mid$(i$,i+1))
                  IF c < l Then {
                        t$ = dict$(c)
                  } Else t$ = w$ + LEFT$(w$,1)
                  o$ += t$
                  Append dict, l:=w$ + LEFT$(t$,1)
                  l += 1 : w$ = t$
            }
            = o$
      }
      Doc$=decodeLZW$(encodeLZW$)+{
      }
      Clipboard Doc$
      Report Doc$
}
FastM2000
}
MODULE UTF8 {Module checkit {
      linespace 60
      Form ! 60,45
      Cls,0
      Report 2, "Read a file character by character/UTF8"
      \\ prepare a file
      \\ Save.Doc and Append.Doc  to file, Load.Doc and Merge.Doc from file
      Report ! 4 ' set 4 to tab size
      Report {
            	The task of this module is simple a reading one by one char, from a UTF8 encoded file. We can save and read entire files in UTF8 encoding, but here we want to  save a file as UTF8 and then read one by one all characters as UTF8 encoded, and diplay them (after converted to UTF-16LE, from a ready made function)
            	We have to read more than one byte to make it one character. But maybe we have less, so we have to stop reading, if that happen. So when we need more we try to get more, and maybe we get error. We use a Try block to get the error in the code, and do something for it.
            	We use buffers as memory area to get the data at a predefined length. So when we use:
            	Get #file_Handler, two
            	intrerpreter check that two is a buffer, get the length and try to get the same length of bytes to that buffer. Each buffer have a base structure and maybe a count value, of how many of them can be stored. The folowwing statement say that the base structure is a byte and we have two of them
            	Buffer Two as byte*2
            	The variable Two is a reference to an object. Two(0) is the real address of offset 0, of buffer two.
            	Here we don't use address, only offsets. We can read using Eval() the byte at any offset, included in the buffer, unless we get an error. So Eval(two, 0) return the byte as an assign value (0 to 255). Also we can use the string reading, Eval$(two,0,2) which return a string with 2 bytes, from offset 0, from buffer referred by two.
            	The following statement perform a memory copy (twice, one to the string and one to the source), with control over the offsets and lengths.
            	Return Bytes, 1:=Eval$(three, 0, 3)
            	So we put from offset 1 (has base structure bytes, so is the second byte), 3 bytes from buffer referred by three.
            	Please use a proper font if you didn't see some letters (use Font "fontname",  check font with ? fontname$)
            	Also check the Choose.Font statement
            }
      document a$
      a$={First Line
            Second line 𐐷
            Third Line
            Ελληνικά Greek Letters
            Γιω̃ργος diacritic (U+303)
            1234 ברוכים הבאים abc
            yä®€
            成长汉
            }
      Save.Doc a$, "checkthis.txt", 2  ' 2 for UTF-8
      b$="*"
      final$=""
      buffer Clear bytes as byte*16
      Buffer One as byte
      Buffer Two as byte*2
      Buffer Three as byte*3
      Locale 1033
      Fall=100/FileLen("checkthis.txt")
      open "checkthis.txt" for input as #f
      seek#f, 4 ' skip BOM
      While b$<>"" {
            Print Over $(1), ~(11), seek(#f)/Fall
            GetOneUtf8Char(&b$)
            final$+=b$
      }
      Print Over $(1), ~(15), "reading done........."
      close #f
      Print
      \\ from cursor settting, Report get the 
      Cursor 20
      Report final$, width-20-8
      Print
      Rem Print #-2, final$
      Document Final$ ' upgrade
      for i=1 to doc.par(final$)
            print paragraph$(final$,i)
      next
      next
      Sub GetOneUtf8Char(&ch$)
            ch$=""
            if Eof(#f) then Exit Sub
            Get #f, One
            Return Bytes, 0:=Eval(one, 0)
            local mrk=Eval(one, 0)
            Try ok {
                  If Binary.And(mrk, 0xE0)=0xC0 then {
                        Get #f,one
                        Return Bytes, 1:=Eval$(one, 0,1) 
                        ch$=Eval$(Bytes, 0, 2)
                  } Else.if Binary.And(mrk, 0xF0)=0xE0 then {
                        Get #f,two
                        Return Bytes, 1:=Eval$(two,0,2)
                        ch$=Eval$(Bytes, 0, 3)
                  } Else.if Binary.And(mrk, 0xF8)=0xF0 then {
                        Get #f,three
                        Return Bytes, 1:=Eval$(three, 0, 3)  
                        ch$=Eval$(Bytes, 0, 4)
                  } Else ch$=Eval$(Bytes, 0, 1)
            }
            if Error or not ok then ch$="" : exit sub
            ch$=string$(ch$ as Utf8dec)
      End Sub
}
checkit
Italic 1 : Print Over "Press any key to return to Info": Italic 0
Push Key$ : Drop
Keyboard "info"+chr$(13)
}
MODULE RF {Module checkit {
      \\ prepare a file
      \\ Save.Doc and Append.Doc  to file, Load.Doc and Merge.Doc from file
      document a$
      a$={First Line
            Second line
            Third Line
            Ελληνικά Greek Letters
            }
      Save.Doc a$, "checkthis.txt", 2  ' 2 for UTF-8
 
      Buffer1=Buffer("checkthis.txt")
      Print Len(Buffer1)=Filelen("checkthis.txt")
      b$=String$(Eval$(Buffer1, 0) as UTF8Dec)
      Report b$
      openfile$=FILE$("text file","txt")
      Merge.doc a$, openfile$
      Edit.Doc a$
}
checkit
}
MODULE RFL {\\ read a file line by line
Module checkit {
      \\ prepare a file
      document a$
      a$={First Line
            Second line
            Third Line
            }
      Save.Doc a$, "checkthis.txt", 0  ' 0 for UTF-16LE
      Flush
      Open "checkthis.txt" For Wide Input as #F
      While not Eof(#f) {
            Data Seek(#f)
            Line Input #F, b$
            Print  b$
      }
      Close #f
      Dim  Index()
      \\ copy stack to index(), flush stack
      Index()=Array([])
      \\ change base to base 1
      Dim  Base 1, Index(len(index()))
      Open "checkthis.txt" For Wide Input as #F
            Seek#F, Index(2)
            Line Input #F, b$
            Print b$  ' print second line
      Close #f
      \\ prepare Ansi file
      Print "Ansi File"
      Save.Doc a$, "checkthis.txt",  1033  ' we use specific locale
      Flush \\ flush the stack to get indexes
      oldlocale=locale
      locale 1033
      \\ no Wide clause
      Open "checkthis.txt" For  Input as #F
      While not Eof(#f) {
            Data Seek(#f)
            Line Input #F, b$
            Print  b$
      }
      Close #f
      Dim  Index()
      \\ copy stack to index(), flush stack
      Index()=Array([])
      \\ change base to base 1
      Dim  Base 1, Index(len(index()))
      Open "checkthis.txt" For Input as #F
            Seek#F, Index(2)
            Line Input #F, b$
            Print b$  ' print second line
      Close #f
      locale oldlocale
}
checkit
}
MODULE PERMALL {Module Checkit {
      Global a$
      Document a$
      Module Permutations (s as array){
            Module Level (n, s, h)   {
                  If n=1 then {
                        m1=each(h)     
                        while m1 {
                              Print Array$(m1);" ";
                        }
                         Print Array$(S)
                         ToClipBoard()
                  } Else {
                        for i=1 to len(s) {
                              call Level n-1, cdr(s),  cons(h, car(s))
                              s=cons(cdr(s), car(s))
                        }  
                  }
                  Sub ToClipBoard()
                        local m=each(h)
                        Local b$=""
                        While m {
                              b$+=If$(Len(b$)<>0->" ","")+Array$(m)+" "
                        }
                        b$+=If$(Len(b$)<>0->" ","")+Array$(s,0)+" "+{
                        }
                        a$<=b$   ' assign to global need <=
                  End Sub
            }
            If len(s)=0 then Error "No items to make permutations"
            Head=(,)
            Call Level Len(s),  s, Head
      }
      Clear a$
      Permutations (1,2,3,4)
      Permutations (100, 200, 500)
      Permutations ("A", "B", "C","D")  
      Permutations ("DOG", "CAT", "BAT")    
      ClipBoard a$
}
Checkit
}
MODULE PERMSTEP {Module StepByStep {
      Function PermutationStep (a as array) {
            \\ a in this c1 has only one item (so we remove the car(a) and place just the a)
            c1=lambda (&f, a) ->{
                  =a
                  f=true
            }
            m=len(a)
            if m=0 then Error "No items to make permutations"
            c=c1
            while m>1 {
                  c1=lambda c2=c,p, m=(,) (&f, a) ->{
                        if len(m)=0 then m=a
                        =cons(car(m),c2(&f, cdr(m)))
                        if f then f=false:p++:  m=cons(cdr(m), car(m)) : if p=len(m) then p=0 : m=(,):: f=true
                  }
                  c=c1  
                  m--    
            }
            =lambda c, a (&f) -> {
                  =c(&f, a)
            }
      }
      k=false
      StepA=PermutationStep((1,2,3,4))
      while not k {
                 Print StepA(&k) 
      }
      k=false
      StepA=PermutationStep((100,200,300))
      while not k {
                 Print StepA(&k) 
      }
      k=false
      StepA=PermutationStep(("A", "B", "C", "D"))
      while not k {
                 Print StepA(&k) 
      }
      k=false
      StepA=PermutationStep(("DOG", "CAT", "BAT"))
      while not k {
                 Print StepA(&k) 
      }      
}
StepByStep
}
MODULE FACT {Cls , 0
Report {
	Factorial Task
	Definitions
               • The factorial of   0   (zero)   is defined as being   1   (unity).
               • The   Factorial Function   of a positive integer,   n,   is defined as the product of the sequence:
                                                                      n,   n-1,   n-2,   ...   1 
                                                                      
}
Cls, row
Module CheckIt {
      Locale 1033 ' ensure #,### print with comma
      Function factorial (n){
            If n<0 then Error "Factorial Error!"
            If n>27 then Error "Overflow"
 
            m=1@:While n>1 {m*=n:n--}:=m
      }
      Const Proportional=4
      Const ProportionalLeftJustification=5
      Const NonProportional=0
      Const NonProportionalLeftJustification=1
      For i=1 to 27 
      \\ we can print over (erasing line first), without new line at the end
      \\ and we can change how numbers apears, and the with of columns
      \\ numbers by default have right justification
      \\ all $() format have temporary use in this kind of print.
      Print Over $(Proportional),$("\f\a\c\t\o\r\i\a\l\(#\)\=",15), i, $(ProportionalLeftJustification), $("#,###",40), factorial(i)
      Print        \\ new line
      Next i
}
Checkit
}
MODULE TTT {Cls
Report {
      Tic Tac Toe
      Player vs Computer
      (Computer may loose. Find when)
      
}

Module Tic.Tac.Toe {
      Dim Board$(1 to 3, 1 to 3)=" "
      WinGame=False
      p=Board$()
      RandomPosition=lambda -> {
            =(random(1,3), random(1,3))
      }
 
      BoardItemEmpty=Lambda p (x, y) -> {
            =Array$(p, x, y)=" "
      }
      BoardSetItem=Lambda p (x, y, w$) -> {
            link p to a$()
            a$(x, y)=w$
      }
      T=9
      R=0
      C=0
      Repeat {
            Print "Computer Move:"
            CompMove()
            T--
            DrawBoard()
            CheckWin()
            if WinGame Then Print "Computer Win": Exit
            if T=0 then exit
            Repeat {
                  GetRowCol("Input Row", &R)
                  GetRowCol("Input Column", &C)
                  If BoardItemEmpty(R,C) then call boardsetitem(R,C,"O") : exit 
            } Always
            T--
            DrawBoard()
            CheckWin()
            if WinGame Then Print "You Win": Exit
      } until T=0 or WinGame
      Sub DrawBoard()
      Print "R/C 1 2 3"
      Print " 1) "; Board$(1,1);"|";Board$(1,2);"|";Board$(1,3)
      Print "    -+-+-"
      Print " 2) "; Board$(2,1);"|";Board$(2,2);"|";Board$(2,3)
      Print "    -+-+-"
      Print " 3) "; Board$(3,1);"|";Board$(3,2);"|";Board$(3,3)
      End Sub
      Sub CheckWin()
            WinGame=false
            local i,j,three$
            For i=1 to 3
                  three$=""
                  For j=1 to 3 : three$+=Board$(i,j) : Next j
                  CheckThree()
                  three$=""
                  For j=1 to 3 :  three$+=Board$(j,i) :Next j
                  CheckThree()
            Next i
            three$=""
            For i=1 to 3 : three$+=Board$(i,i): Next i
            CheckThree()
            three$=""
            For i=1 to 3:three$+=Board$(i,4-i): Next i
            CheckThree()
      End Sub
      Sub CheckThree()
            if instr(three$," ")=0 then  WinGame=WinGame or Filter$(three$, left$(three$,1))=""
      End Sub
      Sub CompMove()
            if T<9 and Board$(2,2)=" " then {
                  call boardsetitem(2,2,"X")
            } Else {
                  local i=3, j=3, found=false
                  if T<=6 then {
                        CompThink("X","X")
                  } 
                  let i=3, j=3
                  If Not found And T<6 then {
                        CompThink("O","X")    
                  }
                  If not found then {
                        Repeat {
                              comp=RandomPosition()
                              If BoardItemEmpty(!comp) then call boardsetitem(!comp, "X") : exit
                        } Always
                  }
            }
      End Sub
      Sub CompThink(Bad$, Good$)
                        While i>0 {
                              j=3
                              While j>0 {
                                    if Board$(i,j)=" " then {
                                          Board$(i,j)=Bad$
                                          CheckWin()
                                          if WinGame then {
                                                 Board$(i,j)=Good$:i=0:j=0: found=true
                                          } Else Board$(i,j)=" "
                                    }
                                    j--
                              }
                              i--
                        }
 
      End Sub
      Sub GetRowCol(What$, &W)
            Print What$;":";
            Repeat {
                  W=Val("0"+Key$)
            } until W>=1 and W<=3
            Print Str$(W,"")
      End Sub
}
Tic.Tac.Toe
}
MODULE GUESS {Module GuessNumber {
      Read Min, Max
      chosen = Random(Min, Max)
      print "guess a whole number between ";Min;" and ";Max
      do
                  \\ we use guess so Input get integer value
                  \\ if we press enter without a number we get error
                  do
                        \\ if we get error then we change line, checking the cursor position
                        If Pos>0 then Print
                        Try ok {
                              input "Enter your number " , guess%
                        }
                  until ok
                  Select Case guess%
                  case  min to chosen-1
                        print "Sorry, your number was too low"
                  case chosen+1 to max
                        print "Sorry, your number was too high"
                  case chosen 
                        print "Well guessed!"
                  else case
                        print "That was an invalid number"
                  end select
      until guess% = chosen
}
GuessNumber 5, 15
}
MODULE GUESS1 {Module QBASIC_Based {
      supervisor:
      GOSUB initialize
      GOSUB guessing
      GOTO continue
 
      initialize:
      \\ Not need to RANDOMIZE TIMER
      \\ we can use Random(1, 100) to get a number from 1 to 100
      n = 0: r = INT(RND * 100 + 1): g = 0: c$ = ""
      RETURN
 
      guessing:
      WHILE g <> r
                INPUT "Pick a number between 1 and 100:"; g
                IF g = r THEN
                    PRINT "You got it!"
                    n ++
                    PRINT "It took "; n; " tries to pick the right number."
                ELSE.IF g < r THEN
                    PRINT "Try a larger number."
                    n ++
                ELSE
                    PRINT "Try a smaller number."
                    n++
                END IF
      END WHILE
      RETURN
 
      continue:
      WHILE c$ <> "YES" AND c$ <> "NO"
          INPUT "Do you want to continue? (YES/NO)"; c$
          c$ = UCASE$(c$)
      END WHILE
      IF c$ = "YES" THEN GOTO supervisor
}
QBASIC_Based
}
MODULE DAY {Print "December 25 is a Sunday in:"
For Year=2008 to 2121 { 
      if  Str$(Date("25/12/"+str$(Year,"")),"w")="1" Then {
            Print Year
      }
}
\\ is the same with this:
Print "December 25 is a Sunday in:"
For Year=2008 to 2121 { 
      if  Str$(Date(str$(Year,"")+"-12-25"),"w")="1" Then {
            Print Year
      }
}
 
}
MODULE FILETIME {Module CheckIt {
      \\ without *for wide output*  we open for ANSI (1 byte per character)
      \\ but here we need it only for the creation of a file
      Open "afile" for output as #f
      Close #f
      Print file.stamp("afile")   'it is a number in VB6 date format.
      \\ day format as for Greece
      Print Str$(File.Stamp("afile"),"hh:nn:ss dd/mm/yyyy") , "utc creation time - by default"
      Print Str$(File.Stamp("afile" ,1),"hh:nn:ss dd/mm/yyyy") , "utc creation time, 1"
      Print  Str$(File.Stamp("afile" ,-1),"hh:nn:ss dd/mm/yyyy"), "local creation time, -1"
      Print Str$(File.Stamp("afile" ,2),"hh:nn:ss dd/mm/yyyy"), "utc write time, 2"
      Print  Str$(File.Stamp("afile" ,-2),"hh:nn:ss dd/mm/yyyy"), "local write time, -2"
}
Checkit
}
MODULE SPEED {Cls,0
Report {
	Time a function
	Using a timer (with the least granularity available) to time how long a function takes to execute
	
	The Test function get one type each time
	
	10000% is Integer 16bit
	
	10000& is Long 32bit
	
	10000@ is Decimal
	
	10000# is Currency
	
	10000~ is Float
	
	10000 is Double (default) 
	
}
cls,row
Module Checkit {
      Module sumtolimit (limit) {
           sum=limit-limit
           n=sum
           n++
           while limit {sum+=limit*n:limit--:n-!}
      }
      Profiler
      sumtolimit 10000%
      Print TimeCount
      Profiler
      sumtolimit 10000&
      Print TimeCount
      Profiler
      sumtolimit 10000#
      Print TimeCount
      Profiler
      sumtolimit 10000@
      Print TimeCount
      Profiler
      sumtolimit 10000~
      Print TimeCount
      Profiler
      sumtolimit 10000
      Print TimeCount
}
Print "Set Slow - more screen refresh - more time to OS"
Set Slow
Checkit
Print "Set Fast - the default"
Set Fast
Checkit
Refresh
Print "Set Fast !  - less screen refresh"
Set Fast !
Checkit
Refresh
Set Fast
}
MODULE STIME {print str$(now,"long time"), time$(now)
}
MODULE SDATE {Print str$(today, "yyyy-mm-dd")
Print str$(today, "dddd, mmm, dd, yyyy")
Print Date$(today, 1033, "dddd, MMM, dd, yyyy")
Print Date$(today, 1036, "dddd, MMM dd, yyyy")
Print Date$(today, 1047, "dddd, MMM dd, yyyy")
Print Date$(today, 1048, "dddd, MMM dd, yyyy")
Module Checkit(locale_id, Locale_out) {
      Enum zones {HAST=-10, HADT,PST, MST, CST, EST, AST, NST=-3.5, UTC=0, WET=0, GMT=0, BST=1,IST=1, CET=1, EET, MSK,MSD}
      INP$="March 7 2009 7:30pm EST"
      dim a$()
      a$()=Piece$(INP$," ")
      date1=date(leftpart$(INP$, a$(3)), locale_id)
      zone=UTC
      Try {
            zone=Eval(a#val$(4))
      }
      date0=date1+time(a$(3))
      Document doc$="Input date:"+{
      }
      doc$= Date$(date0 , Locale_out, "MMMM d, yyyy ")+" "+Lcase$(Time$(date0,1033, "hh:mmtt"))+" "+eval$(zone)+{
      }+"12 hours later:"+{
      }
      m=each(zones)
      while m {
            date2=date1+ctime(time(a$(3)),12+eval(m)-zone,frac(eval(m)-zone)*60,0)      
            doc$=Date$(date2 , Locale_out, "MMMM d, yyyy ")+Lcase$(Time$(date2,1033, "hh:mmtt"))+" "+eval$(m)+{
            }
      }
      Report Doc$
      Clipboard Doc$
}
Checkit 1033, 1036
Checkit 1033, 1032
}
MODULE ENV {Module CheckIt {
      \\ using read only variablles
      Print "Platform: ";Platform$
      Print "Computer Os: "; Os$
      Print "Type of OS: ";OsBit;" bit"
      Print "Computer Name:";  Computer$
      Print "User Name: "; User.Name$
      \\ using WScript.Shell
      Declare objShell "WScript.Shell"
      With  objShell, "Environment" set env ("Process")
      With env, "item" as Env$()
      Print Env$("PATH")
      Print Env$("HOMEPATH")
      Declare objShell Nothing
      \\ using internal Information object
      Declare OsInfo INFORMATION
      With OsInfo, "build" as build, "NtDllVersion" as NtDllVersion$
      Method OsInfo, "GetCurrentProcessSID" as PID$
      Method OsInfo, "IsProcessElevated" as isElevated
      Print "Os build number: ";build
      Print "Nr Dll version: ";NtDllVersion$
      Print "ProcessSID: ";pid$
      Print "Is Process Eleveted: ";isElevated
      Declare OsInfo Nothing
}
Checkit
}
MODULE HELLO {Module CheckIt {
      Declare Simple Form
      \\ we can define form before open
      Layer Simple {
            \\ center Window with 12pt font, 12000 twips width and 6000 twips height
            \\ ; at the end command to center the form in current screen
            Window 12, 12000, 6000;
            \\ make layer gray and split screen 0
            Cls #333333, 0
            \\   set split screen to 3rd line, like Cls ,2 without clear screen
            Scroll Split 2
            Cursor 0, 2
      }
      With Simple, "Title", "Hello Form"
      Function Simple.Click {
            Layer Simple {
                  \\ open msgbox
                  Print Ask("Hello World")
                  Refresh
            }
      }
      \\ now open as modal
      Method Simple, "Show", 1
      \\ now form deleted
      Declare Simple Nothing
}
CheckIt
}
MODULE BUTTON {Module CheckIt {
      Declare Form1  Form
      Declare Label1 Button Form Form1
      Declare Button1 Button Form Form1
      Method Label1,"move", 2000, 2000, 4000, 600
      Method Button1,"move", 2000, 3000, 4000, 600
      With Label1, "Caption" as caption$, "Locked", true, "Caption" as cap
      With Button1, "Caption", "click me", "Default", True   ' make this the default control
      caption$="There have been no clicks yet"
      m=0
      Function Button1.Click {
                  m++
                  cap=m
      }
      Method Form1, "Show",1
      Declare Form1 Nothing
}
Checkit
}
MODULE INTERACTION {Module CheckIt {
      Declare form1 form
      Declare textbox1 textbox form form1
      Declare buttonInc Button form form1
      Declare buttonRND Button form form1
      Method textbox1, "move", 2000,2000,4000,600
      Method buttonInc, "move", 2000,3000,2000,600
      Method buttonRND, "move", 4000,3000,2000,600
      With form1, "Title", "Rosetta Code: GUI component interaction"
      With textbox1,"vartext" as textbox1.value$, "Prompt", "Value:", "ShowAlways", true
      With buttonInc,"Caption","Increment"
      With buttonRND,"Caption","Random"
      textbox1.value$="0"
      Function Local1(new Feed$) {
            \\ this Function can be used from other Integer 
            \\ this$ and thispos, exist just before the call of this Function
            local sgn$
            if feed$="" and this$="-" then thispos-- :  exit
            if left$(this$,1)="-" then sgn$="-": this$=mid$(this$, 2)
            if this$<>Trim$(this$)  then  this$=Feed$ :  thispos-- : exit
            If Trim$(this$)="" then this$="0" : thispos=2 : exit
            if instr(this$,"+")>0 and sgn$="-" then this$=filter$(this$, "+") : sgn$=""
            if instr(this$,"-")>0  and sgn$="" then this$=filter$(this$, "-") : sgn$="-"
            if filter$(this$,"0123456789")<>"" then this$=Feed$ :  thispos-- : exit
            if len(this$)>1 then While  left$(this$,1)="0" {this$=mid$(this$, 2)} 
            this$=sgn$+this$
            if this$="-0" then this$="-" : thispos=2
        }
      Function TextBox1.ValidString {
                  \\ this Function called direct from textbox
                  Read  New &this$, &thispos
                  Call Local local1(textbox1.value$)
      }
      Function buttonInc.Click {
               textbox1.value$=str$(val(textbox1.value$)+1, "")
      }
      Function buttonRND.Click {
            If  AsK$("Change Value with random number", "Question", "Yes", "No")="Yes" Then {
                      textbox1.value$=str$(Random(0, 10000), "")
                      After 100 {Try {Method textbox1,"GetFocus"}}
            }
      }
      \\ open modal
      Method form1, "show", 1
      Declare form1 nothing
}
Checkit
}
MODULE INTER2 {\ this is global, but call as local in events, which means with local visibility for identifiers
\\ so thispos and this$ has to exist in caller 's context

Cls, 0
Report {
	You can increment the value if is less from 10
	You can decrement the value if is higher than 0
	If value is 0 then you can write a new value
	You can use enter as click event, or a mouse clik on either button.
} 
Function Global Local1(new Feed$) {
            \\ this function can be used from other Integer 
            \\ this$ and thispos, exist just before the call of this function
            local sgn$
            if feed$="" and this$="-" then thispos-- :  exit
            if left$(this$,1)="-" then sgn$="-": this$=mid$(this$, 2)
            if this$<>Trim$(this$)  then  this$=Feed$ :  thispos-- : exit
            If Trim$(this$)="" then this$="0" : thispos=2 : exit
            if instr(this$,"+")>0 and sgn$="-" then this$=filter$(this$, "+") : sgn$=""
            if instr(this$,"-")>0  and sgn$="" then this$=filter$(this$, "-") : sgn$="-"
            if filter$(this$,"0123456789")<>"" then this$=Feed$ :  thispos-- : exit
            if len(this$)>1 then While  left$(this$,1)="0" {this$=mid$(this$, 2)} 
            this$=sgn$+this$
            if this$="-0" then this$="-" : thispos=2
        }
Module CheckIt {
      Declare form1 form
      Declare textbox1 textbox form form1
      Declare buttonInc Button form form1
      Declare buttonDec Button form form1
      Method textbox1, "move", 2000,2000,4000,600
      Method buttonInc, "move", 2000,3000,2000,600
      Method buttonDec, "move", 4000,3000,2000,600
      With textbox1,"vartext" as textbox1.value$, "Prompt", "Value:" ', "ShowAlways", True
      With buttonInc,"Caption","Increment" 
      With buttonDec,"Caption","Decrement","Locked", True
      textbox1.value$="0"
      oldval1=True
      oldval2=False
      
      Function controlIncDec(what$){
            if  oldval1 = not val(what$)<10 then  With buttonInc, "locked",  not val(what$)<10 : oldval1~
            if oldval2= not val(what$)>0 then With buttonDec, "locked", not val(what$)>0: oldval2~
      }
      finishEnter=false      
      Function TextBox1.ValidString {
                  \\ this function called direct from textbox
                  Read  New &this$, &thispos
                  Call Local local1(textbox1.value$)
                  Call Local controlIncDec(this$)
      }
      Function TextBox1.Enable {
            With TextBox1, "Enabled", true
            finishEnter=false
      }
      Function TextBox1.Disable {
            With TextBox1, "Enabled", false
            finishEnter=true
      }
      Function TextBox1.Enter {
            Call Local TextBox1.Disable()
      }
      Function buttonInc.Click {
                if  not finishEnter then Call Local TextBox1.Disable()
               textbox1.value$=str$(val(textbox1.value$)+1, "")
                if val(textbox1.value$)=0 then Call Local TextBox1.Enable()
      }
      function buttonDec.Click {
                if  not finishEnter then Call Local TextBox1.Disable()
                textbox1.value$=str$(val(textbox1.value$)-1, "")     
                if val(textbox1.value$)=0 then Call Local TextBox1.Enable()
      }
      Call Local controlIncDec(textBox1.Value$)
      Method form1, "show", 1
      Declare form1 nothing
}
Checkit
}
MODULE PRTRY {Print "Choose a printer:"; : Printer ?
Print printername$

\\ use printer properties to set number of copies
Printer !

if ask("Is printer on","Printing Test","Yes","No")=1 then
	set slow
	\\ use PAGE 1 for new page Portrait or leave it to produce new page if more lines needed.
	\\  PAGE 0 set page to Landscape
	
	printing on
	
	\\ don't forget to set pen to black.
	Pen 0
	\\ you can define font also
	font "Courier New"
	\\ you can define characters by lines, so Mode (size of character) and Linespace produced automatic
	Form 80, 66
	For I=1 TO 85
	Print I
	Next I
	
	printing off
end if
set fast
}
MODULE ADDMUL {\\ Sum and product of an array
Module Checkit {
      a = (1,2,3,4,5,6,7,8,9,10)
      print a#sum() = 55
      sum = lambda->{push number+number}
      product = lambda->{Push number*number}
      print a#fold(lambda->{Push number*number}, 1), a#fold(lambda->{push number+number},0)
      dim a(2,2) = 5
      Print a()#sum() = 20
}
checkit
}
MODULE MULSH {Module CheckIt {
      Dim Base 1, A(12)
      Mult=lambda (n)-> {
            Flush  ' empty stack
            For i=1 to n : Data i*n : Next i
            =Array([])   ' copy stack in an array, and return a pointer
      }
      i=Each(A())
      Print "  |";
      while i {
            Print Format$("{0:0:-4}",i^+1);
            A(i^+1)=Mult(i^+1)
      }
      Print
      Print "--+"+string$("-",4*12)
      For i=1 to 12 {
            Print Format$("{0:0:-2}|",i); 
            For j=1 to 12 {
                  If len(A(j)())>=i then {
                        Print Format$("{0:0:-4}",A(j)(i-1));
                  } Else Print "    ";
            }
            Print
      }
}
CheckIt

Module CheckIt2 {
      Dim Base 1, A(12)
      Mult=lambda (n)-> {
            Flush  ' empty stack
            For i=1 to n : Data i*n : Next i
            =Array([])   ' copy stack in an array, and return a pointer
      }
      i=Each(A())
      Print "  |";
      while i {
            Print Format$("{0:0:-4}",i^+1);
            A(i^+1)=Mult(i^+1)
      }
      Print
      Print "--+"+string$("-",4*12)
      For i=1 to 12 {
            j=Each(A())
            Print Format$("{0:0:-2}|",i); 
            While j {
                  r1=A(j^+1)
                  If len(r1)>=i then {
                        Print Format$("{0:0:-4}",Array(r1,i-1));
                  } Else Print "    ";
            }
            Print
      }
}
CheckIt2
}
MODULE PA15 {Module Puzzle15 {
\\ BASIC STYLE  FROM COMMODORE BASIC
\\ http://www.rosettacode.org/wiki/15_Puzzle_Game#COMMODORE_BASIC
REM {
I make a function RND() and I set Base for arrays to 1 Also I put some semi colons to Print statement. To be actual BASIC compatible we have to set FOR NEXT like BASIC, because for M2000 the direction defined by the starting-ending values, so always we get at least one time the block between FOR NEXT. So we can use:

SET SWITCHES "+FOR"

But here we don't have to skip FOR NEXT and no STEP clause used.

Also the code is not the best, because we can move from 4 position to 5 (we can't do that with real puzzle) 
}
Escape OFF
Report 1, {
	
	
	Hold down Ctrl+C to exit any time - Escape key not used
	
	
	}
TRY {
            00 BASE 1 : DEF RND(X)=RND
            10 REM 15-PUZZLE GAME
            20 REM COMMODORE BASIC 2.0
            30 REM ********************************
            40 GOSUB 400 : REM' INTRO AND LEVEL
            50 GOSUB 510 : REM' SETUP BOARD
            60 GOSUB 210 : REM' PRINT PUZZLE
            70 PRINT "TO MOVE A PIECE, ENTER ITS NUMBER:"
            80 INPUT X
            90 GOSUB 730 : REM' CHECK IF MOVE IS VALID
            100 IF MV=0 THEN PRINT "WRONG MOVE" : GOSUB 1050 : GOTO 60
            110 D(Z)=X : D(Y)=0
            120 GOSUB 210 : REM' PRINT PUZZLE
            130 GOSUB 950 : REM' CHECK IF PUZZLE COMPLETE
            140 IF PC THEN 160
            150 GOTO 70
            160 PRINT"YOU WON!"
            170 END
            180 REM
            190 REM' *******************************
            200 REM' PRINT/DRAW THE PUZZLE
            210 FOR P=1 TO 16
            220   IF D(P)=0 THEN D$(P)="     " : GOTO 260
            230   S$=STR$(D(P))
            240   N=LEN(S$)
            250   D$(P) = LEFT$("   ",3-N)+S$+"  "
            260 NEXT
            270 PRINT "+-----+-----+-----+-----+"
            280 PRINT "!";D$(1);"!";D$(2);"!";D$(3);"!";D$(4);"!"
            290 PRINT "+-----+-----+-----+-----+"
            300 PRINT "!";D$(5);"!";D$(6);"!";D$(7);"!";D$(8);"!"
            310 PRINT "+-----+-----+-----+-----+"
            320 PRINT "!";D$(9);"!";D$(10);"!";D$(11);"!";D$(12);"!"
            330 PRINT "+-----+-----+-----+-----+"
            340 PRINT "!";D$(13);"!";D$(14);"!";D$(15);"!";D$(16);"!"
            350 PRINT "+-----+-----+-----+-----+"
            360 RETURN
            370 REM
            380 REM' *******************************
            390 REM' INTRO AND LEVEL OF DIFFICULTY
            400 REM PRINT CHR$(147)    ' NOT USED HERE
            410 DIM SH(3) : SH(1)=10 : SH(2)=50 : SH(3)=100
            420 PRINT "15 PUZZLE GAME FOR COMMODORE BASIC 2.0" : PRINT : PRINT
            430 PRINT "PLEASE ENTER LEVEL OF DIFFICULTY,"
            440 PRINT "1(EASY), 2(MEDIUM) OR 3(HARD):";
            450 INPUT V
            460 IF V<1 OR V>3 THEN 440
            470 RETURN
            480 REM
            490 REM' *******************************
            500 REM' BUILD THE BOARD
            510 DIM D(16) : DIM D$(16) : REM' BOARD PIECES
            520 REM' SET PIECES IN CORRECT ORDER FIRST
            530 FOR P=1 TO 15
            540   D(P) = P
            550 NEXT
            560 D(16) = 0 : REM' 0 = EMPTY PIECE/SLOT
            570 Z=16      : REM' Z = EMPTY POSITION
            580 PRINT: PRINT "SHUFFLING PIECES";
            590 FOR N=1 TO SH(V)
            600   PRINT".";
            610   X = INT(RND(0)*4)+1
            620   R = Z+(X=1)*4-(X=2)*4+(X=3)-(X=4)
            630   IF R<1 OR R>16 THEN 610
            640   D(Z)=D(R)
            650   Z=R
            660   D(Z)=0
            670 NEXT
            680 PRINT CHR$(147)
            690 RETURN
            700 REM
            710 REM' *******************************
            720 REM' CHECK IF MOVE IS VALID
            730 MV = 0
            740 IF X<1 OR X>15 THEN RETURN
            750 REM' FIND POSITION OF PIECE X
            760 P=1
            770 IF D(P)=X THEN Y=P : GOTO 810
            780 P=P+1 : IF P>16 THEN PRINT "UH OH!" : STOP
            790 GOTO 770
            800 REM' FIND POSITION OF EMPTY PIECE
            810 P=1
            820 IF D(P)=0 THEN Z=P : GOTO 860
            830 P=P+1 : IF P>16 THEN PRINT "UH OH!" : STOP
            840 GOTO 820
            850 PRINT Y;Z
            860 REM' CHECK IF EMPTY PIECE IS ABOVE, BELOW, LEFT OR RIGHT TO PIECE X
            870 IF Y-4=Z THEN MV=1 : RETURN
            880 IF Y+4=Z THEN MV=1 : RETURN
            890 IF Y-1=Z THEN MV=1 : RETURN
            900 IF Y+1=Z THEN MV=1 : RETURN
            910 RETURN
            920 REM
            930 REM' *******************************
            940 REM' CHECK IF PUZZLE IS COMPLETE / GAME OVER
            950 PC = 0
            960 P=1
            970 IF D(P)<>P THEN RETURN
            980 P=P+1
            990 IF P<16 THEN 970
            1000 PC = 1
            1010 RETURN
            1020 REM
            1030 REM' ******************************
            1040 REM' A SMALL DELAY
            1050 FOR T=0 TO 400
            1060 NEXT
            1070 RETURN
}
\\ SET BACK THE BASE OF ARRAYS
BASE 0
}
Puzzle15
}
MODULE CRYPTO {\\ https://en.wikipedia.org/wiki/RIPEMD
\\ The original RIPEMD function was designed in the framework of the EU project RIPE (RACE Integrity Primitives Evaluation) in 1992
\\ RIPEMD-160 is 160bit cryptographic hash function.

Module Checkit {
	Function Prepare_RiPeMd_160 {
		Dim Base 0,  K(5), K1(5)
		K(0)=0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E
		K1(0)=0x50A28BE6,0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000
		Dim Base 0,r(80), r1(80), s(80), s1(80)
		r(0)=0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
		r(16)=7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8
		r(32)= 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12
		r(48)=1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2
		r(64)=4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
		k=r() : k*=4   ' k is a pointer to array. We have to multiply to make them offsets
		
		r1(0)=5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12
		r1(16)=6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2
		r1(32)=15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13
		r1(48)=8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14
		r1(64)=12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
		
		k=r1() : k*=4
		
		s(0)=11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8
		s(16)=7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12
		s(32)=11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5
		s(48)=11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12
		s(64)=9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
		
		s1(0)=8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6
		s1(16)=9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11
		s1(32)=9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5
		s1(48)=15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8
		s1(64)=8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
		
		Dim Base 0, T(5), TT(5)
		T(0)=lambda ->binary.xor(binary.xor(number,number),number)
		T(1)=lambda (B,C,D)->binary.or(binary.and(B,C), binary.and(binary.not(B), D))
		T(2)=lambda ->binary.xor(binary.or(number, binary.not(number)), number)
		T(3)=lambda (B,C,D)->binary.or(binary.and(B,D), binary.and(C,binary.not(D)))
		T(4)=lambda ->binary.xor(number, binary.or(number, binary.not(number)))
		
		\\ no need for variables we read form stack with number
		TT(0)=lambda ->binary.xor(number, binary.or(number, binary.not(number)))
		TT(1)=lambda (BB,CC,DD)->binary.or(binary.and(BB,DD), binary.and(CC,binary.not(DD)))	
		TT(2)=lambda ->binary.xor(binary.or(number, binary.not(number)), number)
		TT(3)=lambda (BB,CC,DD)->binary.or(binary.and(BB,CC), binary.and(binary.not(BB),DD))	
		TT(4)=lambda ->binary.xor(binary.xor(number,number),number)
		
		\\ return of this function is a lambda function
		\\ all arrays are closures to this lambda
		=lambda K(),K1(),TT(), T(),r(),r1(), s(), s1() (&message$, ansi as boolean=true, ansiid=1033)-> {
			set fast!
			def h0 = 0x67452301, h1 = 0xEFCDAB89, h2 = 0x98BADCFE
			def h3 = 0x10325476, h4 = 0xC3D2E1F0
			def i, j, l, padding, l1, blocks, acc, f64 as boolean=true, oldid
			if ansi then oldid=locale : locale ansiid
			\\ we use a buffer of 64 bytes
			buffer clear message as byte*64
			l=len(message$)*if(ansi->1,2 )
			if binary.and(l,63)>55 then  padding=64 
			padding+= 64 - (l Mod 64)
			l1=padding+l+1
	
			f64=binary.and(l,63)<>0
	
			blocks=l1 div 64
rem
			Print "blocks:";blocks
			\\ now prepare the buffer
			PrepareBuffer()
			def decimal  A, B, C, D, E, AA, BB, CC, DD, EE, T, TT
			do
			A  = h0 : B  = h1 : C  = h2 : D  = h3 : E  = h4
			AA = h0 : BB = h1 : CC = h2 : DD = h3 : EE = h4
			for J=0 to 79 {
				JJ=J DIV 16
				PUSH binary.add(Binary.Rotate(binary.add(A,T(JJ)(B,C,D),eval(message ,r(j) as long),k(jj)), s(j)), e)
				A = E : E = D : D = Binary.Rotate(C, 10) : C = B : READ B 
				PUSH binary.add(Binary.Rotate(binary.add(AA,TT(JJ)(BB,CC,DD),eval(message, r1(j) as long),k1(jj)),s1(j)),EE)
				AA = EE : EE = DD : DD = Binary.Rotate(CC, 10) : CC = BB : READ BB
			}
			push binary.add(h1, C, DD)
			h1 = binary.add(h2, D, EE)
			h2 = binary.add(h3, E, AA)
			h3 = binary.add(h4, A, BB)
			h4 = binary.add(h0, B, CC)
			Read h0
			blocks--
rem
			print over $(0,8), blocks : Refresh
			if blocks=0 then exit
			PrepareBuffer()
			always
rem
			print
			buffer ans as byte*20
			\\ we put ulong (long ar ulong in buffers)
			Return ans, 0:=h0 as long, 4:=h1 as long,8:=h2 as long, 12:=h3 as long, 16:=h4 as long
			=ans
			if ansi then locale oldid
			set fast
			
			Sub PrepareBuffer()
				
				if l-acc>=64 then
					LoadPart(64)
				else.if blocks=1 then
					return message, 0:=string$(chr$(0),32)
					if l-acc=0 and f64 then
						Return message, 56:=l*8 as long, 60 :=binary.shift(l,-29) as long
					else
						Return message, l-acc:=0x80, 56:=l*8 as long, 60 :=binary.shift(l,-29) as long
						if l>acc then LoadPart(l-acc)
					end if
				else
					Return message, l-acc:=0x80
					LoadPart(l-acc)
				end if
			End Sub
			sub LoadPart(many)
				\\ str$() convert to ansi, one byte per character
				\\ using 1033 as Ansi language
				if ansi then
					Return message, 0:=str$(mid$(message$,1+acc, many))
				else
					Return message, 0:=mid$(message$, 1+acc, many)
				end if
				acc+=many
			end sub
		}
	}
	Module TestHash (RIPEMD){
		Flush
		\\ push data to stack of values, as fifo (each entry append to end of stack)
		Data "b3be159860842cebaa7174c8fff0aa9e50a5199f","Rosetta Code"
		Data "9c1185a5c5e9fc54612808977ee8f548b2258d31",""
		Data "0bdc9d2d256b3ee9daae347be6f4dc835a467ffe","a"
		Data "8eb208f7e05d987a9b044a8e98c6b087f15a0bfc","abc"
		Data "5d0689ef49d2fae572b881b123a85ffa21595f36", "message digest"
		Data "f71c27109c692c1b56bbdceb5b9d2865b3708dbc","abcdefghijklmnopqrstuvwxyz"
		Data "b0e20b6e3116640286ed3a87a5713079b21f5189"
		Data "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
		Data "9b752e45573d4b39f4dbd3323cab82bf63326bfb", String$("1234567890",8)
rem		Data "52783243c1697bdbe16d37f97f68f08325dc1528", String$("a",1000000)
		
		While not empty
			Read check$, text$
			Print "RIPEMD160 for ";quote$(Left$(if$(len(text$)>30->left$(text$,27)+"...",  text$),30))
			\\ pass text$ by reference
			Display(RIPEMD(&text$))
		End While
		
		sub Display(ans)
			local answer$
			for i=0 to len(ans)-1
				answer$+=hex$(eval(ans,i),1)
			next i
			Print lcase$(answer$)
			Print lcase$(answer$)=check$
		end sub
	}
	TestHash Prepare_RiPeMd_160()	
}
Checkit
}
MODULE DIJKSTRA {Module Dijkstra`s_algorithm {
        const max_number=infinity '1.E+306
        GetArr=lambda (n, val)->{
                dim d(n)=val
                =d()
        }
        term=("",0)
        Edges=(("a", ("b",7),("c",9),("f",14)),("b",("c",10),("d",15)),("c",("d",11),("f",2)),("d",("e",6)),("e",("f", 9)),("f",term))
        Document Doc$="Graph:"+{
        }
        ShowGraph()
        Doc$="Paths"+{
        }
        Print "Paths"
        For from_here=0 to 5
                pa=GetArr(len(Edges), -1)
                d=GetArr(len(Edges), max_number)
                Inventory S=1,2,3,4,5,6
                return d, from_here:=0
                RemoveMin=Lambda S, d, max_number-> {
                        ss=each(S)
                        min=max_number
                        p=0
                        while ss
                                val=d#val(eval(S,ss^)-1)
                                if min>val then let min=val : p=ss^ 
                        end while
                        =s(p!)  ' use p as index not key
                        Delete S, eval(s,p)
                }
                Show_Distance_and_Path$=lambda$ d, pa, from_here, max_number (n) -> {
                        ret1$=chr$(from_here+asc("a"))+" to "+chr$(n+asc("a"))
                        if d#val(n) =max_number then =ret1$+ " No Path" :exit
                        let ret$="", mm=n, m=n
                        repeat
                                n=m
                                ret$+=chr$(asc("a")+n)
                                m=pa#val(n)
                        until  from_here=n 
                        =ret1$+format$("{0::-4} {1}",d#val(mm),strrev$(ret$))
                }
                while len(s)>0 
                        u=RemoveMin()
                        rem Print u, chr$(u-1+asc("a"))
                        Relaxed()
                end while
                For i=0 to len(d)-1
                        line$=Show_Distance_and_Path$(i)
                        Print line$
                        doc$=line$+{
                        }
                next
        next
        Clipboard Doc$
        End
        Sub Relaxed()
                local vertex=Edges#val(u-1), i
                local e=Len(vertex)-1, edge=(,), val
                for i=1 to e
                        edge=vertex#val(i)
                        if edge#val$(0)<>"" then \\\\\\ if not edge is term then
                                val=Asc(edge#val$(0))-Asc("a")
                                if d#val(val)>edge#val(1)+d#val(u-1) then  return d, val:=edge#val(1)+d#val(u-1) : Return Pa, val:=u-1
                        end if
                next 
        end sub
        Sub ShowGraph()
                Print "Graph"
                local i
                for i=1 to len(Edges)
                        show_edges(i)
                next
        end sub
        Sub show_edges(n)
                n--
                local vertex=Edges#val(n), line$
                local e=each(vertex 2 to end), v2=(,)
                While e 
                        v2=array(e)
                        line$=vertex#val$(0)+if$(v2#val$(0)<>""->"->"+v2#val$(0)+format$(" {0::-2}",v2#val(1)),"")
                        Print line$
                        Doc$=line$+{
                        }
                end while
        end sub
}
Dijkstra`s_algorithm

}
MODULE ANT {Flush
Set Fast !
Escape off
Esc=False
Form 120,102
Double
Print "Langton's ant"
Print "press right mouse button to draw partial image"
Print "press left mouse button to exit"
Normal
N=100
refresh
Enum CellColor {black=0,white=#FFFFFF}
Enum Direction{North=90, West=180, South=270, East=0}
Function Rotate(cd as Direction, clockwise=true) {
		cd=(cd+if(clockwise->270,90)) mod 360
		=cd  ' return a Direction Enum type
}
 
dim rect(1 to N, 1 to N)=white
cx=N div 3
cy=N div 3
cd=North
rect(cx,cy)=black
endmove=False
m=1
while not endmove
	movecell()
	if m mod 20=0 then if keypress(1) then if ask("Quit")=1 then  Esc=true : exit while
	m++ : if keypress(2) then Disp()
end while
if not Esc then
	Disp(true)
	refresh 40
	a$=key$
end if
Escape ON
Set Fast
keyboard "INFO"+chr$(13)
sub movecell()
	select case rect(cx,cy)
	case black
		cd=Rotate(cd, false) : rect(cx, cy)=white
	case white
		cd=Rotate(cd) : rect(cx, cy)=black
	end select
	select case cd
	case North
		cy--
	case West
		cx--
	case South
		cy++
	case East
		cx++
	end select
	endmove= cx<1 or cx>N or cy<1 or cy>N
end sub
sub disp(clip=false)
	Local Doc$, i, j
	Document Doc$
	for j=1 to N:for i=1 to N
		Doc$=if$(rect(i, j)=White->"_","#")
	next
	Doc$={
	}
	next
	cls
	Print #-2,Doc$
	refresh 1000
	if clip then clipboard Doc$ : Cursor 0, 100 : Print "Done", @(100),"Press any key"
end sub

}
MODULE ANON {\\ Anonymous Functions
curry=lambda (f)->{
        \\ get arguments as a stack object and store reference to s
        \\ f and s are closures to returned anonymous function
        =lambda f, s=[] -> {
                \\ pass arguments [] to f() if any
                \\ pass arguments using a copy of s
                \\ passing done using ! symbol before a stack object
                =f(![], !stack(s))
        }
}
sum=lambda -> {
        s=0   \\ number pop numbers from stack
        while not empty : s+=number:end while
        =s
}
curried=curry(sum, 5,7,9)
Print curried(1,2,3)=5+7+9+1+2+3  ' true
Print curried(10,20,30)=5+7+9+10+20+30 ' true
Print curried()=5+7+9  ' true
curried2=curry(sum)
Print curried2()=0
curried2=curry(sum, 10,20,30,40)
Print curried2(1,2,3,4)=110
\\ make a closure for a lambda function
disp=lambda title$="my title:" (that$) -> {
        Print title$;that$
}
Call disp("Anonymous Function")
Dim A(10)
A(3)=disp
ret=A(3)("Call from array")
Inventory Abc="100":=disp
ret=Abc("100")("Call from inventory")
ret=lambda title$="another tilte1:" (that$)->{Print title$;that$}("call anonymous function")
ret=lambda title$="another tilte2:" (that$)->{
        Print title$;that$
}("call anonymous function")
}
MODULE CHAIN {\\ Chain of Responsibility design pattern 
\\ a Class: part in Class Function removed from object after first copy (when copied from Class function)
\\ So constructors are not part of Logger Group (Group is the type of a user object in M2000)
Form 80,50
Global enum LogLevel    {
		None = 0,
		Info = 1, 
		Debug = 2, 
		Warning = 4,
		Error = 8,   
		FunctionalMessage = 16, 
		FunctionalError = 32, 
		All = 63
		}
Class Logger {
Private:
logMask=0&
Group NextLogger
Public:
	Module Final Message(msg$, severity) {
		If not Valid(.NextLogger=>Null) Then
			.NextLogger=>Message msg$, severity
		End If
		If Binary.And(.logMask ,severity)<>0 Then
			.WriteMessage msg$
		End If
	}
	Module WriteMessage (m$) {
		Print m$
	}
	Module Final SetNext ( p as pointer) {
		.NextLogger<=p
	}
	Function Final Dispose {
		x=valid(.NextLogger=>Dispose())
		Clear .NextLogger
	}
Class:
	Module Logger (z) {
		.logMask<=z
		Class EmptyLogger {
			Null
		}
		.NextLogger<=Pointer(EmptyLogger())
	}
}
Class ConsoleLogger {
	Module  Final WriteMessage (m$) {
		Print "Writing to console: " + m$
	}
Class:
	Module ConsoleLogger {
		This=Logger(![])
	}
}
Class EmailLogger {
	Module  Final WriteMessage (m$) {
		Print "Sending via email: " + m$
	}
Class:
	Module EmailLogger {
		This=Logger(![])
	}
}
Class FileLogger {
	Module  Final WriteMessage (m$) {
		Print "Writing to Log File: " + m$
	}
Class:
	Module FileLogger {
		This=Logger(![])
	}
}
A=ConsoleLogger(All)
B=EmailLogger(FunctionalMessage+FunctionalError)
C=FileLogger(Warning+Error)
C.SetNext Pointer(B)
B.SetNext Pointer(A)


C.Message "Entering function ProcessOrder().", Debug
C.Message "Order record retrieved.", Info
C.Message "Customer Address details missing in Branch DataBase.", Warning
C.Message "Customer Address details missing in Organization DataBase.", Error
C.Message "Unable to Process Order ORD1 Dated D1 For Customer C1.", FunctionalError
C.Message "Order Dispatched.",FunctionalMessage
Call C.Dispose()  ' no need we use weak refrences (automatic created If poiner produced for named groups
}
MODULE CHAIN1 {\\ Chain of Responsibility design pattern 

Form 80,50
Global enum LogLevel    {
		None = 0,
		Info = 1, 
		Debug = 2, 
		Warning = 4,
		Error = 8,   
		FunctionalMessage = 16, 
		FunctionalError = 32, 
		All = 63
		}
Class Logger {
Private:
	logMask=0&
	Group NextLogger
	Module super (z) {
		.logMask<=z
		Class EmptyLogger {
			Null
		}
		.NextLogger<=Pointer(EmptyLogger())
	}
Public:
	Module Final Message(msg$, severity) {
		If not Valid(.NextLogger=>Null) Then
			.NextLogger=>Message msg$, severity
		End If
		If Binary.And(.logMask ,severity)<>0 Then
			.WriteMessage msg$
		End If
	}
	Module WriteMessage (m$) {
		Print m$
	}
	Module Final SetNext ( p as pointer) {
		.NextLogger<=p
	}
	Function Final Dispose {
		x=valid(.NextLogger=>Dispose())
		Clear .NextLogger
	}
}
Class MessageTypeHolder {
	message$="nothing yet"
	Module  Final WriteMessage (m$) {
		Print .message$+": " + m$
	}
}
Class ConsoleLogger as  MessageTypeHolder as Logger {
Class:
	Module ConsoleLogger {
		.message$<="Writing to console"
		.super
	}
}
Class EmailLogger as MessageTypeHolder  as Logger {
Class:
	Module EmailLogger {
		.message$<="Sending via email"
		.super
	}
}
Class FileLogger as MessageTypeHolder  as Logger {
Class:
	Module FileLogger {
		.message$<="Writing to Log File"
		.super
	}
}
A=ConsoleLogger(All)
B=EmailLogger(FunctionalMessage+FunctionalError)
C=FileLogger(Warning+Error)
C.SetNext Pointer(B)
B.SetNext Pointer(A)

C.Message "Entering function ProcessOrder().", Debug
C.Message "Order record retrieved.", Info
C.Message "Customer Address details missing in Branch DataBase.", Warning
C.Message "Customer Address details missing in Organization DataBase.", Error
C.Message "Unable to Process Order ORD1 Dated D1 For Customer C1.", FunctionalError
C.Message "Order Dispatched.",FunctionalMessage
Call C.Dispose()  ' no need we use weak refrences (automatic created If poiner produced for named groups
}
MODULE CHAIN2 {\\ Chain of Responsibility design pattern  2
\\ example from https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern
\\ This example use real pointers to groups
\\ so we have one group, the logger and two groups inside it in a chain
Form 80,50
Global enum LogLevel    {
		None = 0,
		Info = 1, 
		Debug = 2, 
		Warning = 4,
		Error = 8,   
		FunctionalMessage = 16, 
		FunctionalError = 32, 
		All = 63
}
Class Logger {
Private:
	logMask=0&
	Group NextLogger
Public:
	Module Final Message(msg$, severity) {
	If Binary.And(.logMask ,severity)<>0 Then
		.WriteMessage msg$
	End If
	If not Valid(.NextLogger=>Null) Then
		.NextLogger=>Message msg$, severity
	End If
}
Module WriteMessage (m$) {
	Print m$
}
 Module Final SetNext ( p as pointer) {
	If  valid(.NextLogger=>Null) Then
		.NextLogger<=p
	else
		.NextLogger=>SetNext p
	End If
}
Function Final Dispose {
	x=valid(.NextLogger=>Dispose())
	Clear .NextLlogger
}
Class:
	Module Logger (z) {
		.logMask<=z
		Class EmptyLogger {
			Null
		}
		.NextLogger<=Pointer(EmptyLogger())
	}
}
Class ConsoleLogger {
	Module  Final WriteMessage (m$) {
		Print "Writing to console: " + m$
	}
Class:
	Module ConsoleLogger {
		This=Logger(![])	'  ![] pass current stack of values to function Logger()
	}
}
Class EmailLogger {
Module  Final WriteMessage (m$) {
Print "Sending via email: " + m$
}
Class:
	Module EmailLogger {
		This=Logger(![])
	}
}
Class FileLogger {
	Module  Final WriteMessage (m$) {
		Print "Writing to Log File: " + m$
	}
Class:
	Module FileLogger {
		This=Logger(![])
	}
}
Logger->ConsoleLogger(All)


Logger=>SetNext Pointer(EmailLogger(FunctionalMessage+FunctionalError))
Logger=>SetNext Pointer(FileLogger(Warning+Error))


Logger=>Message "Entering function ProcessOrder().", Debug
\\ better to use a For object {} structure
For Logger {
	.Message "Order record retrieved.", Info
	.Message "Customer Address details missing in Branch DataBase.", Warning
	.Message "Customer Address details missing in Organization DataBase.", Error
	.Message "Unable to Process Order ORD1 Dated D1 For Customer C1.", FunctionalError
	\\ we can use Logger=>Message also
	Logger=>Message "Order Dispatched.",FunctionalMessage
	call .Dispose() 
}
Logger->0&   ' or Clear Logger
}
MODULE PYTH {MODULE Pythagoras_tree {
	CLS 5, 0  ' MAGENTA, NO SPLIT SCREEN
	PEN 14   ' YELLOW
	\\ code from zkl/Free Basic
	LET w = scale.x, h = w * 11 div 16
	LET w2 = w div 2, diff = w div 12
	LET TreeOrder = 6
	pythagoras_tree(w2 - diff, h -10, w2 + diff, h -10, 0)
 
	SUB pythagoras_tree(x1, y1, x2, y2, depth)
 
	    IF depth > TreeOrder THEN EXIT SUB
 
	    LOCAL dx = x2 - x1, dy = y1 - y2
	    LOCAL x3 = x2 - dy, y3 = y2 - dx
	    LOCAL x4 = x1 - dy, y4 = y1 - dx
	    LOCAL x5 = x4 + (dx - dy) / 2
	    LOCAL y5 = y4 - (dx + dy) / 2
	    MOVE x1, y1
	    DRAW TO x2, y2
	    DRAW TO x3, y3
	    DRAW TO x4, y4
	    DRAW TO x1, y1
	    pythagoras_tree(x4, y4, x5, y5, depth +1)
	    pythagoras_tree(x5, y5, x3, y3, depth +1)
 
	END SUB
}
Pythagoras_tree
}
MODULE PYTH1 {MODULE Pythagoras_Example{
	CLS 5, 0  ' MAGENTA, split line = 0  
	PEN 14  ' YELLOW
	\\ Linux smoothing not work (we can use the statement but without effect)
	IF ISWINE ELSE SMOOTH ON
	\\ PYTHAGORAS TREE
	\\ by definition all variables ar type of a double
	GLOBAL p=7, p4=PI/4, p2=PI/2, s2=SQRT(2)/2
	MODULE center_p (r, t){
		MODULE pythagoras_tree (r, dx, depth) {
			r2=r-p2
			DRAW ANGLE r, dx
			DRAW ANGLE r2, dx
			DRAW ANGLE r, -dx
			DRAW ANGLE r2, -dx
			IF depth>10 THEN EXIT
			s3=dx*s2
			depth++
			STEP ANGLE r+p4, s3*2
			CALL pythagoras_tree r-p4,  s3, depth
			STEP ANGLE r, -dx-s3
			STEP ANGLE r, s3
			STEP ANGLE r+p4, -s3
			CALL pythagoras_tree r+p4,  s3, depth
			STEP ANGLE r-p4, s3		
		}	
		MOVE SCALE.X/2, SCALE.Y/2	
		STEP ANGLE PI-p4+r, t*s2
		CALL pythagoras_tree r, t, 1
	}
	r=PI/3
	pixels=MIN.DATA(SCALE.X, SCALE.Y)/TWIPSX/8
	Refresh 1000/25
	center_p r, pixels*TWIPSX
	center_p r+PI, pixels*TWIPSX
	Refresh 50
	CopyImageToClipboard()
 
	Sub CopyImageToClipboard()
		LOCAL Scr$=""
		MOVE 0,0
		COPY SCALE.X, SCALE.Y TO Scr$
		CLIPBOARD Scr$
	END SUB
}
Pythagoras_Example
}
MODULE RPN {Module Rpn_Calc {  

	\\ insert a new line after rem to use hidden statements 
	Rem Form 80,60
	function rpn_calc(a$) {
		Print "Calc RPN:"+a$
		def m=0
		dim token$()
		token$()=piece$(a$," ")
		l=len(token$())
		dim type(l)=0, reg(l)
		where=-1
		for i=0 to  l-1
			c=val(token$(i),"",m)
			if m>-1 then
				where++
				reg(where)=c
			else
				reg(where-1)=eval(str$(reg(where-1))+token$(i)+str$(reg(where)))
				where--
			end if
			inf=each(reg(),1, where+1)
			while inf
				export$<=token$(i)+" ["+str$(inf^,"")+"] "+ str$(array(inf))+{
				}
				token$(i)=" "
			end while
		next i
		=reg(0)
	}
	Global export$
	document export$
	example1=rpn_calc("3 4 2 * 1 5 - 2 3 ^ ^ / +")
	example2=rpn_calc("1 2 + 3 4 + ^ 5 6 + ^")
	Print example1, example2
	Rem	Print #-2, Export$
	ClipBoard Export$
}
Rpn_Calc
}
MODULE BANKER {\\ No2
\\ First publish in Rosetta.org
\\ http://www.rosettacode.org/wiki/Banker%27s_algorithm#M2000_Interpreter
Module BankerAlgo {
      Form ! 80, 44   ' we can use Form without ! to display bigger form. 
      Cls 5
      Pen 14
      Function Request(FromWhere as Inventory, What$, Many as long)  {
            =FromWhere(What$)-FromWhere(What$+"_Request")-Many>=0
      }
      Function RequestPreset(FromWhere as Inventory, What$, Many as long)  {
            =FromWhere(What$+"_Request")-Many>=0
      }
      Function Need(FromWhere as Inventory, What$, Many) { 
            =FromWhere(What$ + "_max")-FromWhere(What$)-Many>=0
      }
      \\ code for sub can be found from parent module/function (here parent as in code, not as in call)
      Function NewProcess {
            Inventory Process
            ApplyResources(Process)   ' sub need more arguments and read from current stack
            =Process
      }
      Inventory System, Processes 
      \\ Recource, Max, Available
      ApplyResources(System, "A", 6, 3,"B", 5,1,"C", 7, 1, "D", 6, 2)
      \\ Recource, Max, Available
      Append Processes, "P1":=NewProcess("A", 3, 1, "B", 3, 2, "C", 2, 2, "D", 2,1)
      Append Processes, "P2":=NewProcess("A", 1, 1, "B", 2, 0, "C", 3, 3, "D", 4,3)
      Append Processes, "P3":=NewProcess("A", 1, 1, "B", 3, 2, "C", 5, 1, "D", 0,0)
      Status(True) ' show all process, available resource and max
      SafeState=True
      Print "Current Status"
      RequestResource() ' display Safe State
      RequestResource("P2", "D", 1) ' display Safe State
      RequestResource("P1", "A", 1, "D", 1) ' display Safe State
      RequestResource("P1", "C", 1, "D", 1) ' display Too many resources ...
      RequestResource("P2", "B", 1) ' display Unsafe State
      RequestResource("P3", "C", 1)  ' display Safe State
      Status()
      \\ Second Example
      Clear System, Processes
      ApplyResources(System, "A", 10, 3)
      Append Processes, "P1":=NewProcess("A", 9, 3)
      Append Processes, "P2":=NewProcess("A", 4, 2)
      Append Processes, "P3":=NewProcess("A", 7, 2)
      Status(True) ' show all process, available resource and max    
      Print "Current Status"
      RequestResource() ' display Safe State
      \ Third Example
      Clear System
      ApplyResources(System, "A", 10, 2)
      Return  Processes,"P1":=NewProcess("A", 9,4)
      Status(True) ' show all process, available resource and max    
      Print "Current Status"
      RequestResource() ' display UnSafe State       
      Sub Respond()
            If SafeState Then {
                  Pen 15 {Print "Safe State"}
            } Else Pen 13 {Print "Unsafe State"}
      End Sub
      Sub WaitForKey()
            Pen 11 {Print "Press a key"}
            local a$=key$
      End Sub
      Sub RequestResource(ProcessName$="" )
            SafeState=True
            If ProcessName$="" Then CheckNewState(&SafeState) : Respond() : Print : WaitForKey():Exit Sub
            Local pro=Processes(ProcessName$), ResourceName$, many as long
            ClearAllRequest(pro)
            Local skip=False
            While Match("SN") {
                  Read ResourceName$, many
                  Print  Format$("Claim {1} for type {0} resource ",ResourceName$, many)
                  If skip Then Continue
                  If Request(System, ResourceName$, many) Then {
                        If Need(pro, ResourceName$, many) Then { 
                              Return pro, ResourceName$+"_Request":=many
                              Return System, ResourceName$+"_Request":=-many
                        } Else {
                              Print "Too many Recources "+ResourceName$+" for Process "+ProcessName$  : Skip=True
                        }
                  } Else Print "Too many Recources for System" : Skip=True
                  If Skip Then exit
            } 
            If skip Else  CheckNewState(&SafeState) : Respond()
            Print  ' just a new line
            WaitForKey()
      End Sub
      Sub ApplyResources(Where as Inventory, What$, MaxValue, InitialValue)
            Repeat {
                  If Not Exist(Where, What$) Then {
                        Append Where, What$:=InitialValue, What$+"_max":=MaxValue, What$+"_Request":=0
                  }
                  If not Match("SNN") Then Exit
                  Read What$, MaxValue, InitialValue
            }  Always
      End Sub
      Sub ClearAllRequest(Where  as Inventory)
            Local M=Each(Where)
            While M {
                  If Instr(Eval$(M, M^),"_")=0 Then {
                        Return Where, Eval$(M,M^)+"_Request":=0
                  }
            }
      End Sub
      Sub PrintResources(Where  as Inventory)
            Local M=Each(Where)
            While M {
                  If Instr(Eval$(M, M^),"_")=0 Then Print Eval$(M, M^)+"="+Eval$(M),
            }
            Print
      Exit Sub
      Sub PrintMax(Where  as Inventory)
            Local M=Each(Where)
            While M {
                  If Instr(Eval$(M, M^),"_max")>0 Then Print LeftPart$(Eval$(M, M^), "_")+"="+Eval$(M),
            }
            Print
      Exit Sub
      Sub Status(Ok as boolean=False)
            Print "Total System Resources"
            PrintMax(System)
            Print "Available Resources in System"
            PrintResources(System)
            If Not Ok Then WaitForKey(): Exit Sub
            Local  M=Each(Processes)
            While M {
                  Print "Process "+Eval$(M, M^)
                  PrintResources(Processes(M^!))  ' give index M^ as Key index number (using !)
                  Print "Maximum Resources for "+Eval$(M, M^)
                  PrintMax(Processes(M^!))
            }
      End Sub
      Sub CheckNewState(&Ok)
            local M=Each(Processes), M1, count=len(Processes), alive(0 to count-1)=1
            Local Z, Recource$, safe as boolean=false
            While count {
                  safe=false
                  While M {
                        If alive(M^) Then {
                              Z=Processes(M^!)
                              M1=Each(Z) 
                              safe=True 
                              While M1 {
                                    Recource$=Eval$(M1, M1^)
                                    If Instr(Recource$,"_")=0 Then {
                                         safe=System(Recource$)+System(Recource$+"_Request") >= Z(Recource$ + "_max") - Z(Recource$)-Z(Recource$ + "_Request")
		               }
                                    If not safe Then exit
                              }
                              If safe Then {
                                    print format$("Process {0} is executing", M^+1)
                                    alive(M^)=0
                                    count--
                                    M1=Each(Z) 
                                    While M1 {
                                          Recource$=Eval$(M1, M1^)
                                          If Instr(Recource$,"_")=0 Then {
                                                Return System, Recource$+"_Request":= System(Recource$+"_Request") + Z(Recource$) + Z(Recource$+"_Request")
                                                Return Z, Recource$+"_Request":=0
                                          }
                                    }
                              }
                        }
                  }
                  If safe Else exit
            }
            Ok=safe
            ClearAllRequest(System)
      End Sub
}
BankerAlgo
keyboard "Info"+chr$(13)
}
MODULE MATMUL {\\ http://www.rosettacode.org/wiki/Matrix_multiplication#M2000_Interpreter
Module CheckMatMult2 {
	\\ Matrix Multiplication
	\\ pass arrays by reference
	\\ if we change a passed array here, to a new array then this change also the reference array.
	Function MatMul(&a(),&b()) {
		if dimension(a())<>2 or dimension(b())<>2 then Error "Need two 2D arrays "
		let a2=dimension(a(),2), b1=dimension(b(),1)
		if a2<>b1 then Error "Need columns of first array equal to rows of second array"
		let a1=dimension(a(),1), b2=dimension(b(),2)
		let aBase=dimension(a(),1,0)-1, bBase=dimension(b(),1,0)-1
		let aBase1=dimension(a(),2,0)-1, bBase1=dimension(b(),2,0)-1
		dim base 1, c(a1, b2)
		for i=1 to a1 : let ia=i+abase : for j=1 to b2 : let jb=j+bBase1 : for k=1 to a2
		c(i,j)+=a(ia,k+aBase1)*b(k+bBase,jb)
		next k : next j : next i
		\\ redim to base 0
		dim base 0, c(a1, b2)
		=c()
	}
	\\ define arrays with different base per dimension
	\\ res() defined as empty array
	dim a(10 to 13, 4), b(4, 2 to 5), res()
	\\ numbers from ADA task
	a(10,0)= 1, 1, 1, 1, 2, 4, 8, 16, 3, 9, 27, 81, 4, 16, 64, 256
	b(0,2)= 4, -3, 4/3, -1/4, -13/3, 19/4, -7/3, 11/24, 3/2, -2, 7/6, -1/4, -1/6, 1/4, -1/6, 1/24
	res()=MatMul(&a(), &b())
	for i=0 to 3 :for j=0 to 3
	Print res(i,j),
	next j : Print : next i
}
CheckMatMult2
}
MODULE MATEXP {\\http://www.rosettacode.org/wiki/Matrix-exponentiation_operator#M2000_Interpreter
Module CheckIt {
	Class cArray {
		a=(,)
		Function Power(n as integer){
			cArr=This     ' create a copy
			dim new()
			new()=cArr.a   ' get a pointer from a to new()
			Let cArr.a=new()    ' now new() return a copy
			cArr.a*=0  ' make zero all elements
			link cArr.a to v()
			for i=dimension(cArr.a,1,0) to dimension(cArr.a, 1,1) : v(i,i)=1: next i
			while n>0
				let cArr=cArr*this    ' * is the operator "*"
				n--
			end while
			=cArr
		}
		Operator "*"{
			Read cArr
			b=cArr.a
			if dimension(.a)<>2 or dimension(b)<>2 then Error "Need two 2D arrays "
			let a2=dimension(.a,2), b1=dimension(b,1)
			if a2<>b1 then Error "Need columns of first array equal to rows of second array"
			let a1=dimension(.a,1), b2=dimension(b,2)
			let aBase=dimension(.a,1,0)-1, bBase=dimension(b,1,0)-1
			let aBase1=dimension(.a,2,0)-1, bBase1=dimension(b,2,0)-1
			link .a,b to a(), b()  ' change interface for arrays
			dim base 1, c(a1, b2)
			for i=1 to a1 : let ia=i+abase : for j=1 to b2 : let jb=j+bBase1 : for k=1 to a2
			c(i,j)+=a(ia,k+aBase1)*b(k+bBase,jb)
			next k : next j : next i
			\\ redim to base 0
			dim base 0, c(a1, b2)
			.a<=c()
			}
		Module Print {
			link .a to v()
			for i=dimension(.a,1,0) to dimension(.a, 1,1) 
			for j=dimension(.a,2,0) to dimension(.a, 2,1) 
			print  v(i,j),: next j: print : next i
 
		}
	Class:
		\\ this module used as constructor, and not returned to final group (user object in M2000)
		Module cArray (r) {
			c=r
			Dim a(r,c)
			For i=0 to r-1 : For j=0 to c-1: Read a(i,j): Next j : Next i
			.a<=a()
		}
	}
	Print "matrix():"
	P=cArray(2,3,2,2,1)
	P.Print
	For i=0 to 9 
		Print "matrix()^"+str$(i,0)+"="
		K=P.Power(i)
		K.Print
	next i
}
Checkit
}
MODULE NQ {form ! 60,32
Set Fast !
Double
Print "N-Queens"
Refresh 1000
Cls,2
Module N_queens {
Const l = 9  'number of queens)
Const b = true  'print option
Dim a(0 to  l), s(0 to l), u(0 to 4 * l - 2)
Def long n, m, i, j, p, q, r, k, t
For i = 1 To l: a(i) = i: Next
For n = 1 To l
	m = 0 : i = 1:j=0:r=2*n-1
	Do
		i-- :j++:p=0:q=-r
		Do :i++ :u(p)=1:u(q+r)=1:Swap a(i), a(j):p=i-a(i)+n:q=i+a(i)-1:s(i)=j:j=i+1:Until j > n Or u(p) Or u(q + r)
		If u(p)=0 Then If u(q+r)=0 Then m++ : If b Then Disp()
		if Esc then Print"Esc" : break
		j = s(i)
		While j >= n And i <> 0
			Do :Swap a(i), a(j) :j--:Until j < i
			i--:p=i-a(i)+n :q=i+a(i)-1:j = s(i):u(p)=0:u(q+r)=0
		End While
	Until i=0
	Print Part @(0),~(15),"Queens:";~(14);n, @(tab(2)), ~(15),"Solutions:";~(14);m
	if n<l Then Print Under $(7,width),"Press a key",@(0) : Push Key$ : Drop Else Print Under
Next
Sub Disp()
	Pen 14 {Print "n="; n; "    m="; m}
	For k=1 To n  :For t=1 To n
		Print If$(a(n-k+1)=t-> "♛", ".");
	Next :Print : Next
	Refresh
	wait 1  ' this is the spot where a thread get time to run
End Sub
}
Escape Off
\\ simulate Esc key,using a thread (threads need time, so we use Wait to get it)
Global Esc=False
Thread {Esc<=keypress(27)} as M interval 100

Pen 15{N_queens}
Thread M Erase
Print
Normal
while keypress(27) : Wait 1: End While
Set Fast
Escape On
}
MODULE MOUSEPOS {Module Checkit {
	\\ works when console is the active window
	\\ pressing right mouse button exit the loop
	While mouse<>2
		Print mouse.x, mouse.y
	End While
	\\ end of part one, now we make a form with title Form1 (same name as the variable name)
	Declare Form1 Form
	Layer Form1 {
		window 16, 10000,8000  ' 16pt font at maximum 10000 twips x 8000 twips
		cls #335522,0
		cls , 2 \\ from 3rd line start the split screen (for form's layer)
		pen 15 ' white
	}
	Function Form1.MouseMove {
		Read new button, shift, x, y  ' we use new because call is local, same scope as Checkit.
		Layer Form1 {
			print
			print part x, y, button
			refresh
		}
	}
	Function Form1.MouseDown {
		Read new button, shift, x, y
		\\ when we press mouse button we print in console
		\\ but only the first time
		print x, y, button
		refresh
	}
	\\ open Form1 as modal window above console
	Method Form1, "Show", 1
	Declare Form1 Nothing
}
CheckIt
}
MODULE PRI {Module  Prime_decomposition    {
	Inventory Known1=2@, 3@
	IsPrime=lambda  Known1 (x as decimal) -> {
		=0=1
		If exist(Known1, x) Then =1=1 : Exit
		If x<=5 OR frac(x) Then {If x == 2 OR x == 3 OR x == 5 Then Append Known1, x  : =1=1
		Break}
		If frac(x/2) Else Exit
		If frac(x/3) Else Exit
		x1=sqrt(x):d = 5@
		{If  frac(x/d ) Else Exit
		d += 2: If d>x1 Then Append Known1, x : =1=1 : Exit
		If frac(x/d) Else Exit
		d += 4: If d<= x1 Else Append Known1, x :  =1=1: Exit
		Loop}
	}
	decompose=lambda IsPrime (n as decimal) -> {
	Inventory queue Factors
	k=2@
	While frac(n/k)=0:n/=k:Append Factors, k:End While
	If n=1 Then =Factors : Exit
	k++ 
	While frac(n/k)=0:n/=k: Append Factors, k:End While
	If n=1 Then =Factors : Exit
	do
		k+=2
		While not isprime(k) :k+=2:End While
		While frac(n/k)=0 :n/=k: Append Factors, k:End While
	until n=1
	=Factors
	}
	Data 10, 100, 12, 144, 496, 842,1000, 1122, 5555, 9999, 1212454, 10242048
	Data  22819637
	Back {cls #666666}
	Mode 8
	gradient #666666,#666666
	olinespace=linespace
	linespace twipsy*6
	oPen=Pen
	oBold=Bold
	Bold 1
	Pen=14
	Print $(0,width div 6-1),
	tab1=width -tab
	oBold=Bold
	bb=#123612
	cc=#16A2A8
	Cursor 0, (height-Stack.Size-4) div 2
	Scroll Split 0
	Bold 0 : Italic : double
	Print Part $(6, 6), ~(0,7),"Number", $(6, width-6+1),~(oPen,3,3), "Prime decomposition"
	Bold oBold : Italic : Normal
	Print
	Pen 15 {Print Under}
	While not empty
		Over  ' make a copy
		Print Over  ~(oPen,cc)
		Print Part $(4,12), ~(15,bb),Number,$(6,5),~(oPen),Decompose(Number) : Refresh
		Pen 15 {Print Under}
	End While
	Bold oBold
	Scroll Split 0  ' reset without clear
	Linespace olinespace
	a$=key$
	keyboard "info"+chr$(13)
}
Prime_decomposition
}
MODULE ECHELON {\\ http://www.rosettacode.org/wiki/Reduced_row_echelon_form#M2000_Interpreter
\\ Reduced row echelon form
Module base0 {
      dim base 0, A(3, 4)
      A(0, 0)= 1,    2,   -1,   -4,  2 ,   3,   -1,   -11,  -2  ,  0 ,  -3,    22
      lead=0
      rowcount=3
      columncount=4
      gosub disp()   \\ we can use gosub if an array has the same name as a sub,
      for r=0 to rowcount-1 {
            if columncount<=lead then exit
            i=r
            while A(i,lead)=0 {
                  i++
                  if rowcount=i then i=r : lead++ : if columncount<lead then exit
            }
            for c =0 to columncount-1 {
                  swap A(i, c), A(r, c)
            }
              if A(r, lead)<>0 then {
                  div1=A(r,lead)
                  For c =0 to columncount-1 {
                      A( r, c)/=div1
                  } 
            }
            for i=0 to rowcount-1 {
                  if i<>r then {
                        mult=A(i,lead)
                        for j=0 to columncount-1 {
                                 A(i,j)-=A(r,j)*mult
                        }
                  }
            } 
            lead=lead+1
      }
      Print "Solution"
      disp()
      sub disp()
            local i, j
            for i=0 to rowcount-1
                  for j=0 to columncount-1
                        Print A(i, j),
                  Next j
                  if pos>0 then print
            Next i
      End sub
}
base0
}
MODULE ERATO {Module EratosthenesSieve (x) {
      \\ Κόσκινο του Ερατοσθένη
      If x>200000 Then Exit
      Dim i(x+1)
      k=2
      k2=x div 2
      While k<=k2 {
            m=k+k
            While m<=x {
                  i(m)=1
                  m+=k
            }
            k++
      }
      For i=2 to x {
      If i(i)=0 Then Print i,
      }
      Print
}
EratosthenesSieve 1000
}
MODULE BUB {Module Bubble {
      function bubblesort {
                  dim a()    
                  \\ []  is a stack object,  interpreter pass current stack pointer, and set a new stack for current stack
                  \\ array( stackobject ) get a stack object and return an array
                  a()=array([])
                  itemcount=len(a())
                   repeat {
                        haschange=false
                        if itemcount>1 then {
                              for index=0 to itemcount-2 {
                                  if a(index)>a(index+1) then swap a(index), a(index+1) : haschange=true
                              }
                        }
                       itemcount-- 
                   } until not haschange
                   =a()
      }
      \\ function can take parameters
      Print bubblesort(5,3,2,7,6,1)
      A=(2, 10, 17, 13, 20, 14, 3, 17, 16, 16)
 
      \\ !A copy values from array A to function stack
      B=bubblesort(!A)
      Print Len(A)=10 
      Print B
      \\ Print array  in descending order
      k=each(b, -1, 1)
      While k {
            Print Array(k),
      }
      \\ sort two arrays in one
      Print BubbleSort(!A, !B)
      \\ We can use a stack object,  and values pop from object
      Z=Stack:=2, 10, 17, 13, 20, 14, 3, 17, 16, 16
      Print Len(Z)=10
      Def GetStack(x)=Stack(x)
      Z1=GetStack(BubbleSort(!Z))
      Print Type$(Z1)="mStiva"
      Print Z1
      Print Len(Z1)
      Print Len(Z)=0  ' now Z is empty
}
Bubble
}
MODULE SHELL {Module ShellSortExample {
	Module shellsort(&a()) {
		DEf h%, i%, j%, k, n%
		n%= LEN(a())
		h% = n%
		WHILE h%
			IF h% = 2  THEN h% = 1 ELSE h%= h% DIV 2.2
			FOR i% = h% TO n% - 1
				k = a(i%)
				j% = i%
				WHILE j% >= h% AND k < a(ABS(j% - h%))
					a(j%) = a(j% - h%)
					j% -= h%
				END WHILE
				a(j%) = k
			NEXT
		END WHILE
	}
	
	DIM BASE 0,  numbers(20)
	numbers(0)=4, 65, 2, -31, 0, 99, 2, 83, 782, 1, 4, 65, 2, -31, 0, 99, 2, 83, 782, 1   ' first item must be number
	REM numbers(0):=4, 65, 2, -31, 0, 99, 2, 83, 782, 1, 4, 65, 2, -31, 0, 99, 2, 83, 782, 1  ' first item can be anything (using := an operator for arrays)
	\\ Pass array by reference
	shellsort &numbers()
	\\ Print all items using columns (automatic append lines)
	PRINT numbers()
}
ShellSortExample
}
MODULE TOWERS {Module Hanoi {
      Rem HANOI TOWERS
      Print "Three disks" : Print
      move(3, 1, 2, 3)
      Print 
      Print "Four disks" : Print
      move(4, 1, 2, 3)
 
 
      Sub move(n, from, to, via)
            If n <=0 Then Exit Sub
            move(n - 1, from, via, to)
            Print "Move disk"; n; " from pole"; from; " to pole"; to
            move(n - 1, via, to, from)
      End Sub
}
Hanoi
}
MODULE VARIAD {Module CheckIt {
      \\ Works for numbers and strings (letters in M2000)
      Function Variadic {
            \\ print a letter for each type in function stack
            Print Envelope$()
            \\Check types using Match
            Print Match("NNSNNS")
            =stack.size
            While not Empty {
                  if islet then {print letter$} else print number
            }
      }
      M=Variadic(1,2,"Hello",3,4,"Bye")
      Print M
      \\ K is a poiner to Array
      K=(1,2,"Hello 2",3,4,"Bye 2")
      \\ !K pass all items to function's stack
      M=Variadic(!K)
}
Checkit
 
 
Module CheckIt2 {
      Function Variadic {
            \\ [] return a pointer to stack, and leave a new stack as function's stack
            a=[]
            \\ a is a pointer to stack
            \\ objects just leave a space, and cursor move to next column (spread on lines)
            Print a
      }
      M=Variadic(1,2,"Hello",3,4,"Bye")
      Print M
      \\ K is a poiner to Array
      K=(1,2,"Hello 2",3,4,"Bye 2")
      \\ !K pass all items to function stack
      \\ ! operator unpack the array (place copies)
      M=Variadic(!K, "another one")
      S=Stack:=1,2,"Hello 2",3,4,"Bye 3"
      \\ ! operator remove items from S and place them to function's stack
      M=Variadic(!S, "from a stack object, removing items")
      Print Len(S)=0
      S=Stack:=1,2,"Hello 2",3,4,"Bye 3"
      \\ we use Stack() to get a copy of S (can be used for a list of stack objects)
      M=Variadic(!Stack(S), "from a stack object, without removing itmes")
      Print Len(S)=6
      Stack S {Flush}  ' we can use Flush when attach the S stack as a current stack preserving the old one (which we can't use in the block)
}
Checkit2
}
MODULE CREATEWINDOW {\\ simple code to create a window - and open as modal
\\ for fun we have a thread running in the background, each 1/60 of second  (1000mSec/60)
Profiler
Thread {
	Print format$("running in the background {0::-10}, {1:2:-10}", tick, timecount)
	refresh  ' need to refresh manualy because console window has lost focus when form open
} as k interval 1000/60
Module DisplayWindow (a$){
      Declare MyForm Form
      \\ split statement from rem to see the change in form's title
      Rem With MyForm,"Title", a$
      Method MyForm,"Show",1    ' wait to close
      Print "close now"
}
DisplayWindow "Window 1"
DisplayWindow "Window 2"
DisplayWindow "Window 3"
Thread k Erase
}
MODULE KNUTH {\\ Trabb Pardo–Knuth algorithm
\\ We use stack (a collection, which we add to top or to bottom and read from top)
\\ Each call place the arguents on top of stack (this isn't the return stack, we say this as Stack of Values)
\\ A module call another module placing the same stack
\\ A User function begin with a fresh stack with any number of arguments we pass
\\ M2000 Interpreter except for Events Objects, has no use of "signature" as an automatic tool
\\ Singature can be checked before reading from stack using Match() function
\\ and that we did in Run module.
\\ If we try to Read a number but a string is on top of stack then we get error
\\ Also Interpreter has to give a value to a variable in Read statement and if nothing found raise an error.
\\ We can give a value say Read X=10 so if no value found then X get value 10
\\ For Stack of Values between Module's calls (and the same if we call a function using Call like a statement)
\\ we have to make proper pops (also we can pusj to return values). The callee has to clean the stack for a proper state.

\\ Each module has own scope (it is like  a program). Variables, Modules, Functions can be defined on the fly (at run time). So we can use an If structure to choose definition for a function.
\\ We can see Globals, but a local or a global defined in module shadow the previous global. At the return from module, any new identifier erased (including local modules and functions).


Report {ask for 11 numbers to be read into a sequence S
      reverse sequence S
      for each item in sequence S
          result := call a function to do an operation
          if result overflows
              alert user
          else
              print result
      
      The task is to implement the algorithm:
                  
            Use the function:    f(x)=|x|^{0.5}+5x^3
            The overflow condition is an answer of greater than 400.
            The 'user alert' should not stop processing of other items of the sequence.
            Print a prompt before accepting eleven, textual, numeric inputs.
            You may optionally print the item as well as its associated result, but the results must be in reverse order of input.
            The sequence   S   may be 'implied' and so not shown explicitly.
            Print and show the program in action from a typical run here. (If the output is graphical rather than text then either add a screendump or describe textually what is displayed).
            }
Module Input11 {
      Flush ' empty stack
      For I=1 to 11 {
            Do : Print : Try ok {Input "Give me a number ", a} : Until ok
            \\ using Push a we do the reverse here, but ge have to indicate somehow in module Run to not reverse again then stack
            Data a   ' add to bottom of stack, use: Push a to add to top, to get reverse order here
            Print if$(i<11->format$("need {0} more number{1}", 11-I, if$(i<10->"s","")),"ok")
      }
}
Module Run {
      Module Msg {Drop}  ' not used if we pass a decoration
      Msg  "Trabb Pardo–Knuth algorithm"
      Msg "f(x)=Sqrt(Abs(x))+5*x^3"
      if not match("NNNNNNNNN") then Error "Need 11 numbers" 
      Shiftback 1, -11 ' reverse  order 11 elements of stack of values
      Def f(x)=Sqrt(Abs(x))+5*x^3
      For i=1 to 11 {
            Read pop
            y=f(pop)
            if y>400 Then {
                  Pen Pen {Print ~(12), format$("f({0}) = Overflow!", pop)}
            }  Else {
                  Print format$("f({0}) = {1}", pop, y)
            }
      }
}
Global Counter
Module Msg (a$) {
	Pen 15 {Print a$}
	Counter++
}
\\ we can pass a module (only for modules when we call them by name, not using CALL)
\\ so we can't use an external module for recursion in module
\\ a module can't call his name, except we use Call statement
\\ The Msg is a decorator for Run 
Run 10, -1, 1, 2, 3, 4, 4.3, 4.305, 4.303, 4.302, 4.301 ; Msg
Run 1, 2, 3, -4.55,5.1111, 6, -7, 8, 9, 10, 11  ' ; Msg  ' drop first ' to use external  Msg
Input11
Run ; Msg
Print "You use Msg ";Counter;" times"
}
MODULE PONG {IF IsWine Else Smooth On
\\ Program SoloPong
oldfont$=FontName$
'Font "Tahoma"
Hard=2 \\ 3 for more
Hide
Mode 18, 8000,2400
Motion Center
Module Hit {
              Score 2, 100,"g"
              Play 2, 127
}
Gosub Functions
Background {
font "Verdana"
mode 18
cls
Refresh 5000
Dim D$()
D$()=Nu$()
Cls 5,0
Pen 14
a$=""
b$=""
b1$=""
Move 0,0
Fill 300,Scale.Y, 15
Move 0,0
Copy 300,300 To a$
Copy 300,1800 To b$
Copy 300,Scale.Y To b1$
Again:
Cls 0,0
Refresh 5000
Mouse.Icon Hide
Cls #222222,0
Print @(5,5),
Pen 7 {
      Report {Game SoloPong II
            Press P for pause
            Press space...
            ...to end the game
            }
      }
For i=0 to Scale.Y Step twipsY*2 { Move 0,i : Draw scale.X, 0, #555555 }
xk=Int(scale.X/2-150)
xk0=scale.X/2
xk03=scale.X/3
xk1=xk-300*7
xk2=xk+900
xa0=850
xa00=0
xa2=xa0+150
xa1=400
Refresh 50
xd1=scale.X-1000
xd2=xd1+600
For i=0 to scale.Y-300 Step 600 { Copy xk, i Use a$ }
Score1=0
Score2=0
Copy xk1, 900 Use D$(Score1)
Copy xk2, 900 Use D$(Score2)
yo=-900
yo1=yo-Scale.Y/4
yo2=yo1+Scale.Y/2
yb=Scale.Y+900
Yab=30
Player 1, 850,yo  Use b1$
Player 2, xd1,10000  Use b$
Player 3,  850,yb  Use b1$
y2=scale.Y-900-1000
xm=xk
ym=3000+Random(2,5)*300
Player 4, xm,ym  Use a$,1,0, 45size 2
For i=1 To 4 { Player i Show }
y3=Scale.Y-300
x3=scale.X-300
y4=Scale.Y/2
tx=120
tm=120
yp=Mouse.X
y=yp
kp=0
kw=(xd1-xk) div 2
Thread {
      if (xm<xk and kp=0) or (xm>xk and kp<>0)  then if keypress(1) then kp=-kw-kp
      yp=y : y=Mouse.Y
} As nm Interval 25
Wait 100
Refresh 50
Score=False
Thread {
      If y<1900 Then { y=1900: yp=1900   } Else.If y>y2 Then y=y2: yp=y2
      If ym<300 Then { tm-! : ym+=tm  } Else.If ym>y3 Then tm-! : ym+=tm
      If Collide(4, 80, xa1,yo+y4, xa2, yb-y4) or Score Then {
            Score=True
      } Else.If collide(4, 100, xa1,yo-y4, xa2, yo+y4) Then {
            tx-! : xm=xa2+500
            tx*=1.5
            Hit
       } Else.If collide(4, 100, xa1,yb-y4, xa2, yb+y4) Then {     
            tx-! : xm=xa2+500
            tx*=1.5
            Hit
       } Else.If collide(4, 100, xd1+kp,y-900, xd2+kp, y+900) Then {
	   if kp then hard=1: tz=2
	   tx=-Abs(tx) : xm+=tx*Hard
	   tx=min.data(-Int(Log(Abs(y-yp)+2))*45*Hard, tx/2, -120) 
	   tm=Sgn(ym-y)*Abs(Int((ym-y)/10))+Sgn(tm)*30*Hard
	   Hit
      }
      Rem 1 : Cursor 0,Height-1 : Print Over $(,8),xm, ym , Abs(y-yp), tx, tm
      Player 2,xd1+kp,y
      'Player 4, xm,ym     
      Player 4, xm,ym Use a$,1,0, xm mod 360 size (2*xk-Abs(xm-xk))/xk
      xm+=tx       
      ym+=tm
      } As mp Interval 10
Thread {
Pen 7 {
      Cursor 0,0 : Print Part $(6,8),@(Width -8), ~(Pen,#555555),Str$(Now,"hh:mm:ss")
}
} As tt Interval 1000
Thread {
If xm>xk0 And xa00=0 Then {
      xa00=twipsX*20
}
} As dd Interval 10000
Refresh 50
kr=True
finish=False
Main.Task 100 {
      If kr Then {
            yo+=Yab
            yb+=Yab
            If yo>yo2 Then Yab-! Else.If yo<yo1 Then Yab-!
            xa0+=xa00
            If xa0>xk03 Then {
                  If tx>0  or xk0 <xm Then {
                  Thread dd Hold
                  xa00=0 
                  }  Else xa00=-twipsX*20 : Thread dd Restart
            }
            If xa0<850 Then xa0=850 : xa00=0
            xa2=xa0+150
            Player 1,xa0,yo
            Player 3,xa0,yb
            Rem 2 : Cursor 0,Height-1 : Print Over $(,8), yo, yb, Score
      }
      If xm>x3  or xm<850  Then {
            Score=False
            tx=0
            tm=0
            If xm>x3 Then {
                  Score1++
                  Copy xk1, 900 Use D$(Score1)
            } Else {
                  Score2++
                  Copy xk2, 900 Use D$(Score2)
            }
            If Score1=10 or Score2=10 Then Break
            xm=xk
            ym=3000+Random(2,5)*150
            Player 4, xm,ym
            yp=ym
            tx=60*Random(2,5)/3+120
            tm=tx-60
            Score=False
      }
      Select Case Inkey$
      Case "p","P"
            {
                  If kr Then { 
                        Thread mp Hold
                        Layer {
                              Cls 0, 0
                              Pen 15 {
                                    Cursor 0, 0
                                    Print Over $(6),"Solo Pong II"
                                    Cursor 0, Height/2-1
                                    Print Over $(6),"Press P or p to continue.."
                                    Print Under
                                    Print Over $(6)," or press space to end the game"
                              }
                              Show
                        }
                  } Else {
                        Layer {
                              Hide
                              Cls 5
                        }
                        Thread mp Restart
                  }
                  kr~
            }
      Case " "
            {  If Not kr Then Layer {Hide }: kr~
                  Thread mp Hold
                  Mouse.icon Show 
                  If Ask("Stop this game","SoloPong","Yes","No")=1 Then { 
                  Layer {Cls 5}
                        finish=True
                  } Else Mouse.icon Hide
                  Thread mp Restart
            }
      End Select
      If finish Then Exit
}
Threads Erase
If kr Else { Layer {Hide : Cls 5} : kr~ }
Mouse.icon Show 
If Ask("New Game","SoloPong","Yes","No")=1 Then Goto Again
Player 0
Cls 5
}
Font oldfont$
Form 60,30
Show
Keyboard "Info"+chr$(13)
End
Functions:
Function Nu$ {
x=0
y=0
Zero$={_***_
                  *___*
                  *___*
                  *___*
                  *___*
                  *___*
                  _***_
                  }
One$={__*__
                  _**__
                  *_*__
                  __*__
                  __*__
                  __*__
                  *****
                  }
Two$={_***_
                  *___*
                  ____*
                  _***_
                  *____
                  *____
                  *****
                  }
Three$={_***_
                  *___*
                  ____*
                  __**_
                  ____*
                  *___*
                  _***_
                  }
Four$={___*_
                  __**_
                  _*_*_
                  *__*_
                  *****
                  ___*_
                  ___*_
                  }
Five$={*****
                  *____
                  ****_
                  ____*
                  ____*
                  *___*
                  _***_
                  }
Six$={_***_
                  *___*
                  *____
                  ****_
                  *___*
                  *___*
                  _***_
                  }
Seven$={*****
                  ____*
                  ___*_
                  __*__
                  __*__
                  __*__
                  __*__
                  }
Eight$={_***_
                  *___*
                  *___*
                  _***_
                  *___*
                  *___*
                  _***_
                  } 
Nine$={_***_
                  *___*
                  *___*
                  _****
                  ____*
                  *___*
                  _***_
                  } 
Ten$={*__*_
                  *_*_*
                  *_*_*
                  *_*_*
                  *_*_*
                  *_*_*
                  *__*_
                  }   
Dim D$(11), D1$(11)
W1=300
H1=300
D$(0)=Zero$,One$, Two$, Three$, Four$,Five$, Six$, Seven$, Eight$, Nine$, Ten$
      For D=0 to 10 {
      Cls #222222,0
      For i=0 to 7*H1 Step twipsY*2 {
      Move 0,i
      Draw scale.X, 0, #555555
      }
      L=1
      Move x,y
      For k=0 to 7 {
            For i=0 to 4 {
                       If Mid$(D$(D),L,1)="*" Then { Fill W1, H1,15 }  Else Step W1, H1
                       Step 0, -H1
                  L++
            }
            Step -5*W1, H1
            L+=2
      }
      a$=""
      Move x,y
      Copy W1*5,H1*7 To a$
      D1$(D)=a$
      }
=D1$()
}
Return
}
MODULE DI2 {inline code libDiv
'Form 80, 40
flush
def r(x, p)=int(x*10^p)/10^p
Data ProDiv$("1","580000",16, true), 1 / 580000
Data ProDiv$("1","580000000",16), 1 / 580000000
Data ProDiv$("1","5800",16), 1 / 5800
Data ProDiv$("1","58",16), 1 / 58
Data ProDiv$("632010","58",0), 632010 div 58
Data ProDiv$("2320","58",0),2320 div 58
Data ProDiv$("324200","203",16), 324200 / 203
Data ProDiv$("32420","23",16), 32420 / 23
Data ProDiv$("32420","23",15, true), 32420 / 23
Data ProDiv$("32420","23",15), 32420 / 23
Data ProDiv$("100","1",1), 100/1
Data ProDiv$("1025","2",0), 1025 div 2
Data ProDiv$("3242","23",0), 3242 div 23
Data ProDiv$("324300","23",0), 324300 div 23

Data ProDiv$("232","58",0), 232 div 58
Data ProDiv$("3243","23",0), 3243 div 23
Data ProDiv$("23200","58",0), 23200 div 58
Data ProDiv$("2320","58",0), 2320 div 58
Data ProDiv$("632010","123",16), 632010 / 123
Data ProDiv$("100","1",1), 100/1
Data ProDiv$("100","2",1), 100/2
Data ProDiv$("632010","123",16), 632010 / 123

Data ProDiv$("1000","15",16), 1000 / 15
Data ProDiv$("1500","25000",,,1), r(1500 / 25000, 1)
Data ProDiv$("1500","25000"), r(1500 / 25000, 2)
Data ProDiv$("1500","25000"), r(1500 / 25000, 3)

Data ProDiv$("1500","22000",16), r(1500 / 22000, 16)
Data ProDiv$("1500","22000",14, true), 1500 / 22000
Data ProDiv$("1500","2500",16), 1500/2500

Data ProDiv$("1500","250",,,16), 1500/250

Data ProDiv$("15000","25",,,16), 15000/25

Data ProDiv$("15000000000","25",0), 15000000000/25
Data ProDiv$("15000000000","245",14), 15000000000/245

while not empty
read a$, a
print val(a$)==a , @(12), a$,@(50), a
end while
}
MODULE LIBDIV {\\ use in console EDIT !4
\\ so tab width change to 4 characters
Function ProDiv$ {
	Read a$, b$, pp=10, rd as boolean=false, maxd=-1, dp$="."
	if pp<0 then error "decimal digits>=0 "
	if rd then pp++
	Let v$="", gg=len(b$), p=pp,  mm=0, d1=0, mm1=0, od1=-1
	if len(b$)>len(a$) then 
		gg=len(b$)-len(a$): a$+=string$("0",gg):mm1=gg :gg=1:pp++:p=pp
	else.if len(b$)=len(a$) and b$>a$ then
		a$+="0":  mm1=-1:gg=1: pp++:p=pp		
	end if
	if mm1<>0 and maxd>0 then p=min.data(maxd-1, p)-rd : maxd=0
	lz=pp
	{
		s=len(b$)
		c$=left$(a$,s)
		if c$<b$ then  s++: c$=left$(a$, s) :if s=len(b$) then exit
		d1=val(c$) div val(b$)
		r$=str$(val(c$)-val(b$)*d1,"0")
		if gg<s-1  then
			if v$="0" then
				mm=-s+gg : if p+mm<17 then  a$+=string$("0", p+mm)
				p=p-len(v$) : if p<0 then p=0
			end if
			v$+=string$("0",s-1-gg)
		end if
		v$+=str$(d1,"0")
		if d1<>0 then od1=len(v$)-1
		gg=len(r$)
		a$ =r$+mid$(a$,s+1)
		cc=false
		if len(a$)=len(b$) then
			if a$>=b$ then cc=true
		else
			cc=len(a$)>len(b$) and a$<>"0"
		end if
		
		
		if cc else if p=0 then  exit
		
		if p>0  and not cc then
			if len(a$)>gg then
				mm=len(v$)+2
			else
				mm=len(v$)+1
			end if
			a$+=string$("0", p) : p=0
		end if
		
		loop
	}
	if mm1<>0 then
		if mm1=-1 then if left$(v$,1)="0" then v$=mid$(v$,2)
		if mm1<0 then mm=mm1 : mm1=-2 else mm=2-mm
	end if
	if len(a$)>gg and len(a$)>=len(b$) then v$+=string$("0",gg)
	if maxd>0 then
		if mm=0 then mm=len(v$)+1
		v$=left$(v$,maxd+2) :if len(v$)>maxd+1 then rd=true
	end if
	if rd  then
		bb$=strrev$(v$) :v$="":cc=5
		for i=1 to len(bb$)
			if cc=0 then v$+=mid$(bb$, i) : exit for
			dd=val(mid$(bb$, i,1))+cc  
			if dd>9 then  cc=1 else  cc=0
			v$+=str$(dd mod 10, 0) 
		next i
		v$=strrev$(mid$(v$,2))
	end if
	if left$(v$,1)="0" and len(v$)>1  then v$=mid$(v$,2): mm--

	if mm=0 then  =v$ : exit
	if mm>1 then
		n$=mid$(v$,mm+1)
		if len(n$)<16 then  if val(n$)=0 then n$="" : v$=left$(v$,mm)
		if mm+pp>16 or maxd>0 then
			if od1>0 then v$=left$(v$, od1+1)
			if mm-1<16 and maxd>0 then
				=left$(v$, mm-1)
			else
				=left$(v$,1)+dp$+mid$(v$,2)+if$(mm=2->"","E+"+str$(mm-2,"00"))
			end if
		else.if  mm+pp<16 then
			if val(mid$(v$,mm))=0 then
				=left$(v$,mm-1)
			else
				if od1>0 then v$=left$(v$, od1+1)
				=left$(v$,mm-1)+dp$+mid$(v$,mm)
			end if
		else
			if od1>1 then n$=left$(v$, od1-1)
			=Left$(v$,1)+dp$+n$
		end if
	else.if mm<0  then
		if od1>0 then v$=left$(v$, od1)
		if len(v$)<=16 and mm1+mm<16 then
			if mm1=-1 then
				v$="0"+mid$(v$,-mm,1)
			else
				v$=string$( "0", mm1+1)+mid$(v$,-mm,1)
			end if
			=mid$(v$,1, 1)+dp$+Mid$(v$,2)
		else
			=mid$(v$, -mm, 1)+dp$+Mid$(v$,-mm+1)+if$(mm1+1=0 -> "","E-"+str$(abs(mm1+1),"00"))
		end if
	else
		if od1>0 then v$=left$(v$, od1)
		if maxd=0 then ="0" else =v$
	end if
}
}
MODULE ADDER4BIT {Module  FourBitAdder {
	Flush
	dim not(0 to 1),and(0 to 1, 0 to 1),or(0 to 1, 0 to 1)
	not(0)=1,0
	and(0,0)=0,0,0,1
	or(0,0)=0,1,1,1
	xor=lambda not(),and(),or() (a,b)-> or(and(a, not(b)), and(b, not(a)))
	ha=lambda xor, and() (a,b, &s, &c)->{
		s=xor(a,b)
		c=and(a,b)
	}
	fa=lambda ha, or() (a, b, c0, &s, &c1)->{
		def sa,ca,cb
		call ha(a, c0, &sa, &ca)
		call ha(sa, b, &s,&cb)
		c1=or(ca,cb)
	}
	add4=lambda fa (inpA(), inpB(), &v, &out()) ->{
		dim carry(0 to 4)=0
		carry(0)=v    \\ 0 or 1  borrow
		for i=0 to 3
			\\ mm=fa(InpA(i), inpB(i), carry(i), &out(i), &carry(i+1)) ' same as this
			Call fa(InpA(i), inpB(i), carry(i), &out(i), &carry(i+1))
		next
		v=carry(4)
	}
	dim res(0 to 3)=-1,  low()
	source=lambda->{
		shift 1, -stack.size  ' reverse stack items
		=array([])  ' convert current stack to array, empty current stack
	}
	def v, k, k_low
	Print "First Example 4-bit"
	Print "A", "", 1, 0, 1, 0
	Print "B", "", 1, 0, 0, 1
	call add4(source(1,0,1,0), source(1,0,0,1), &v, &res())
	k=each(res() end to start)  ' k is an iterator, now configure to read items in reverse
	Print "A+B",v, k    ' print 1 0 0 1 1
	Print "Second Example 4-bit"
	v-=v
	Print "A", "", 0, 1, 1, 0
	Print "B", "", 0, 1, 1, 1
	call add4(source(0,1,1,0), source(0,1,1,1), &v, &res())
	k=each(res() end to start)  ' k is an iterator, now configure to read items in reverse
	Print "A+B",v, k    ' print  0 1 1 0 1
	Print "Third Example 8-bit"
	v-=v
	Print "A ", "", 1, 0, 0, 0, 0, 1, 1, 0
	Print "B ", "", 1, 1, 1, 1, 1, 1, 1, 1
	call add4(source(0,1,1,0), source(1,1,1,1), &v, &res())
	low()=res()  ' a copy of res()
	' v passed to second adder
	dim res(0 to 3)=-1
	call add4(source(1,0,0,0), source(1,1,1,1), &v, &res())
	k_low=each(low() end to start)  ' k_low is an iterator, now configure to read items in reverse
	k=each(res() end to start)  ' k is an iterator, now configure to read items in reverse
	Print "A+B",v, k, k_low   ' print 1 1 0 0 0 0 1 0 1
}
FourBitAdder
}
MODULE BASEG {Print "Wait..."
db.provider ""
db.provider "Microsoft.Jet.OLEDB.4.0", "Jet OLEDB", "newpassword"
'db.provider "Microsoft.ACE.OLEDB.12.0","Jet OLEDB", "newpassword"
\\ remove base if exist in current directory
base "mdbfile"
\\ Make a new table and insert values (M2000 use ADOdb with a special connection string)
\\ data taken from example's of MOSH HAMEDANI for SQL, see this video
\\ https://www.youtube.com/watch?v=7S_tz1z_5bA

\\ Create table changed from original to be used here, but the schema is the same.
\\ Maybe integer definition maybe not the same with original int(11).

\\ We use 3 times execute. One return nothing, but the other two return a record set each
\\ recordset saved to stack of values (as top value each time)
\\ so we call subroutine passing just the stack of values, so we read from there.

\\ Inside each subroutine we make some local variables, using a way to link recordset with properties
\\ property fields of recordset used 3 times, to produce different items. One is the actual object, and the
\\ other two by using an index value we get field value (the default property), one as numeric and
\\ the other as string.

\\ So we have to see about NULL. A NULL can exist if table schema allow it. When a field has NULL value
\\ we get it as numeric type of NULL (we can't use it as a value in expressions, always return NULL),
\\ but if we read it as string value we get empty string. 

\\ Here we see two rows, one with a NULL phone and one with empty string (which isn't Null)
\\ To examine if we have NULL we have to check the numeric variant of field.

\\ for checking the NULL we have a string function which return "NULL" or the string value,
\\ including empty string.


execute "mdbfile", {
	CREATE TABLE customers (
		customer_id AUTOINCREMENT PRIMARY KEY,
		first_name VARCHAR(50) NOT NULL,
		last_name VARCHAR(50) NOT NULL,
		birth_date date DEFAULT NULL,
		phone VARCHAR(50) DEFAULT NULL,
		address VARCHAR(50) NOT NULL,
		city VARCHAR(50) NOT NULL,
		state char(2) NOT NULL,
		points integer NOT NULL DEFAULT 0
	);
	INSERT INTO `customers` VALUES (1,'Babara','MacCaffrey','1986-03-28','781-932-9754','0 Sage Terrace','Waltham','MA',2273);
	INSERT INTO `customers` VALUES (2,'Ines','Brushfield','1986-04-13','804-427-9456','14187 Commercial Trail','Hampton','VA',947);
	INSERT INTO `customers` VALUES (3,'Freddi','Boagey','1985-02-07','719-724-7869','251 Springs Junction','Colorado Springs','CO',2967);
	INSERT INTO `customers` VALUES (4,'Ambur','Roseburgh','1974-04-14','407-231-8017','30 Arapahoe Terrace','Orlando','FL',457);
	INSERT INTO `customers` VALUES (5,'Clemmie','Betchley','1973-11-07',NULL,'5 Spohn Circle','Arlington','TX',3675);
	INSERT INTO `customers` VALUES (6,'Elka','Twiddell','1991-09-04','312-480-8498','7 Manley Drive','Chicago','IL',3073);
	INSERT INTO `customers` VALUES (7,'Ilene','Dowson','1964-08-30','615-641-4759','50 Lillian Crossing','Nashville','TN',1672);
	INSERT INTO `customers` VALUES (8,'Thacher','Naseby','1993-07-17','941-527-3977','538 Mosinee Center','Sarasota','FL',205);
	INSERT INTO `customers` VALUES (9,'Romola','Rumgay','1992-05-23','559-181-3744','3520 Ohio Trail','Visalia','CA',1486);
	INSERT INTO `customers` VALUES (10,'Levy','Mynett','1969-10-13','','68 Lawn Avenue','Atlanta','GA',796);
}

\\ id 10 has no Null phone, has no phone (is an empty string)
\\ Null means "no information yet"
report "customers created"
\\ execute a SELECT query to get a Recordset
report "Selected customers where Points<1000 in descending order"
execute "mdbfile",{
	SELECT 	customer_id,
			last_name,
			first_name,
			phone,
			points
	FROM 	`customers`
	WHERE 	Points<1000 
	ORDER BY 	Points DESC,
			last_name,
			first_name
}
Def CheckNull$(a, a$)=If$(type$(a)="Null"->"NULL", a$)
GetListA() ' value is already in stack

report  "Select customers id where phone is null"
execute "mdbfile",{
	SELECT 	customer_id,
			phone
	FROM 	`customers`
	WHERE 	phone IS Null 
	ORDER BY 	customer_id 
}
GetIDwithNullPhone()    ' value is already in stack

close base "mdbfile"
\\ using list to check the variable names
list
\\ there are no variables in module, at this moment.
\\ All variables was local to subs, and they erased at the exit of subs
\\ we can use dots in names, like a normal variable.
\\ so rs.fields is a norma variable name. This variable is a PropReference type.
\\ This type of variable is an object which link a property to an object
\\ We can't use these variables as return values, because the use a hard link,
\\ and not a standard reference to object. So PropReference can't hold alive a linked object.
\\ So if we return the PropReference from where we make it then became invalid, and we have
\\ to use it to raise the error.


sub GetListA(RS)
if type$(RS)="Recordset" then
	with RS, "EOF" as new rs.eof, "fields" as new fields(), "fields" as new fields$(), "fields" as new rs.fields
	with rs.fields, "count" as new rs.fields.count
	print  "Test number of fields:", rs.fields.count
	while not rs.eof
		print $(6),fields(0),
		print $(9)," ";fields$(1);" ";fields$(2);@(32); CheckNull$(fields(3), fields$(3));@(42), fields(4)
		method rs, "movenext"
	end while
	print $(0),,
end if
end sub
sub GetIDwithNullPhone(RS)
if type$(RS)="Recordset" then
	with RS, "EOF" as new rs.eof, "fields" as new fields(), "fields" as new fields$(), "fields" as new rs.fields
	with rs.fields, "count" as new rs.fields.count
	print  "Test number of fields:", rs.fields.count	
	while not rs.eof
		print $(4), fields(0), $(7), CheckNull$(fields(1), fields$(1)), $(0)
		method rs, "movenext"
	end while
	print
end if
end sub
}
MODULE EN1 {Module Checkit {
      \\ need revision 15, version 9.4
      Enum Fruit  {apple, banana, cherry}
      Enum Fruit2  {apple2=10, banana2=20, cherry2=30}
      Print apple, banana, cherry
      Print apple2, banana2, cherry2
      Print Len(apple)=0
      Print Len(banana)=1
      Print Len(cherry)=2
      Print Len(cherry2)=2, Cherry2=30, Type$(Cherry2)="Fruit2"
 
      k=each(Fruit) 
      While k {
            \\ name of variable, value, length from first (0, 1, 2)
            Print Eval$(k), Eval(k), k^
      }
      m=apple
      Print Eval$(m)="apple"
      Print Eval(m)=m
      m++
      Print Eval$(m)="banana"
      Try {
            \\ error, m is an object
            m=100
      }
      report error$
      Try {
            \\ error not the same type
            m=apple2
      }
      report error$
      Try {
            \\ read only can't change
            apple2++
      }
      report error$
      m++
      Print Eval$(m)="cherry", m
      k=Each(Fruit2 end to start) 
      While k {
             Print Eval$(k), Eval(k) , k^   
             CheckByValue(Eval(k))
      }
      m2=apple2
      Print "-------------------------"
      CheckByValue(m2)
      CheckByReference(&m2)
      Print m2
 
      Sub CheckByValue(z as Fruit2)
            Print Eval$(z), z
      End Sub
 
      Sub CheckByReference(&z as Fruit2)
            z++
            Print Eval$(z), z
      End Sub
}
Checkit
}
MODULE WUMPUS {Module WumpusGame {
      Print "Game: Hunt The Wumpus"
      Arrows=5
      Dim Room(1 to 20)
      Room(1)=(2,6,5),(3,8,1),(4,10,2),(5,2,3),(1,14,4)
      Room(6)=(15,1,7),(17,6,8),(7,2,9),(18,8,10),(9,3,11)
      Room(11)=(19,10,12),(11,4,13),(20,12,14),(5,11,13), (6,16,14)
      Room(16)=(20,15,17),(16,7,18),(17,9,19),(18,11,20),(19,13,16)
      Enum Things {EmptyRoom, Bat1, Bat2, Pit1, Pit2, Wumpus}
      Dim Content(1 to 20)=EmptyRoom
      i=each(Things,2)  ' from 2 to End
      While i {
            r=random(1,20)
            if Content(r)<>EmptyRoom then restart
            Content(r)=Eval(i)
      }
      WumpusPos=r
      PlayerPos=-1
      TranspotPlayer()
      Done=False
      \\ Help is statement but here used as variable
      Help=False
      While Arrows>0 And Not Done {
            Sense()
            Print "W- Walk, T - Throw Arrow, G - Give up or H for Help"
            a$=Ucase$(Key$)
            If a$="W" Then {
                  Print "Choose Tunnel to Walk: 1, 2 or 3"
                  r=Val("0"+Key$)-1
                  if r>=0 and r<=2 then {
                        PlayerPos=Array(room(PlayerPos), r)
                        Select Case Content(PlayerPos)
                        Case Wumpus
                        Eaten()
                        Case Pit1, Pit2
                        {
                              Arrows=0
                              Print "You fall to a bottomless pit;"
                        }
                        Case Bat1, Bat2
                        {
                              Print "A giant bat takes you in another room;"
                              TranspotPlayer()
                        }
                        End Select
                  }
            } Else.if a$="T" Then {
                  Arrows--
                  Print "Choose Tunnel to Throw Arrow: 1, 2  or 3"      
                  r=Val("0"+Key$)-1
                  if r>=0 and r<=2 then {
                        i=room(PlayerPos)
                        If Content(Array(i, r))=Wumpus then {
                              Done=True
                      } Else.if random(1,4)<4 then WakeWumpus()
                  }            
            } Else.if a$="G" Then {
                   Arrows=0
            } Else.if a$="H" Then Help~
      }
      If Done then Print "You kill the Monster Wumpus; You Win.": Exit
      Print "You loose."
 
      Sub TranspotPlayer()
            local r=random(1,20)
            While Content(r)<>EmptyRoom {r=random(1,20)}
            PlayerPos=r
      End Sub
      Sub WakeWumpus()
            local j=array(room(WumpusPos),random(0,2))
            If content(j)=EmptyRoom Then {
                  swap content(j), content(WumpusPos)
                  WumpusPos=j
                  If WumpusPos=PlayerPos then Eaten()
            }
      End Sub
      Sub Eaten()
            Arrows=0
            Print "You eaten by Wumpus;"
      End Sub
      Sub Sense()
            local k=Room(PlayerPos)
            local j=each(k), Wumpus_near, bat_near, pit_near
            Print "Player Room:";PlayerPos,
            If Help then Print "Wumpus Room:";WumpusPos
            While j {
                  If Help Then Print "Tunnel:";j^+1, "Room:";Array(j), "Content:";eval$(content(array(j)))
                  Select Case content(array(j))
                  Case Bat1, Bat2
                  bat_near=True
                  Case Pit1, Pit2
                  pit_near=True
                  Case Wumpus
                  Wumpus_near=True
                  End Select
            }
            If Wumpus_near Then Print "You smell something terrible nearby."
            If bat_near Then Print "You hear a rustling."
            if pit_near Then Print "You feel a cold wind blowing from a nearby cavern."
      End Sub    
}
cls,0
WumpusGame
}
MODULE FORTH {\\ https://rosettacode.org/wiki/Fixed_length_records#Forth_Blocks
\\ A Forth block is 1024 bytes. Source code is stored as 16 lines of 64 characters each (no newline character or sequence to mark the end of a line).

Form 80,50
Print "Forth's Blocks"
\\ Forth Blocks
Structure Line16 {
      a`Line as byte*64
}
NewBlock=lambda Line16 -> {
      Buffer a`Block as Line16*16
      \\ fill spaces
      Return a`Block, 0:=str$(string$(" ",1024))
      =a`Block
}
\\ Events are value types, but for closures and groups are reference types
Event Doit {
      Read something$
}
Header=Doit
DisplayBlock= Lambda NewBlock, Line16, Doit, Header (Blocks`File$,Block`Number, UseLocale=1033)->{
      Page1=NewBlock()
      Open Blocks`File$ for input as #f
            Seek #f, 1024*(Block`Number-1)+1
            Get #f,Page1
      Close #f
      Document NewDoc$
      \\ need to convert from Ansi
      Call Event Header, "Block:"+Str$(Block`Number)
      oldlocale=locale
      locale UseLocale
      For i=0 to 15
            lineAny$=chr$(Eval$(Page1,i, Len(Line16)))
            Call Event Doit, format$("{0::-2} {1}",i,chr$(Eval$(Page1,i, Len(Line16))))
      Next i
      locale oldlocale
}
Document ForthCode$={( Large letter F) 
      : STAR    [CHAR] * EMIT ;
      : STARS   0 DO  STAR  LOOP ;
      : MARGIN  CR 30 SPACES ;
      : BLIP    MARGIN STAR ;
      : BAR     MARGIN 5 STARS ;
      : F       BAR BLIP BAR BLIP BLIP CR ;
      }
\\ Make Document bigger than 16 lines
\\ doc.par(ForthCode$)  return paragraphs (here we have no wrap)
\\ actuall lines per layer can be found from Report (the renderer)
\\ using Reportlines. layer can be the printer page.
ForthCode$=string$(ForthCode$,5)
Print "Make Block"
Page1=NewBlock()
Locale 1033
Blocks`File$="Forth Blocks"
Block`Number=1
\\ Apppend three times same blocks
For Pass=1 to 3
      If Doc.Len(ForthCode$)>0 then
            For i=1 to Doc.par(ForthCode$)-1
            \\ we give order number but Paragraph$ use unique number for paragraphs
            \\ if we didn't delete or insert lines, then these two are the same
                  Print Paragraph$(ForthCode$, Paragraph(ForthCode$,i))
                  \\ convert to Ansi using Locale
                  \\ offset from 0, so minus 1
                  \\ offset 1 is at len(Line16)
                  \\ Page1(0) is the real address, but here doesn't matter
                  Return Page1, (i-1) mod 16:=Str$(Paragraph$(ForthCode$, Paragraph(ForthCode$,i)))
                  if i mod 16=0 then Gosub SaveBlock
            Next i
            i--
            if Not i mod 16=0 then  Gosub SaveBlock
      End if
Next Pass
\\ now we read from disk
Class DocumentKeeper {
      Document Text$
      Function AppendLine(aline$) {
            \\ right trim$
            .Text$<=Mid$(Trim$("*"+aline$),2)+{
            }
      }
}
Function Disp(aline$) {
      Print aline$
}
DocumentKeeper=DocumentKeeper()
Event Doit New Disp()
Event Header New Disp()
For i=1 to Block`Number-1
      Call DisplayBlock(Blocks`File$, i)
      Print "Press any key"
      Push key$ : Drop
Next i
Event Doit Drop Disp()
Event Doit New DocumentKeeper.AppendLine()
Event Header Hold
For i=1 to Block`Number-1
      Call DisplayBlock(Blocks`File$, i)
Next i
Report DocumentKeeper.Text$
 
End 
SaveBlock:
      Print "Save as Number ";Block`Number
      If Exist(Blocks`File$) then 
            \\ check if there is space for this block
            If Not filelen(Blocks`File$) div 1024>=Block`Number-1 Then
                  Error "Wrong Block Number"
            End if
      Else
            Print "not exist"
            Open Blocks`File$ for output as #f
            Close #f
            Wait 100
            \\ or Error "Empty File" if we wish only read
            If Block`Number<>1 then Error "Wrong Block Number"
      End if
      Open Blocks`File$ for append as #f
      Seek #f, Block`Number*1024-1023 ' so we seek to first byte
      Put #f, Page1
      Close #f
      Block`Number++
      Page1=NewBlock()
Return
}
MODULE FIXLENGTH {Module FixedFile {
      Read fixed$
      OldLocale=Locale
      \\ chr$(string_argument$)
      \\ use Locale to convert from Ansi to Utf-16LE
      \\ Read Ansi form files also use Locale
      Locale 1032
      Try ok {
            \\ Make the file first
            Const Center=2
            Font "Courier New"
            Bold 0
            Italic 0
            Def long m, z=1, f
            Def text2read$,test3write$
            Form 100, 50  ' 100 by 60 characters
            Document txt$={Line 1...1.........2.........3.........4.........5.........6.........7.........8
                  Line 2
                  Line 3
                  Line 4
 
                  Line 6
                  Line 7
                       Indented line 8............................................................
                  Line 9                                                                 RT MARGIN
                  }
            \\ use Help Open in M2000 console for details
            \\ Method one
            Report Center,  "Make file"
            \\ for WIDE Random \\  for Utf-16
            Open fixed$ for Random Exclusive as #f len=80
            m=Paragraph(txt$, 0)
            z=1
            If forward(txt$, m) then
                  while m, z<10
                        text2write$=Paragraph$(txt$,(m))
                        Print format$("Len:{0}, Data: {1}",Len(text2write$),text2write$)
                        Put #f, text2write$ , z
                        \\ record number from 1
                        \\ if number is total records plus one
                        \\ we append a record
                        z++     
                  End while
            End If
            Print "Press any key"
            Push Key$ : Drop
            Form 80, 40
            Report Center,  "Method1"
            For z=1 to 9
                  Get #f, text2read$, z
                  text2read$=StrRev$(text2read$)
                  Put #f, text2read$, z
                  Print text2read$
            Next z
            Close #f
            Report Center,  "Method2"
            \\ Method2
            \\ Buffer Clear Line80 ... \\ to clear memory
            \\ here we write all bytes so not needed
            Buffer Line80 as byte*80
            m=filelen(fixed$)
            If m mod 80=0 Then
                  m=1
                  \\ now Get/Put read write at byte position
                  \\ we have to use seek to move to byte position
                  \\ This way used for Binary files
                  Open fixed$ for Input as #f1
                  Open fixed$ for Append as #f2
                  while not eof(#f1)
                        seek #f1, m
                        Rem Print seek(#f)
                        Get #f1, Line80
                        Return line80,0:=Str$(StrRev$(Chr$(Eval$(line80,0,80))))
                        seek #f2, m
                        Put #f2, Line80
                        seek #f1, m
                        Get #f1, Line80
                        Print Chr$(Eval$(line80,0,80))
                        m+=80
                  End While
                  Close #f1
                  Close #f2
            End if
      }
      \\ use Close with no parameters for close all files if something happen
      If error then Close: Print Error$
      Locale OldLocale    
}
FixedFile "fixed.random"
Print "Press any key to display info page"
Push Key$ : Drop
Keyboard "Info"+chr$(13)
}
MODULE EERTREE {\\ https://rosettacode.org/wiki/Eertree
\\ https://en.wikipedia.org/wiki/Trie
\\ https://en.wikipedia.org/wiki/Suffix_tree
\\ Construct an eertree for the string "eertree", then output all sub-palindromes by traversing the tree.
Class Node {
      inventory myedges
      length, suffix=0
      Function edges(s$) {
            =-1 : if exist(.myedges, s$) then =eval(.myedges)
      }
      Module edges_append (a$, where) {
            Append .myedges, a$:=where
      }
Class:
      Module Node(.length) {
            Read ? .suffix, .myedges
      }     
}
function eertree(s$) {
      Const evenRoot=0, oddRoot=1
      Inventory Tree= oddRoot:=Node(-1,1),evenRoot:=Node(0,1)
      k=0
      suffix=oddRoot
      for i=0 to len(s$)-1 {
            c$=mid$(s$,i+1,1)
            n=suffix
            Do {
                 k=tree(n).length
                 b=i-k-1
                 if b>=0 then if mid$(s$,b+1,1)=c$ Then exit
                 n =tree(n).suffix  
            } Always
            e=tree(n).edges(c$)
            if e>=0 then suffix=e :continue
            suffix=len(Tree)
 
            Append Tree, len(Tree):=Node(k+2)
            Tree(n).edges_append c$, suffix
            If tree(suffix).length=1 then tree(suffix).suffix=0 : continue
            Do {
                  n=tree(n).suffix
                  b=i-tree(n).length-1
                  if b>0 Then If  mid$(s$, b+1,1)=c$ then exit
            } Always
            e=tree(n).edges(c$)
            if e>=0 then tree(suffix).suffix=e
 
      } 
      =tree
}
children=lambda (s, tree,  n, root$="")->{
            L=Len(tree(n).myEdges)
            if L=0 then =s : exit
            L--
            For i=0 to L {
                  c=tree(n).myEdges
                  c$=Eval$(c, i)  ' read keys at position i
                  nxt=c(i!)   '  read value using position 
                  p$ = if$(n=1 -> c$, c$+root$+c$)
                  append s, (p$,)
                  \\ better use lambda() and not children()
                  \\ for recursion when we copy this lambda to other identifier.
                  s = lambda(s, tree, nxt, p$)
            }
         = s
      }
aString=Lambda ->{
          Push Quote$(Letter$)
}
aLine=Lambda ->{
      Shift 2  ' swap two top stack items
      if stackitem$()="" then  { Drop}  Else Push letter$+", "+Letter$
}
Palindromes$=Lambda$ children, aString, aLine (Tree)-> {
            ="("+children(children((,), Tree, 0), Tree, 1)#Map(aString)#Fold$(aline,"")+")"
 }
 
Print Palindromes$(eertree("eertree"))
Print Palindromes$(eertree("banana"))
}
MODULE COMMON {thread.plan sequential   ' can run as concurrent too
linespace twipsY*2
' Mode as read only value return the height of layer form in pt. Using Mode we set to the same Mode but we cut extra space (use linespace also)
Mode 12
double  
backcolor=point
oldpen=pen
Refresh 500
Print Part $(6,Width+1),~(15, 7,pen),"Greatest common divisor"
Print under
gcd=lambda (u as long, v as long) -> {
           =if(v=0&->abs(u), lambda(v, u mod v))
}
gcd_Iterative= lambda (m as long, n as long) -> {
   while m  {
       let old_m = m
       m = n mod m
       n = old_m
   }
   =abs(n)
}
Module CheckGCD (f){
      Print Over  ~(#FFCCFF);"Calc gcd for 49865, 69811 = "; f(49865, 69811)  '=9973
      Print Under
      Def ExpType$(x)=Type$(x)
      Print Over "Return type:"; ExpType$(f(49865, 69811)) '="Long"
      Print Under
}
Print Part "Using a lambda function working with ";~(#AACCFF);"recursion"
Print Under
CheckGCD gcd
Print Part  "Using a lambda function working ";~(#AACCFF);"iterative"
Print Under
CheckGCD gcd_Iterative
normal
Print
Print
Press()
Keyboard "infobasic"+chr$(13)
End  ' we can omit this
Sub title(a$)
Pen #ffeeff {
	cursor 0
	Italic 1
	a$=replace$(chr$(9),"      ", a$)
	Report a$
	Italic 0
	cursor 6, row-1
}
End Sub
Sub Press()
	wait 200
	local col=15,  col2=backcolor, threadid
	Input End  ' empty buffer too
	Print @(0,Height);
	Thread {
		Pen col {
		Print Over $(3), "Press space bar or mouse key" 
		}
		swap col, col2
	} as threadid interval 250	
	Main.Task 10 {
		if keypress(1) or keypress(32) then exit
	rem		if mouse>0 or inkey$<>"" then exit
	}
	Threads Erase
End Sub
}
MODULE CLOCK {Αν Έγκυρο(ok) Αλλιως Πληκτρολόγιο "Clock1"+χαρ$(13) : Έξοδος
Όρισε Μ Μοναδικό      ' Declare m Mutex  : Methos m, "Create", "onename" return error if can't created with ownership
\\ we can create more than one mutexs in the m, using create
\\ so now this run only one time for the user. The second time the mutex exist so exit the program early.
Κάνε Συνέχισε Ως Λογικός
Δες  {
      Μέθοδος Μ, "CREATE", "Global\CLOCK10101001"
      Συνέχισε=Αληθής     
}
Αν Συνέχισε Αλλιώς Έξοδος
Ανανέωση 5000
Φόρμα
ομαλά ναί
Παράθυρο 16, Παράθυρο
Οθόνη 5,0
Πενα 14
Περιθώριο {Πένα 14}
Επιφάνεια 220, 5
\\ ανοίγει με ctrl+f1
Περί ! "Μ2000 Ρολόι 12 ωρών - M2000 Clock 12 hours", κλιμαξ.χ*5/7, κλιμαξ.υ*2/3,{
      Ελληνικά
            Ξυπνητήρι από 1 λεπτό έως 12 ώρες
            Μεσαίο πλήκτρο του ποντικιού βάζει/βγάζει το ξυπνητήρι/ σταματάει το κουδούνισμα
            Αριστερό/Δεξί πλήκτρο αλλάζει το ξυπνητήρι ανά λεπτό
            Μαζί με το μεσαίο αλλαζει το ξυπνητήρι ανά 10 λεπτά
            Τα βελάκια αριστερά - δεξιά αλλάζει επίσης το ξυπνητήρι
            Μαζί με το άνω βελάκι αλλάζει το ξυπνητήρι ανά 10 λεπτά
            Το κάτω βελάκι βάζει/βγάζει το ξυπνητήρι/ σταματάει το κουδούνισμα
            Το Enter αλλάζει τους δείκτες σε εμφάνιση (ανά ολόκληρες ώρες ή αναλογικά)
            Το διάστημα κλείνει το πρόγραμμα
            
      English
            Alarm for 1 minute to 12hours
            Middle mouse button set/reset/snooze alarm
            Left/right mouse button change at step one minute alarm time
            Using midle button and any of left or right change at step ten minutes
            Ledt/right arrows on keyboard change at step one minute alarm time
            pressing up arrow and of left or right on keyboard change at step ten minutes
            Down arrow used to set/reset/snooze alarm
            Enter key change clock hour to return analog to minutes time or at hour intervals.
            Space key exit the clock
      }
κχ=χ.σημεία-4000
κυ=4000
απ1=3000
απ2=600
απ3=απ1-απ2
κυκλ=πι*2
κυκλ60=κυκλ/60
Ξυπνητήρι=0
ΞυπνητήριΟκ=Ψευδής
ΠαίξεΉχο=Ψευδής
ΟλόκληρεςΏρες=Ψευδές
Αναβοσβήνει=Ψευδής
ΑρχικόςΧρόνος=20*10 \\ 20 δευτερόπλεπτα
ΧρόνοςΜπιπ=ΑρχικόςΧρόνος
Ωρα=0
Ωρα12=0
λεπτό=υπωρα(0,0,1,0)
Θέση κχ, κυ
\\ η χρώμα { } ; φτιάχνει περιοχή μόνο για εμφάνιση
Χρώμα { Κύκλος Γέμισμα 2, απ2+απ1 } ;
Θέση κχ-απ2-απ1, κυ-απ2-απ1
Βάψε 2*(απ2+απ1),2*(απ2+απ1), 7,1,1
Θέση κχ, κυ-απ1*3/4
Τίτλος "Μ2000 Ρολόι"
Επιγραφή "Μ2000 Ρολόι","Arial Black",18,0,2
Θέση κχ, κυ
\\ με χρώμα 5 αντί για #2277ff γίνεται διάφανο
\\ έχουμε δηλώσει το 5 (ματζέντα) στην εντολή Επιφάνεια
Πένα #2277ff {Κύκλος Γέμισμα #2277ff, απ3/2}
π=2
ι=0
Για ν=0 εως 59 
      Αν ν υπολ 5 = 0 τότε {π=4} αλλιώς π=1
      Πάχος π {
            Βήμα γωνια ι, απ1
            Χάραξε γωνία ι, απ2
            Βήμα γωνια ι, -απ2-απ1
      }
            ι+=κυκλ60
Επόμενο ν
Κράτησε
Μετακίνηση=Ψευδές
Ανανέωση 1000
Μετά 200 {Άναψε : Τίτλος "Μ2000 Ρολόϊ"}
Κάθε 100  {
Αναβοσβήνει~   \\ αντιστροφή λογικής  (Αναβοσβήνει = Δεν Αναβοσβήνει)
Άφησε
Ωρα=Τώρα
Ωρα12=(τιμη(γραφη$(Ωρα,"h")) υπολ 12) *60+τιμη(γραφη$(Ωρα,"n"))
Θέση κχ, κυ+απ1/2
      Αν Ωρα12<60 τότε {
            Επιγραφή Γραφη$(υπωρα(0,12,Ωρα12,τιμη(γραφη$(Ωρα,"s"))), "hh:nn:ss"), "Verdana", 18,0,2
      } Αλλιώς {
            Επιγραφή Γραφη$(υπωρα(0,0,Ωρα12,τιμη(γραφη$(Ωρα,"s"))), "hh:nn:ss"), "Verdana", 18,0,2
      }
Πένα -ΞυπνητήριΟκ*8+4 {      
      Βήμα , +απ1/8
      Επιγραφή "+"+Γραφη$(υπωρα(0,0,(ξυπνητήρι-Ωρα12+720) υπολ 720,0), "hh:nn "), "Verdana", 18,0,2
      Βήμα , +απ1/8

      Αν ξυπνητήρι<60 τότε {
            Επιγραφή Γραφη$(υπωρα(0,12,ξυπνητήρι,0), "hh:nn"), "Verdana", 18,0,2
      } Αλλιώς {
            Επιγραφή Γραφη$(υπωρα(0,0,ξυπνητήρι,0), "hh:nn"), "Verdana", 18,0,2
      }
}
Θέση κχ, κυ
γωνία_ξυπν=-ξυπνητήρι*πι/360+πι/2
Αν  Αναβοσβήνει ή όχι ΞυπνητήριΟκ τότε {
      Πάχος 2 {
            Βήμα Γωνία γωνία_ξυπν, απ3
            Χάραξε Γωνία γωνία_ξυπν, απ2, 13
                  Βήμα Γωνία γωνία_ξυπν, -απ2
            Βήμα Γωνία γωνία_ξυπν, -απ3
      }
}
Αν ΟλόκληρεςΏρες Τότε {
       γωνια_ώρα=-(τιμη(γραφη$(Ωρα,"h")) υπολ 12)*πι/6+πι/2
} Αλλιώς  γωνια_ώρα=-(τιμη(γραφη$(Ωρα,"h")) υπολ 12+τιμη(γραφη$(Ωρα,"n"))/60)*πι/6+πι/2
Πάχος 2 {
      Χάραξε Γωνία γωνία_ώρα+πι/20, απ3/2
      Χάραξε Γωνία γωνία_ώρα-πι/20, απ3/2
      Χάραξε Γωνία γωνία_ώρα+πι/20, -απ3/2
      Χάραξε Γωνία γωνία_ώρα-πι/20, -απ3/2
}
Αν ΟλόκληρεςΏρες Τότε {
      γωνία_λεπτά=-τιμη(γραφη$(Ωρα,"n"))*πι/30+πι/2
} Αλλιώς {
      γωνία_λεπτά=-(τιμη(γραφη$(Ωρα,"n"))+τιμη(γραφη$(Ωρα,"s"))/60)*πι/30+πι/2
}
Πάχος 2 {
      Χάραξε Γωνία γωνία_λεπτά+πι/20, απ1/2
      Χάραξε Γωνία γωνία_λεπτά-πι/20, απ1/2
      Χάραξε Γωνία γωνία_λεπτά+πι/20, -απ1/2
      Χάραξε Γωνία γωνία_λεπτά-πι/20, -απ1/2
}
γωνία_δευτ=-τιμη(γραφη$(Ωρα,"s"))*πι/30+πι/2
Πάχος 2 {
      Χάραξε Γωνία γωνία_δευτ, απ3, 15
      Βήμα Γωνία γωνία_δευτ, -απ3
}

Αν Πατημένο(1) ή Πατημένο(0x25) ή μετακίνηση τότε {

Αν Πατημένο(1) και ((Απολ(δείκτης.χ-κχ)<1000 και απολ(δείκτης.υ-κυ)<1000) ή Μετακίνηση)  τότε {
	κίνηση.π κίνηση.πχ+δείκτης.χ-κχ, κίνηση.πυ+δείκτης.υ-κυ
	Δείκτη.Μορφή 5
	Μετακίνηση=Αληθές
} Αλλιώς {
	Μετακίνηση=ψευδές
	Δείκτη.Μορφή 1
	Αν Πατημένο(4) ή Πατημένο(0x26) τότε {ξυπνητήρι-=10: ΞυπνητήριΟκ=Αληθής} αλλιώς ξυπνητήρι-- 
      ξυπνητήρι=(ξυπνητήρι+720) υπολ 720
}
} Αλλιως.Αν Πατημένο(2) ή Πατημένο(0x27) τότε {
	Μετακίνηση=ψευδές
	Δείκτη.Μορφή 1

Αν Πατημένο(4)  ή Πατημένο(0x26) τότε {ξυπνητήρι+=10: ΞυπνητήριΟκ=Αληθής} αλλιώς ξυπνητήρι++ 
      ξυπνητήρι=(ξυπνητήρι+720) υπολ 720
} Αλλιώς Μετακίνηση=Ψευδές: Δείκτη.Μορφή 1
Αν Πατημένο(32) τότε Έξοδος
Ανανέωση 1000
Αν ΞυπνητήριΟκ και ΧρόνοςΜπιπ>0 Τότε {
      Αν (τιμη(γραφη$(Ωρα,"h")) υπολ 12 )*60+τιμη(γραφη$(Ωρα,"n"))=ξυπνητήρι τότε {
            ΠαίξεΉχο=Αληθής
      }
}
Αν ΞυπνητήριΟκ και όχι (Πατημένο(2) ή Πατημένο(1)) Τότε {
      Αν Πατημένο(4) ή Πατημένο(0x28) Τότε ΠαίξεΉχο=Ψευδής: ΞυπνητήριΟκ=Ψευδής : ΧρόνοςΜπιπ=ΑρχικόςΧρόνος
} Αλλιώς.Αν Πατημένο(4) ή Πατημένο(0x28) Τότε {
            ΞυπνητήριΟκ=Αληθής
            ΧρόνοςΜπιπ=ΑρχικόςΧρόνος
}
Αν ΠαίξεΉχο Τότε {
      Αν ΧρόνοςΜπιπ υπολ 3 =0 τότε Μπιπ
      ΧρόνοςΜπιπ-- 
      Αν ΧρόνοςΜπιπ=0 Τότε ΠαίξεΉχο=Ψευδής: ΞυπνητήριΟκ=Ψευδής
}

Αν Πατημένο(13) τότε ΟλόκληρεςΏρες~  \\ αντιστροφή αληθές<>ψευδές
}
Τιτλος ".....",0
Οθόνη \\ επαναφορά από το περιορισμό περιοχής της Χρώμα
Επιφάνεια 255
Επιφάνεια Κρυψε
Μέθοδος Μ, "DESTROY", "Global\CLOCK10101001"   ' Declare m, "Destroy"
Όρισε Μ Τίποτα   ' Declare m Nothing
}
MODULE BOOK {Class Book {
      \\ these are public but can get value one time
      Final title$, des$, price, pback
      \\ we use a class part, which means a part that exist only at contruction time
Class:
      Module Book (a$, b$, c as decimal, d as boolean) {
      \\ we use fresh variables to catch a missin value
            .title$<=a$
            .des$<=b$
            .price<=c
            .pback<=d
      }
}
m=Book("a","b", 10, True)
Rem z=m.price
Rem Print type$(z)="Decimal"
try ok {
      m.price++
      Print "ok"
}
Rem Print Error$
Rem Print type$(m.price)="Constant"
Class BookDB {
Private:
      countme=0
      dim p()
Public:
      module final AddBook {
            newdim =.countme+1
            dim .p(newdim)
            read .p(.countme)
            .countme++
      }
      module final ProcessPaperbackBooks (&ProcessBookDelegate) {
            if .countme<1 then break
            for i=0 to .countme-1 {  
                  if .p(i).pback then call  ProcessBookDelegate.processBook(.p(i)) 
            }

      }
}
Group PrintTitle {
      function final processBook(AnyBook) { Report format$("    {0}", AnyBook.title$)} 
}
Group PriceTotaller {
      items, total
      function final processBook(AnyBook) {.items++ :  .total+=AnyBook.price }
      \\  look the <= operator, if we use = then we define local variables. Items and total are like global but for Group only
      module final zero { .total<=0 : .items<=0   }
      function final AveragePrice { if .items>0 then =.total/.items }
}
bookDB=bookDB()
Report "First Book DB"

      bookDB.AddBook Book("The C Programming Language",  "Brian W. Kernighan and Dennis M. Ritchie", 19.95, True)
      bookDB.AddBook Book("The Unicode Standard 2.0",  "The Unicode Consortium", 39.95, True)
      bookDB.AddBook Book("The MS-DOS Encyclopedia", "Ray Duncan", 129.95, False)
      bookDB.AddBook Book("Dogbert's Clues for the Clueless", "Scott Adams", 12.00, True)
      bookDB.ProcessPaperbackBooks &PriceTotaller
      Report  "Average Paperback Book Price: $" + str$(PriceTotaller.AveragePrice(),"#.##")
      bookDB.ProcessPaperbackBooks &PrintTitle

Report "Second Book DB"    \\Report prints text  proportionally with justifiation
PriceTotaller.zero
SecondbookDB=bookDB()

      SecondbookDB.AddBook Book("Any Big Big and Big Tilte",  "Any Author", 3.45, True)
      SecondbookDB.ProcessPaperbackBooks &PriceTotaller
      Report  "Average Paperback Book Price: $" + str$(PriceTotaller.AveragePrice(),"#.##")
      SecondbookDB.ProcessPaperbackBooks &PrintTitle
}
MODULE BOOK1 {prototype {
      local countme=0
      dim t$(), a$(), p(), pb()
      function AddBook {
            for this {
                  newdim =.countme+1
                  dim .t$(newdim), .a$(newdim), .p(newdim), .pb(newdim)      
                  read .t$(.countme), .a$(.countme), .p(.countme), .pb(.countme)
                  .countme++
            }
      }
      module ProcessPaperbackBooks {
            read &ProcessBookDelegate 
            if .countme<1 then exit
            for i=0 to .countme-1 {  
                  if .pb(i) then call  ProcessBookDelegate.processBook(&this, i) 
            }
      }
} as booktype$
group PrintTitle {
      function processBook { read &AnyBook, i : Report format$("    {0}", AnyBook.t$(i) )} 
}
group PriceTotaller {
      local items, total
      function processBook { read &AnyBook, i : for this {.items++ : for Anybook {.total+=..p(i)  } }}
      \\  look the <= operator, if we use = then we define local variables. Items and total are like global but for group only
      module zero { .total<=0 : .items<=0 }  
      function  AveragePrice { if .items>0 then =.total/.items }
}
group bookDB type booktype$      
report "First Book DB"
for bookDB {
      call .AddBook("The C Programming Language",  "Brian W. Kernighan and Dennis M. Ritchie", 19.95, true)
      call .AddBook("The Unicode Standard 2.0",  "The Unicode Consortium", 39.95, true)
      call .AddBook("The MS-DOS Encyclopedia", "Ray Duncan", 129.95, false)
      call .AddBook("Dogbert's Clues for the Clueless", "Scott Adams", 12.00, true)
      call .ProcessPaperbackBooks &PriceTotaller
      report  "Average Paperback Book Price: $" + str$(PriceTotaller.AveragePrice(),"#.##")
      call .ProcessPaperbackBooks &PrintTitle
}
report "Second Book DB"    \\report prints text  proportionally with justification
PriceTotaller.zero
group SecondbookDB type booktype$
for SecondbookDB {
      call .AddBook("Any Big Big and Big Tilte",  "Any Author", 3.45, true)
      call .ProcessPaperbackBooks &PriceTotaller
      report  "Average Paperback Book Price: $" + str$(PriceTotaller.AveragePrice(),"#.##")
      call .ProcessPaperbackBooks &PrintTitle
}
}
MODULE BOOK2 {class BookDB {
      countme=0
      dim t$(), a$(), p(), pb()
      module AddBook {
            newdim =.countme+1
            dim .t$(newdim), .a$(newdim), .p(newdim), .pb(newdim)      
            read .t$(.countme), .a$(.countme), .p(.countme), .pb(.countme)
            .countme++
      }
      module ProcessPaperbackBooks (&ProcessBookDelegate) {
            if .countme<1 then break
            for i=0 to .countme-1 {  
                  if .pb(i) then call  ProcessBookDelegate.processBook(&this, i) 
            }

      }
}
group PrintTitle {
      function processBook (&AnyBook, i) { Report format$("    {0}", AnyBook.t$(i) )} 
}
group PriceTotaller {
      items, total
      function processBook (&AnyBook, i) {for this {.items++ : for Anybook {.total+=..p(i)  } }}
      \\  look the <= operator, if we use = then we define local variables. Items and total are like global but for group only
      module zero { .total<=0 : .items<=0   }
      function  AveragePrice { if .items>0 then =.total/.items }
}
bookDB=bookDB()
report "First Book DB"

      bookDB.AddBook "The C Programming Language",  "Brian W. Kernighan and Dennis M. Ritchie", 19.95, true
      bookDB.AddBook "The Unicode Standard 2.0",  "The Unicode Consortium", 39.95, true
      bookDB.AddBook "The MS-DOS Encyclopedia", "Ray Duncan", 129.95, false
      bookDB.AddBook "Dogbert's Clues for the Clueless", "Scott Adams", 12.00, true
      bookDB.ProcessPaperbackBooks &PriceTotaller
      report  "Average Paperback Book Price: $" + str$(PriceTotaller.AveragePrice(),"#.##")
      bookDB.ProcessPaperbackBooks &PrintTitle

report "Second Book DB"    \\report prints text  proportionally with justifiation
PriceTotaller.zero
SecondbookDB=bookDB()

      SecondbookDB.AddBook "Any Big Big and Big Tilte",  "Any Author", 3.45, true
      SecondbookDB.ProcessPaperbackBooks &PriceTotaller
      report  "Average Paperback Book Price: $" + str$(PriceTotaller.AveragePrice(),"#.##")
      SecondbookDB.ProcessPaperbackBooks &PrintTitle
}
MODULE BOOK3 {Class Book {
      \\ read only properties -- we change value using private variables any time.
      property title$ {value}
      property des$ {value}
      property price {value} =0@	\\ a decimal value
      property pback {value} =1=1	\\ this is a boolean value, True is -1 double
      \\ we use a class part, which means a part that exist only at contruction time
Class:
      Module Book (a$, b$, c, d) {
      \\ we use fresh variables to catch a missin value
            .[title]$<=a$
            .[des]$<=b$
            .[price]<=c
            .[pback]<=d
      }
}
Class BookDB {
Private:
      p=(,)
Public:
      module final AddBook {
            \\ group return a float pointer
            \\ use of (group) inside pointer to return a real pointer, else we get error, we can't get a weak pointer from stack.
            \\ a weak pointer is a pointer to an identifier, which has to exist when we have to use it.
            \\ (1,)  is an one item array
            \\ append to an array a series of arrays. here we add an array with one item
            append .p, (pointer((group)),)
      }
      module final ProcessPaperbackBooks (&ProcessBookDelegate) {
            m=each(.p)
            \\ m is iterator for .p
            while m
                  aBook=array(m)
                  \\ aBook get a pointer to a group
                  if aBook=>pback then
                        call  ProcessBookDelegate.processBook(aBook)
                  end if
            end while
      }
}
group PrintTitle {
      function final processBook (AnyBook as pointer) { Report format$("    {0}", AnyBook=>title$)} 
}
group PriceTotaller {
      items, total
      function final processBook (AnyBook as pointer) {.items++ :  .total+=AnyBook=>price }
      \\  look the <= operator, if we use = then we define local variables. Items and total are like global but for group only
      module final zero { .total<=0 : .items<=0   }
      function final AveragePrice { if .items>0 then =.total/.items }
}
\\ bookDB is a pointer to a float group (a float group is a closed type group)
\\  -> is same as pointer()
\\ a class always return a float group
\\ from float groups we get real pointers
bookDB->bookDB()
report "First Book DB"

      For bookDB {
            \\ a non float group prepared with values from the float group
            \\ any new definition deleted after the end of a for object block
            .AddBook Book("The C Programming Language",  "Brian W. Kernighan and Dennis M. Ritchie", 19.95, true)
            .AddBook Book("The Unicode Standard 2.0",  "The Unicode Consortium", 39.95, true)
            .AddBook Book("The MS-DOS Encyclopedia", "Ray Duncan", 129.95, false)
            .AddBook Book("Dogbert's Clues for the Clueless", "Scott Adams", 12.00, true)
            .ProcessPaperbackBooks &PriceTotaller
            report  "Average Paperback Book Price: $" + str$(PriceTotaller.AveragePrice(),"#.##")
            .ProcessPaperbackBooks &PrintTitle
      }

report "Second Book DB"    \\report prints text  proportionally with justifiation
PriceTotaller.zero
\\ the SecondbookDB  is a non float group.
SecondbookDB=bookDB()

      SecondbookDB.AddBook Book("Any Big Big and Big Tilte",  "Any Author", 3.45, true)
      SecondbookDB.ProcessPaperbackBooks &PriceTotaller
      report  "Average Paperback Book Price: $" + str$(PriceTotaller.AveragePrice(),"#.##")
      PointerA->SecondbookDB
      PointerA=>ProcessPaperbackBooks &PrintTitle
\\ PointerA is not a real pointer. Is a weak pointer to a non float group.
}
MODULE POPUP {title "",0
Declare Form1 Form
Declare aPopUpForm Form
With Form1, "Title", "Hello There"
With aPopUpForm, "Title", "This is a PopUp Form", "Visible" as PopUpVisible
Declare Text1 TextBox Form aPopUpForm
Method Text1,"Move", 2000,2000,6000,600
With Text1,"Text" as txt$
txt$="U+10437 (𐐷) in UNICODE"
Function Text1.Enter {
      \\ If we press enter in textbox in popup form
      \\ we change title in form1
      With Form1, "Title", txt$
      With form1, "GetFocus"
}
X=1000
Function Form1.MouseDown {
\* Use STACK to see stack in console...
\* ...before you decide what to do with the values
\* Stack is cleared by you or by system, if stack isn't empty
      Rem 1 : Stack
      Read button
      If button<>2 Then Exit
      Drop  \\ drop shift
      Local X, Y : Read X, Y
      
      Method Form1, "PopUp", aPopUpForm, X, Y
}
refresh
With Form1, "visible" as visible
p=0
thread {
      if visible then print "ok" : refresh :  p=ask("test RIGHT click on form's layer ","Explain","Test now","") : thread this erase
} as k interval 100
Method Form1,"Show", 1  \\ modal  means wait to return
\\ we return focus to console
Show
Declare Form1 Nothing
Declare aPopUpForm Nothing
Print X
Title "Info"
end
}
MODULE SURROGATE {\\ pressing alt press INS or + on keypad and 10437 on keypad or number keys and release alt to get 𐐷

Print #-2, {"𐐷"}
Print hex$(chrcode("𐐷"),2.5)="10437"
Print chrcode$(0x10437)="𐐷"

keyboard "𐐷"
print inkey$
keyboard "𐐷"
Print key$
keyboard "1𐐷2"+chr$(13)
Input "surrogate=",a$
Print a$
Print $(4), "surrogate=";
Input ! a$, 30
Print a$, $(0)   ' return to normal text
if random(1,2)=1 then Print else Print Under
Report a$
}
MODULE CS {Clear \\ Clear all variables/objects
Flush \\ Empty the stack
first$={using System;
            using System.Drawing;
            using System.Windows.Forms;
             
            class CSharpPendulum
            {
                Form _form;
                Timer _timer;
             
                double _angle = Math.PI / 2, 
                       _angleAccel, 
                       _angleVelocity = 0, 
                       _dt = 0.1;
             
                int _length = 50;
             
                [STAThread]
                static void Main()
                {
                    var p = new CSharpPendulum();
                }
             
                public CSharpPendulum()
                {
                    _form = new Form() { Text = "Pendulum -  Γιώργος", Width = 400, Height = 200 };
                    _timer = new Timer() { Interval = 30 };
             
                    _timer.Tick += delegate(object sender, EventArgs e)
                    {
                        int anchorX = (_form.Width / 2) - 12,
                            anchorY = _form.Height / 4,
                            ballX = anchorX + (int)(Math.Sin(_angle) * _length),
                            ballY = anchorY + (int)(Math.Cos(_angle) * _length);
             
                        _angleAccel = -9.81 / _length * Math.Sin(_angle);
                        _angleVelocity += _angleAccel * _dt;
                        _angle += _angleVelocity * _dt;
             
                        Bitmap dblBuffer = new Bitmap(_form.Width, _form.Height);
                        Graphics g = Graphics.FromImage(dblBuffer);
                        Graphics f = Graphics.FromHwnd(_form.Handle);
             
                        g.DrawLine(Pens.Black, new Point(anchorX, anchorY), new Point(ballX, ballY));
                        g.FillEllipse(Brushes.Black, anchorX - 3, anchorY - 4, 7, 7);
                        g.FillEllipse(Brushes.DarkGoldenrod, ballX - 7, ballY - 7, 14, 14);
             
                        f.Clear(Color.White);
                        f.DrawImage(dblBuffer, new Point(0, 0));    
                    };
             
                    _timer.Start();
                    Application.Run(_form);
                }     
            }
            }
title$="C# Editor"
typ$="cs"
W$=""
path$=""
Dir User
lookpath$=dir$
Declare NotePad Form
Declare Pad EditBox Form NotePad
Declare Inform1 Button Form NotePad
With Inform1, "Caption" as Informe$
Method Inform1, "Colors", 15, #FFA000
With Inform1, "Locked", True
Declare File1 Combobox Form NotePad
Declare Edit1 Combobox Form NotePad
Declare Run1 Combobox Form NotePad
Declare Help1 Combobox Form NotePad
With File1,"label","File", "listtext" As list$, "list" As list$() '
With Edit1,"label","Edit",  "Mark", Color(255,100,0)
With Run1,"label","Run",  "Mark", Color(255,100,0)
With Help1,"label","Help",  "Mark", Color(255,100,0)

With NotePad, "Title" As Caption$, "Visible" As Visible, "TitleHeight" As tHeight, "Sizable", True
With NotePad, "UseIcon", True, "UseReverse", True
With Pad, "Text" As Pad.text$, "ShowAlways", True,"NoColor", True,"SelLength" as SelLength
With Pad, "ColorSet", 1, "linespace", 30, "NoCenterLineEdit", True   ' we can tongle value of  NoCenterLineEdit  using shift F9
Method Pad, "UserColorSet", false, , -#ff0000
Def TitleStr$(a$)=Ucase$(Left$(a$,1))+Mid$(a$,2)
Filename$=Dir$+"pendulum.cs"

Caption$=TitleStr$(File.Name$(Filename$)) +" - C# Editor"
Title "",0
Method NotePad,"MakeStandardInfo", 1
Method NotePad,"move", 2000, 4000, 8000, 4000
Layer NotePad {Cls #FFA000}
With File1,"MenuStyle", True, "MenuWidth", 3000 
With Edit1,"MenuStyle", True, "MenuWidth", 3000,"menuEnabled" as Enabled() 
With Run1,"MenuStyle", True, "MenuWidth", 3000,"menuEnabled" as Comp.Enabled()
With Help1,"MenuStyle", True, "MenuWidth", 3000 
With File1, "MenuEnabled" As mEnable()
For This {
      mi$="MenuItem"  \\ is a temporary variable only for For This Block
      With File1, "MenuGroup","This"
      Method File1, mi$,"Open",True
      Method File1, mi$,"Save",True
      Method File1, mi$,""    \\  only  a line here
      Method File1,"MenuRadio","txt files",True,False
      Method File1,"MenuRadio","cs files",True,True
      
      Method File1, mi$,""
      Method File1, mi$,"Close",True
      Method File1, mi$,""
      Method File1, mi$,"Quit",True
           
      
      With Edit1, "MenuGroup","This"
      Method Edit1, mi$,"Cut",False
      Method Edit1, mi$,"Copy",False
      Method Edit1, mi$,"Paste",True
      Method Edit1, mi$,""
      Method Edit1, mi$,"Less Indent",True
      Method Edit1, mi$,"More Indent",True  
      
      With Run1, "MenuGroup","This"
      Method Run1, mi$,"Compile test",true
      Method Run1, mi$,"Run test > out",False
      Method Run1, mi$,"Run test",False
      Method Run1, mi$,"Show Out.Txt",False
      Method Run1, mi$,""
      Method Run1, mi$,"Compile Final",true
      Method Run1, mi$,"Open Cmd.exe",true
    
      With Help1, "MenuGroup","This"
      Method Help1, mi$, "About", True
      Method Help1, mi$,""
      Method Help1, mi$,"Bright Themel",true
      Method Help1, mi$,"Dark Theme",true
}

if exist(Filename$) then
      Document BackUp$
      Load.Doc BackUp$, filename$
else
      Document BackUp$=first$
end if
Pad.text$=BackUp$
Function NotePad.Unload {
      Read New &Ok
      After 30 {Call local File1.DblClick(8) }
      Ok=True

}
Function Notepad.Resize {
      Layer NotePad { Cls Color(255, 160, 0) ,0}
      With NotePad, "Width" As NP.Width, "Height" As NP.Height, "TitleHeight" As tHeight
      tHeight1=theight*2
      Method File1,"move", twipsX*2, tHeight,  twipsX*80, tHeight
      Method Edit1,"move", twipsX*2+twipsX*80, tHeight,  twipsX*80, tHeight
      Method Run1,"move", twipsX*2+twipsX*160, tHeight,  twipsX*80, tHeight
      Method Help1,"move", twipsX*2+twipsX*240, tHeight,  twipsX*160, tHeight
      Method Inform1,"move", twipsX*2+twipsX*320, tHeight,  twipsX*240, tHeight
      If NP.height>1000 Then {
            Method Pad,"move", twipsX*2, tHeight1,  NP.Width-twipsX*5, NP.Height-tHeight1-twipsx*3
            With Pad, "NoWrap" As NoWrap
            If Not NoWrap Then Method Pad,"Resize"
      }
}
Function Edit1.OpenMenu {
            Local X
            X=SelLength>0
            Enabled(0)=X
            Enabled(1)=X
}

Function Edit1.DblClick {
      Read Local Edit1index
      Select Case Edit1index
      Case 0
            {
            Method Pad,"mn1sub"
            Method Pad,"Resize"
            }
      Case 1
            Method Pad,"mn2sub"
      Case 2
            {
                 Method Pad, "mn3sub"
                 Method Pad,"GetFocus"
                 Method Pad,"Resize"
           }
        Case 4
           {
                  Method Pad,"PressKey", 9, 1
            }
        Case 5
           {
                  Method Pad,"PressKey", 9, 0
            }
      End Select

}
Function Pad.Inform {
      Read New L, P
      Informe$=format$("{0}-{1}", L,P)
      Method Pad,"Show"
}
Function Pad.PopUp {
      Read Local X, Y
      Method Pad,"PopUpMenu", "",X , Y
}
function cs_choose{
       With Pad, "ColorCollection1", lcase$("|abstract|as|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|do|double|else|enum|event|explicit|extern|false|finally|fixed|float|for|foreach|goto|if|implicit|in|int|interface|internal|is|lock|long|namespace|new|null|object|operator|out|override|params|private|protected|public|readonly|ref|return|sbyte|sealed|short|sizeof|stackalloc|static|string|struct|switch|this|throw|True|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|using|static|virtual|void|volatile|while|add|alias|ascending|async|await|by|descending|dynamic|equals|from|get|global|group|into|join|let|nameof|on|orderby|partial|remove|select|set|value|var|when|where|yield|"),"NoColor", False, "UseCase", True,"ExtraFront", "_", "LineComment2", "", "CommentSymbols","[/][/]", "ComSymbolsWidth", 2, "CommentLineLight", false, "MultiLineComment1", "/*","MultiLineComment2", "*/"
      With Pad, "WordCharLeft"," ,+-=/*^()[];<>:?", "WordCharRight"," .,+-=/*^()[];<>?:","OtherSymbols","@","UseColon",";"
      With Pad,"StartSymbols", "+-&|*=></,.1234567890()'"+chr$(34), "StringSep2","'", "EnablePairs", True, "linespace", 30
      With Pad, "SearchWords", True, "nowrap", True, "AllowInsertBrackets",  True, "SpaceIndent", 2, "HighlightParagraph", True
      Method Pad, "ReColor"
      Method Pad, "Show"
}

Function Dark(){  '  13619071
      With Pad, "ColorSet", 0, "linespace", 60, "SelectionColor", -#FF0000, "SelectionTextColor", -color(14), "HighLightColor", -Color(60,60,128)
       Method Pad, "Colors", -color(50,50,50),-color(14),,,-color(0)
      Method Pad, "Show"
}
Function Bright(){
      With Pad, "ColorSet", 1, "HighLightColor", -Color(225,255,255)
      Method  Pad, "UserColorSet",0,,,,,,,,-#FF0000
      With Pad, "ColorSet", -1
      Method Pad, "ColorsReset"
      Method Pad, "ResetSelColors"
      Method Pad, "Show"
}

Function Run1Status() {
      if file.type$(filename$)="cs" then
            Comp.Enabled(0)=True
            Comp.Enabled(1)=False
            Comp.Enabled(2)=False
            Comp.Enabled(5)=True        
      else
            Comp.Enabled(0)=False
            Comp.Enabled(1)=False
            Comp.Enabled(2)=False
            Comp.Enabled(5)=False            
      end if
}
Function File1.MenuChecked {
Read New RadioIndex \\ 3 or 4
If RadioIndex =3 Then {
      After 30 { Static a$="."+File.type$(Filename$), b$=File.name$(Filename$)
      Filename$=File.path$(Filename$)+Left$(b$,Len(b$)-Len(a$))+".txt"
      Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
      typ$="txt"
      Call local Run1Status()
      With Pad, "ColorCollection1", "","NoColor", True,  "UseCase", False
      Pad.text$=Pad.text$
      Method Pad, "Show"
      }
} Else.If RadioIndex =4 Then {
     After 30 { local a$="."+File.type$(Filename$), b$=File.name$(Filename$)
      Filename$=File.path$(Filename$)+Left$(b$,Len(b$)-Len(a$))+".cs"
      Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
      typ$="cs"
      Call local cs_choose()
      Call local Run1Status()
      }      
}

}
Function File1.DblClick {
\\ we use functions As subs here
\\ each function and each module have a name (define a namespace)
\\ but here real module name is the File1.DblClick() host module
\\ this is done because is a Gui Event Service Function
\\ and is Call With Local tag (Call Local)
      Read New File1index
      Local cont, cont2, f$, NL$={
      }
      File1index++
      \\ Because we want some jumps..we use  On Goto
      \\ on Goto need here a block
      {
      On File1index Goto Open1, Save1, ExitNow, ExitNow, ExitNow, ExitNow, Save2, ExitNow,  Unload
Exitnow:
      Exit
Open1:
      If Pad.text$<>BackUp$ Then {
            If Ask("Save Changes first?",title$, "Yes","No")=1 Then Goto Save1
      }
     Layer NotePad {
           Open.file filename$,,"Load Text ("+typ$+") File",typ$
     }
     
     Method Pad,"GetFocus"
     Read f$
     If f$<>"" Then {
           Filename$=f$
           If Exist(F$) Then {
           Clear BackUp$
           Call Local Run1Status()
           Load.Doc BackUp$, f$
           
           Caption$=TitleStr$(File.Name$(Filename$)) +" - C# Editor"
           lookpath$=file.path$(Filename$)
           \\ silent means here without refresh
           With Pad, "SelStartSilent", 0, "SellengthSilent",0 
           Pad.text$=BackUp$
           } Else Pad.text$="": Clear BackUp$
           Method Pad, "ReColor"
      }
      Exit
Save1:
      Layer NotePad {
            Save.As Filename$,,"Save Text ("+typ$+") File",typ$
      }
      If Not cont2 Then Method Pad,"GetFocus"
      Read f$   ' from save.as we get a value
      If f$="" Then Exit 
      If Lcase$(File.type$(f$))<>typ$ Then f$=f$+"."+typ$
      If Exist(f$) Then  If Ask(NL$+"Overwrite"+NL$+f$,title$, "Yes","No")<>1 Then Exit
      Try ok {
        Clear BackUp$
        BackUp$=Pad.text$
        Save.Doc BackUp$, f$  ' by default 2 - Utf-8
        filename$=f$
        lookpath$=file.path$(Filename$)
        Caption$=TitleStr$(File.Name$(Filename$)) +" - C# Editor"
      }
     If ok Else Beep
     If Not cont Then Exit
Save2:
      cont=True
      If Pad.text$<>BackUp$ Then {
            If Ask("Save Changes?",title$, "Yes","No")=1 Then Goto Save1
      }
      Clear BackUp$
      Pad.text$=""
      If Cont2 Then {
            Method NotePad, "CloseNow"
      } Else {
            FileName$=Dir$+"Untitled."+typ$
            Caption$=TitleStr$(File.Name$(Filename$)) +" - C# Editor"
            Method Pad, "Resize"
      }
      Exit
Unload:
      Cont2=True : Goto Save2
      }
}
function gecsc_folder {
             dir path$(0x24)+"Microsoft.NET\Framework\"
             dir ? dir$, "Choose Framework"
             path$=dir$
             dir user
}

thread {
      informe$=if$((tick mod 4 +1) ->"|", "/","-","\")
      If not Comp.Enabled(3) then {
            if exist(dir$+"test.bat") then {
                  Informe$="ready to compile"
                  Comp.Enabled(3)=True
                  Comp.Enabled(0)=True
                  Method Pad,"Show"                  
            }
      } else.if exist(lookpath$+"test.exe") then {
             Comp.Enabled(1)=true
             Comp.Enabled(2)=true
             informe$="Compiled"
             thread this hold
      }

} as lookEXE interval 1000
thread lookEXE hold
Function Run1.DblClick {
      Read New Run1index
      select case Run1index
      case 0
      {            
            Comp.Enabled(0)=False
            Comp.Enabled(1)=False
            Comp.Enabled(2)=False
            Comp.Enabled(3)=False
            Informe$=""
            Call local gecsc_folder()
            if  path$="" then Beep:Comp.Enabled(0)=True :exit
            if not exist(path$+"csc.exe") then beep : Comp.Enabled(0)=true : exit 
            try {
                   if exist(dir$+"test.bat") then dos "del "+quote$(dir$+"test.bat");
                  if exist(dir$+"test.exe") then dos "del "+quote$(dir$+"test.exe");
            }
            local aa$
            Document aa$=Pad.text$
            dir user
            Save.doc aa$, "test.cs", 2   ' for UTF-8  see help
            
            if instr(aa$,"System.Windows.Forms")>9 then w$="win" else w$=""
            clear aa$
            aa$={setlocal
                        set PATH=}+Path$+{;
                        set LIB=%WINDIR%\Microsoft.NET\Framework\;
                        csc.exe  /target:}+w$+{exe /out:test.exe test.cs
                        endlocal
                        }
            Save.doc aa$, "test.bat", 3  ' Ansi for bat
            after 300 {
                  dir user
                  dos "cd "+dir$+" && test.bat  > out.txt";
                  after  200 {
                  
                        Thread lookEXE interval 100
                        Thread lookEXE Restart
                  }                 
                  'Method Pad,"GetFocus"
            }
           after 500 {Comp.Enabled(0)=true}
      }
      case 1
            {
                  thread lookEXE Hold
                  After 40 {
                  if w$="" then
                         dos "cd "+dir$+" && test.exe > out.txt";
                        Comp.Enabled(3)=True
                   else
                         win dir$+"test.exe"
                   end if
                  }
            }
      case 2
            {
                  thread lookEXE Hold
                  After 40 {
                  if w$="" then
                         dos "cd "+dir$+" && test.exe"
                        Comp.Enabled(3)=False
                   else
                         win dir$+"test.exe"
                   end if
                  }
            }
      case 3
        {
            try {win "out.txt"
            Thread lookEXE hold
            }
            informe$=""
      }
      case 5
      {
            local aa$
            Document aa$
            try {
                  Call local gecsc_folder()
                  if  path$="" then exit
                  if not exist(Filename$) then 
                        Call local File1.DblClick(1)
                  else
                        Load.doc aa$, Filename$
                        if aa$<>Pad.text$ then Call local File1.DblClick(1)
                        if instr(aa$,"System.Windows.Forms")>9 then w$="win" else w$=""
                        clear aa$
                  end if
                  aa$={setlocal
                        set PATH=}+Path$+{;
                        set LIB=%WINDIR%\Microsoft.NET\Framework\;
                        csc.exe  /target:}+w$+{exe /out:}+quote$(File.Name.only$(Filename$)+".exe")+" "+quote$(File.Name$(Filename$))+{
                        endlocal
                  }
                  Save.doc aa$, "final.bat", 3
                  After 40 {
                        dos "cd "+shortdir$(dir$)+" && final.bat";
                  }     
            }
      }   
      case 6
      dos "cd "+quote$(dir$)+" && cls "   
      end select
}
Function Help1.DblClick {
     rem  Read New Help1index  \\ we get the number without variable
      select case Number
      case 0
      {
          Local A, info$
            Info$={
                  This is an example
                  of an editor for c#
                  written for M2000 Environment
                  use F1 to change wrap
                  }
            A=Ask(info$,title$,"","")
            Method Pad, "GetFocus"
      }
      Case 2
      Call Local Bright()
      Case 3
      Call Local Dark()
      End Select

}
Function Notepad.InfoClick {
    Read New X
    If X=0 Then Call Local Help1.DblClick(0)  ' 0 for first menu item
}
Call Local Notepad.Resize()
\\ open As modal
Title "", 0
Call local cs_choose()
Call Local Bright()
Method NotePad,"Show" , 1
Declare Pad Nothing
Declare NotePad Nothing 
If Module(Info) Then
    Title "Info"
    keyboard "INFOBasic"+chr$(13)
end if
}
MODULE ΓΛΩΣΣΑ {\\ `notepad for educational school language ΓΛΩΣΣΑ
Greek  ' this make the popup menu of edit boc as 
Show
Clear
Flush
first$={ΠΡΟΓΡΑΜΜΑ Κυκλική_Ουρά
ΣΤΑΘΕΡΕΣ
  ΛάθοςΕξ = "Λάθος Εξαγωγής, Η ουρά είναι άδεια"
  Εξ = "Εξαγωγή "
ΜΕΤΑΒΛΗΤΕΣ
  ΑΚΕΡΑΙΕΣ: Πίσω, Μπροστά, Ουρα[10], ι, Τιμή
ΑΡΧΗ
  Τιμή <- 0
  Πίσω <- 1
  Μπροστά <- 0
  ΓΙΑ ι ΑΠΟ 1 ΜΕΧΡΙ 10
    Ουρα[ι] <- 0
  ΤΕΛΟΣ_ΕΠΑΝΑΛΗΨΗΣ
  ΚΑΛΕΣΕ Δείξε(Πίσω, Μπροστά, Ουρα) 
!! Προσθήκη 10 στοιχεία 1 έως 10
  ΓΙΑ ι ΑΠΟ 1 ΜΕΧΡΙ 10
    ΚΑΛΕΣΕ Εισαγωγή_Στοιχείου(ι, Πίσω, Μπροστά, Ουρα) 
  ΤΕΛΟΣ_ΕΠΑΝΑΛΗΨΗΣ
  ΚΑΛΕΣΕ Δείξε(Πίσω, Μπροστά, Ουρα) 
!! Αφαίρεση 5 στοιχείων
  ΓΙΑ ι ΑΠΟ 1 ΜΕΧΡΙ 5
    ΑΝ Μπροστά <> 0 ΤΟΤΕ
      ΚΑΛΕΣΕ Εξαγωγή_Στοιχείου(Τιμή, Πίσω, Μπροστά, Ουρα) 
      ΓΡΑΨΕ Εξ, Τιμή
    ΑΛΛΙΩΣ
      ΓΡΑΨΕ ΛάθοςΕξ
    ΤΕΛΟΣ_ΑΝ
  ΤΕΛΟΣ_ΕΠΑΝΑΛΗΨΗΣ
  ΚΑΛΕΣΕ Δείξε(Πίσω, Μπροστά, Ουρα) 
!! Προσθήκη 5 στοιχεία 11 έως 15
  ΓΙΑ ι ΑΠΟ 1 ΜΕΧΡΙ 5
    ΚΑΛΕΣΕ Εισαγωγή_Στοιχείου(ι + 10, Πίσω, Μπροστά, Ουρα) 
  ΤΕΛΟΣ_ΕΠΑΝΑΛΗΨΗΣ
  ΚΑΛΕΣΕ Δείξε(Πίσω, Μπροστά, Ουρα) 
!! Αφαίρεση 10 στοιχείων
  ΓΙΑ ι ΑΠΟ 1 ΜΕΧΡΙ 10
    ΑΝ Μπροστά <> 0 ΤΟΤΕ
      ΚΑΛΕΣΕ Εξαγωγή_Στοιχείου(Τιμή, Πίσω, Μπροστά, Ουρα) 
      ΓΡΑΨΕ Εξ, Τιμή
    ΑΛΛΙΩΣ
      ΓΡΑΨΕ ΛάθοςΕξ
    ΤΕΛΟΣ_ΑΝ
  ΤΕΛΟΣ_ΕΠΑΝΑΛΗΨΗΣ
  ΚΑΛΕΣΕ Δείξε(Πίσω, Μπροστά, Ουρα) 
!! Προσθήκη 2 στοιχεία 16 έως 17
  ΓΙΑ ι ΑΠΟ 1 ΜΕΧΡΙ 2
    ΚΑΛΕΣΕ Εισαγωγή_Στοιχείου(ι + 15, Πίσω, Μπροστά, Ουρα) 
  ΤΕΛΟΣ_ΕΠΑΝΑΛΗΨΗΣ
  ΚΑΛΕΣΕ Δείξε(Πίσω, Μπροστά, Ουρα) 
!! Αφαίρεση 3 στοιχείων
  ΓΙΑ ι ΑΠΟ 1 ΜΕΧΡΙ 3
    ΑΝ Μπροστά <> 0 ΤΟΤΕ
      ΚΑΛΕΣΕ Εξαγωγή_Στοιχείου(Τιμή, Πίσω, Μπροστά, Ουρα) 
      ΓΡΑΨΕ Εξ, Τιμή
    ΑΛΛΙΩΣ
      ΓΡΑΨΕ ΛάθοςΕξ
    ΤΕΛΟΣ_ΑΝ
  ΤΕΛΟΣ_ΕΠΑΝΑΛΗΨΗΣ
  ΚΑΛΕΣΕ Δείξε(Πίσω, Μπροστά, Ουρα) 
ΤΕΛΟΣ_ΠΡΟΓΡΑΜΜΑΤΟΣ

ΔΙΑΔΙΚΑΣΙΑ Εισαγωγή_Στοιχείου(Α, Πίσω, Μπροστά, Ουρα) 
ΜΕΤΑΒΛΗΤΕΣ
  ΑΚΕΡΑΙΕΣ: Α, Πίσω, Μπροστά, Ουρα[10] 
ΑΡΧΗ
  ΑΝ Πίσω = Μπροστά ΤΟΤΕ
    ΓΡΑΨΕ "Η ουρά γέμισε, δεν θα βάλω το ", Α
  ΑΛΛΙΩΣ
    ΑΝ Μπροστά = 0 ΤΟΤΕ
      Μπροστά <- Πίσω
    ΤΕΛΟΣ_ΑΝ
    Ουρα[Πίσω] <- Α
    Πίσω <- Πίσω mod 10 + 1
  ΤΕΛΟΣ_ΑΝ
ΤΕΛΟΣ_ΔΙΑΔΙΚΑΣΙΑΣ
ΔΙΑΔΙΚΑΣΙΑ Εξαγωγή_Στοιχείου(Α, Πίσω, Μπροστά, Ουρα) 
ΜΕΤΑΒΛΗΤΕΣ
  ΑΚΕΡΑΙΕΣ: Α, Πίσω, Μπροστά, Ουρα[10] 
ΑΡΧΗ
  ΑΝ Μπροστά > 0 ΤΟΤΕ
    Α <- Ουρα[Μπροστά] 
    Μπροστά <- Μπροστά mod 10 + 1
    ΑΝ Μπροστά = Πίσω ΤΟΤΕ
      Μπροστά <- 0
    ΤΕΛΟΣ_ΑΝ
  ΤΕΛΟΣ_ΑΝ
ΤΕΛΟΣ_ΔΙΑΔΙΚΑΣΙΑΣ
ΔΙΑΔΙΚΑΣΙΑ Δείξε(Πίσω, Μπροστά, Ουρα) 
ΜΕΤΑΒΛΗΤΕΣ
  ΑΚΕΡΑΙΕΣ: Πίσω, Μπροστά, Ουρα[10], ι
ΑΡΧΗ
  ΑΝ Μπροστά = 0 ΤΟΤΕ
    ΓΡΑΨΕ "Η ουρά είναι άδεια"
  ΑΛΛΙΩΣ
    ΓΡΑΨΕ "Αρχή Ουράς ", Μπροστά
    ΑΝ Μπροστά = Πίσω ΤΟΤΕ
      ΓΡΑΨΕ Ουρα[Μπροστά] 
      ι <- Μπροστά mod 10 + 1
    ΑΛΛΙΩΣ
      ι <- Μπροστά
    ΤΕΛΟΣ_ΑΝ
    ΟΣΟ ι <> Πίσω ΕΠΑΝΑΛΑΒΕ
      ΓΡΑΨΕ Ουρα[ι] 
      ι <- ι mod 10 + 1
    ΤΕΛΟΣ_ΕΠΑΝΑΛΗΨΗΣ
    ΓΡΑΨΕ "Τέλος ουράς ", Πίσω
  ΤΕΛΟΣ_ΑΝ
ΤΕΛΟΣ_ΔΙΑΔΙΚΑΣΙΑΣ
}
Title$="Πρόχειρο Γλώσσας"
Dir User
Declare NotePad Form

Declare Pad EditBox Form NotePad
Declare Inform1 Button Form NotePad
With Inform1, "Caption" as Informe$
Method Inform1, "Colors", 15, #FFA000
With Inform1, "Locked", True
Declare File1 Combobox Form NotePad
Declare Edit1 Combobox Form NotePad
Declare Help1 Combobox Form NotePad
Method NotePad, "FontAttr", "Times", 28, True
With NotePad, "UseIcon", True, "UseReverse", True
Method Pad, "FontAttr", "COURIER NEW", 14, true
identifiers$="<-|ΠΡΟΓΡΑΜΜΑ|ΜΕΤΑΒΛΗΤΕΣ|ΠΡΑΓΜΑΤΙΚΕΣ|ΑΚΕΡΑΙΕΣ|ΛΟΓΙΚΕΣ|ΧΑΡΑΚΤΗΡΕΣ|ΣΤΑΘΕΡΕΣ|ΑΡΧΗ|ΓΡΑΨΕ|ΔΙΑΒΑΣΕ|ΤΕΛΟΣ_ΠΡΟΓΡΑΜΜΑΤΟΣ|DIV|MOD|ΑΝ|ΤΟΤΕ|ΑΛΛΙΩΣ|ΑΛΛΙΩΣ_ΑΝ|ΤΕΛΟΣ_ΑΝ|ΓΙΑ|ΑΠΟ|ΜΕΧΡΙ|ΜΕ_ΒΗΜΑ|ΤΕΛΟΣ_ΕΠΑΝΑΛΗΨΗΣ|ΕΠΙΛΕΞΕ|ΠΕΡΙΠΤΩΣΗ|ΤΕΛΟΣ_ΕΠΙΛΟΓΩΝ|ΟΣΟ|ΕΠΑΝΑΛΑΒΕ|ΑΡΧΗ_ΕΠΑΝΑΛΗΨΗΣ|ΜΕΧΡΙΣ_ΟΤΟΥ|ΚΑΙ|Η|ΟΧΙ|ΑΛΗΘΗΣ|ΨΕΥΔΗΣ|ΚΑΛΕΣΕ|ΔΙΑΔΙΚΑΣΙΑ|ΤΕΛΟΣ_ΔΙΑΔΙΚΑΣΙΑΣ|Α_Μ(|Α_Τ(|Ε|ΕΦ(|ΗΜ(|ΛΟΓ(|ΣΥΝ(|Τ_Ρ(|ΣΥΝΑΡΤΗΣΗ|ΤΕΛΟΣ_ΣΥΝΑΡΤΗΣΗΣ|"
With Pad, "NoWrap", True, "ColorCollection1", identifiers$, "LineComment1", "!", "OtherSymbols","@", "CommentSymbols", "[!][!]", "ComSymbolsWidth", 2, "WordCharRight", ": ,[]+()-*/)}≤≥≠"+chr$(9), "WordCharleft", " :,[]+*/)({≤≥≠"+chr$(9), "WordCharRightButIncluded", "("
With Pad, "LineComment2",CHR$(0), "StringSep2","'", "AssignSym","<-", "SearchWords",False, "UseColon","","SplitExpr",",", "CommentLineLight", True
With Pad, "Sellength" as Pad.SelLength, "EnablePairs", True, "BracketsForArrays", True
With File1,"label","Αρχείο", "listtext" As list$, "list" As list$() '
With Edit1,"label","Επεξεργασία",  "Mark", Color(255,100,0)
With Help1,"label","Βοήθεια",  "Mark", Color(255,100,0)
With NotePad, "Title" As Caption$, "Visible" As Visible, "TitleHeight" As tHeight, "Sizable", True
With Pad, "Text" As Pad.Text$, "NoColor", False, "ShowAlways", True, "SpaceIndent", 2, "NoCenterLineEdit", true, "HighlightParagraph", True
Def TitleStr$(a$)=ucase$(left$(a$,1))+mid$(a$,2)
LastWord$=""
Filename$=Dir$+"κυκλική_ουρά.glo"
Caption$=TitleStr$(File.Name$(Filename$)) +" - ΓΛΩΣΣΑ"
Method NotePad,"MakeStandardInfo", 0
Method NotePad,"move", 2000, 4000, 12000, 8000
Layer NotePad {Cls #FFA000}
With File1,"MenuStyle", True, "MenuWidth", 3000 
With Edit1,"MenuStyle", True, "MenuWidth", 4500
	\\ Advanced programming. Handling of the real control under Edit1 (the drop down list)
	With Edit1, "GlistN" set Control1
	With Control1, "UseTab", True, "TabWidthChar", 12
With Help1,"MenuStyle", True, "MenuWidth", 3000 , "List" as Help.List$()
With File1, "MenuEnabled" As mEnable()
this_line=1
For This {
      mi$="MenuItem"  \\ is a temporary variable only for For This Block
      Method File1, mi$,"Φόρτωσε",True
      Method File1, mi$,"Σώσε",True
      Method File1, mi$,""    \\  only  a line here
      Method File1, mi$,"Κλείσε",True
      Method File1, mi$,"Έξοδος",True
      
      Method Edit1, mi$,"Αποκοπή",True
      Method Edit1, mi$,"Αντιγραφή",True
      Method Edit1, mi$,"Επικόληση",True
      Method Edit1, mi$,"",True
      Method Edit1, mi$,"Λιγότερη εσοχή"+chr$(9)+"Ctrl Q",True
      Method Edit1, mi$,"Περισσότερη εσοχή"+chr$(9)+"Ctrl W",True
      Method Edit1, mi$,"",True
      Method Edit1, mi$,"Άνοιγμα στη Γλώσσα", exist(filename$)
      
      With Help1, "Mark", -#7777FF
      Method Help1, mi$,"Περί",True
      Method Help1, mi$,"Βοήθεια",True
      Method Help1, mi$,"",True
      Method Help1, mi$,"Μέγεθος",False
      Method Help1, "MenuRadio","Mεγάλο",True, False
      Method Help1, "MenuRadio","Μικρό",True, True  
}
Function Help1.MenuChecked {
      Read New RadioIndex \\ 3 or 4
      If RadioIndex =4 Then {
            'After 30
            {
                  Method Pad, "FontAttr", "COURIER NEW", 18, true
                  Method Pad, "Show"
            }
      } Else.If RadioIndex =5 Then {
            'After 30
            {
                  Method Pad, "FontAttr", "COURIER NEW", 14, true
                  Method Pad, "Show"
            }
      }
}
If exist(Filename$) then
	Document BackUp$
	Load.Doc BackUp$, filename$
else
	Document BackUp$=first$
End If
Pad.text$=BackUp$
Function NotePad.Unload {
      Read New &Ok
      After 30 {Call local File1.DblClick(4) }
      Ok=True
}
\\ called when we press ctrl+f1 and not text selected
Function Pad.About {
      Pad.SelLength=0
      Method Pad,"Show"
      call local Help1.DblClick(if(lastword$=""->0,1))
}
\\ normaly send a string, but here we drop it
Function Pad.Help {
      call local Help1.DblClick(if(lastword$=""->0,1))
}
Function Notepad.Resize {
      Layer NotePad { Cls Color(255, 160, 0) ,0}
      With NotePad, "Width" As NP.Width, "Height" As NP.Height, "TitleHeight" As tHeight
      
      tHeight1=theight*2
      local theight2=theight*.8, theight0=theight*1.2
      Method File1,"move", twipsX*2, theight0,  twipsX*100, tHeight2
      Method Edit1,"move", twipsX*2+twipsX*100, theight0,  twipsX*160, tHeight2
      Method Help1,"move", twipsX*2+twipsX*260, theight0,  twipsX*120, tHeight2
      Method Inform1,"move", twipsX*2+twipsX*360, theight0,  twipsX*120, tHeight2
      If NP.height>2000 Then {
            Method Pad,"move", twipsX*2, tHeight1,  NP.Width-twipsX*5, NP.Height-tHeight1-twipsx*3
            With Pad, "NoWrap" As NoWrap
            If Not NoWrap Then Method Pad,"Resize"
      }
}
Function LessI(){
      Method Pad,"SetRowColumn", This_line, 0, true
      Method Pad,"PressKey", 9, 1
}
Function MoreI(){
      Method Pad,"SetRowColumn", This_line, 0, true
      Method Pad,"PressKey", 9, 0
}
\\  ctrl+Q for less indentation (adjust also the column)
\\ (also Ctrl+Shift+Tab  - for one row we have to select a block or to have the column before letters else we get spaces)
\\  ctrl_W for more indentation () (adjust also the column)

Function Pad.KeyDown {
      Read New &kc, &Shf
      If kc=81 and shf=2 Then
            kc=0 : shf=0
            After 20{
                  Call Local LessI()
            }
      Else.if Kc=87 and shf=2 then
            kc=0 : shf=0
            After 20{
                  Call Local MoreI()
            }      
      End If
}
Function Edit1.DblClick {
      Read Local Edit1index
      Select Case Edit1index
      Case 0
            {
            Method Pad,"mn1sub"
            Method Pad,"Resize"
            }
      Case 1
            Method Pad,"mn2sub"
      Case 2
            {
                  Method Pad, "mn3sub"
                  Method Pad,"GetFocus"
                  Method Pad,"Resize"
           }
      Case 4
            Call Local LessI()
      Case 5
            Call Local MoreI()
      Case 7
            {
                  If Pad.Text$<>BackUp$ then
                        call local File1.DblClick(1)
                  End If
                  If exist(filename$) then Win "Γλώσσα.exe", filename$
            }
      End Select
}
Function Pad.PopUp {
      Read Local X, Y
      Method Pad,"PopUpMenu", "",X , Y
}
Function Pad.Inform {
      Read New L, P
      this_line=L
      Informe$=format$("{0}-{1}", L,P)
      Method Pad,"Show"
}
informe$="Έτοιμο"
Function File1.DblClick {
      Read New File1index
      Local cont, cont2, f$, NL$={
      }
      File1index++
      {
      On File1index Goto Open1, Save1, ExitNow, Save2, Unload
      Exitnow:
      Exit
Open1:
      If Pad.Text$<>BackUp$ Then {
            If Ask("Να σωθούν οι αλλαγές;",Title$, "ΝΑΙ", "ΟΧΙ")=1 Then Goto Save1
      }
     Layer NotePad {
           Open.file filename$,"c:\","Φόρτωσε Αρχείο","glo"
     }
     Method Pad,"GetFocus"
     Read f$
     If f$<>"" Then {
           Filename$=f$
           If exist(F$) then {
           Clear BackUp$
           Load.Doc BackUp$, f$
           Caption$=TitleStr$(File.Name$(Filename$)) +" - ΓΛΩΣΣΑ"
           Pad.Text$=BackUp$
           } else Pad.text$="": Clear BackUp$
           Method Pad, "Resize"
      }
      Exit
Save1:
      Layer NotePad {
            Save.As Filename$,"c:\","Σώσε αρχείο","glo"
      }
      If not cont2 then Method Pad,"GetFocus"
      Read f$
      If f$="" Then Exit 
      If lcase$(file.type$(f$))<>"glo" then f$=f$+".glo"
      If Exist(f$) Then  If Ask(NL$+"Να αλλάξω το αρχείο"+NL$+f$,Title$, "ΝΑΙ", "ΟΧΙ")<>1 Then Exit
      Try ok {
        Clear BackUp$
        BackUp$=Pad.Text$
        Save.Doc BackUp$, f$
        filename$=f$
        Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
      }
     If ok else beep
     If not cont then Exit
Save2:
      cont=True
      If Pad.Text$<>BackUp$ Then {
            If Ask("Να σωθούν οι αλλαγές;",Title$, "ΝΑΙ", "ΟΧΙ")=1 Then Goto Save1
      }
      Clear BackUp$
      Pad.Text$=""
      If Cont2 then {
           Method NotePad, "CloseNow"
      } Else {
            FileName$=Dir$+"νεο.glo"
            Caption$=TitleStr$(File.Name$(Filename$)) +" - ΓΛΩΣΣΑ"
            Method Pad, "Resize"
      }
      Exit
Unload:
      Cont2=True : Goto Save2
      }
}
Function Help1.DblClick(new index) {
If index=0 then
      Local A, info$
      Info$={
            Πρόχειρο για συγγραφή προγραμμάτων σε ΓΛΩΣΣΑ για το μάθημα της ΑΕΠΠ.
            Η εξαγωγή στο πρόχειρο γίνεται σε Html και απλό κείμενο, ταυτόχρονα.
            }
      A=Ask(info$,Title$,"ΝΑΙ","")  ' one button only
else.if index=1 then
      if  lastword$<>"" then
            If not exist(lastword$+".txt") then local a$ : Document a$ : Save.Doc a$, lastword$+".txt"
            win "notepad", dir$+lastword$+".txt"
      else
            after 30 {local A=Ask("Επίλεξε μια λέξη και γύρνα στο μενού βοήθεια ξανά!", Title$, "Κατάλαβα","")
            }            
      end if
else.if index>2 then
      Call Local Help1.MenuChecked(index)
End If

}
Function Pad.Word(new alfa$) {
      If instr(identifiers$, "|"+alfa$+"|")>0 then
            Lastword$=alfa$	
            Help.list$(1)="Βοήθεια για "+alfa$
            With Help1,"MenuWidth", Max.data(Size.X(Help.list$(1), "Verdana",12 )+1000, 3000)
      End If
}
Function Notepad.InfoClick {
	Read New X
	If X=0 Then Call Local Help1.DblClick(0)  ' 0 for first menu item
}
Call Local Notepad.Resize()

After 100 {Title "", 0}
Method NotePad,"Show" , 1

Declare Control1 Nothing 
Declare Pad Nothing
Declare NotePad Nothing 
Latin
If Module(Info) Then
	Title "Info"
	keyboard "INFOBasic"+chr$(13)
end if
}
MODULE HTMLEDITOR {\\ Version 0.2
\\ default set true to Pad
\\ need some work inside interpreter code
Clear \\ Clear all variables/objects
def setagain as boolean, hidetitle as boolean=True
if file.name$("A.abc")="a.abc" then
Set switches "+CASESENSITIVE"
setagain=true
\\ we want to see and use  the actual case of a filename
End if
Global Const  CSIDL_MY_DOCUMENTS  = 0x5
if match("S") then
hidetile=false
Filename$=Dir$+letter$
document first$
load.doc first$, filename$
else
Filename$=Dir$+"floatforms.html"
first$={<!DOCTYPE html>
<html lang = "en-US">
      <head>
            <meta charset = "UTF-8">
            <title>floatForm.html</title>
            <link rel = "stylesheet"
                  type = "text/css"
                  href = "floatForm.css" />
      </head>
      <body>
            <form action = "">
                  <fieldset>
                        <label>Name</label>
                        <input type = "text"
                              id = "txtName" />
                        <label>Address</label>
                        <input type = "text"
                              id = "txtAddress" />
                        <label>Phone</label>
                        <input type = "text"
                              id = "txtPhone" />
                        <button type = "button">
                              submit request
                        </button>
                  </fieldset>
            </form>
      </body>
</html>
}
end if
Flush \\ Empty the stack
makelist()
title$="Html Editor"
typ$="html"
W$=""
path$="" 
Read hBase, identifiers$
Dir User
lookpath$=dir$
Declare NotePad Form
Declare Pad EditBox Form NotePad
Declare Inform1 Button Form NotePad
With Inform1, "Caption" as Informe$
Method Inform1, "Colors", 15, #FFA000
With Inform1, "Locked", True
Declare File1 Combobox Form NotePad
Declare Edit1 Combobox Form NotePad
Declare Tools Combobox Form NotePad
Declare Help1 Combobox Form NotePad
With File1,"label","File", "listtext" As list$, "list" As list$() '
With Edit1,"label","Edit",  "Mark", Color(255,100,0)
With Tools,"label","Tools",  "Mark", Color(255,100,0), "list" As tList$()
With Help1,"label","Help",  "Mark", Color(255,100,0)
Method Pad, "FontAttr", "VERDANA", 13.5, true
With NotePad, "Title" As Caption$, "Visible" As Visible, "TitleHeight" As tHeight, "Sizable", True
With NotePad, "UseIcon", True, "UseReverse", True
With Pad, "Text" As Pad.text$, "ShowAlways", True,"NoColor", True,"SelLength" as SelLength
With Pad, "SearchWords", False, "nowrap", False, "linespace", 30
With Pad, "ReplaceTitle" as InnerInfo$,"Default", True
Def TitleStr$(a$)=a$ '   Ucase$(Left$(a$,1))+Mid$(a$,2)


Caption$=TitleStr$(File.Name$(Filename$)) +" - HTML Editor"
Title Caption$
Method NotePad,"MakeStandardInfo", 1
Method NotePad,"move", 2000, 4000, 8000, 4000
Layer NotePad {Cls #FFA000}
With File1,"MenuStyle", True, "MenuWidth", 3000 
With Edit1,"MenuStyle", True, "MenuWidth", 3000,"menuEnabled" as Enabled() 
With Tools,"MenuStyle", True, "MenuWidth", 5400
With Help1,"MenuStyle", True, "MenuWidth", 3000 
With File1, "MenuEnabled" As mEnable()
For This {
      mi$="MenuItem"  \\ is a temporary variable only for For This Block
      With File1, "MenuGroup","This"
      Method File1, mi$,"Open",True
      Method File1, mi$,"Save",True
      Method File1, mi$,""    \\  only  a line here
      Method File1,"MenuRadio","css files",True,False
      Method File1,"MenuRadio","html files",True,True
      
      Method File1, mi$,""
      Method File1, mi$,"Close",True
      Method File1, mi$,""
      Method File1, mi$,"Quit",True
           
      
      With Edit1, "MenuGroup","This"
      Method Edit1, mi$,"Cut",False
      Method Edit1, mi$,"Copy",False
      Method Edit1, mi$,"Paste",True
      Method Edit1, mi$,""
      Method Edit1, mi$,"Less Indent",True
      Method Edit1, mi$,"More Indent",True  
      
      With Tools, "MenuGroup","This"
      Method Tools, mi$,"Open in "+piece$(file.title$("html")," ")(0),true
      Method Tools, mi$,""
      Method Tools, mi$,"Set Directory from User", true
      Method Tools, mi$,"Set Directory from My Documents",true
      
      With Help1, "MenuGroup","This"
      Method Help1, mi$, "About", True
}

if exist(Filename$) then
      Document BackUp$
      Load.Doc BackUp$, filename$
else
      Document BackUp$=first$
end if
Pad.text$=BackUp$
Function NotePad.Unload {
      Read New &Ok
      After 30 {Call local File1.DblClick(8) }
      Ok=True

}
Function Notepad.Resize {
      Layer NotePad { Cls Color(255, 160, 0) ,0}
      With NotePad, "Width" As NP.Width, "Height" As NP.Height, "TitleHeight" As tHeight
      tHeight1=theight*2
      Method File1,"move", twipsX*2, tHeight,  twipsX*80, tHeight
      Method Edit1,"move", twipsX*2+twipsX*80, tHeight,  twipsX*80, tHeight
      Method Tools,"move", twipsX*2+twipsX*160, tHeight,  twipsX*80, tHeight
      Method Help1,"move", twipsX*2+twipsX*240, tHeight,  twipsX*160, tHeight
      Method Inform1,"move", twipsX*2+twipsX*320, tHeight,  twipsX*240, tHeight
      If NP.height>1000 Then {
            Method Pad,"move", twipsX*2, tHeight1,  NP.Width-twipsX*5, NP.Height-tHeight1-twipsx*3
            With Pad, "NoWrap" As NoWrap
            If Not NoWrap Then Method Pad,"Resize"
      }
}
Function Edit1.OpenMenu {
            Local X
            X=SelLength>0
            Enabled(0)=X
            Enabled(1)=X
}

Function Edit1.DblClick {
      Read Local Edit1index
      Select Case Edit1index
      Case 0
            {
            Method Pad,"mn1sub"
            Method Pad,"Resize"
            }
      Case 1
            Method Pad,"mn2sub"
      Case 2
            {
                 Method Pad, "mn3sub"
                 Method Pad,"GetFocus"
                 Method Pad,"Resize"
           }
        Case 4
           {
                  Method Pad,"PressKey", 9, 1
            }
        Case 5
           {
                  Method Pad,"PressKey", 9, 0
            }
      End Select

}
Function Pad.Inform {
      Read New L, P
      Informe$=format$("{0}-{1}", L,P)
      Method Pad,"Show"
}
Function Pad.PopUp {
      Read Local X, Y
      Method Pad,"PopUpMenu", "",X , Y
}
function cs_choose{
      With Pad, "ColorCollection1",identifiers$,"SetHTML", true
      Method Pad, "ReColor"
      Method Pad, "Show"
}

Function File1.MenuChecked {
Read New RadioIndex \\ 3 or 4
If RadioIndex =3 Then {
      After 30 { Static a$="."+File.type$(Filename$), b$=File.name$(Filename$)
      Filename$=File.path$(Filename$)+Left$(b$,Len(b$)-Len(a$))+".css"
      Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
      typ$="css"
      With Pad, "ColorCollection1", "","NoColor", True,  "UseCase", False
      Pad.text$=Pad.text$
      Method Pad, "Show"
      }
} Else.If RadioIndex =4 Then {
     After 30 { local a$="."+File.type$(Filename$), b$=File.name$(Filename$)
      Filename$=File.path$(Filename$)+Left$(b$,Len(b$)-Len(a$))+".html"
      Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
      typ$="html"
      Call local cs_choose()
      }      
}

}
Function File1.DblClick {
\\ we use functions As subs here
\\ each function and each module have a name (define a namespace)
\\ but here real module name is the File1.DblClick() host module
\\ this is done because is a Gui Event Service Function
\\ and is Call With Local tag (Call Local)
      Read New File1index
      method Pad, "CloseTitle"
      
      Local cont, cont2, f$, NL$={
      }
      File1index++
      \\ Because we want some jumps..we use  On Goto
      \\ on Goto need here a block
      {
      On File1index Goto Open1, Save1, ExitNow, ExitNow, ExitNow, ExitNow, Save2, ExitNow,  Unload
Exitnow:
      Exit
Open1:
      If Pad.text$<>BackUp$ Then {
            If Ask("Save Changes first?",title$, "Yes","No")=1 Then Goto Save1
      }
     Layer NotePad {
           Open.file filename$,,"Load Text ("+typ$+") File",typ$
     }
     
     Method Pad,"GetFocus"
     Read f$
     If f$<>"" Then {
           Filename$=f$
           If Exist(F$) Then {
           Clear BackUp$
           Load.Doc BackUp$, f$
           
           Caption$=TitleStr$(File.Name$(Filename$)) +" - Html Editor"
           lookpath$=file.path$(Filename$)
           \\ silent means here without refresh
           With Pad, "SelStartSilent", 0, "SellengthSilent",0 
           Pad.text$=BackUp$
           } Else Pad.text$="": Clear BackUp$
           Method Pad, "ReColor"
      }
      Exit
Save1:
      Layer NotePad {
            Save.As Filename$,,"Save Text ("+typ$+") File",typ$
      }
      If Not cont2 Then Method Pad,"GetFocus"
      Read f$   ' from save.as we get a value
      If f$="" Then Exit 
      If Lcase$(File.type$(f$))<>typ$ Then f$=f$+"."+typ$
      If Exist(f$) Then  If Ask(NL$+"Overwrite"+NL$+f$,title$, "Yes","No")<>1 Then Exit
      Try ok {
        Clear BackUp$
        BackUp$=Pad.text$
        Save.Doc BackUp$, f$  ' by default 2 - Utf-8
        filename$=f$
        lookpath$=file.path$(Filename$)
        Caption$=TitleStr$(File.Name$(Filename$)) +" - Html Editor"
      }
     If ok Else Beep
     If Not cont Then Exit
Save2:
      cont=True
      If Pad.text$<>BackUp$ Then {
            If Ask("Save Changes?",title$, "Yes","No")=1 Then Goto Save1
      }
      Clear BackUp$
      Pad.text$=""
      If Cont2 Then {
            Method NotePad, "CloseNow"
      } Else {
            FileName$=Dir$+"Untitled."+typ$
            Caption$=TitleStr$(File.Name$(Filename$)) +" - Html Editor"
            Method Pad, "Resize"
      }
      Exit
Unload:
      Cont2=True : Goto Save2
      }
}

Function Tools.OpenMenu {
      tlist$(0)="Open in "+piece$(file.title$("html")," ")(0)
}
Function Tools.DblClick {
      Read New Toolsindex
      select case Toolsindex
      case 0
      {
            lookpath$=file.path$(Filename$)
            local test$, ok
            document test$
            test$=pad.text$
            try ok {
                  save.doc test$, dir$+"_test_.html"
                  win dir$+"_test_.html"
            }
            if not ok then beep
      }
      case 2
      {
            dir user
            dir ? dir$, "Choose Folder"
            filename$=dir$+file.name$(filename$)
       }
      case 3
      {
             dir path$(CSIDL_MY_DOCUMENTS)
             dir ? dir$, "Choose Folder"
             filename$=dir$+file.name$(filename$)
      }
      end select

}
Function Help1.DblClick {
      Read New Help1index
      Local A, info$
      Info$={
            This is an example
            of an editor for html files
            written for M2000 Environment
            use F1 to change wrap
            }
      A=Ask(info$,title$,"","")
      Method Pad, "GetFocus"

}
Function Notepad.InfoClick {
	Read New X
	If X=0 Then Call Local Help1.DblClick(0)  ' 0 for first menu item
}
Function Pad.Word(new alfa$) {
      if exist(hBase, alfa$) then
            InnerInfo$=alfa$+" "+eval$(hbase)
      end if
}

Call Local Notepad.Resize()
\\ open As modal
if hidetitle then Title "", 0
after 200 {
	Call local cs_choose()
}
\\After 100 {Title "", 0}
Method NotePad,"Show" , 1
Declare Pad Nothing
Declare NotePad Nothing 
if setagain Then Set switches "-CASESENSITIVE"
Print "Done"
If module(Info) then Title "Info"
Dir User
Exit
Sub makelist()
Document Help$ ={
	<a>	Defines a hyperlink.
	<article> 	Defines an article.
	<aside> 	Defines some content loosely related to the page content.
	<body>	Defines the document's body.
	<br>	Produces a single line break.
	<!DOCTYPE> The type of document
	<details> 	Represents a widget from which the user can obtain additional information or controls on-demand.
	<div>	Specifies a division or a section in a document.
	<h1>		Defines HTML headings level 1.
	<h2>		Defines HTML headings level 2.
	<h3>		Defines HTML headings level 3.
	<h4>		Defines HTML headings level 4.
	<h5>		Defines HTML headings level 5.
	<h6>		Defines HTML headings level 6.
	<head>	Defines the head portion of the document that contains information about the document.
	<header> 	Represents the header of a document or a section.
	<hgroup> 	Defines a group of headings.
	<hr>	Produce a horizontal line.
	<html>	Defines the root of an HTML document.
	<footer> 	Represents the footer of a document or a section.
	<nav> 	Defines a section of navigation links.
	<p>	Defines a paragraph.
	<section> 	Defines a section of a document, such as header, footer etc.
	<span>	Defines an inline styleless section in a document.
	<summary> 	Defines a summary for the <details> element.
	<base>	Defines the base URL for all linked objects on a page.
	<basefont>	Obsolete Specifies the base font for a page.
	<link>	Defines the relationship between the current document and an external resource.
	<meta>	Provides structured metadata about the document content.
	<style>	Inserts style information (commonly CSS) into the head of a document.
	<title>	Defines a title for the document.
	<button>	Creates a clickable button.
	<datalist> 	Represents a set of pre-defined options for an <input> element.
	<fieldset>	Specifies a set of related form fields.
	<form>	Defines an HTML form for user input.
	<input>	Defines an input control.
	<keygen> 	Represents a control for generating a public-private key pair.
	<label>	Defines a label for an <input> control.
	<legend>	Defines a caption for a <fieldset> element.
	<meter> 	Represents a scalar measurement within a known range.
	<optgroup>	Defines a group of related options in a selection list.
	<option>	Defines an option in a selection list.
	<select>	Defines a selection list within a form.
	<textarea>	Defines a multi-line text input control (text area).
	<abbr>	Defines an abbreviated form of a longer word or phrase.
	<acronym>	Defines an acronym.
	<address>	Specifies the author's contact information.
	<b>	Displays text in a bold style.
	<bdi> 	Represents text that is isolated from its surrounding for the purposes of bidirectional text formatting.
	<bdo>	Overrides the current text direction.
	<big>	displays text in a large size.
	<blockquote>	Defines a long quotation.
	<center>	Obsolete Align contents in the center of the enclosing block.
	<cite>	Indicates a citation or reference to another source.
	<code>	Specifies text as computer code.
	<del>	Specifies a block of deleted text.
	<dfn>	Specifies a definition.
	<em>	Specifies emphasized text.
	<font>	Obsolete Defines font, color, and size for text.
	<i>	Displays text in an italic style.
	<ins>	Defines a block of text that has been inserted into a document.
	<kbd>	Specifies text as keyboard input.
	<mark> 	Represents text highlighted for reference purposes.
	<output> 	Represents the result of a calculation.
	<pre>	Defines a block of preformatted text.
	<progress> 	Represents the completion progress of a task.
	<q>	Defines a short inline quotation.
	<rp> 	Provides fall-back parenthesis for browsers that that don't support ruby annotations.
	<rt> 	Defines the pronunciation of character presented in a ruby annotations.
	<ruby> 	Represents a ruby annotation.
	<s>	Obsolete Displays text in strikethrough style.
	<samp>	Specifies text as sample output from a computer program.
	<small>	Displays text in a smaller size.
	<strike>	Obsolete Displays text in strikethrough style.
	<strong>	Indicate strongly emphasized text.
	<sub>	Defines subscripted text.
	<sup>	Defines superscripted text.
	<tt>	Displays text in a teletype style.
	<u>	Obsolete Displays text with an underline.
	<var>	Defines a variable.
	<wbr> 	Represents a line break opportunity.
	<dd>	Specifies a definition for a term in a definition list.
	<dir>	Obsolete Defines a directory list.
	<dl>	Defines a definition list.
	<dt>	Defines a term (an item) in a definition list.
	<li>	Defines a list item.
	<ol>	Defines an ordered list.
	<menu>	Represents a list of commands.
	<ul>	Defines an unordered list.
	<caption>	Defines the title of a table.
	<col>	Defines attribute values for one or more columns in a table.
	<colgroup>	Specifies attributes for multiple columns in a table.
	<table>	Defines a data table.
	<tbody>	Groups a set of rows defining the main body of the table data.
	<td>	Defines a cell in a table.
	<tfoot>	Groups a set of rows summarizing the columns of the table.
	<thead>	Groups a set of rows that describes the column labels of a table.
	<th>	Defines a header cell in a table.
	<tr>	Defines a row of cells in a table.
	<noscript>	Defines alternative content to display when the browser doesn't support scripting.
	<script>	Places script in the document for client-side processing.
	<applet>	Obsolete Embeds a Java applet (mini Java applications) on the page. Use the <object> element instead.
	<area>	Defines a specific area within an image map.
	<audio> 	Embeds a sound, or an audio stream in an HTML document.
	<canvas> 	Defines a region in the document, which can be used to draw graphics on the fly via scripting (usually JavaScript).
	<embed> 	Embeds external application, typically multimedia content like audio or video into an HTML document.
	<figcaption> 	Defines a caption or legend for a figure.
	<figure> 	Represents a figure illustrated as part of the document.
	<frame>	Defines a single frame within a frameset.
	<frameset>	Defines a collection of frames or other frameset.
	<iframe>	Displays a URL in an inline frame.
	<img>	Displays an inline image.
	<map>	Defines a client-side image-map.
	<noframes>	Defines an alternate content that displays in browsers that do not support frames.
	<object>	Defines an embedded object.
	<param>	Defines a parameter for an object or applet element.
	<source> 	Defines alternative media resources for the media elements like <audio> or <video>.
	<time> 	Represents a time and/or date.
	<video> 	Embeds video content in an HTML document.
}
Inventory hBase
Document final$
m=Paragraph(Help$, 0) 
If Forward(Help$,m) then {
      While m {
            a$=Paragraph$(Help$,(m))
            if a$<>"" then
                  \\ help pair to hBase
                  b$=rightpart$(a$, "<")
                  c$=trim$(filter$(rightpart$(b$,">"), chr$(9)))
                  b$=leftpart$(b$,">")
                  Append hBase,b$:=c$
                  \\ indentifiers for color syntax
                  b$=rightpart$(a$, "<")
                  b$=leftpart$(b$,">")
                  final$="|"+b$
            end if
      }
}
final$="|"
Push	final$
Push hBase
end sub
}
MODULE VALIDATOR {makelist()
read tags
a$ ={
<!DOCTYPE html>
<html lang = "en-US">
      <head>
            <meta charset = "UTF-8">
            <title>floatForm.html</title>
            <link rel = "stylesheet"
                  type = "text/css"
                  href = "floatForm.css" />
      </head>
      <!-- CSS injected by skin and extensions -->
      <body>
            <form action = "">
                  <fieldset>
                        <label>Name</label>
                        <input type = "text"
                              id = "txtName" />
                        <label>Address</label>
                        <input type = "text"
                              id = "txtAddress" />
                        <label>Phone</label>
                        <input type = "text"
                              id = "txtPhone" />
                        <button type = "button">
                              submit request
                        </button>
                  </fieldset>
            </form>
      </body>
</html>
}
document valdoc$ =filter$(a$,chr$(9))
Function count34 (a$){
	i=1 : n=0:t=len(a$)
	{
		b= chrcode(mid$(a$,i))
		if b=34 then n++
		if b>0x10000 then i+=2 else i++
		if i<=t then loop
	}
	=n
}
Function drop34 (&a$){
	i=1 : n=0:t=len(a$)
	{
		b= chrcode(mid$(a$,i))
		if b=34 then n++
		if b>0x10000 then i+=2 else i++
		if n=2 then exit
		if i<=t then loop
	}
	if n=2 then a$=mid$(a$, i) : = true
}
er$="general"
valcurline=0
valposline=0
valm=Paragraph(valdoc$, 0) 
def FindTag as boolean=True
LastTag$=""
FindEndComment=false
def i,j,k
Stack New {
      If Forward(valdoc$,valm) then {
            a$=Paragraph$(valdoc$,(valm))
            valcurline++
            a$=replace$(chr$(9)," ", a$)
            k=len(a$)+1
            valposline=1
            Print valcurline , " "+a$
            rem Stack
            a$=trim$(a$)
            valposline=K-len(a$)
            while valposline<k  {
                  if FindTag then {
                        
                        if left$(a$,1)=">" then{
                              if LastTag$="" then er$=" not tag for >" : goto exitall1
                              a$=trim$(mid$(a$,2))
                              findtag=false
                        } 
                        if LastTag$="*" then {
                        if left$(a$,2)="/>" then a$=mid$(a$,2)
                        
                              if not empty then read LastTag$ else LastTag$="" 
                              FindTag=false
                        }
                        if left$(a$,1)="<" then{
                               a$=mid$(a$,2)
                               findtag=true
                        }
                        if not findtag then exit
                        if left$(a$,3)="!--" then {
                              a$=mid$(a$,4)
                              FindEndComment=True
                              FindTag=false
                        } else.if left$(a$,1)="!" then {
                              a$=rightpart$(a$, ">")
                        } else.if left$(a$,2)="/>" then {
                              if LastTag$="" then er$="missing tag" : goto exitall
                              a$=mid$(a$,3)
                              if LastTag$<>"link" and LastTag$<>"input" then {
                                    
                                    if  empty then  er$="missing tag" : goto exitall1
                                    read LastTag1$
                                    If LastTag1$<>LastTag$ then er$=LastTag$+" no match "+LastTag1$: goto exitall
                              }
                              if not empty then Read LastTag$
                        } else.if left$(a$,1)="/" then {
                              a$=mid$(a$,2)
                              if LastTag$<>"" then {
                                    LastTag1$=leftpart$(a$," ")
                                    if LastTag1$="" then {
                                          LastTag1$=leftpart$(a$,">") 
                                          if LastTag1$="" then if len(a$)>0 then LastTag1$=a$ : a$=""
                                         
                                          if LastTag1$<>LastTag$ then er$=LastTag$ + " no match /"+LastTag1$ : goto exitall
                                          a$=trim$(rightpart$(a$,">") )
                                    } else {
                                          if LastTag1$<>LastTag$ then er$=LastTag$ + " no match /"+LastTag1$ : goto exitall
                                          a$=trim$(a$)
                                          if left$(a$,1)<>">" then er$="missing > from end tag "+LastTag$: goto exitall
                                    }
                                    if not empty then read LastTag$
                              } else {
                                    LastTag1$=leftpart$(a$," ")
                                    if LastTag1$="" then {
                                          LastTag1$=leftpart$(a$,">") 
                                          if LastTag1$="" then if len(a$)>0 then LastTag1$=a$ : a$=""
                                    } 
                                    if LastTag1$<>"" then er$="/" + LastTag1$ + " no pair" : goto exitall
                                    er$="</  without tag"
                                    goto exitall
                              }
                        } else {
                              a$=trim$(a$)
                              LastTag1$=leftpart$(a$," ")
                              if instr(LastTag1$,">")>0 then
                              LastTag1$=leftpart$(LastTag1$," ")
                              end if
                              if LastTag1$="" then {
                                    LastTag1$=leftpart$(a$,">") 
                                    if LastTag1$="" then{
                                           if len(a$)>0 then LastTag1$=a$ : a$=""
                                    } else a$=trim$(mid$(a$,len(lasttag1$)+1)) :   FindTag=true
                              } else a$=trim$(rightpart$(a$," ")) :   FindTag=false
                              if LastTag1$="" then er$="not tag found" : goto exitall
                              if LastTag1$="meta" then {
                                    if LastTag$<>"" then push LastTag$
                                 LastTag$="*"   
                                     a$=trim$(a$)
                              } else {
                                    if LastTag$<>"" then push LastTag$
                                    LastTag$=LastTag1$
                                    a$=trim$(a$)
                                    if not FindTag then FindTag=left$(a$,2)="/>" : if FindTag then a$=mid$(a$,22) : FindTag=False
                              }
                        }
                  } else.if FindEndComment then {
                        i=instr(a$,"-->")
                        if i>0 then {
                             a$=mid$(a$, i+3)
                             FindEndComment=false
                             FindTag=True
                        }
                  } else.if left$(a$,1)="<" then {
                        FindTag=true
                  } else {
                        i=count34(a$)
                        if i mod 2=1 then er$="problem with strings" : goto exitall
                        if i>0 then while drop34(&a$) {}
                        a$=trim$(a$)
                        
                        i=instr(a$,"<"): if i=0 then i=len(a$)+1
                        j=instr(a$,"/"): if j=0 then j=len(a$)+1
                        g=instr(a$,">"): if g=0 then g=len(a$)+1
                        a$=TRIM$(mid$(a$,min.data(i, j, g))): FindTag= a$<>""
                  }
                  valposline=K-len(a$)
            }
            if valm<>0 then loop
      }
      if not empty then er$=str$(stack.size,"")+" tag left" :goto exitall
}
Print "ok"
exit
exitall:
valposline=K-len(a$)
Print "Error ";er$;" at line ";valcurline; " at cursor pos ";valposline
Exit
Sub makelist()
' test "here"
Document Help$ ={
	<a>	Defines a hyperlink.
	<article> 	Defines an article.
	<aside> 	Defines some content loosely related to the page content.
	<body>	Defines the document's body.
	<br>	Produces a single line break.
	<details> 	Represents a widget from which the user can obtain additional information or controls on-demand.
	<div>	Specifies a division or a section in a document.
	<h1>		Defines HTML headings level 1.
	<h2>		Defines HTML headings level 2.
	<h3>		Defines HTML headings level 3.
	<h4>		Defines HTML headings level 4.
	<h5>		Defines HTML headings level 5.
	<h6>		Defines HTML headings level 6.
	<head>	Defines the head portion of the document that contains information about the document.
	<header> 	Represents the header of a document or a section.
	<hgroup> 	Defines a group of headings.
	<hr>	Produce a horizontal line.
	<html>	Defines the root of an HTML document.
	<footer> 	Represents the footer of a document or a section.
	<nav> 	Defines a section of navigation links.
	<p>	Defines a paragraph.
	<section> 	Defines a section of a document, such as header, footer etc.
	<span>	Defines an inline styleless section in a document.
	<summary> 	Defines a summary for the <details> element.
	<base>	Defines the base URL for all linked objects on a page.
	<basefont>	Obsolete Specifies the base font for a page.
	<link>	Defines the relationship between the current document and an external resource.
	<meta>	Provides structured metadata about the document content.
	<style>	Inserts style information (commonly CSS) into the head of a document.
	<title>	Defines a title for the document.
	<button>	Creates a clickable button.
	<datalist> 	Represents a set of pre-defined options for an <input> element.
	<fieldset>	Specifies a set of related form fields.
	<form>	Defines an HTML form for user input.
	<input>	Defines an input control.
	<keygen> 	Represents a control for generating a public-private key pair.
	<label>	Defines a label for an <input> control.
	<legend>	Defines a caption for a <fieldset> element.
	<meter> 	Represents a scalar measurement within a known range.
	<optgroup>	Defines a group of related options in a selection list.
	<option>	Defines an option in a selection list.
	<select>	Defines a selection list within a form.
	<textarea>	Defines a multi-line text input control (text area).
	<abbr>	Defines an abbreviated form of a longer word or phrase.
	<acronym>	Defines an acronym.
	<address>	Specifies the author's contact information.
	<b>	Displays text in a bold style.
	<bdi> 	Represents text that is isolated from its surrounding for the purposes of bidirectional text formatting.
	<bdo>	Overrides the current text direction.
	<big>	displays text in a large size.
	<blockquote>	Defines a long quotation.
	<center>	Obsolete Align contents in the center of the enclosing block.
	<cite>	Indicates a citation or reference to another source.
	<code>	Specifies text as computer code.
	<del>	Specifies a block of deleted text.
	<dfn>	Specifies a definition.
	<em>	Specifies emphasized text.
	<font>	Obsolete Defines font, color, and size for text.
	<i>	Displays text in an italic style.
	<ins>	Defines a block of text that has been inserted into a document.
	<kbd>	Specifies text as keyboard input.
	<mark> 	Represents text highlighted for reference purposes.
	<output> 	Represents the result of a calculation.
	<pre>	Defines a block of preformatted text.
	<progress> 	Represents the completion progress of a task.
	<q>	Defines a short inline quotation.
	<rp> 	Provides fall-back parenthesis for browsers that that don't support ruby annotations.
	<rt> 	Defines the pronunciation of character presented in a ruby annotations.
	<ruby> 	Represents a ruby annotation.
	<s>	Obsolete Displays text in strikethrough style.
	<samp>	Specifies text as sample output from a computer program.
	<small>	Displays text in a smaller size.
	<strike>	Obsolete Displays text in strikethrough style.
	<strong>	Indicate strongly emphasized text.
	<sub>	Defines subscripted text.
	<sup>	Defines superscripted text.
	<tt>	Displays text in a teletype style.
	<u>	Obsolete Displays text with an underline.
	<var>	Defines a variable.
	<wbr> 	Represents a line break opportunity.
	<dd>	Specifies a definition for a term in a definition list.
	<dir>	Obsolete Defines a directory list.
	<dl>	Defines a definition list.
	<dt>	Defines a term (an item) in a definition list.
	<li>	Defines a list item.
	<ol>	Defines an ordered list.
	<menu>	Represents a list of commands.
	<ul>	Defines an unordered list.
	<caption>	Defines the title of a table.
	<col>	Defines attribute values for one or more columns in a table.
	<colgroup>	Specifies attributes for multiple columns in a table.
	<table>	Defines a data table.
	<tbody>	Groups a set of rows defining the main body of the table data.
	<td>	Defines a cell in a table.
	<tfoot>	Groups a set of rows summarizing the columns of the table.
	<thead>	Groups a set of rows that describes the column labels of a table.
	<th>	Defines a header cell in a table.
	<tr>	Defines a row of cells in a table.
	<noscript>	Defines alternative content to display when the browser doesn't support scripting.
	<script>	Places script in the document for client-side processing.
	<applet>	Obsolete Embeds a Java applet (mini Java applications) on the page. Use the <object> element instead.
	<area>	Defines a specific area within an image map.
	<audio> 	Embeds a sound, or an audio stream in an HTML document.
	<canvas> 	Defines a region in the document, which can be used to draw graphics on the fly via scripting (usually JavaScript).
	<embed> 	Embeds external application, typically multimedia content like audio or video into an HTML document.
	<figcaption> 	Defines a caption or legend for a figure.
	<figure> 	Represents a figure illustrated as part of the document.
	<frame>	Defines a single frame within a frameset.
	<frameset>	Defines a collection of frames or other frameset.
	<iframe>	Displays a URL in an inline frame.
	<img>	Displays an inline image.
	<map>	Defines a client-side image-map.
	<noframes>	Defines an alternate content that displays in browsers that do not support frames.
	<object>	Defines an embedded object.
	<param>	Defines a parameter for an object or applet element.
	<source> 	Defines alternative media resources for the media elements like <audio> or <video>.
	<time> 	Represents a time and/or date.
	<video> 	Embeds video content in an HTML document.
}
Inventory hBase
Document final$
m=Paragraph(Help$, 0) 
If Forward(Help$,m) then {
      While m {
            a$=Paragraph$(Help$,(m))
            if a$<>"" then
                  \\ help pair to hBase
                  b$=rightpart$(a$, "<")
                  c$=trim$(filter$(rightpart$(b$,">"), chr$(9)))
                  b$=leftpart$(b$,">")
                  Append hBase,b$:=c$
                  \\ indentifiers for color syntax
                  b$=rightpart$(a$, "<")
                  b$=leftpart$(b$,">")
                  final$="|"+b$
            end if
      }
}
final$="|"
'Push	final$
Push hBase
end sub
}
MODULE EXPORTHELP {\\ prepare the groups of help database

Print "Greek or English Help File:(G/E)"
Select Case Ucase$(Key$)
case "G", "Γ"
      Gr=True : Print "Greek... Περίμενε"
case "E", "Ε"
      Gr=False : Print "English...Wait"
Else Case
      Break
End Select
Flush
if isnum or  not exist(appdir$+"HELP2000.mdb") then Error "No mdb (Access) help file found"
gosub dat
Read  myGroups
Dim No(1 to myGroups), name$(1 to myGroups)
for i=1 to myGroups
      Read No(i), name$(i)
      name$(i)=Replace$(chr$(160)," ", name$(i))
Next
 
Document GreekInfo$, EnglishInfo$, out$ 
\\ we have to read from application directory
Dir AppDir$

For i=1 To myGroups {

      EnglishInfo$=RightPart$(name$(i),", ")
      GreekInfo$= LeftPart$(name$(i),", ")
      if  GR Else Swap EnglishInfo$, GreekInfo$
      GreekInfo$={ - }+EnglishInfo$+{
      }
      Print GreekInfo$
      out$ =  If$(GR->"Ομάδα: ", "Group: ")
      out$ =  GreekInfo$ 'EnglishInfo$
      out$ = {
      }
      Retrieve "HELP2000", "SELECT * FROM COMMANDS WHERE GROUPNUM ="+Str$(No(i)),1,"",""
      Read mywords
                
      For j=1 To mywords  {
       If i=1 then
            Retrieve  "HELP2000", "SELECT * FROM COMMANDS WHERE GROUPNUM ="+Str$(No(i)) +" ORDER BY [ENGLISH]",j,"","" 
      Else
            Retrieve "HELP2000", "SELECT *FROM COMMANDS WHERE GROUPNUM ="+Str$(No(i))+If$(GR -> ""," ORDER BY [ENGLISH]"),j,"",""
      End if
      Drop ' no need this number - is equal to mywords
      Read GreekName$, HelpText$, EnglishName$, groupnumFrom
      if  GR Else Swap  GreekName$, EnglishName$
      if i>1 then
            out$ = If$(GR->"Αναγνωριστικό: ", "identifier:  ")
            out$ =  GreekName$ + "      ["+ EnglishName$+"]"
      else
            out$ =  "  *  "+Replace$(chr$(160)," ", GreekName$ + "      ["+ EnglishName$+"]")
      end if
      out$ =  {
      }
      if i>1 then
            out$ =  If$(Gr->LeftPart$(HelpText$,"__<ENG>__"), RightPart$(HelpText$,"__<ENG>__"))
            out$ =  {
            
            }
      end if
      }
      Clear GreekInfo$
      Clear EnglishInfo$  
   
}
done:
Print "DONE"
Flush
clipboard out$
dir user
if Gr then fname$="Γενικά.doc" else fname$="General.doc"
save.doc out$, fname$
win dir$+fname$   
end
dat:
Data 24
Data 22,"ΓΕΝΙΚΑ, GENERAL"
Data 14,"ΔΙΕΡΜΗΝΕΥΤΗΣ, INTERPRETER"
Data 15,"ΧΕΙΡΙΣΜΟΣ ΤΜΗΜΑΤΩΝ, MODULE COMMANDS"
Data 3,"ΡΟΗ ΠΡΟΓΡΑΜΜΑΤΟΣ, FLOW CONTROL"
Data 9,"ΕΝΤΟΛΕΣ ΣΩΡΟΥ, STACK COMMANDS"
Data 7,"ΟΡΙΣΜΟΙ, DEFINITIONS"
Data 25,"ΕΓΓΡΑΦΑ, DOCUMENTS"
Data 11,"ΧΕΙΡΙΣΜΟΣ ΑΡΧΕΙΩΝ, FILE OPERATIONS"
Data 8,"ΕΝΤΟΛΕΣ ΚΟΝΣΟΛΑΣ, CONSOLE COMMANDS"
Data 16,"ΟΘΟΝΗ ΚΑΙ ΑΡΧΕΙΑ, SCREEN AND FILES"
Data 24,"ΧΕΙΡΙΣΤΕΣ ΤΗΣ ΤΥΠΩΣΕ, OPERATORS IN PRINT"
Data 13,"ΣΤΟΧΟΙ ΚΑΙ ΕΠΙΛΟΓΗ, TARGET AND MENU"
Data 1,"ΓΡΑΦΙΚΑ 2Δ, DRAWING 2D"
Data 4,"ΕΝΤΟΛΕΣ ΕΙΚΟΝΩΝ, BITMAP COMMANDS"
Data 2,"ΒΑΣΕΙΣ ΔΕΔΟΜΕΝΩΝ, DATABASES"
Data 5,"ΗΧΟΙ ΚΑΙ ΤΑΙΝΙΕΣ, SOUNDS AND MOVIES"
Data 6,"ΕΝΤΟΛΕΣ ΔΕΙΚΤΗ, MOUSE COMMANDS"
Data 10,"ΕΝΤΟΛΕΣ ΙΣΤΟΥ, BROWSER COMMANDS"
Data 12,"ΚΟΙΝΕΣ ΦΟΡΜΕΣ, COMMON DIALOGUES"
Data 19,"ΑΡΙΘΜΗΤΙΚΑ, ARITHMETIC FUNCTIONS"
Data 20,"ΑΛΦΑΡΙΘΜΗΤΙΚΑ, STRING FUNCTIONS"
Data 21,"ΜΕΤΑΒΛΗΤΕΣ ΣΥΣΤΗΜΑΤΟΣ, VARS READ ONLY"
Data 23,"ΣΤΑΘΕΡΕΣ, CONSTANTS"
Data 17,"ΕΚΤΥΠΩΣΕΙΣ, PRINTINGS"
Print "Dat ok"
Return

}
MODULE EXPORTHELPNEW {
Print "Greek or English Help File:(G/E)"
Select Case Ucase$(Key$)
case "G", "Γ"
      Gr=True : Print "Greek... Περίμενε"
case "E", "Ε"
      Gr=False : Print "English...Wait"
Else Case
      Break
End Select
Flush
if isnum or  not exist(appdir$+"help2000utf8.dat") then Error "No help2000utf8.dat file found"


inventory GroupOrder=22,14,15,3,9,7,25,11,8,16,24,13,1,4,2,5,6,10,12,19,20,21,23,17
R=lambda GroupOrder (x)->{
	if exist(GroupOrder, x) then =eval(GroupOrder!)
}
Document aLL$, doc$
Load.doc aLL$, appdir$+"help2000utf8.dat"
A=Val(paragraph$(aLL$, 1))
B=Val(paragraph$(aLL$, 2+A))
dim Base 1, a$(B,4)
link a$() to a()

for i=1 to B
	a$(i,1)=mid$(leftpart$(paragraph$(aLL$,2+A+i+(3+GR)*B),"!"),2)
	a(i,2)=Val(rightpart$(paragraph$(aLL$,2+A+i+(3+GR)*B),"!"))
	a(i,3)=R(a(i,2))
	a(i,2)++
	a(i,4)=If(GR->i, Val(rightpart$(paragraph$(aLL$,2+A+i+3*B),"- ")))
next i
sort a(),1,B,3,0,1,0
m=0
deli$=","+chr$(160)
doc$="M2000 "+if$(GR->"Αρχείο Βοήθειας", "Help File")
grp=each(GroupOrder, 2)
doc$={
	
	}+if$(GR->"ΓΕΝΙΚΑ [GENERAL]", "GENERAL [ΓΕΝΙΚΑ]")+{
	
	}
while grp
	d$=paragraph$(aLL$, Eval(grp)+1)
	if len(d$)=0 then continue
	if GR else
		d$=piece$(d$,deli$,2)+deli$+piece$(d$,deli$,1)
	end if
	doc$=" * "+replace$(", "," [",replace$(chr$(160), " ",d$))+{]
	
	}
end while
For i=A to B
	print over
	print part i
	refresh 50
	if instr(a$(i,1),"_2")>0 then continue
	if a(i,2)<>m then
		c$={
		}+"***"+ Piece$(paragraph$(aLL$, a(i,2)), deli$)(GR+1)+{***
		
		}
		m=a(i,2)
	else
		c$={
		
		}
	end if
	f$=If$(instr(a$(i,1),"(")>0->")","")
	d$=paragraph$(aLL$,2+A+a(i,4)+B*(GR+1))
	c$+=If$(GR->"Αναγνωριστικό: ", "identifier:  ")+a$(i,1)+f$+"      ["+Mid$(leftpart$(d$, "\"),4)+f$+{]
	}+format$(mid$(d$,instr(d$,"\")))
	doc$=c$
next i
print
doc$={
}
FL$=IF$(GR->"GreekHelpFile.doc" , "EnglishHelpFile.doc")
Save.Doc doc$,FL$, 2
wait 200
Win Quote$(Dir$+FL$)
}
MODULE CHANGEHELP {
if not exist(appdir$+"HELP2000.mdb") then {
      Report {You have to place in appdir$ the HELP2000.mdb
            Also you may install Access2007 runtime
            After edit the help file, use Swicth "+mdb" to use mdb file for help
      }
      break
}
Base 0  \\ for arrays
Font "Arial"
menu fill 1,11,0
menu frame
DB.Provider ""  \\ reset
Window 12,0
Bold 1 : Form 70, 32
OldDir$=Dir$  \\ keep direcory
Dir AppDir$  \\ Use helpfile from application's Dir
Selection=1
Document HelpText$   \\ this is an object, = means append
{
      Here = 0
      Cls #ffd074,0
      Pen #3c1414 \\dark sienna
      Menu
      Retrieve "HELP2000","GROUP", 1,"",""
      Read Many, NoDummy, nnDummy$
      Dim No(Many+1)  'redim
      For i=1 To Many {
      Retrieve "HELP2000","GROUP", i,"",""
      Read Many, No(i), P$
      If Instr(P$,",")=0 Then {
            Menu + "Without Description Yet  No"+Str$(No(i))
      } Else {
            Menu + Mid$(P$, Instr(P$,",")+1)
      }
}
Print "Prepare the Help Database"
Print "Select Group:";
Menu Show Selection
Selection=Menu
If Menu>0 Then {
      GroupName$=Menu$(Menu)
      If left$(GroupName$,19)="Without Description" Then  {
            Menu "Change Description","Not Now"
            If Menu=1 Then {
            Retrieve "HELP2000","GROUP", Selection,"",""
            Read Many, No(Selection), P$
            GroupName$ =Field$(P$, 50)
            Field 0,Row+1,50 As GroupName$
            Return "HELP2000","GROUP" To Selection, ,GroupName$  
            Print
            If Instr(P$,",")=0 Then {
                        GroupName$ = "Without Description Yet  No"+Str$(No(Selection))
                  } Else {
                        GroupName$ =  Mid$(P$, Instr(P$,",")+1)
                  }
            }
      }
      Print GroupName$
      Retrieve "HELP2000", "SELECT * FROM COMMANDS WHERE GROUPNUM ="+Str$(No(Selection)),1,"",""
      Read Many
      Menu
      Print "Select identifier:";
      If Many>0 Then {
            Clear HelpText$
            Read GreekName$, HelpText$, EnglishName$, GroupNumFrom
            Menu + "<New>"
            View "HELP2000", "SELECT [ENGLISH] FROM COMMANDS WHERE GROUPNUM ="+Str$(No(Selection))+" ORDER BY [ENGLISH]",1,Many
            Sel2=Menu
            If Sel2>1 Then {
                  Print Menu$(Sel2)
                  Retrieve "HELP2000", "COMMANDS",1,"ENGLISH",Menu$(Sel2)
                  Cls #fdf5e8,3  \\ paper white
                  Pen #100c08  \\ smoky black
                  Read Many
                  If Many= 0 Then Exit
                  Clear HelpText$
                  Read GreekName$, HelpText$, EnglishName$, GroupNumFrom
                  Print "Greek:";GreekName$ 
                  Print "English:";EnglishName$
                  Report HelpText$
                  Menu
                  Print @(40);"Choose ";
                  Menu "Edit Description","Change Group","Pick another","End"
                  Cls #edca85,3
                  Pen #3c1414
                  If Menu=4 Then Exit
                  If Menu=3 Then Here = True : Exit
                  If Menu=2 Then {
                        ChangeGroup(EnglishName$)
                        Here = True
                  } Else {
                        Escape Off
                        Scroll Split Row
                        Cls #0077AA
                        Pen #66DD77
                        Edit.doc Code HelpText$
                        Return "HELP2000", "SELECT * FROM [COMMANDS] WHERE ENGLISH LIKE '"+EnglishName$ +"'", ,HelpText$
                        Escape On
                        Here=True  
                  }
            } Else.If Sel2=1 Then {
                  Print "New"
                  Escape off
                  Input "Greek:", GreekID$
                  Input "English:", EnglishID$                      
                  ''Input ! HelpText$, Width-1, Height-Row-2
                  Scroll Split Row
                  Clear HelpText$    ' we need a fresh one
                  Cls #0077AA
                  Pen #66DD77
                  Edit.doc Code HelpText$
                  Menu
                  Escape on
                  Print "Save it?"; : Menu "Yes","No"
                  If Menu =1 Then {
                        Append "HELP2000","COMMANDS",GreekID$, HelpText$, EnglishID$, No(Selection) 
                        Wait 100 
                  }
            Here =True
            }     
      } Else {
      ' If is empty delete group
            Delete "HELP2000","GROUP","GROUPNUM", No(Selection)
      }
}
If Here Then Loop
      Cls #ffd074,0
}
Print "Create General (Y/N) ?"
If Ucase$(Key$)="Y" Then CreateGeneral()
Dir OldDir$
Print "Compress (Y/N) ?"
If Ucase$(Key$)="Y" Then Compress()
End
Sub ChangeGroup(descr2match$)
      Stack New {
            Cls
            Menu
            Retrieve "HELP2000","GROUP", 1,"",""
            Read MANY, No, nn$
            For i=1 To MANY {
                  Retrieve "HELP2000","GROUP", i,"",""
                  Read MANY, No, P$
                  Print No, P$
            }
            Retrieve "HELP2000", "SELECT * FROM [COMMANDS] WHERE ENGLISH LIKE '"+descr2match$+"'",1,"",""
            
            If Not Empty Then {
                  Read MANY, GreekName$, HelpText$, EnglishName$, groupnumFrom
                  Print "ENGLISH:";EnglishName$
                  Print "No", groupnumFrom
                  Try ok {
                        Input "New No:", groupnumTo
                  }
                  If Not ok Then exit
                  If groupnumTo>0 Then {
                        return "HELP2000","SELECT * FROM [COMMANDS] WHERE ENGLISH = '"+EnglishName$+"'",,,,groupnumTo
                  }
            }
      }
End Sub
Sub Compress()
      Print Part $("#,###,###,###\ \B\y\t\e\s"),FILELEN(AppDir$+"help2000.mdb")
      Print Under
      Close Base Lcase$(AppDir$+"help2000.mdb")
      a$=Dir$
      Dir AppDir$
      compress AppDir$+"help2000.mdb"
      Dir a$
      Print PART $("#,###,###,###\ \B\y\t\e\s"),FILELEN(AppDir$+"help2000.mdb")
      Print 
      Dir User
End Sub
Sub CreateGeneral()
\\ this module exist only in until this sub exit
Module CreateGeneral {

\* For each group we get a field in General Group
\* Use module mg to create grouporder
\\ flush
Data 24
Data 22
Data 14
Data 15
Data 3
Data 9
Data 7
Data 25
Data 11
Data 8
Data 16
Data 24
Data 13
Data 1
Data 4
Data 2
Data 5
Data 6
Data 10
Data 12
Data 19
Data 20
Data 21
Data 23
Data 17
Data 24
Data 1,"ΓΡΑΦΙΚΑ 2Δ, DRAWING 2D"
Data 2,"ΒΑΣΕΙΣ ΔΕΔΟΜΕΝΩΝ, DATABASES"
Data 3,"ΡΟΗ ΠΡΟΓΡΑΜΜΑΤΟΣ, FLOW CONTROL"
Data 4,"ΕΝΤΟΛΕΣ ΕΙΚΟΝΩΝ, BITMAP COMMANDS"
Data 5,"ΗΧΟΙ ΚΑΙ ΤΑΙΝΙΕΣ, SOUNDS AND MOVIES"
Data 6,"ΕΝΤΟΛΕΣ ΔΕΙΚΤΗ, MOUSE COMMANDS"
Data 7,"ΟΡΙΣΜΟΙ, DEFINITIONS"
Data 8,"ΕΝΤΟΛΕΣ ΚΟΝΣΟΛΑΣ, CONSOLE COMMANDS"
Data 9,"ΕΝΤΟΛΕΣ ΣΩΡΟΥ, STACK COMMANDS"
Data 10,"ΕΝΤΟΛΕΣ ΙΣΤΟΥ, BROWSER COMMANDS"
Data 11,"ΧΕΙΡΙΣΜΟΣ ΑΡΧΕΙΩΝ, FILE OPERATIONS"
Data 12,"ΚΟΙΝΕΣ ΦΟΡΜΕΣ, COMMON DIALOGUES"
Data 13,"ΣΤΟΧΟΙ ΚΑΙ ΕΠΙΛΟΓΗ, TARGET AND MENU"
Data 14,"ΔΙΕΡΜΗΝΕΥΤΗΣ, INTERPRETER"
Data 15,"ΧΕΙΡΙΣΜΟΣ ΤΜΗΜΑΤΩΝ, MODULE COMMANDS"
Data 16,"ΟΘΟΝΗ ΚΑΙ ΑΡΧΕΙΑ, SCREEN AND FILES"
Data 17,"ΕΚΤΥΠΩΣΕΙΣ, PRINTINGS"
Data 19,"ΑΡΙΘΜΗΤΙΚΑ, ARITHMETIC FUNCTIONS"
Data 20,"ΑΛΦΑΡΙΘΜΗΤΙΚΑ, STRING FUNCTIONS"
Data 21,"ΜΕΤΑΒΛΗΤΕΣ ΣΥΣΤΗΜΑΤΟΣ, VARS READ ONLY"
Data 22,"ΓΕΝΙΚΑ, GENERAL"
Data 23,"ΣΤΑΘΕΡΕΣ, CONSTANTS"
Data 24,"ΧΕΙΡΙΣΤΕΣ ΤΗΣ ΤΥΠΩΣΕ, OPERATORS IN PRINT"
Data 25,"ΕΓΓΡΑΦΑ, DOCUMENTS"

            Read  myGroups
            Dim No(myGroups+1), Name$(myGroups+1) , PointTo(100)
            for i=1 to myGroups {
                  Read n
                  PointTo(n)=i
            }
           drop  ' a second 24 value
            
          for i=1 to myGroups {
                Read n
                No(PointTo(n))=n
                Read  name$(PointTo(n))           
            }  
Document GreekInfo$, EnglishInfo$, GroupInfo$, AllGreek$, AllEnglish$
Dir AppDir$
stp$=","+chrcode$(160)
Execute "HELP2000", "DELETE FROM COMMANDS WHERE GROUPNUM =22;"
\\ Retrieve "HELP2000","GROUP", 1,"",""
      For i=1 To myGroups {
           EnglishInfo$= RightPart$(name$(i),stp$)
           GreekInfo$= LeftPart$(name$(i),stp$)
           GreekInfo$={
           }
           EnglishInfo$={
           }
         
            Retrieve "HELP2000", "SELECT * FROM COMMANDS WHERE GROUPNUM ="+Str$(No(i)),1,"",""
            Read mywords
            If no(i)<>22 Then {
            For j=1 To mywords {
                  Retrieve  "HELP2000", "SELECT * FROM COMMANDS WHERE GROUPNUM ="+Str$(No(i))+" ORDER BY [ENGLISH]",j,"",""        
                  Read mywords
                  Read GreekName$, HelpText$, EnglishName$, groupnumFrom     
                  If mywords=j Then {EnglishInfo$= EnglishName$ } Else  EnglishInfo$= EnglishName$+", "
                  Retrieve  "HELP2000", "SELECT * FROM COMMANDS WHERE GROUPNUM ="+Str$(No(i))+" ORDER BY [DESCRIPTION]",j,"",""
                  Read mywords
                  Read GreekName$, HelpText$, EnglishName$, groupnumFrom     
                  If mywords=j Then {GreekInfo$= GreekName$} Else GreekInfo$= GreekName$+", "                
            }
         AllGreek$=GreekInfo$+{
         
         }
         AllEnglish$=EnglishInfo$+{
         
         }
         GroupInfo$=GreekInfo$+{
         __<ENG>__
         }+EnglishInfo$+{
         
         }
         \\  print LeftPart$(name$(i),stp$)    \\ Greek name of group
         print RightPart$(name$(i),stp$)
         Append "HELP2000",  "COMMANDS",  LeftPart$(name$(i),stp$),  GroupInfo$, RightPart$(name$(i),stp$), 22
         Clear GroupInfo$
         }
         Clear GreekInfo$
         Clear EnglishInfo$  
         
      }  
      AllGreek$={
      __<ENG>__
      } + AllEnglish$
         Append "HELP2000",  "COMMANDS",  "ΟΛΑ",  AllGreek$,"ALL", 22
         Help All
Print "DONE"
clear
Flush
Dir User

}
Stack New {
	CreateGeneral	
}

End Sub
}
MODULE MAKEHELP {
if not exist(appdir$+"HELP2000.mdb") then {
	Report {You have to place in appdir$ the HELP2000.mdb
		Also you may install Access2007 runtime
		After edit the help file, use Swicth "-mdb" to use dat file for help
		To use a new dat file you have to exit  m2000.exe, and start again, becaue the first time we use help with dat file interpreter load it.
		You can place the Help2000.mdb in USER file. Deletet appdir$+ before "HELP2000.mdb"
		Don't forget after edit this module to exit and press F1 to save info to USER directory
	}
	break
}
pen 14 : cls 5
flush
\\DIR APPDIR$ \\  from installation folder use this
Retrieve  APPDIR$+"HELP2000","GROUP", 1,"",""
Read many
Flush
Dim Labels$(1 to 25), ser(1 to many)
For i=1 to many
Retrieve  APPDIR$+"HELP2000","GROUP", i,"",""
drop
Read where, Labels$(where)
ser(i)=where
flush
next i
Retrieve  APPDIR$+"HELP2000", "SELECT * FROM COMMANDS",1,"",""
Read many
dim ALL(1 to many)
Document infoGr$, Info$, greek$, english$, no2lang$
br$={__<ENG>__
}
nl$=string$({
} as json )
p1=1
for i=1 to many
Retrieve APPDIR$+"HELP2000", "SELECT * FROM COMMANDS",i,"",""
drop
ALL(i)=Array([])
Print ALL(i)#val$(2), rightpart$(Labels$(ALL(i)#val(3)), ","+chr$(160))
Print ALL(i)#val$(0), leftpart$(Labels$(ALL(i)#val(3)), ","+chr$(160))
greek$="\"+ALL(i)#val$(0)+"!"+str$(ALL(i)#val(3),"")+{
}
english$="\"+ALL(i)#val$(2)+"!"+str$(ALL(i)#val(3),"")+"-"+Str$(i)
if i<many then
	english$={
	}
end if
if instr(ALL(i)#val$(1), br$)=0 then
infoone$="GR:"+ALL(i)#val$(0)+nl$+ALL(i)#val$(1)
info$=infoone$+{
}
infoone$="EN:"+ALL(i)#val$(2)+nl$+ALL(i)#val$(1)
infoGR$=infoone$+{
}
no2lang$=ALL(i)#val$(2)+{
}
else

infoone$="GR:"+ALL(i)#val$(0)+nl$+string$(rightpart$(ALL(i)#val$(1), br$) as json)
info$=infoone$+{
}
infoone$="EN:"+ALL(i)#val$(2)+nl$+string$(leftpart$(ALL(i)#val$(1), br$) as json)
infoGR$=infoone$+{
}
end if

next
Method english$, "SetLocaleCompare", 1033
Method english$, "SetBinaryCompare"
Sort english$
Dir User   \\ open this using Win Dir$
open "Help2000.dat" for wide output as #k
Print #k, Len(Labels$())
for i=1 to len(Labels$())
	Print #k, Labels$(i)
next i
Print #k, Many
Print #k, infoGr$;info$;greek$;english$
close #k
Print "No second language"
report no2lang$
clear
Document ALL$, all1$
Load.doc ALL$, "help2000.dat"
print filelen("help2000.dat")
save.doc all$,"help2000utf8.dat", 2   ' utf-8
print filelen("help2000utf8.dat")
Try {
	dir appdir$
	save.doc all$,"help2000utf8.dat", 2   ' utf-8
}
dir user
}
MODULE SNAKE {Αν Τοπικό=1032 ή Ελληνικά Τότε {
      Αν Ρώτα( "Κράτα πατημένο το διάστημα πριν τελειώσει το παιχνίδι για άμεσο τερματισμό","Παιχνίδι Φιδάκι","*Ξεκινάω","Όχι τώρα")<>1 τότε Διέκοψε
} Αλλιως {
      Αν Ρώτα( "Press Space to exit before the game end","snake game","*Start","Leave")<>1 τότε Διέκοψε
}
Διαφυγή Όχι
Δυαδικό {
      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
      CvwDsQToRRwHj3AAAAAASUVORK5CYII=
} Ως ΦιδάκιΕικόνα

\\ Φιδάκι!
Πένα 14
Ομαλά Ναι
Θέσε Γρήγορα !
\\Διαφυγή Όχι
Οθόνη,0
Καθαρό Α$
Κλάση Κ_5χ6 {
      μεταφορά$
      Ιδιότητα θ {Θέσε}
      Ιδιότητα Χ { 
            Αξία {
                  Ένωσε Γονικό [θ] στο θ
                  Αξία=(θ-1) υπολ 6
            }
            }
      Ιδιότητα Υ { 
            Αξία {
                  Ένωσε Γονικό [θ] στο θ
                  Αξία=(θ-1) Δια 6
            }
      }            

}
Κλάση Πιόνι {
      θέση_π, νο
      νέα_θέση
      Τμήμα Αφαίρεσε {
            .θέση_π<=0
      }
      Τμήμα Μετακίνηση {
            .θέση_π<=.νέα_θέση
            .νέα_θέση<=0
      }
}
Πάλι_εδώ:
Πίνακας Θέσεις(31)=Κ_5χ6(), Πιόνια(4)=Πιόνι(), ΣειράΝικητών(4)=0
Για ι=1 Έως 4 { Για Πιόνια(ι-1) {.θέση_π=1 : .νο=ι}}
Για ι=1 εως 30 {
      Αν ((ι-1) Υπολ 12)>5 Τότε { θέσεις(ι).θ=6*((ι-1) Δια 6)+(6-(ι-1) υπολ 6) } Αλλιώς θέσεις(ι).θ=ι
}
\\ φίδια!
Θέσεις(27).μεταφορά$="22,23,24,13,12,1"
Θέσεις(21).μεταφορά$="16,15,10,9"
Θέσεις(19).μεταφορά$="18,7"
Θέσεις(17).μεταφορά$="8,9,4"
\\ σκάλες
Θέσεις(3).μεταφορά$="10,15,22"
Θέσεις(5).μεταφορά$="8"
Θέσεις(11).μεταφορά$="14,23,26"
Θέσεις(20).μεταφορά$="29"

Γενικές χ,υ, θχ, θυ, Χρ(5)
Χρ(1)=14,11,13,12
Στοίχισε(ΦιδάκιΕικόνα, &χ,&υ,&θχ,&θυ)
Ανανεώση 5000
Φοντο 1,5
κ=υ/1200
Βάλε_Τίτλο("Snake Board Game - AutoPlay", 0, θυ*.8, 0)
Βάλε_Τίτλο("Dice", 0,θυ*.4, θυ, θχ)
ΠλαίσιοΠαικτών(0,θυ*.4, Θυ, θχ, κ)
Για ι=1 Έως 4 {
      ΠιόνιΣτοΠλαίσιο(0,θυ*.4,θυ, θχ, κ, ι)
}
Βάλε_Τίτλο("Final", θχ+χ,θυ*.4, θυ)
ΠλαίσιοΠαικτών(θχ+χ,θυ*.4,θυ,Χ.σημεία, κ)
Για ι=1 Έως 4 {
      ΠιόνιΣτοΠλαίσιο(θχ+χ,θυ*.4, θυ,Χ.σημεία, κ, ι)
}
θέση θχ, θυ
Εικόνα ΦιδάκιΕικόνα, χ
\\ το φιδάκι έχει 6 Χ 5 θέσεις
Κάνε ΜετΧ(χχ,κ)=(χ Δια 6)*χχ+(κ/30)*χ+χ/40+θχ
Κάνε ΜετΥ(υυ)=(υ Δια 5)*υυ+υ/20+θυ
Κράτησε
Οθόνη, -5
Δείξε_Όλα(-1,"")
ολα=1
Νικητές=0
Ενώ  ολα>0 και όχι πατημένο(32) {
      ολα=0
      Για ι=1 Έως 4 {
            Αν πιόνια(ι-1).θέση_π>0 Τότε {
                  ολα++
                  Ζάρι=Τυχαίος(1,6) ' για μεγάλο Ζάρι 1,10 !
                  Αν πιόνια(ι-1).θέση_π+Ζάρι >31 τότε {
                        ΠαίξεΜε(ι, Ζάρι, Αληθής, μορφή$("{0}",Ζάρι))
                  } Αλλιώς {
                        Για μ=1 Έως Ζάρι {
                              ΠαίξεΜε(ι, 1, ζαρι=μ, μορφή$("{0}",Ζάρι))
                        }     
                  }
            }
            Αν νικητές=4 Τότε Έξοδος
      }
}
Αν νικητές=4 Τότε {
      Για ι=1 Έως 4 {
            Αν πιόνια(ι-1).θέση_π>0 Τότε πιόνια(ι-1).θέση_π=0 : ΣειράΝικητών(ι-1)=4
      }
}
Δείξε_Όλα(-1,"")
Κύλιση Χώρισμα 0  ' όπως το Οθόνη,0 χωρίς να καθαρίσει την οθόνη!
Ανανέωση 25
Αν Τοπικό=1032 ή Ελληνικά Τότε {
      Αν Ρώτα( "Νέο Παιχνίδι","Παιχνίδι Φιδάκι","*Να Παίξω","Όχι τώρα")=1 τότε προς Πάλι_εδώ
} Αλλιως {
      Αν Ρώτα( "New Game","snake game","*Play","Not now")=1 τότε προς Πάλι_εδώ
}
Αν Τμημα(info) Τότε  Πληκτρολόγιο "info"+χαρ$(13)
Διαφυγή Ναι
Θέσε Γρήγορα
Τέλος
Ρουτίνα ΠαίξεΜε(Πιόνι, Ζάρι, τελικό, ζαρ$)
      Τοπική πιόνι1=-1, μεζάρι=Αληθής, πρ$, ι
      Σωρός Νέος {
            Για Πιόνια(Πιόνι-1) {
                        Αν μεζάρι Τότε {
                        Άν (Ζάρι+.θέση_π)<=30 Τότε { 
                                 .νέα_θέση=Ζάρι+.θέση_π 
                                 πιόνι1=Πιόνι
                                 Αν τελικό Τότε {
                                       πρ$=Θέσεις(.νέα_θέση).μεταφορά$
                                       Αν πρ$<>"" Τότε Σωρός πρ$
                                 }
                        } Αλλιώς.Άν (Ζάρι+.θέση_π)>31 τότε {
                              \\ Φιδάκι 2....επιστροφή!
                               .νέα_θέση= 61-Ζάρι-.θέση_π
                              πιόνι1=Πιόνι
                              Δες οκ {
                              Αν Ζάρι+.θέση_π>32 Τότε {
                                     πρ$=Θέσεις(.νέα_θέση).μεταφορά$
                                     Αν πρ$<>"" Τότε Σωρός πρ$
                                     Για ι=61-Ζάρι-.θέση_π  έως 29 {
                                          Βάλε ι 
                                     }
                               }
                              Αν .θεση_π<30 τότε {
                                    Για ι=30 έως .θέση_π+1 {
                                          Βάλε ι
                                    }
                              }      
                              }
                           Αν είναρ τότε  Διάβασε .νέα_θέση
                              αν όχι οκ τότε ανανέωση 50 : δοκιμη
                        } Αλλιώς .θέση_π=0 : νικητές++ : ΣειράΝικητών(Πιόνι-1)=νικητές
                  } Αλλιώς {
                          Διάβασε .νέα_θέση     
                  }   
            }
            Δείξε_Όλα(πιόνι1, ζαρ$) 
            μεζάρι=0
            Αν ΕινΑρ Τότε Κυκλικά
      }
Τέλος Ρουτίνας
Ρουτίνα Δείξε_Όλα(εκτός, λεζ$)
      Τοπική ι, κιν, εξ=Αληθής
      Για κιν=1 Έως 4 {
            Άφησε
            Για ι=0 Έως 3 {
                  Για Πιόνια(ι) {
                        Αν .θέση_π>0 Τότε {
                              Αν .νο<>εκτός Τότε {
                                    Για θέσεις(.θέση_π) {
                                          ΠιόνιΔείξε(..Χ,..Υ,.νο)
                                    } 
                              } Αλλιώς {
                                    ΠιόνιΚιν(Θέσεις(.θέση_π).Χ,Θέσεις(.θέση_π).Υ, Θέσεις(.νέα_θέση).Χ,Θέσεις(.νέα_θέση).Υ,κιν, .νο)
                                    εξ=Ψευδές
                                    Αν κιν=4 Τότε .μετακίνηση
                              }
                        }            
                  }
                  Αν ΣειράΝικητών(ι)>0 Τότε ΛεζάνταΣτοΠλαίσιο(θχ+χ,θυ*.4, θυ,Χ.σημεία, κ, ι+1, μορφή$("{0}",ΣειράΝικητών(ι)))
            }
            Αν εκτός>=0 Τότε {
                  ΛεζάνταΣτοΠλαίσιο(0, θυ*.4,θυ,θχ ,κ,εκτός, λεζ$)
            }
            Ανανέωση 5000
            Αν εξ Τότε Έξοδος
      }
Τέλος Ρουτίνας
Ρουτίνα Στοίχισε(εικόνα1, &χχ, &υυ, &μ_χ, &μ_υ)
      Τοπική αναλογία_εικόνας
      αναλογία_εικόνας=Εικόνα.Χ.Σημεία(εικόνα1)/Εικόνα.Υ.Σημεία(εικόνα1)
      χχ=Χ.σημεία*.7
      υυ=Υ.σημεία*.7
      Αν χχ>αναλογία_εικόνας*υυ Τότε {χχ=αναλογία_εικόνας*υυ} Αλλιώς υυ=χχ/αναλογία_εικόνας
      μ_χ=(Χ.σημεια-χχ) Δια 2
      μ_υ=(Υ.σημεια-υυ) Δια 2
Τέλος Ρουτίνας
Ρουτίνα ΠιόνιΔείξε(χ1, υ1, νο)
      Θέση ΜετΧ(χ1,νο-1),ΜετΥ(4-υ1)
      βήμα χ/120, υ*3/44
      Πάχος 3 { Πένα 0 { Κύκλος Γέμισμα Χρ(νο), υ*3/44,3 } }
Τέλος Ρουτίνας
Ρουτίνα ΠιόνιΚιν(χ1, υ1, χ2,υ2, κιν, νο)   
      Θέση ΜετΧ(χ1,νο-1)-κιν*(ΜετΧ(χ1,νο-1)-ΜετΧ(χ2,νο-1))/4,ΜετΥ(4-υ1)-κιν*(ΜετΥ(4-υ1)-ΜετΥ(4-υ2))/4
      βήμα χ/120, υ*3/44
      Πάχος 3 { Πένα 0 { Κύκλος Γέμισμα Χρ(νο), υ*3/44,3 } }
Τέλος Ρουτίνας
Ρουτίνα Βάλε_Τίτλο(τ$, χ1, μυ, υ2)
      Αν Ταύτιση("Α") Τότε { Διάβασε Τοπικά χ2 } Αλλιώς χ2=χ.σημειά
      Τοπική μ,μχ
      μ=μυ/30*ύψος.σημείου/15
      μχ=(χ2-χ1-Μέγεθος.χ(τ$, "Arial Black",μ)) Δια 2
      Αν μχ<0 Τότε  {
            μ=μεγαλο.σειράς(μ/2,6)
            μχ=(χ2-χ1-Μέγεθος.χ(τ$, "Arial Black",μ)) Δια 2
      }
      θέση μχ+χ1, υ2
      Επιγραφή τ$, "Arial Black",μ
Τέλος Ρουτίνας
Ρουτίνα ΠιόνιΣτοΠλαίσιο(χ1, μυ, υ2, χ2, ν, νο)
      Τοπική μ,μχ
      μχ=(χ2-χ1)/6
    Θέση χ1+μχ+χ/30, υ2+μυ+(υ-μυ*2)*(νο-.5)/4
    Πάχος 3 { Πένα 0 { Κύκλος Γέμισμα χρ(νο), υ*3/44,3 } }
Τέλος Ρουτίνας
Ρουτίνα ΛεζάνταΣτοΠλαίσιο(χ1, μυ, υ2, χ2, ν, νο, Λ$)
      Τοπική μ,μχ
      μχ=(χ2-χ1)/6
      Βάλε_Τίτλο(Λ$,χ1, μυ*2,υ2+(υ-μυ*2)*(νο-.5)/4, χ2) 
Τέλος Ρουτίνας
Ρουτίνα ΠλαίσιοΠαικτών(χ1, μυ, υ2, χ2, ν)
      Τοπική μ,μχ
      μχ=(χ2-χ1)/6
      Θέση χ1+μχ, υ2+μυ
      Πάχος 2 {
            Χρώμα 3 {
                  Βάψε μχ*4, υ-μυ*2
            }
      }
Τέλος Ρουτίνας

}
MODULE MAXITEM {Module TestThis {
      Print "Search a tuple type list (is an array also)"
      A=(,)
      For i=1 to Random(1,10)
      Append A, (Random(1,100),)
      Next
      Print Len(A)
      Print A
      Print A#max()
      
      Print "Search an array"
      B=lambda->Random(1,100)
      Rem Dim A(1 to Random(1,10))<<B()
      Dim A(1 to Random(1,10))<<lambda->{=Random(1,100)}()
      Print Len(A())
      Print A()
      Print A()#max()
      
      \\ #max() skip non numeric values
      Rem Print (1,"100",3)#max()=3
      
      Print "Search an inventory list"
      Inventory C
      for i=1 to Random(1,10)
            do
                  key=random(10000)
            until not exist(c, key)
            \\ we can put a number as string
            if random(1,2)=1 then Append c, key:=B() else Append c, key:=str$(B())
      Next
      
      \\ if inventory item is string with a number work fine
      Function MaxItem(a) {
            k=each(a,2)
            val=a(0!)
            while k
                  \\ using stack of values
                  \\ over -equal to over 1 - copy value from 1 to top, means double the top value
                  \\ number - pop top value
                  \\ drop -equal to drop 1 : drop top value 
                  Push a(k^!): Over : If Number>val then Read Val else drop
                  Rem If a(k^!)>Val Then Val=a(k^!)
            end while
            =val
      }
      Print Len(C)
      Print C
      Print MaxItem(C)
      
      Print "Search a stack object"
      \\ a stack object is the same as the stack of values
      \\ which always is present
      D=stack
      I=0
      J=Random(1,10)
      \\ Stack stackobjext {}
      \\ hide current stack and attach the D stack
      Stack D {
            Push B() : I++ : IF I>J Else Loop
      }
      \\ if stack item isn't numeric we get a run time error
      Function MaxItemStack(a) {
            Stack a {env$=envelope$()}
            if replace$("N","", env$)<>"" then error "only numbers allowed"
            k=each(a,2)
            val=Stackitem(a,1)
            while k
                  If Stackitem(k)>val then Val=stackitem(k)
            end while
            =val
      }
      Print Len(D)
      Print D
      Print MaxItemStack(D)     	
}
TestThis
}
MODULE INFO {keyboard "UseThis : InfoBasic"+chr$(13)
}
MODULE CLOCK1 {''keyboard " clock %ok=1 : clear :  info "+chr$(13)
Report{
	Wait for loading another m2000.exe which load info.gsb as modules
	Click on clock and press space to close it
	Hold mouse down at the center to move the clock
	Code written in GREEK Language
	Use ctrl+F1 for help (Greek and English lanugage)
	To see the code give here: edit clock
}
win appdir$+"m2000.exe", {load modules info.gsb: ok=1: clock: end}

}
MODULE USETHIS {hide
window mode, window
back {cls 11,0}
Font "Verdana"
Bold 1
PEN 14
CLS,0
If Version<9.9 then Error "No proper M2000 version (must be >=9.9)"
If Version=9.9 and revision<33 then Error "No proper M2000 revision for version 9.9"
Set Fast
Title "Info",1   ' open a window in task bar with name info (If  you run Demo, at the exit you get no window in task bar, so we can restore it)
dir user
Player 0  ' erase any layer

\\ Use form without ! for less border
\\ Form ! 100,66

}
MODULE DOWN4 {thread.plan concurrent 'sequential
module OpenHtml (filename$){
	\\ call m2000.exe and then load info without executing commands, and then execute htmleditor passing the filename
	\\ and last an End command to end the program
	win appdir$+"m2000.exe","{{load modules info : htmleditor {"+filename$+"}: end}}"
}
Declare form1 form
With form1, "visible" as visible
with form1, "Title", "Download Example"
layer form1 {
	window 12, 12000,6000
	cls #333333
	cursor 0,2
	report 2,"close form to exit download"
}
Method form1, "show"
cls,0
report 2, "Download 4 Files using Download object"
cls, 10
declare withevents d(3) download
w=0
m=row
Function d_Start(new con, host$,port) {
	cursor 0,m
	Print Part con, host$, port
	Print under
	m=row
	w++
}
Function d_DownloadProgress(new con, many, total) {
	cursor 0,3+con
	Print over $(4,10), con,  many;"/";total
	\\ do not use Refresh here
	cursor 0, m
	layer form1 {
		cursor 0,3+con
		Print over $(4,10), con,  many;"/";total		
	}
}
Function d_DownloadError(new con) {
	cursor 0,m
	Print "DownLoad Error"
	Print  con, number, letter$
	m=row
	layer form1 {
		cursor 0,3+con
		Print over $(4,10), con,  "failed"
	}
	w--
}
Function d_DownloadComplete(new who, a$) {
	cursor 0,3+who
	print over a$+" - complete"+str$(filelen(a$))
	layer form1 {
		cursor 0,3+who
		print over a$+" - complete	"
	}
	w--	
}
declare d() over   ' one more withevents - so now we have 4
\\ GetUrl$() function used if we wish the property url to connect on the fly, and disposed
\\ because object is naked (not in a mHandler carrier), can't used as value
\\ so we have to pass it by reference
\\ M2000 pass array items by reference using a second variable, which pass by reference
\\ and at the exit get the value from the variable and try to store it back to array to proper item
\\ no error happen if array has no item with specific item number
\\ this method is like copy in copy out
\\ VB6 lock arrays if we pass an array item by reference. M2000 never lock arrays.
Function GetUrl$(&where) {
	With where, "url" as url$
	=url$
}
Dim url$(4)
for i=0 to len(d())-1
	With d(i), "url" as url$(i)  \\ connect property url of d(i) to url$(i)
next i
Method d(0), "DownloadFile", "http://www.vbforums.com/showthread.php?818583-Binary-Code-Thunk-Experiment", dir$+"vbforums.html"
Method d(2), "DownloadFile", "http://www.cs.virginia.edu/~evans/cs216/guides/x86.html", dir$+"x86.html"
Method d(1), "DownloadFile","http://rosettacode.org/wiki/Rosetta_Code", dir$+"rossetacode.html"
Method d(3), "DownloadFile","http://georgekarras.blogspot.gr", dir$+"m2000.html"
cursor 0, m

for i=0 to len(d())-1
	Print Part "Read Property Url for"+str$(i)+":";~(11); url$(i)  ' GetUrl$(&d(i)) 
	Print Under
Next
Print "press left mouse to exit"
refresh
m=row
cls,m
kk=0
\\ we use a block in thread so concurrent not happen for each statement in thread but all statements in block executed in once
thread {
{
	cursor 0, m
	print kk
	kk++
	m=row

}
} as mm interval 10
While w
	cursor 0,2
	print over $(4),"live connections:";w, visible
	if keypress(2)  or not visible then exit
	bb$=inkey$
	\\ wait 0
	\\ threads need a wait or a Key$, or Inkey$ or a Main.Task or a Every, or a Modal form to be opend.
	\\ com events no need this.
End While
threads erase
wait 100
cursor 0,2
print over $(4),"live connections:";w
cursor 0,m
If exist("vbforums.html") then Print "vbforums.html - ";Filelen("vbforums.html")
If exist("rossetacode.html") then Print "rossetacode.html - ";Filelen("rossetacode.html")
If exist("x86.html") then Print "x86.html - ";Filelen("x86.html")
If exist("m2000.html") then Print "m2000.html - ";Filelen("m2000.html")
print "done"
declare d() nothing
declare form1 nothing
if exist("m2000.html") then
	if filelen("m2000.html")>0 then
		ok=false
		if Ask("Open m2000.html in htmlEdtitor, as other process?")=1 then ok=true 
		if Ask("Open m2000.html in console text editor?")=1 then
			if ok then After 500 {openhtml "m2000.html"}: Mes()
			Edit "m2000.html", 1
		else
			if ok then After 50 {openhtml "m2000.html"}: Mes()
		end if
		
	end if
end if
Sub Mes()
	Print "wait and then use ctrl+tab (or maybe not use it) to get the htmleditor window"
	Wait 100
End Sub
}
MODULE CHESSGAME {\\ George Karras, 2019
\\ Chess Example (a big one)
\\ Example Using sprites
\\ Rev. 4
chessfont$="Arial Unicode MS"
Font chessfont$
if not Fontname$="Arial Unicode MS" then
	chessfont$="DejaVu Sans"
end if
Font "Verdana"
Thread.plan sequential
Set Fast
Hide
window 12, window
if random(1, 3)=1 then
window 12, scale.x*random(6,9)/10,scale.y*random(6,9)/10;
end if
form 48,34
def thismode
thismode=mode
global const  NoSound = False
Module NothingToMove {
	Layer {Print $(4)," Nothing to move",$(0);}
}
Module Proper {
	Layer {Print $(4)," Wrong color",$(0);}
}
Module Beep {
	Layer {Print $(4)," Not Possible",$(0);}
	if NoSound Else Beep
}
back {
	\\ we use a switch to alter the return code in Input ! variant, when we press Enter key
	\\ normally "-inp" return in Field  read only variable 1 when we press enter or down arrow
	\\ using "+inp" we can get 13 for enter and 1 for down arrow
	Cls 0,0
	font "Times"
	Pen 15
	Mode thismode*5
	cursor 0,height div 2
	Report 2, "Wait...."
	refresh 10000	
	Mode thismode

	set switches "+inp"
	Fkey Clear
	Escape off
	Cls #FFA000,0
	Pen 14
	bold 1
	mode thismode
	Def White$="PNBRQK", Black$="pnbrqk", WhiteDisp$="♙♘♗♖♕♔"
	Def BlackDisp$="♟♞♝♜♛♚", empty$="12345678", disp$
	disp$=WhiteDisp$+BlackDisp$ 
	Def White_♔_file, White_♔_rank, Black_♚_rank, Black_♚_file
	Def boolean White_♔_no_roke, Black_♚_no_roke
	Def boolean White_no_left_roke, Black_no_left_roke
	Def boolean White_no_right_roke, Black_no_right_roke
	Def Halfmove_clock, Fullmove_number, threat, Clip$
	Dim emptydisp$(1 to 8), BoardSq(1 to 8, 1 to 8)=(,)
	Def en_passant_rank=0, en_passant_file=0
	for i=1 to 8 :emptydisp$(i)=string$(" ",i):next i
	Def board$, status$, oldI, color1, color2, C=14
	color1=Color(209, 139, 71)
	color2=Color(255, 206,158)
	
	dim line$()
	Def flashtime=300
	Dim PastGames$(1 to 200)
	Def freeSlot=0, cur=0, ok=true, k$, condition$
	Def double ip, jp, ip1, jp1, si, sj, getone as boolean
	Def st, fig$, tr, mx, my, lx,ly, key=0, mmx,mmy, mmb
	Def movelogic as boolean=false, mvx, mvy
	sa=(,) : sb=each(sa)
	Double
	OldI=Italic
	Italic 1
	Def upperlimit
	Cursor 0,0
	Pen 15 {Report 2, "Chess Game for two"}
	Italic OldI
	Normal
	Move !      ' Move graphic cursor to character cursor  - Cursor !  the other way
	upperlimit=pos.y*1.6
	move 0, upperlimit*6/8
	Fill scale.x,scale.y-upperlimit*6/8, 3,5,1
	Set Fast !
	\\ calc based to height
	HalfWidth=(scale.y*.65) div 16
	def downlimit=0, White as boolean=True, fw
	DrawEmptyBoard((scale.x/2-HalfWidth*8),upperlimit, HalfWidth, 15)
	fw=HalfWidth*2-60
	\\ hold
	\\ set new game
	\\ -1 for no FEN
	def NoFEN(aGame$)=len(aGame$)<>len(filter$(aGame$,"/"))+7
	Inventory OnBoard
	Const NewGame$="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"
	Def ThisGame$
	\\ CHECK IF A STRING IS IN STACK (SO THIS MAYBE A FEN NOTATION FOR A STARTING POSITION)
	if match("S") then
		For this {
			\\block for temporary definitions
			Local row$(),  i, nok, m
			Read ThisGame$
			row$()=piece$(ThisGame$, chr$(13)+chr$(10))
			\\ we drop lines by redim the array (dim also is a "dim preserve")
			while  len(row$())>1
				if row$(len(row$())-1)="" then dim row$(len(row$())-1) else exit
			end while
			if len(row$())>0  then
				m=each(row$())
				while m
					if NoFEN(array$(m)) Then nok=true: exit
				end while
			End if
			if nok then Push ThisGame$ : ThisGame$=NewGame$ : exit
			PastGames$()=row$()
			Dim PastGames$(1 to 200)
			freeSlot=len(row$())
			ThisGame$=PastGames$(freeSlot)
		}
	else
		ThisGame$=NewGame$
	End if
	
	SetBoard(ThisGame$)
	RedrawBoard(True)
	sx=scale.x
	sy=scale.y-downlimit
	move 0,downlimit
	fill  sx,sy, 5
	Layer {
		font "Verdanal"
		mode thismode, sx,sy
		motion center
		motion, downlimit
		Cls 5,0
		Pen 14
	}
	Refresh 60
	flush
	move$=""
	refresh
	\\ ctrl+F1 help
	About  ! "How to play", 14000,9000,{Give one or more moves in one input line.
		Each move has a letter a number a letter and  final a number
		so:
					e2e4   or  e2-e4  or e2..e4
					(symbols other than aebcdefgh and 123456789 are white space)
		move something from e2 to e4, but this
					e2e3e7e5
		give two moves (so we can paste a number of moves)
		before a move a new FEN string compiled and copied to clipboard.
		if nothing exist in e2 then we get a beep sound. If a move break a rule then no move happen and we get a beep. If King have a threat then we have to do a proper move to eliminate threat otherwise we get a beep.
		We can press enter without giving a move, so we asked for ending the game or not.
		If we press Y then a new input start to get a FEN board notation, so we can use ctrl+V to paste the string and pressing enter we get the new boad.
		* Castling work automatic. So if rules are ok wen can give a e1c1 for queen side castling for white king.
		* En passant works fine
		* A pawn at last rank turn to Queen
		You can call this module passing a FEN string as parameter.
		George Karras
		}
	Thread {
		if control$<>"MAIN" then continue
		mmb=mouse
		If mmb=0 then continue
		mmy=mouse.y : mmx=mouse.x
		if mmy>downlimit  then
			if  mmx<scale.x*.8 then
				if mmb=2  then Field New 99 : Input End
			else
				if mmb=1 then Input End
			end if
		else.if mmy<downlimit  and mmy>upperlimit then
			Field New if(mmy>((downlimit+upperlimit)/2)->1,-1)
			Input End
		end if
		
	} as Handler interval 100
	Thread Handler Hold
	Thread {
		if control$<>"MAIN" then continue
	
		if getone then
		move lx, ly
		Refresh 100
		sprite sprite$
		mx=mouse.x : my=mouse.y :mmb=mouse
		sb=each(BoardSq())
		
		St=(,)
		While sb
		sa=array(sb)
		if sa#val(3)-twipsX<=mx and sa#val(5)+twipsX>=mx and sa#val(4)-twipsY<=my and sa#val(6)+twipsY>=my then St=sa : exit
		End While
		if len(st)>0 then
			si=st#val(10) : sj=st#val(11)
			if mmb=0 then
				keyboard chr$(ip+96)+chr$(jp+48)+chr$(si+96)+chr$(sj+48)+chr$(13)
				getone=false:  refresh 100 : mouse.icon show
			else
				lx=mx : ly=my
				move lx, ly
				if st#val$(8)=" " or  (si=ip and sj=jp) then
					sprite fig$, tr
				else
					sprite fig$, tr,-10,,80
				end if
				refresh 100
			end if
		else.if mmb=0 then
			RedrawBoard(?)
			getone=false
			mouse.icon show
			Thread Sp restart
		end if
		if not getone  then Thread this hold
	} as pSp interval 1000/30
	Thread pSp hold
	Thread {
		if control$<>"MAIN" then continue
		if mouse=0 and movelogic then movelogic=false 
		if mouse.y<upperlimit then mouse.icon 15 else mouse.icon 1
		
		if not movelogic then if mouse.y<upperlimit and mouse=1 then  movelogic=true: mvx=mousea.x : mvy=mousea.y:continue
		if movelogic then if  mouse=1 then motion  motion.wx- mvx+mousea.x, motion.wy-mvy+mousea.y : continue
		
		mx=mouse.x : my=mouse.y
		if mouse=1 and my>downlimit then input end : Thread this hold
		if mouse=1 and not getone then{
		move mx, my
		if point=0 or point=#FFFFFF else exit
		sb=each(OnBoard)
		
		St=(,)
		While sb
		sa=eval(sb)
		if sa#val(3)<mx and sa#val(5)>mx and sa#val(4)<my and sa#val(6)>my then St=sa : exit
		End While
		if len(st)=0 then exit
		move st#val(3)+30, st#val(4)+30
		refresh 1000
		tr=point
		copy fw,fw to fig$
		Image fig$ to fig$,120,120
		fill fw,fw, tr
		move mx, my
		lx=mx:ly=my
		ip=st#val(10):jp=st#val(11)
		sprite fig$, tr
		mouse.icon hide
		getone=true
		Thread pSp restart
		Thread this hold
		}
	} as Sp interval 100
	mouse.icon show
	isok=true
	{
	
		{
			if white then		
				CheckThreat(white, White_♔_file, White_♔_rank, &threat)
			else
				CheckThreat(white, Black_♚_file, Black_♚_rank, &threat)
			end if
			if isok  then
				freeSlot++
				GetBoard(&Clip$)
				if freeSlot>Len(PastGames$()) then Dim PastGame$(1 to 2*Len(PastGames$()))
				PastGames$(freeSlot)=Clip$
			end if
			\\\test
			condition$=if$(White->"White move", "Black move") + if$(threat->" (check)","")+ if$(Halfmove_clock>50->"(You can draw)","")+":"
			Layer {
				Print Part $(4,5), right$(string$(chrcode$(8199), 3)+str$(Fullmove_number,""),3)+".", $(7,12),condition$,
			}

			White~
			if empty then
			Layer {
				Pen 15 {Input "",move$;}
			}
			\\\test !			
			Thread Sp hold
			Thread pSp Hold
			mouse.icon 1
			getone=false
			if move$="" then
				
				Layer {
					wait 100
					Refresh 60
					profiler
					Every 1000/60 {
						if timecount>flashtime then
							profiler
							Cls
							Pen C {Double : Report 2,"End this Game ?" : Normal}
							C=20-C
							Cursor width, Height
							Move !   \\ copy character cursor to graphic cursor
							Legend "Use Y or Left Mouse Click  to exit | Right Mouse Click or N to continue", FontName$, Mode*.7, 0,1, 1,twipsX
						end if
						k$=""
						if keypress(0x1B) then k$="Y":exit
						if keypress(0x4E) then exit
						if keypress(0x59) then  k$="Y":exit
						if keypress(1) then k$="Y": exit
						if keypress(2) then exit
						
					}
				}
				while not inkey$ ="" {Wait 1}  'drop key any
				If k$="Y" else
					\\ if stack has something then RedrawBoard mey use it (because read for optional variable)
					\\ we can be sure we set the optional value using ?
					White~ :RedrawBoard(?): Layer {Cls}
					getone=false
					Thread Sp restart
					flush ' make empty true (so stack is empty for sure)
					loop  ' set a flag for restart at end bracket of current block
				end if
			else
				move$=lcase$(move$)
				while len(move$)>0
					select case left$(move$,1)
					case "1" to "8"
						data asc(move$)-48
					case "a" to "h"
						data asc(move$)-96
					end select
					insert 1,1 move$=""
				end while
			end if
			isok=false
			if not empty then
				if stack.size mod 4 = 0 then
					try ok {
						MakeAmove(&isok)
						if not isok then flush : White~: exit
						if not empty then
						white~: refresh : wait 500 : loop
						end if
					}
					Layer {Print}
					getone=false
					if isok else RedrawBoard(?)
					
					if ok then loop : Thread Sp restart
				else
				
					flush : White~ : loop  : Thread Sp restart' loop processed at the end of the block, so only a flag raised here
				end if
			end if
		}
		Thread Sp Hold
		Thread pSp Hold
		cur=freeSlot
		Clip$=PastGames$(cur)
		Layer {
			if cur=0 then cur=1
			if cur>freeSlot then cur=freeSlot 
			if  Clip$<>PastGames$(cur) then
			Clip$=PastGames$(cur)
			if len(Clip$)=len(filter$(Clip$,"/"))+7  and  trim$(Clip$)<>"" then Back {SetBoard(Clip$) :RedrawBoard(?)}
			end if
			Refresh  60
			Cls
			Cursor width, Height
			Move !
			Legend "Right Mouse Click or Esc to Quit | Left Mouse Click right of the FEN to continue play | About Ctrl+F1", FontName$, Mode*.7, 0,1, 1,twipsX
			Cursor 0,0
			Report 2, "Replay the Game,(arrows u/d) or Start a new one setting a new FEN"
			Print Part $(7,7), "Board FEN: "
			Field New 13
			Thread Handler Restart
			Pen 15 {Input ! Clip$, width-7 len=100}
			Thread Handler Hold
			Report Clip$
			refresh 60
			if field=13 then exit
			if field=-1then cur-- : loop
			if field=99 then Clip$="": exit
			if field=1 then cur++ : loop
		}
		if len(Clip$)<>len(filter$(Clip$,"/"))+7  or  trim$(Clip$)="" then SaveGame():Layer {Cls} : exit
		if Clip$<>PastGames$(cur) then
			SaveGame()
			PastGames$(1)=Clip$:cur=1
		end if
		freeSlot=cur
		SetBoard(Clip$)
		RedrawBoard(?)
		Layer {Cls}
		Thread Sp restart
		Loop
	}
	Cls 0,0	
}
hide
threads erase
wait 200
about ""
if module(info) then keyboard "info"+chr$(13)
Flush
set switches "-inp"
escape off
Window 12,0
form
form ;
About ! ""
end
Sub SaveGame()
if freeSlot=1 then exit sub
Local Out$
Document Out$     ' upgrade to Document
layer {
	Cls
	if ask("Copy the game to clipboard?","Finish","*Yes","No")=1  then
		Report "Wait..."
		for i=1 to freeSlot
			Out$+=PastGames$(i)
			if i<freeSlot then
			Out$={
			}
			end if
		next
		Clipboard Out$
		Save.Doc Out$, "LastGame.chess"
		Report "Done..."
		wait 300
	end if	
}
end sub
Sub SaveGame1()
local Out$, i
Document Out$  ' upgrate to document
layer {
}
End Sub
Sub DrawEmptyBoard(leftmargin, topmargin, squarewidth, labelcolor)
	Local a=true, z=bold : bold 0
	Local l=squarewidth, k=2*l, k1=k*.85, N1=6, N=6, M=4, B=k*8, B1
	Local d=0, im=0, jm=0
	Repeat
	N=N1
	N1+=.25
	Until K1<size.Y("A",chessfont$, N1)
	topmargin-=l
	leftmargin-=l
	move leftmargin+l,topmargin+l
	B1=(l div 300)*twipsX
	step -B1,-B1
	B+=B1*2
	Pen 0 {
	Width b1 div 2+1 {
		color color1 , 1{Polygon 0, B, 0, 0, B, -B, 0, 0, -B}
	}
	M=N*.65
	For i=1 to 9
		d=leftmargin
		move d, topmargin
		if i<9 then
			step 0, k
			Pen labelcolor{Legend str$(9-i,""), chessfont$, M,0,2}
			step 0, -k
			else
			N=M
		end if
		for j=1 to 8
			If i<9 then
				step l, l
				color  color1,1 {fill k,k, if(a->color1,color2)}
				step  -l, -l
				BoardSq(j, 9-i)=(N, pos.x, pos.y, pos.x-l+twipsX, pos.y-l+twipsX, pos.x+l-twipsX, pos.y+l-twipsX, k-twipsX*2, " ", a, j,9-i)
				a~
			else
				step k, k
				pen labelcolor {
					Legend mid$("abcdefgh",j,1), chessfont$, N, 0, 2
				}
			end If
			d+=k
			move d, topmargin
		next
		a~ : topmargin+=k
	next
	}
	bold z
	downlimit=topmargin+500
end sub
Sub MakeAmove( &ok, i, j, i1, j1)
Local z=bold, p$, p1$ : bold 0
Local t,t1, N=BoardSq(1,1)#val(0), again as boolean, playroke as boolean
ok=false
Local rule=true, threat as boolean
refresh 10000
Pen 0 {
	again=false
	t=BoardSq(i,j)
	t1=BoardSq(i1, j1)
	p$=t#val$(8)
	p1$=t1#val$(8)
	if p$=" " then NothingToMove : exit
	if t is t1 then NothingToMove : exit
	if p1$<>" " then if p1$<"♚" and p$<"♚" then Proper : exit
	if p1$<>" " then if p1$>="♚" and p$>="♚" then Proper : exit
	\\ white change logic here
	if not white and instr(WhiteDisp$, p$)=0 then Proper : exit
	if white and instr(BlackDisp$, p$)=0 then Proper :exit
	select case p$
	case "♔"
	{
		If not White_♔_no_roke  then
			CheckThreat(not white, White_♔_file, White_♔_rank, &threat)
			if not threat then
				if i1=3 and j1=1  then
					if p1$=" " and BoardSq(2,1)#val$(8)=" " and  BoardSq(4,1)#val$(8)=" " and not White_no_left_roke then
						CheckThreat(not white, 4, 1, &threat)
						if not threat then push 1, 4, 1, 1 : again=true : playroke=true
					end if
				else.if i1=7 and j1=1 then
					if p1$=" " and BoardSq(6,1)#val$(8)=" " and not White_no_right_roke then
						CheckThreat(not white, 6, 1, &threat)
						if not threat then push 1, 6, 1, 8 : again=true :  playroke=true
					end if
				end if
			end if
		end if
		if not playroke Then
			if abs(i-i1)>1 then rule=false: exit
			if abs(j-j1)>1 then rule=false: exit
			White_♔_no_roke=true
			White_no_right_roke=True
			White_no_left_roke=true
		end if
		CheckKing()
		if threat then
			rule=false
			if playroke then drop 4
		else
			White_♔_rank=j1
			White_♔_file=i1
		end if
	}
	case "♚"
	{
		If not Black_♚_no_roke  then
			CheckThreat(not white, Black_♚_file, Black_♚_rank, &threat)
			if not threat then
				if i1=3 and j1=8 then
					if p1$=" " and BoardSq(2,8)#val$(8)=" " and  BoardSq(4,8)#val$(8)=" " and not Black_no_left_roke then
						CheckThreat(not white, 4, 8, &threat)
						if not threat then push 8, 4, 8, 1 : again=true : playroke=true
					end if
				else.if i1=7 and j1=8 then
					if p1$=" " and BoardSq(6,8)#val$(8)=" " and not Black_no_right_roke then
						CheckThreat(not white, 6, 8, &threat)
						if not threat then push 8, 6, 8, 8 : again=true :  playroke=true
					end if
				end if
			end if
		end if
		if not playroke Then
			if abs(i-i1)>1 then rule=false: exit
			if abs(j-j1)>1 then rule=false: exit
			Black_♚_no_roke=true
			Black_no_right_roke=true
			Black_no_left_roke=true
		end if
		CheckKing()
		if threat then
			rule=false
			if playroke then drop 4
		else
			Black_♚_rank=j1
			Black_♚_file=i1
		end if
		}
	case "♕","♛"
	{
		if i1<>i and j1<>j then
			if abs(i1-i)<>abs(j1-j) then rule=false: exit
			jm=0
			if abs(i1-i)>1 then
				jm=j+sgn(j1-j)
				for im=i+sgn(i1-i) to i1-sgn(i1-i)
				if BoardSq(im,jm)#val$(8)<>" "  then jm=-1: exit for
				jm+=sgn(j1-j)
			next
			end if
		else
		jm=0:im=0
		if abs(i1-i)>1 then
			for im=i+sgn(i1-i) to i1-sgn(i1-i) 
				if BoardSq(im,j)#val$(8)<>" " then jm=-1: exit for
			next
		else.if abs(j1-j)>1 then
			for jm=j+sgn(j1-j) to j1-sgn(j1-j) 
				if BoardSq(i,jm)#val$(8)<>" " then im=-1 :exit for
			next
		end if
		if im=-1 or jm=-1 then rule=false:exit
		end if
		CheckIt()
	}
	case "♜"
	{
		If playroke then Black_no_right_roke=true : Black_no_left_roke=true : Black_♚_no_roke=True : exit
		if i1<>i and j1<>j then rule=false: exit
		jm=0:im=0
		if abs(i1-i)>1 then
			for im=i+sgn(i1-i) to i1-sgn(i1-i) 
				if BoardSq(im,j)#val$(8)<>" " then jm=-1: exit for
			next
		else.if abs(j1-j)>1 then
			for jm=j+sgn(j1-j) to j1-sgn(j1-j) 
				if BoardSq(i,jm)#val$(8)<>" " then im=-1 :exit for
			next
		end if
		if im=-1 or jm=-1 then rule=false:exit
		CheckIt()
		if not rule then exit
		if i=1 and j=8 then Black_no_left_roke=true
		if i=8 and j=8 then Black_no_right_roke=true
	}
	case "♖"
	{
		If playroke then White_no_right_roke=true : White_no_left_roke=true : White_♔_no_roke=True : exit
		if i1<>i and j1<>j then rule=false: exit
		jm=0:im=0
		if abs(i1-i)>1 then
			for im=i+sgn(i1-i) to i1-sgn(i1-i) 
				if BoardSq(im,j)#val$(8)<>" " then jm=-1: exit for
			next
		else.if abs(j1-j)>1 then
			for jm=j+sgn(j1-j) to j1-sgn(j1-j) 
				if BoardSq(i,jm)#val$(8)<>" " then im=-1 :exit for
			next
		end if
		if im=-1 or jm=-1 then rule=false:exit
		CheckIt()
		if not rule then exit
		if i=1 and j=1 then White_no_left_roke=true
		if i=8 and j=1 then White_no_right_roke=true
	}
	case "♗","♝"
	{
		if i1=i or j1=j then rule=false: exit
		if abs(i1-i)<>abs(j1-j) then rule=false: exit
		jm=0
		if abs(i1-i)>1 then
			jm=j+sgn(j1-j)
			for im=i+sgn(i1-i) to i1-sgn(i1-i)
				if BoardSq(im,jm)#val$(8)<>" "  then jm=-1: exit for
				jm+=sgn(j1-j)
			next
		end if
		if jm=-1 then rule=false:exit
		Checkit()
      	}
	case "♘","♞"
	{
		if abs(i1-i)=abs(j1-j) then rule=false: exit
		if abs(i1-i)=0 or abs(j1-j)=0 then rule=false: exit
		if abs(i1-i)+abs(j1-j)<>3 then rule=false: exit
		Checkit()
	}
	case "♙"
	{
		if j1<=j then rule=false:exit
		if i<>i1 then if i1<i-1 or i1>i+1 then rule=false: exit
		if j>2 then if j1>j+1 then rule=false:exit
		if j=2 and j1>j+2 then rule=false:exit
		if i=i1 and p1$<>" " then rule=false:exit
		if i<>i1 and p1$=" "and not (en_passant_file=i1 and en_passant_rank=j1-1)  then rule=false:exit
		if i<>i1 and j1>j+1 then rule=false exit
		if en_passant_file=i1 and en_passant_rank=j1-1 then
			Checkit2()
		else
			Checkit()
		End if
		en_passant_file=0
		en_passant_rank=0
		if j1=8 then p$="♕" else if j1=j+2 then en_passant_file=i1:en_passant_rank=j1
	}
	case "♟"
	{
		if j1>=j then rule=false:exit
		if i<>i1 then if i1<i-1 or i1>i+1 then rule=false: exit
		if j<7 then if j1<j-1 then rule=false:exit
		if j=7 and j1<j-2 then rule=false:exit
		if i=i1 and p1$<>" " then rule=false:exit
		if i<>i1 and p1$=" " and not (en_passant_file=i1 and en_passant_rank=j1+1) then rule=false:exit
		if i<>i1 and j1<j-1 then rule=false:exit
		if en_passant_file=i1 and en_passant_rank=j1+1 then
			Checkit2()
		else
			Checkit()
		End if
		en_passant_file=0
		en_passant_rank=0
		if j1=1 then p$="♛" else if j1=j-2 then en_passant_file=i1:en_passant_rank=j1
	}
	end select
	If not rule then beep : exit
	move t#val(3), t#val(4)
	return t, 8:=" "
	delete OnBoard, i*9+j
	if t#val(9) then fill t#val(7), t#val(7),color1 else fill t#val(7), t#val(7), color2
	
	t=t1
	move t#val(3), t#val(4)
	fill t#val(7), t#val(7),15
	if p1$<>" " then
		Halfmove_clock=0
		Return OnBoard, i1*9+j1:=t
	else
		Halfmove_clock++
		Append OnBoard, i1*9+j1:=t
	end if
	return t, 8:=p$
	move t#val(1), t#val(2): Legend p$, chessfont$, N, 0, 2,0
	move t#val(3)+twipsx*2, t#val(4)+twipsy*2
	if t#val(9) then floodfill  ,,color1 else floodfill , , color2
	if again then read  i, j, i1, j1 : Restart
	if p$<>"♙" and p$<>"♟" then en_passant_file=0 : en_passant_rank=0
	if white then Fullmove_number++
	Ok=true	
}
bold z
refresh 10000
end Sub

Sub RedrawBoard(NoRefresh as boolean=False)
Local z=bold, p$ : bold 0
Local t, N=BoardSq(1,1)#val(0)
If NoRefresh Else refresh 10000
Pen 0 {
	For j=1 to 8
		For i=1 to 8
			t=BoardSq(i,j)
			move t#val(3), t#val(4)
			fill t#val(7), t#val(7),15
			p$=t#val$(8)
			
			if p$=" " else move t#val(1), t#val(2): Legend p$, chessfont$, N, 0, 2,0
			move t#val(3)+twipsx*2, t#val(4)+twipsy*2	
			if t#val(9) then floodfill  ,,color1 else floodfill , , color2
		Next
	Next
}
bold z
If NoRefresh Else refresh 60
end Sub
Sub GetBoard(&chessboard$)
chessboard$=""
local i, j,a$, spc, line$
for j=8 to 1
line$=""
for i=1 to 8
a$=BoardSq(i,j)#val$(8)
if a$<>" " then
if spc>0 then line$+=str$(spc,""): spc=0

line$+=mid$("PNBRQKpnbrqk", instr("♙♘♗♖♕♔♟♞♝♜♛♚", a$),1)
else
spc++
end if
next
if spc>0 then line$+=str$(spc,""): spc=0
if j>1 then chessboard$+=line$+"/" else chessboard$+=line$+" "
next
if white then chessboard$+="w " else chessboard$+="b "
if  White_♔_no_roke and  Black_♚_no_roke then
	chessboard$+="-"
else
	if White_no_right_roke else chessboard$+="K"
	if White_no_left_roke else chessboard$+="Q"
	if Black_no_right_roke else chessboard$+="k"
	if Black_no_left_roke else chessboard$+="q"
end if
if not en_passant_file=0 then
	chessboard$+=" "+chr$(96+en_passant_file)+chr$(48+en_passant_rank)
else
	chessboard$+=" -"
end if
chessboard$+=str$(Halfmove_clock)
chessboard$+=str$(Fullmove_number)
End Sub
Sub SetBoard(chessboard$)
	Rem https://en.wikipedia.org/wiki/Forsyth–Edwards_Notation
	Clear OnBoard
	board$=leftpart$(chessboard$," ")
	if len(filter$(board$,"K"))<>len(board$)-1 Then  Error "Problem with White King"
	if len(filter$(board$,"k"))<>len(board$)-1 Then  Error "Problem with Black King"
	status$=ltrim$(rightpart$(chessboard$," "))
	white=left$(status$,1)="w" 
	status$=ltrim$(mid$(status$,2))
	if left$(status$,1)="-" then
		White_no_right_roke=True
		White_no_left_roke=True
		White_♔_no_roke =True
		Black_no_right_roke=True
		Black_no_left_roke=True
		Black_♚_no_roke=True
		status$=ltrim$(mid$(status$,2))
	else
		local L=len(status$)
		status$=filter$(status$,"K")
		White_no_right_roke= len(status$)=L
		L=len(status$) : status$=filter$(status$,"Q")
		White_no_left_roke= len(status$)=L
		White_♔_no_roke = White_no_right_roke and White_no_left_roke
		L=len(status$) : status$=filter$(status$,"k")
		Black_no_right_roke= len(status$)=L
		L=len(status$) : status$=filter$(status$,"q")
		Black_no_left_roke= len(status$)=L
		Black_♚_no_roke=Black_no_right_roke and Black_no_left_roke
		status$=ltrim$(status$)
		
	End if
	if left$(status$,1)="-" then
		en_passant_file=0
		en_passant_rank=0
		status$=mid$(status$,2)
	else
		en_passant_file=Asc(left$(status$,1))-96
		en_passant_rank=Asc(Mid$(status$,2,1))-48
		if en_passant_rank=3 then en_passant_rank=4 else en_passant_rank=5
		status$=mid$(status$,3)
	end if
	Local m 
	Halfmove_clock=val(status$, "int", &m)
	status$=mid$(status$,m)
	Fullmove_number=max.data(val(status$, "int", &m), 1)
	nl$={
	}
	for i=1 to 6
		board$=replace$(mid$(White$,i,1),mid$(WhiteDisp$,i,1), board$)
		board$=replace$(mid$(Black$,i,1),mid$(BlackDisp$,i,1), board$)
	next
	for j=1 to 8
		board$=replace$(str$(j,""),emptydisp$(j), board$)
	next
	line$()=piece$(board$,"/")
	local t
	dim line$(1 to 8)
	For j=1 to 8: For i=1 to 8
		t=BoardSq(i,j)
		return t, 8:=mid$(line$(9-j), i, 1)
		if t#val$(8)<>" " then Append OnBoard, i*9+j:=t
		if t#val$(8)="♔" then
			White_♔_rank=j
			White_♔_file=i
			if i<>5 and j<>1 then White_♔_no_roke=True : White_no_left_roke=true : White_no_right_roke=true
		else.if t#val$(8)="♚" then
			Black_♚_rank=j
			Black_♚_file=i
			if i<>5 and j<>8 then Black_♚_no_roke=True: Black_no_left_roke=true : Black_no_right_roke=true
		end if
	next : next
end Sub
Sub CheckIt()
		return t, 8:=" "
		return t1, 8:=p$
		if not white then		
			CheckThreat(not white, White_♔_file, White_♔_rank, &threat)
		else
			CheckThreat(not white, Black_♚_file, Black_♚_rank, &threat)
		end if
		if threat then rule=false
		return t, 8:=p$
		return t1, 8:=p1$
end Sub
Sub CheckIt2()
		return t, 8:=" "
		return t1, 8:=p$
		local t2=BoardSq(en_passant_file, en_passant_rank)
		local p2$=t2#val$(8)
		return t2, 8:=" "
		if not white then		
			CheckThreat(not white, White_♔_file, White_♔_rank, &threat)
		else
			CheckThreat(not white, Black_♚_file, Black_♚_rank, &threat)
		end if
		if threat then rule=false
		return t, 8:=p$
		return t1, 8:=p1$
		if  threat then
			return t2, 6:=p2$
		else
			move t2#val(3), t2#val(4)
			if t2#val(9) then
				fill t2#val(7), t2#val(7),color1
			else
				fill t2#val(7), t2#val(7), color2
			end if
			Halfmove_clock=-1
		end if
		
end Sub
Sub CheckKing()
		return t, 8:=" "
		return t1, 8:=p$
		CheckThreat(not white, i1, j1,&threat)
		if threat then rule=false
		return t, 8:=p$
		return t1, 8:=p1$
end Sub
Sub CheckThreat(White as boolean, c, c1, &Yes)
local i=1, i1=8, j=1, j1=8, k=c, k1=c1
if white then
	local oKin$="♚",hor$="♜♛", dia$="♝♛", Kni$="♞"
else
	local oKin$="♔",hor$="♖♕", dia$="♗♕", Kni$="♘"
end if
 
' WhiteDisp$="♙♘♗♖♕♔"
' BlackDisp$="♟♞♝♜♛♚"
Yes=false
if c1<7 and white then
	if c>1 then
		if BoardSq(c-1, c1+1)#val$(8)="♟" then Yes=True :exit sub
	end if
	if c<8 then
		if BoardSq(c+1, c1+1)#val$(8)="♟" then Yes=True :exit sub
	end If
else.if c1>1 and not white then
	if c>1 then
		if BoardSq(c-1, c1-1)#val$(8)="♙" then Yes=True :exit sub
	end if
	if c<8 then
		if BoardSq(c+1, c1-1)#val$(8)="♙" then Yes=True :exit sub
	end If
end if
for k=max.data(c-1, 1) to min.data(c+1, 8)
for k1=max.data(c1-1, 1) to min.data(c1+1, 8)
if k1=c1 and k=c else if BoardSq(k, k1)#val$(8) =oKin$ then Yes=True : Exit Sub
next
next
for k=c to i
	if Instr(hor$,BoardSq(k,c1)#val$(8))>0 then Yes=True :exit sub
	if k<>c then if Instr(disp$,BoardSq(k,c1)#val$(8))>0 then exit for
next
if c>1 and c1<8 then {
k1=c1+1
for k=c-1 to i   \\  look up left
	if Instr(Dia$,BoardSq(k,k1)#val$(8))>0 then Yes=True :exit sub
	if k<>c then if Instr(disp$,BoardSq(k,k1)#val$(8))>0 then exit for
	K1++
	if k1>8 then exit for
next
}
for k=c to i1
	if Instr(hor$,BoardSq(k,c1)#val$(8))>0 then Yes=True :exit sub
	if k<>c then if Instr(disp$,BoardSq(k,c1)#val$(8))>0 then exit for
next
if c<i1 and c1>1 then {
k1=c1-1
for k=c+1 to i1   \\  look down right
	if Instr(Dia$,BoardSq(k,k1)#val$(8))>0 then Yes=True :exit sub
	if Instr(disp$,BoardSq(k,k1)#val$(8))>0 then exit for
	K1--
	if k1<1 then exit for
next
}
for k1=c1 to j
	if Instr(hor$,BoardSq(c,k1)#val$(8))>0 then Yes=True :exit sub
	if k1<>c1 then if Instr(disp$,BoardSq(c,k1)#val$(8))>0 then exit for
next
if c1>j and c>1 then {
k=c-1
for k1=c1-1 to j   \\  look down left
	if Instr(Dia$,BoardSq(k,k1)#val$(8))>0 then Yes=True :exit sub
	if Instr(disp$,BoardSq(k,k1)#val$(8))>0 then exit for
	k--
	if k<1 then exit for
next
}
for k1=c1 to j1
	if Instr(hor$,BoardSq(c,k1)#val$(8))>0 then Yes=True :exit sub
	if k1<>c1 then if Instr(disp$,BoardSq(c,k1)#val$(8))>0 then exit for
next
if c1<j1 and c<8 then {
k=c+1
for k1=c1+1 to j1   \\ look up right
	if Instr(Dia$,BoardSq(k,k1)#val$(8))>0 then Yes=True :exit sub
	if Instr(disp$,BoardSq(k,k1)#val$(8))>0 then exit for
	k++
	if k>8 then exit for
next
}
rem test "here"
for k=max.data(c-2,i) to min.data(c+2, i1)
	for k1=max.data(c1-2,j) to min.data(c1+2, j1)
		if Abs(k-c)+Abs(k1-c1)=3 then if BoardSq(k,k1)#val$(8)=Kni$ then Yes=True :exit sub
	next
next
end Sub

}
MODULE URLNEW {Stack New {
      Data "foo://example.com:8042/over/there?name=ferret#nose",  "urn:example:animal:ferret:nose" 
      Data "jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true",   "ftp://ftp.is.co.za/rfc/rfc1808.txt"
      Data "http://www.ietf.org/rfc/rfc2396.txt#header1",   "ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two"
      Data "mailto:John.Doe@example.com",   "news:comp.infosystems.www.servers.unix",   "tel:+1-816-555-1212"
      Data "telnet://192.0.2.16:80/",   "urn:oasis:names:specification:docbook:dtd:xml:4.1.2",  "ssh://alice@example.com"
      Data "https://bob:pass@example.com/place",   "http://example.com/?a=1&b=2+2&c=3&c=4&d=%65%6e%63%6F%64%65%64"
      data "ftp://username:password@hostname/"
      a=Array([])
}
function prechar$(a$, b$) {
      if a$<>"" then {=quote$(b$+a$)} else ={""}
}
z=each(a)
document s$="["+{
}
While z {
      a$=array$(z)
      s1$={           "uri": }+quote$(a$)+{,
            "authority": }+ quote$(string$(a$ as URLAuthority))+{,
            "userInfo": }+ quote$(string$(a$ as URLUserInfo))+{,
            "username": }+ quote$(string$(a$ as URLpart 3))+{,
            "password": }+ quote$(string$(a$ as URLpart 4))+{,
            "scheme": }+quote$(string$(a$ as URLScheme))+{,
            "hostname": }+quote$(string$(a$ as UrlHost))+{,
            "Port": }+quote$(string$(a$ as UrlPort))+{,
            "pathname": }+quote$(string$(a$ as UrlPath))+{,
            "search": }+prechar$(string$(a$ as URLpart 6),"?")+{,
            "hash": }+prechar$(string$(a$ as UrlFragment),"#")+{
      } 
      s$="     {"+{
      }+s1$+"     }"
      if  z^<len(a)-1 then s$=" ,"   ' append to document
      s$={
      }
}
s$="]"
Report s$
}
MODULE COMBO1 {\\ module Au is like this with less controls

about call {
      select case about$ 
      case "is a big name here"
            about "Title: is a big name here", 8000,6000,"that [is a big name here] easy [too]"
      else
            about "Title: too", 8000,6000,"that [is a big name here] easy"+about$
      end select
}

declare form1 form
With form1, "Width" as form1.Width, "Height" as form1.Height
layer Form1 {
      window 12, 8000,6000;
      cls #202020
      max_x=scale.x
}

declare combo1 combobox form form1
declare text1 textbox form form1
declare but1 button form form1
With form1,"Title" as title$, "Sizable", True, "UseReverse", True
Method form1, "MakeStandardInfo", 1

With combo1,"Edit", True,"UseOnlyTheList", false,"autocomplete", True, "listIndex" as ListIndex,"ShowAlways", True
With combo1,"label","Combo1", "ListText" as item$, "list" as list$(), "text" as combo1$, "icon", 3
item$={alfa
            delta
            gamma
            beta
            }
With combo1,"Find" as Find()
Method combo1,"Sort"
combo1$=list$(find("gam*"))

Method combo1,"Move", 1000,1000,6000,600
Method text1, "Move", 1000,1900,6000,600
Method but1, "Move", 1000, 2800, 6000, 600
With But1, "Blink" as but1.blink, "caption" as but1.caption$
but1.caption$="press to stop"
but1.blink=300
With text1, "left" as left, "text" as text1.text$ , "ShowAlways", True , "Default", true,"icon", 3
Print left
Method form1, "show"

\\ we use mono for part structure. when a part executed the mono change to true,
\\ so no other part with same variable can executed
def boolean mono, allow=true
Function but1.Blink {
      Read New face
      if allow<>0 and face then
      part {
            print face, if$(internet$<>"127.0.0.1"->"connected to internet","not connection found")
            refresh
      } as mono
      end if
      If Face then {
            Method but1,"Colors", 15,2
      } else Method but1,"Colors", 14,7
      Method but1,"TransparentOff"
}
Function but1.click {
      part {
            if allow then but1.caption$="ok" :allow=false
            Print "click: Your ip=";lan$, "Your public ip=" ;internet$
            but1.blink=0
            refresh
      } as mono
}
function form1.resize {
      layer form1 {
          if form1.width<max_x then form1.width=max_x
          if form1.height<4000 then form1.height=4000
          move form1.Width, form1.Height  
          cls
          local oldi=italic
          italic 1
          Legend "Use Ctrl+F1 in textboxes","Courier",8,0,1
          italic oldi
    }
}
Call Local form1.resize()
function form1.unload {
      about
      Keyboard "!"
      show
}
function combo1.about {
      about show "is a big name here"
}
function text1.about {
      about show ""
}
Function combo1.dblclick {
      text1.text$=combo1$
      title$=combo1$
      if find(title$)= -1 then {
            Method combo1,"additem",title$ 
            Method combo1,"Sort"
            listindex=find(title$)
      }
      combo1$=combo1$
      Method text1,"GetFocus"
}
Function combo1.click {
      if listindex>=0 then  text1.text$=list$(listindex)
}
Function combo1.scroll {
      if listindex>=0 then  text1.text$=list$(listindex) 
}
\\ just wait for a key in console
a$=key$

declare Text1 nothing
declare combo1 nothing
declare form1 nothing
}
MODULE PROF {cls
Rem
 Set Fast!
Rem Set fast
Rem Set Slow
Report {From Version 9.9 rev 1
		Profiler	reset the current profiler (if a local exist then reset the local one)
		Profiler !	if not local profiler exist then one created else Reset the profiler
		timecount	value return from local profiler if exist, or from global
	
		For this example we use global profiler in this module and in glo() function
		Modules and functions may have local profilers if we create one using Profiler !
		Only one local profiler for each module and function.
	}
Report "First Example: Accessing both local and global profiler"
module alfa {
	def glo()=timecount
	profiler !
	for i=1 to 1000
	next
	print timecount,"", glo()
}

profiler
for i=1 to 10
alfa
next
Print @(tab(3)), timecount, "/total"
Report "Second Example: using only global profiler"
Profiler
Function Deep(N) {
	if N>1 then =Deep(N-1)
	For i=1 to 100
	Next i
	Print N, "", timecount
}
N=Deep(10)
Print @(tab(2)), timecount, "/total"
Report "Third example: using local profiler"
Function Deep(N) {
	if N>1 then =Deep(N-1)
	Profiler !
	For i=1 to 100
	Next i
	Print N, "", timecount
}
Profiler
N=Deep(10)
Print @(tab(2)), timecount, "/total"
Set Fast
}
MODULE BASIC {
\\ this is a style like BASIC
\\ we use line numbers
\\ we have two types of subroutines
\\ the sinple routine (Gosub/Return)
\\ the SUB/END SUB  (GOSUB is optional for the call)
\\ we use FOR as in BASIC SO IF A < 1 we SKIP THE FOR LOOP
\\ we use arrrays like in VB, so we get plus one ITEM (here 11 items fro 0 to 10)
\\ the gosub 200 enable these features
\\ the gosub 210 disable these features


000 GOSUB 200
010 
020 REM 
030 FORM 80,48
040 CONST MAX=64%   ' % for Integer
050 DEF INTEGER A1, I  :  DEF Z$
060 DIM P(MAX)
070 PRINT $(0,20)   ' SET WIDTH TO 20
080 INPUT "Give a value for variable A (try 64)=", A1
090 GOSUB ALFA(&A1)
100 IF A1<=1 THEN 170 ELSE PRINT "We have ";A1;"items with these types:"
110 PRINT $(0,10)
120 WHILE A1>0
130 PRINT FORMAT$("({0}) : {1}", A1, TYPE$(P(A1))),
140 A1-- 
150 END WHILE
160 PRINT
170 GOSUB 220
180 END


200 SET SWITCHES "+FOR +DIM"
210 RETURN
220 SET SWITCHES "-FOR -DIM"
230 RETURN


300 SUB ALFA(&A AS Integer)
310 P(0)=1~   ' we use ~ for float constant values
320 FOR I=1 TO A
330 IF I>MAX THEN A=I : EXIT
340 P(I)=P(I-1)*I
350 IF I<10 THEN F$=STR$(P(I),"") ELSE F$=STR$(P(I),"#.######E+###")
360 PRINT @(TAB((I-1) MOD 4)), "P(";STR$(I,"00");")=";F$;
370 IF (I-1) MOD 4=3 THEN PRINT
380 NEXT I
390 PRINT
400 END SUB
}
MODULE REPORTTEST {
\\ USE SHIFT TAB AT START OF PARAGRAPH TO ADD SPACES
Global B$={      Tokyo (CNN)Typhoon Hagibis weakened to a tropical depression as it continued to move across central Japan on Sunday, leaving at least 15 people dead and more than 140 injured in its wake.
      The storm made landfall just before 7 p.m. Saturday local time on the Izu Peninsula, southwest of Tokyo, bringing hurricane-force winds and heavy rains which led to widespread flooding. More than 230,000 people were evacuated ahead of the storm, with emergency orders issued for many cities around the greater Tokyo area.
      Along with the 15 deaths, Japan's Fire Disaster and Management Agency said about 140 people had been injured and nine remain missing.
      Prime Minister Shinzo Abe offered his "condolences for the people killed in the disaster and my sincere sympathy for the people affected by this disaster."
      "Now not only police, fire department and coast guard, but also 27,000 staff of the self-defense force are on rescue, search for missing and supporting evacuation," Abe said Sunday. "We are to enhance the scale of operation depending on necessity."
      Typhoon Hagibis came as the country hosts the Rugby World Cup. Two matches -- England-France and New Zealand-Italy -- had to be preemptively canceled. Sunday's Pool B match between Namibia and Canada in Kamaishi was also canceled hours before it was due to take place.
      Original:https://edition.cnn.com/2019/10/13/asia/typhoon-hagibis-japan-rugby-intl-hnk/index.html
}
Module Check {
	READ A, k
	Print @(0,5);" 199";@(pos,row,k+pos,10+row, 5, 8);
	Report 0, B$, k, 10  Line a
	Print @(23,5);" 200";@(pos,row,k+pos,10+row, 5, 8);
	Report 2, B$, k, 10  Line a+1
	Print @(0,17);" 201";@(pos,row,k+pos,10+row, 5, 8);
	Report 1, B$, k, 10  Line a
	Print @(23,17);" 202";@(pos,row,k+pos,10+row, 5, 8);
	Report 3, B$, k, 10  Line a+1
	Print
	Refresh 5000	
}
\\ set tab width
Report ! 4
KK=80
Repeat {
Refresh 5000
form KK, 32
g=20 : d=2
\\ Blocks {} handle Goto jumps
Repeat {
	Cls 5, 0
	Pen 14
	Double
	Pen 15 {Report 2, "Example of Report statement"}
	Normal
	OldItalic=Italic
	Italic 1
	Cursor 0,1
	Pen 7 {
		Report {
			Press space to Exit
			Press M to stop - press any key again to start
			Press any other key to change mode (font size)
		}
	}
	Italic OldItalic
	For f=2 to 5{
		check  f, g
		Wait 4
		If Keypress(32) Then Goto ExitLoop		
		M$=Inkey$
		If M$<>"" Then {
			If Ucase$(M$)="M" Then M$=Key$ Else Goto ContHere
		}
	}
	For f=4 to 1 {
		Check  f, g
		Wait 4
		If Keypress(32) Then Goto ExitLoop
		M$=Inkey$
		If M$<>"" Then {
			If Ucase$(M$)="M" Then M$=Key$ Else Goto ContHere
		}
	}
	g=g-d
	If g<=3 Then d=-d
	If g>18 Then d=-d
} Always
ContHere:
KK=KK-5
} Until KK<50
ExitLoop:
}
MODULE TEXTONLY {Declare Form1 Form
Layer Form1 { Cls 7
	Move scale.x/2, scale.y/2
	Pen 14 { Circle Fill 14, 100, 0.5}
	w=scale.x
 }
Declare Edit1 EditBox Form Form1
Declare Text1 TextBox Form Form1
Method Edit1, "move",1000,1000,w-2000,2000
Method Text1, "move",1000,3600,w-2000,600
With Edit1, "Text",{Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum
TextBox Handle:
Use ctrl + left or right arrow, for moving fast skipping words and spaces. You can paste text with Ctrl+V, but without merging, the old text replaced with the new one. You can't get a copy.
}, "ScrollKeyUpDown", True
With Text1, "MaxCharLength", 100
Method Edit1,"TextViewOnly"
Method Edit1, "Transparent"
Method Edit1, "Colors", 15, 15
Method Text1, "Transparent"
Method Text1, "Colors", 15,15
m=1 : s=1
Function Form1.Unload {
	read new &ok
	If mm<>0 then thread mm erase : mm=0:ok=true     
}
Layer Form1 {
	gradient 7,0
	hold
	Thread {
		{
			Release
			Pen 0 { Circle Fill 0, m*100, 0.5}
			m+=s
			If m>=60 then
				pen random(1,4)
				s-!
			Else.If m<2 then
				s-!
				pen random(1,4)
			End If
			\\		refresh 5000
			method Form1, "RefreshAll"
		}
	} as mm interval 1000/24
}
Method Form1, "Show", 1
Threads Erase
Declare Form1 Nothing
}
MODULE PRMASTER {      let col=8, flip=True, oldbold=Bold
      Bold 0
      Refresh 1000
      Form ! (100 div col)*col,32
      Cls 5
      Pen 14
      For i=0 To Width-1 Step col {
            If flip Then {
                  Print @(i,0,i+col,Height,#222222,3),
            } Else Print @(i,0,i+col,Height,5,3),
            flip~
      }

      For i=2 To Height-2
            Cursor 0, i
            Pen 2 { Print Under }
      Next i
      Print @(0,2),   \\ same as Cursor 0,2
      For i=0 To 9 {
            Print $(i, col),145355,34.23432,34.222, ~(10,2, 2-12*(i=8)), "aaa",~(14),"bb"
            Print 145355,"A So Real Big String",34.222, "Small", 10, i
            Print $(0),  ' For να το επαναφέρουμε
      }
      Print $(";True;False;"), 0,-1, True, False, "A">" ", "*"
      Print $(""), True, "*Ok"
      Print Part @(Tab*2), $(6,col*2),~(10,2),"Double Column",$(4,col), ~(14), 1000
      Pen 2 { Print Under }
      Print Part @(Tab*2), $(6,col*3),~(10,2),"Triple Column",$(4,col),~(14), "ok"
      For i=0 To 1 {
            Cursor 0,i : Print Over ~(14,7,7),
      }
      Cursor 0,0
      Double : Bold 1
      Pen 15 { Report 2, "Example with Print & Report Statements"}
      Pen 2 { Print Under }
      Normal : Bold
      Print @(Tab(8),15, Tab(11),30,#222222, 2),
      Print @(Tab(8),4, Tab(11),14,#222222, 2),
      Document$={   Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo.
   Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem.
   Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?
}
      Pen 7 {
            Report Document$, Tab*3, 10
            Cursor Tab(8), 16
            Report Document$, Tab*3, 14 Line 12
      }
      Pen 13 {
            Cursor Tab(8), 15
            Report Document$, Tab*3, 1 Line 11
           }
      Cursor 0,Height-2
      Bold OldBold
}
MODULE BREAKPOINT {Test "start", test("ok"), A
For A=1 to 100 {
      Wait 1
      Print A
      if A=41 then test "ok" : test test("ok2")
      if A=81 then test "ok2": test  \\ wait for keypress
}
Test !
}
MODULE RTL {form ! 36,24
Print "Right to left display"
Double
Print "ברוכים הבאים الجامعات والكليات", "ok"
Print "ok", "ok", "ok","ok"
Normal
Report 1, "ברוכים הבאים الجامعات والكليات"
Report 2, "ברוכים הבאים الجامعات والكليات"
Report 3, "ברוכים הבאים الجامعات والكليات"
Report 2, "Word Wrap"
r=row
Cursor 4, r
Report "ברוכים הבאים الجامعات والكليات", 8
Cursor 16, r
Report 2, "ברוכים הבאים الجامعات والكليات" , 4
Cursor 22, r
Report 1, "ברוכים הבאים الجامعات والكليات" , 5
Print
}
MODULE SIMPLETXT {Όρισε Φόρμα1 Φόρμα
Όρισε Κειμ1 Κείμενο Φόρμα Φόρμα1
Όρισε Κειμ2 Κείμενο Φόρμα Φόρμα1
Όρισε Κειμ3 Κείμενο Φόρμα Φόρμα1
θεσηΧ=4000
Μέθοδος Κειμ1, "Move", θεσηΧ,1200,5000,400
Μέθοδος Κειμ2, "Move", θεσηΧ,1800,5000,400
Μέθοδος Κειμ3, "Move", θεσηΧ,2400,5000,400
νγ$={
}
Με Κειμ1, "ShowAlways", Αληθές, "NumberOnly", Αληθές, "Value" ως Τιμ1
Με Κειμ2, "ShowAlways", Αληθές, "NumberIntOnly",Αληθές, "Value" ως Τιμ2
Με Κειμ3, "ShowAlways", Αληθές, "UsedAsTextBox", Αληθές,"Text" ως Τιμ3$
Τιμ1=93.112
Τιμ2=1456
Τιμ3$="Μια γραμμή μόνο"
Συνάρτηση Κειμ1.About {
      Κάλεσε Τοπικά Φόρμα1.About()
}
Συνάρτηση Κειμ2.About {
      Κάλεσε Τοπικά Φόρμα1.About()
}
Συνάρτηση Κειμ3.About {
      Κάλεσε Τοπικά Φόρμα1.About()
}
Συνάρτηση Φόρμα1.About {
      Επίπεδο Φόρμα1 {
            Οθόνη  #606060
            Τύπωσε $(Τρόπος),"Κάνε κλικ εδώ ή πάτα Enter"
      }
}
Συνάρτηση Φόρμα1.Enter {
      Κάλεσε Τοπικά Φόρμα1.Click()
}
Συνάρτηση Φόρμα1.Click {
      Επίπεδο Φόρμα1 {
            Τιμ1=Τιμ1+1  \\ δεν δουλεύει το Τιμ1++ γιατί είναι αντικείμενο και όχι μεταβλητή
            Οθόνη  #606060
            Τύπωσε Τιμ1, Τιμ2, " Ctrl+F1"
            Τύπωσε Πάνω $(9), Τιμ3$
            Ανανέωση
            Μέθοδος Κειμ1, "Show"
      }
}
Τρόπος=4
Επίπεδο Φόρμα1 {
      Γραμματοσειρά "Arial Black"
      Παράθυρο 16, 10000,4500
      Πένα 15
      Οθόνη #202020
      Οθόνη #606060, Ύψος-2
      Θέση θεσηΧ, 1200+400
      Επιγραφή "Ετικέτα ", Γραμματοσειρά$, Τύπος, 0, 1
      Θέση θεσηΧ, 1800+400
      Επιγραφή "Άλλη ετικέτα ", Γραμματοσειρά$, Τύπος, 0, 1
      Θέση θεσηΧ, 2400+400
      Επιγραφή "Και άλλη ετικέτα ", Γραμματοσειρά$, Τύπος, 0, 1
      Πένα 13
      Τύπωσε $(Τρόπος),"Κάνε κλικ εδώ ή πάτα Enter"
}
Μέθοδος Φόρμα1, "Show",1
Όρισε Κειμ1 Τίποτα
Όρισε Φόρμα1 Τίποτα
}
MODULE SIMPLETXTEN {Declare Form1 Form
Declare text1 editbox Form Form1
Declare text2 editbox Form Form1
Declare text3 editbox Form Form1
PositionX=4000
Method text1, "Move", PositionX,1200,5000,400
Method text2, "Move", PositionX,1800,5000,400
Method text3, "Move", PositionX,2400,5000,400
nl$={
}

With text1, "ShowAlways", True, "NumberOnly", True, "Value" As Value1
With text2, "ShowAlways", True, "NumberIntOnly", True, "Value" As Value2
With text3, "ShowAlways", True, "UsedAsTextBox", True,"Text" As Value3$
Value1=93.112
Value2=1456
Value3$="One line only"
Function text1.About {
      Call Local Form1.About()
}
Function text2.About {
      Call Local Form1.About()
}
Function text3.About {
      Call Local Form1.About()
}
Function Form1.About {
      Layer Form1 {
            Cls  #606060
            Print $(Way),"Press right mouse button or Enter"
      }
}
Function Form1.Enter {
      Call Local Form1.Click()
}
Function Form1.Click {
      Layer Form1 {
            Value1=Value1+1  \\  Value1++ not work becaue Value1 is an object (linked property)
            Cls  #606060
            Print Value1, Value2, " Ctrl+F1"
            Print Over $(9), Value3$
            Refresh
            Method text1, "Show"
      }
}
Way=4
Layer Form1 {
      Font "Arial Black"
      Window 16, 10000,4500
      Pen 15
      Cls #202020
      Cls #606060, Height-2
      Move PositionX, 1200+400
      Legend "Label ", Fontname$, Mode, 0, 1
      Move PositionX, 1800+400
      Legend "Another Label ", Fontname$, Mode, 0, 1
      Move PositionX, 2400+400
      Legend "And another Label ", Fontname$, Mode, 0, 1
      Pen 13
      Print $(Way),"Press right mouse button or Enter"
}
Method Form1, "Show",1
Declare text1 Nothing
Declare Form1 Nothing
}
MODULE CONV2 {Module Checkit {
	k$=lambda$ (m, b as integer=16) -> {
		if b<2 or b>16 then error "base out of range"
		if m=0 then ="0" : exit
		z$="0123456789ABCDEF"	
		=lambda$ z$, b (m) ->{
			=if$(m=0->"", lambda$(m div b)+mid$(z$, m mod b + 1, 1))
		}(m)
	}
	k=lambda (m$, b as integer=16) -> {
		if b<2 or b>16 then error "base out of range"
		m$=trim$(m$)
		if m$="0" then =0 : exit
		z$="0123456789ABCDEF"	
		=lambda z$, b (m$) ->{
			=if(Len(m$)=0->0, lambda(mid$(m$,2))+(instr(z$, left$(m$,1))-1)*b**(len(m$)-1))
		}(m$)
	}
	Print k$(0)="0", k("0")=0
	Print k$(65535)="FFFF", k("FFFF", 16)=65535
	Print k$(0xF00F)="F00F", k("F00F", 16)=0xF00F
	Print k$(0xFFFFFFFF)="FFFFFFFF", k("FFFFFFFF", 16)=0xFFFFFFFF
	Print k$(100, 8)="144", k("144", 8)=100
	Print k$(100, 2)="1100100", k("1100100", 2)=100
}
Checkit
}
MODULE SIMPLETHREAD {m=100
thread {
	m--
	if m<1 then thread this erase
} as countdown interval 100

Main.Task 25 {
	Print m, "inside main task"
	if keypress(1) then exit
}
Threads ' just report
Print "ok"
}
MODULE PHILO {Module Dining_philosophers (whichplan) {
Form 80, 32
Const MayChangePick=Random(True, False)
Dim energy(1 to 5)=50
Document Doc$
Const nl$={
}
Print $(,12),  ' set column width to 12
Pen 14
Pen 15	{
	Doc$="Dining Philosophers"+nl$
	\\ we can change thread plan only if no threads defined
	if whichplan=1 then
		Doc$="Sequential threads - to execute exclusive one threads code"+nl$
		thread.plan sequential
		\\ need time_to_think>time_to_eat, but time_to_appear maybe the same for all
		time_to_think=150  ' one or more intervals
		time_to_eat=100 ' one interval to eat only	
		time_to_appear=(150,150,150,150,150)
		Return time_to_appear, random(0,3):=300
	else
		Doc$="Concurrent threads  - to execute a statement or a block of code"+nl$
		thread.plan concurrent 
		time_to_think=100  ' one or more intervals
		time_to_eat=50 ' one interval to eat only
		time_to_appear=(100,100,100,100,100)
		Return time_to_appear, random(1,4):=200	 
	end if
	Print #-2,Doc$
	Print @(0,2),"Press left mouse button to exit"
	Print Part $(1), time_to_appear
	Print under
}
Pen 13 {Print "Aristotle", "Kant", "Spinoza", "Marx", "Russell"}
enum philosopher {
	Aristotle, Kant, Spinoza, Marx, Russell
}
global enum forks {NoFork, Fork}
RoundTable =(Fork, Fork, Fork, Fork, Fork)
Getleft=lambda RoundTable (ph as philosopher) -> {
	where=(ph+4) mod 5
	= RoundTable#val(where)
	Return RoundTable, where:=NoFork
}
GetRight=lambda RoundTable (ph as philosopher) -> {
	where=ph mod 5
	=RoundTable#val(where)
	Return RoundTable, where:=NoFork
}
PlaceForks=lambda RoundTable (ph as philosopher) -> {
	Return RoundTable,  (ph+4) mod 5:=Fork,ph mod 5:=Fork 
}
PlaceAnyFork=lambda RoundTable (ph as philosopher, &ForkL, &ForkR) -> {
	If ForkL=Fork then Return RoundTable,  (ph+4) mod 5:=Fork : ForkL=NoFork
	If ForkR=Fork then  Return RoundTable, ph mod 5:=Fork : ForkR=NoFork
}
ShowTable=lambda RoundTable -> {
	m=each(RoundTable)
	while m
		print if$(array(m)=NoFork->"No Fork", "Fork"),
	end while
	Print
}
noforks=lambda RoundTable -> {
	k=0
	m=each(RoundTable)
	while m
		if array(m)=NoFork then k++
	end while
	=k=5
}
 
def critical as long, basetick
Document page$
m=each(philosopher)
while m {
	\\ we make 5 threads
	\\ a thread has module scope (except for own static variables, and stack of values)
	thread {
		if  energy(f)<1 then {
				call PlaceAnyFork(f, ForkL, ForkR)
				energy(f)=0
				Page$=format$("{0::-12} - ",tick-basetick)+eval$(f)+" - Die"+nl$
				thread this erase
		} else	{
				Page$=format$("{0::-12} - ",tick-basetick)+eval$(f)
				Page$=if$(ForkL=NoFork or ForkR=NoFork->" thinking",  " eating"+str$(eatcount))
				Page$=if$(R->"- R", " - L")+nl$
		}
		if not think then 
			{ \\ a block always run blocking all other threads
				energy(f)++
				eatcount--
				if eatcount>0 then exit
				Call PlaceForks(f) : ForkL=NoFork:ForkR=NoFork
				eatcount=random(4,8)
				if MayChangePick then R=random(-1,0)
				think=true :thread this interval  time_to_think*random(1,5)
			}
		else.if energy(f)>70 or critical>5 then
			{
				call PlaceAnyFork(f, &ForkL, &ForkR)
				if energy(f)>70  then energy(f)=60
			}
		else.if R then
				if ForkR=NoFork then ForkR=GetRight(f)
				if ForkR=Fork and ForkL=NoFork then ForkL=GetLeft(f)
				if ForkL=Fork then think=false:thread this interval  time_to_eat else energy(f)--
		else
				if ForkL=NoFork then ForkL=GetLeft(f)
				if ForkL=Fork and ForkR=NoFork then ForkR=GetRight(f)
				if ForkR=Fork then think=false:thread this interval  time_to_eat else energy(f)--
		end if
		
	} as a interval time_to_appear#val(m^)		
	\\ a is a variable which hold the number of thread (as returned from task manager)
	\\ so we can get 5 times a new number.
	\\ for each thread we make some static variables (only for each thread)
	\\ this statement execute a line of code in thread a
	thread a execute {
		\\ this executed on thread execution object
		static f=eval(m), think=true, ForkL=NoFork
		static ForkR=NoFork, eatcount=random(2,5)
		static R=-1
		if MayChangePick then  R=Random(-1,0)
	}
}
cls ,5  ' set split screen from fifth row
\\ Main.Task is a thread also. Normaly exit if no other threads running in background
\\ also serve a the wait loop for task manager (we can use Every 200 {} but isn't a thread, is a kind of a wait statement)
\\ tick return the counter from  task manager which used to triger threads
basetick=tick
\\ 4hz display results
MaxCritical=0
Main.Task 1000/4 {
	{ \\ a block always run blocking all other threads		
		cls
		Print Part $(1),$("####;\D\I\E;\D\I\E"),energy()
		Print Under
		Print "Table:"
		Call ShowTable()
		if noforks() then critical++  else critical=0
		MaxCritical=if(MaxCritical<critical->critical,MaxCritical)
		Print "noforks on table counter:";critical, "Max:";MaxCritical
		Print #-2,Page$
		Doc$=Page$
		Clear Page$
	}
	if critical>40 or keypress(1) then exit
}
threads erase
thread.plan sequential
Clipboard Doc$
}
Dining_philosophers Random(1,2)
}
MODULE COLUMNSSORT {Form 80,40
Const max=36
\\ setup random generator to produse the same sequence
x=random(!12493587)
Rand$=Lambda$ labels=("LONDON","PARIS","BERLIN","ATHENS", "ROME","SOFIA") ->{
	= Field$(labels#val$(random(0,5)), 10)
}
PickNumber=Lambda (m)-> {
      dim A(1 to m)
      =lambda A(), m -> {
            if m<1 then exit
            i=random(1, m)
            =if(A(i)=0->i, A(i))
            A(i)=if(i<m->if(A(m)=0->m,A(m)),0)
            m--
            if m=0 then A()=(,) else Dim A(1 to m)
      }
}(max)

Flush
Dim A(1 to max, 1 to 3)
Link A() to A$()
Title("1. Populate Array")
R=0
refresh 5000
for i=1 to max
      A(i,1):= PickNumber(), Rand$(), Random(1,6)*100
      Gosub 100
next
Refresh 20
Gosub 240
Title("2. Sort Ascending First Column")
sort A(),1, max, 1,0
R=20
Gosub 200
Title("3. Sort Ascending Second, Third and First")
sort A(),1, max, 2,0,3,0,1,0
R=40
Gosub 200
Title("4. Sort Columns Third Descending, Second Ascending, First Ascending")
sort A(),1, max, 3,1,2,0,1,0
R=60
Gosub 200
keyboard "Info"+chr$(13)
End
100 Print Part  $(0), @(R),~(11),str$(A(i,1),"0000 "),@(R+5), ~(0, 7,7), $(6),A$(i,2),~(15), @(R+15),$(0), ~(14), format$("{0::4}",A(i,3)) : Print
110 Return
200 Refresh 5000
210 For i=1 to max
220       Gosub 100
230 Next : Refresh 50
240 T=True
250 Every 1000/8 {
260       T~
270       Print Over $(6),~(If(T->7,15)),"PRESS LEFT MOUSE BUTTON"
280       If keypress(1) then Exit
290 }
300 Print Over
310 Return
320 Sub Title(A$)
330       Cursor 0,0: Double
340       Print Over ~(15),A$
350       Print
360       Normal
370 End Sub

}
MODULE CRAWL {Escape Off
Hide
Window 12,1
Back {
Ybig=scale.Y
Window 18,0, 2000;
Motion.w Motion.wx , Ybig-2000
Refresh 5000

\\ For changing the decimal character use Locale (Locale 1033 for English, Locale 1032 fro Greek)
\\ Here we use Locale value in Time$()
\\ Locale is a statement and a read only value

\\ Greek and Latin statements used for message;s language
\\ Greek also is a read only variable to read the status for message's language
If Greek Then
      m$="Πάτα ένα πλήκτρο στο πληκτρολόγιο για τερματισμό - Πάτα τα πλήκτρα του ποντικιού για να αλλάξεις ταχύτητα στο μήνυμα - "
Else
      m$="Press a key on keyboard to end this - Press a key on mouse to change the crawl speed - "
End If
fn$="Arial Black"
sz=48
mw=Size.X(m$,fn$, sz)
m1=0
m2=mw
my=Scale.y/2-Size.Y("Α", fn$, sz)/2
ms=twipsX*3
t=2
Cls
Gradient 4, 12
if module(ico) then ico 0 : Read ico
Hold
Font Fn$
Pen 14
refresh 500
Every 1000/25{
D=Mouse
If Inkey$<>"" Then
      Exit
Else
      Release
      Cursor 0,0
      Print Part $(3,width), Time$(now, 1033+Greek, "hh:mm:ss tt")
      Move m1, my
      Pen 15 {
            Legend m$, fn$, sz
            If m2<scale.x Then
                  Move m2, my
                  Legend m$, fn$, sz
            End If
      }
      If D=4 Then t=2 Else.If D=1 Then t+=1 Else.If D=2 Then t-=Αν(t>2->1,0)
      m1-=ms*t
      m2-=ms*t
      If m2<0 Then m1=m2+mw: Swap m1, m2
      if module(ico) then
            Move  if(keypress(4)->mouse.x,  twipsX*5),0
            Image ico, scale.x/width*5  ' (twips/character)
      end if
      Refresh
End If
}
set fast
Cls 11
}
Window 12,0
\\Show
Escape On
keyboard "info"+chr$(13)
}
MODULE ZONES {zones=time()
m=each(zones)
Menu ' empty menu list
while m
      menu + eval$(m!)
End While
Print "choose a time zone:";
\\ now open the menu
Menu !

if menu then
      Pen 15 {Print menu$(menu)}
      Print "From UTC: ";zones(menu$(menu))
      Print "UTC time: ";time$(time("utc"),1033, "Long Time")
      Print menu$(menu);": ";time$(ctime(time("utc"), zones(menu$(menu)),0,0),1033, "Long Time")
      Print "Current OS system time zone: ";
      Pen 15 {Print time$()}
End If
}
MODULE WIND4 {\\ An old example, new revision.
Thread.plan sequential
Global Caption$="M2000 THREAD-INPUT-HANDLE WINDOW"
Title caption$
puticon=false
If module(ico) Then
ico 0
read m2000
puticon=true
End If
dim label$(6)
label$(1)="Basic style Input for input a number", "Field Input - Work the INS key","One line transparent textbox, cut, copy, paste, drag/drop, no menu","Multi line textbox with menu (press esc to exit from editor)","Multi line for documents with transparent background (press Esc to exit from editor)"
Example=random(1, 5)
Global messrow
Escape Off
Global STATE=0, EXITNOW as boolean=false
module global mayexit {
	EXITNOW<=True
	Try {field new 99: input End }
	beep
}
window.size=random(7,9)
Hide  \\ prepare Window
Window 10,0  \\ center full size 10pt letters
global abX=scale.x/2, abY=scale.y/2,  cur$, prev$
About ! "Wind4 Module", abX, abY, {
	This is the help file
}
ABout Call {
	cur$=About$
	Select case cur$
	case "Esc"
	{ ' use block for more than one line after case	
		About "Text Editing -  Esc", abX, abY, {
			Just press the Escape key to exit editor
		}+If$(prev$<>""->"["+prev$+"]","")
		prev$<=cur$
	}
	case "shift F10"
	{ ' use block for more than one line after case
		About "Text Editing -  Shift F10", abX, abY, {
			You can use right mouse click, on editor's text area or left on header.
			Also you scroll the menu to see all options.
		}+If$(prev$<>""->"["+prev$+"]","")
		prev$<=cur$
	}	
	case "", "top"
	{
		About "Text Editing", abX, abY, {
		Use [Esc] to exit
		use [shift F10] for context menu
		Threr are some combinations with shift for:
		F2, F3, F4, F5, F9, F10, F12
		}+If$(prev$<>""->"["+prev$+"]","")
		prev$<="top"
	}
	end select
}
Window random(9,14) , scale.x*.1*window.size, scale.y*.1*(window.size-1);  \\centered - random font size
Form 60, 24
Form   
Cls 15,0      \\white bacground - no Split screen
Gradient 0,9  \\ two colors gradient
Move 0,0
Fill scale.x,scale.y/height-25,7,6,0  \\Gradient fill to Window caption
Pen #FF7766
\\ Targets are from earlier versions - but works fine
\\ This is the windows caption. We change only a variable.
\\ Targets works with globals.
Pen 14 {
      Target A,"STATE++",width-2,1,,,5,caption$
}

Print @(width-2,0);
Pen 15
Let IamOut=False
Let kk=0, MayStart=False
\\ This is a second target, the X in the right corner
\\ when we click on it system call mayexit global module
Target b, {Title caption$,0} ,1,1,6,,5,"_"
If puticon Then
	Move twipsx*2, twipsy*2
	Image m2000, scale.x/width*1.5
End If
Print @(width-1,0);
Target C, "mayexit" ,1,1,6,,5,"X"
Pen 15
Print @(4,1);  \\ like Cursor
Report {This is console as Window by software. We use targets for title and  buttons "_" and  "X" in the right top corner. You can Move the window. Console not support events for user. We can scan targets, using Scan statement. Threads run in background  when we use an input method (one of five options).
Press some keys and then the return key. Exit by clicking the X in the right up corner.}, width-6
aa$=Field$("",10)  \\ for second example - change gosub
If pos>0 Then print
Let messrow=row   \\ we can use Let instead of messrow<=row+1
Scroll Split  row+1
Pen 0
Refresh 40
threads erase
Thread {
	scan 0.01 : thread this interval 10  \\ repait interval
	Layer {Cursor 0,messrow : Print  Over  : Print Part ~(0),"waiting..." , kk }
} as LL : Thread LL interval 10
Scroll Split 1
Thread  {   \\ this thread used for moving the Window
	Layer {
		Cursor 0,messrow+1 : Print  Over $(4), ~(0, 15), "MOVING"
		Motion.W Motion.XW-MX+Mouse.X,Motion.YW-MY+MOUSE.Y
		If Mouse=0 Then {
			Mouse.icon 1
			STATE<=0: Cursor 0,messrow+1
			Print  Over $(4), ~(0, 15), "HOLD": REFRESH
			After 30  {
			Try {Cursor 0,messrow+1 : Print  Over  $(9), ~(0,15), Label$(Example)}
			}
			Thread this hold
		}
	}
} As Moveme
Thread moveme hold  \\ not started yet
Thread moveme interval 100  \\ we set an interval
MayStart<=True


\\ main thread here
Main.Task 10 {
	kk++
	If MayStart Then
		A$=Inkey$
		If A$<>"" Then 
			Layer {
				Cursor 0,messrow+1 : Print  Over  $(9), ~(0,15), Label$(Example)
				MayStart~: keyboard A$
			}
			Select Case Example
			Case 1
				gosub OpenField()
			Case 2
				gosub OpenField1()
			Case 3
				gosub OpenField2()
			Case 4
				gosub OpenField3()
			Else Case
				gosub OpenField4()
			End select
		End If
	End If
	If iamout Then iamout~: Cursor 0,messrow+1 :  Print  Over $(4), ~(0, 15),"You press escape..."  
	If STATE=1 Then 
		Mouse.icon 5
		Cursor 0,messrow+1 : Print  Over $(4), ~(0, 15), "START MOVING"
		MX=Mouse.X:MY=Mouse.Y   \\ setup now position
		Thread moveme restart  \\here we restart thread
		STATE++   \\ and we closed this If
	End If
	If exitnow Then exit
}
wait 1000
threads erase 
targets new
Cursor 0,messrow+1 : Print  Over $(4), ~(0, 15), "End.."
Cls #72ff77, messrow+3   \\Split screen from 7 (8th line)
Cls
Cursor 0, row-1
Print Over $(6), ~(15,0,0), "Just press  F1 to choose another input  or press F3 for info"
Fkey 1, "Wind4"
Fkey 3,  "info"
Escape On
About Call ""
About ! ""
Sub OpenField()
	After 10 {    \\ this is an automatic thread, for one time, After 10 miliseconds
		Layer {
			Cursor 10,10
			for i=1 to 4 : Print Over : Pen 15 { Print under } : next
			Cursor 10,10
			A=0
			Try {Input "Number:", A}
			If exitnow Then exit
			Cursor 0,messrow+2 : Print  Over "Field:";A
			MayStart=True 
		}
	}
End Sub
Sub OpenField1()     \\this is an alternative by using Field
	After 10 {
		Layer {
			Field 10,10,10 AS aa$
			If Field=99 Then
				IamOut=True : aa$=""
				Field New   \\ Clear feedback from Field statement.
				A$=Inkey$
			Else
				Cursor 0,messrow+2 : Print  Over "Field:";aa$ : aa$=""
			End If
			MayStart=True
			If exitnow Then exit
		}
	}
End Sub
Sub OpenField2() 
	After 10 {
		Layer {
			Cursor 10,10
			aa$=inkey$
			If aa$<" " Then aa$=""
			Pen 14 { input ! aa$, 10 len=30}
			If exitnow Then exit
			If Field<>99 Then Cursor 0,messrow+2 : Print  Over "Field:";aa$ : aa$=""
			Field New
			MayStart=True       
		}
	}
End Sub
Sub OpenField3() 
	After 10 {
		Layer {
			Cursor 10,10
			Clear aa$
			aa$=inkey$
			If asc(aa$)<32 Then aa$=""
			input ! aa$, 20, 8,"Input", len(aa$)+1
			If exitnow Then exit            
			document aa$  \\ upgrade to document
			Cursor 0,messrow+2 : Print  Over "Field:";paragraph$(aa$,1) : aa$=""
			MayStart=True       
		}
	}
End Sub
Sub OpenField4() 
	After 10 {
		Layer {
			Cursor 10,10
			Clear aa$
			Document bb$=""  \\ this is a new variable, but not for Sub, Sub ends before this thread run.
			bb$=inkey$
			If asc(bb$)<32 Then Clear bb$
			Scroll Split 10
			Pen 11 {
				Edit.Doc bb$, 2,,Pen
			}
			If exitnow Then exit
			Cursor 0,messrow+2 : Print  Over "Field:";paragraph$(bb$,1) 
			Clear bb$
			MayStart=True
		}
	}
End Sub
}
MODULE WRITEWITH {Report {
	Write With  stringsep$, decimalse$ [, [JsonFlag], Nouseofchr34]
	
	stringsep$		only one char used, if "" then we get the default ","
	decimalse$	 	only one char used, if "" then we get the default "."
	jsonflag 		if non zero means enconding string using \n and other characters like json strings
				so we can put mulrinlie text withoutbreaking the line
	Nouseofchr34	a  no zero value means no "" araound a string.
	
	so Write With "", "" reset the writing using Write
	
	The same for Input #
	We use Input With as Write With
	We can define different set so we can read with one way and write with another.
	
	We can use ANSI or UTF16LE files
	For ANSI files we have to use LOCALE to set the locale for conversion
	A Local 1032 used for greek conversion.
	
}



Pen 11{Print "Ansi first"}
Print "Export csv using tab as seperator, and dot for decimal char"
open "testnochr34.csv" for output as k
Write With chr$(9), ".", ,1
Write #k, "Hello There", "And There", 1212.12, "Bye"
Close #k
Document docA$
Load.Doc docA$, "testnochr34.csv"   ' automatic get the file type
Print "The file as a string - tabs are expanded"
Pen 15 {report DocA$}
Print "ok..."
Print "Now we use Input # programming the separator and dot"
open "testnochr34.csv" for input as k
Input With chr$(9), ".", ,1
Input #k, A$, B$, C, D$
Close #k
Print "Results"
Print A$, B$, C, D$
Pen 11{Print "For UTF16LE wide chars"}
open "testnochr34.csv" for wide output as k
Write With chr$(9), ".", ,1
Write #k, "Hello There", "surrogate 𐐷", 1212.12, "1234 ברוכים הבאים abc"
Close #k
Document docA$
Load.Doc docA$, "testnochr34.csv"
Print "The file as a string - tabs are expanded"
Pen 15 {report DocA$}
open "testnochr34.csv" for wide input as k
Input With chr$(9), ".", ,1
Input #k, A$, B$, C, D$
Close #k
Print "Results"
Print A$, B$, C, D$
}
MODULE DUTCH {Report "Dutch Flag from Dijkstra"
const center=2
enum balls {Red, White, Blue}
fillarray=lambda a=(Red, White, Blue) (size as long=10)-> {
	if size<1 then size=1
	randomitem=lambda a->a#val(random(0,2))
	dim a(size)<<randomitem()
	=a()
}
Display$=lambda$ (s as array) ->{
	Document r$=eval$(array(s))
	if len(s)>1 then
	For i=1 to len(s)-1 {
		r$=", "+eval$(array(s,i))
	}
	end if
	=r$
}
TestSort$=lambda$ (s as array)-> {
	="unsorted: "
	x=array(s)
	for i=1 to len(s)-1 {
		k=array(s,i)
		if x>k then break
		swap x, k
	}
	="sorted: "
}
Positions=lambda mid=White (a as array) ->{
	m=len(a)
	dim Base 0, b(m)=-1
	low=-1
	high=m
	m--
	i=0
	medpos=stack
	link a to a()
	for i=m to 0 {
		if a(i)<=mid then exit
		high--
		b(high)=high
	}
	for i=0 to m {
		if a(i)>=mid then exit
		low++
		b(low)=low
	}
	if high-low>1 then
	for i=low+1 to high-1 {
		select case a(i)<=>Mid
		case -1
			low++ : b(low)=i
		case 1
		{
			high-- :b(high)=i
			if High<i then swap b(high), b(i)
		}
		else case
			stack medpos {data i}
		end select
	}
	end if
	if Len(medpos)>0 then
	dim c()
	c()=array(medpos)
	stock c(0) keep len(c()), b(low+1)
	for i=low+1 to high-1
   		if b(i)>low and b(i)<high and b(i)<>i then swap b(b(i)), b(i)	
	next i
	end if
	if low>0  then
		for i=0 to low
			if b(i)<=low and b(i)<>i then swap b(b(i)), b(i)
		next 
	end if
	if High<m then
		for i=m to High
			if b(i)>=High and b(i)<>i then swap b(b(i)), b(i)
		next 
	end if
	=b()
}
InPlace=Lambda (&p(), &Final()) ->{
	def i=0, j=-1, k=-1, many=0
	for i=0 to len(p())-1
		if p(i)<>i then
			j=i
			z=final(j)
			do
				final(j)=final(p(j))
				k=j
				j=p(j)
				p(k)=k
				many++
			until j=i
			final(k)=z
		end if
	next
	=many
}


Dim final(), p(), second(), p1()
Rem final()=(White,Red,Blue,White,Red, Red, Blue)
Rem final()=(white, blue, red, blue, white)

final()=fillarray(30)
Print "Items: ";len(final())
Report TestSort$(final())+Display$(final())
\\ backup for final() for second example
second()=final()
p()=positions(final())
\\ backup p() to p1() for second example
p1()=p()


Report Center,  "InPlace"
rem Print p()   ' show array items
many=InPlace(&p(), &final())
rem print p()  ' show array items
Report TestSort$(final())+Display$(final())
print "changes: "; many

Report Center, "Using another array to make the changes"
final()=second()
\\ using a second array to place only the changes
item=each(p1())
many=0
While item {
	if item^=array(item) else final(item^)=second(array(item)) : many++
}
Report TestSort$(final())+Display$(final())
print "changes: "; many
}
MODULE KNIGHT {Function KnightTour$(StartW=1, StartH=1){
	def boolean swapH, swapV=True
	if startW<=4  then swapH=true: StartW=8+1-StartW
	if startH>4  then swapV=False: StartH=8+1-StartH
	Let final=8*8, last=final-1, HighValue=final+1
	Dim Board(1 to 8, 1 to 8), Moves(1 to 8, 1 to 8)=HighValue
	f=stack:=1,2,3,4,5,6,7,8
	if 8-StartW=2 and StartH=2 then stack f {shift 1,-8}
	Function KnightMove(x,w,h) {
		a=2:b=1:z=1:p=1
		if x mod 2=1  then swap a,b
		if x>2 then p-! : if x>4 then swap z, p : if x>6 then p-!
		w+=z*a
		h+=p*b
		if w>=1 and w<=8 and h>=1 and h<=8 then =(w, h) else =(,)
	}
	For j=1 to 8 :For i=1 to 8
	s=stack
	For k=1 to 8
		m=KnightMove(stackitem(f, k),i, j)
		if len(m)>1 then Stack s {data m} 
	Next : Board(i,j)=s : Next 
           stack f {shift 1,-8}
	Next
	For i=1 to 8 :For j=1 to 8
	s=Board(i, j)
	if len(s)>2 then
		so=queue
		For k=1 to len(s)
			m=stackitem(s, k)
			Append  so, Len(Board(m#val(0), m#val(1))) :=m
		Next
		sort ascending so as number
		s=stack
		stack s {for k=0 to len(so)-1:data so(k!):next}
		Board(i,j)=s
	end if
	Next :	Next
	s= Board(StartW, StartH)
	n=0
	BackTrack=Stack
	Moves=1
	Moves(StartW, StartH)=1
	Repeat
	n++
	While n>len(s) {
		if Len(BackTrack)=0 then Print "Break", moves : Break
		Moves--
		Stack BackTrack {Read s, n}
		m=stackitem(s, n)
		Moves(m#val(0), m#val(1))=HighValue
		n++
	}
	m=stackitem(s, n)
	w=m#val(0)
	h=m#val(1)
	if Moves(w, h)>=Moves then
		if Moves<last then
		s1=Board(w, h) :ii=-1
		for i=1 to len(s1){m1=stackitem(s1, i) :if Moves(m1#val(0),m1#val(1))>moves then ii=i-1 : exit
		}
		if ii>=0 then
			Moves++
			Moves(w,h)=Moves
			Stack BackTrack {Push n, s}
			s=s1: n=ii
		end if
		else
			Moves++
			Moves(w,h)=Moves
		end if
	end if
	until Moves=final
	Document export$
	Inventory Tour
	letters=stack:="a","b","c","d","e","f","g","h"
	f=stack:=1,2,3,4,5,6,7,8
	if swapV Else stack f {Shift 1,-8}
	if swapH then stack letters {Shift 1,-8}
	For j=1 to 8:For i=1 to 8
		Append Tour, Moves(i,j) :=stackitem$(letters, i)+str$(stackitem(f, j),"")
	Next : Next
	Sort ascending Tour as number
	one=each(Tour)
	While one {
		export$=Eval$(one)
		if  not one^=last then export$="->"
		If (one^+1) mod 8=0 then
		export$={
		}
		End if
	}
	=export$
}
Document ex$
ex$= {Knight's Tour from a1

}+ KnightTour$()+{Knight's Tour from h1

}+ KnightTour$(8, 1)+{Knight's Tour from a8

}+KnightTour$(1, 8)+{Knight's Tour from h8

}+KnightTour$(8, 8)
Clipboard ex$
Report ex$
}
MODULE KNIGHTEXP {module Experiment(StartW=1, StartH=1, &mmm){
	Global ww=8, hh=8
	def boolean swapH, swapV=True
	if startW<=ww div 2  then swapH=true: StartW=ww+1-StartW
	if startH>hh div 2  then swapV=False: StartH=hh+1-StartH
	Form 80, 32
	Let final=ww*hh, last=final-1, HighValue=final+1
	Dim Board(1 to ww, 1 to hh), Moves(1 to ww, 1 to hh)=HighValue
	f=stack:=1,2,3,4,5,6,7,8
	if ww-StartW=2 and StartH=2 then stack f {shift 1,-8}
	Function KnightMove(x,w,h) {
		a=2:b=1:z=1:p=1
		if x mod 2=1  then swap a,b
		if x>2 then p-! : if x>4 then swap z, p : if x>6 then p-!
		w+=z*a
		h+=p*b
		if w>=1 and w<=ww and h>=1 and h<=hh then
			=(w, h)
		else
			=(,)
		end if
	}
	For j=1 to hh
	For i=1 to ww
	s=stack
	For k=1 to 8
		m=KnightMove(stackitem(f, k),i, j)
		if len(m)>1 then Stack s {data m} 
	Next
	Board(i,j)=s
	Next 
           stack f {shift 1,-8}
	Next
	For i=1 to ww
	For j=1 to hh
	s=Board(i, j)
	if len(s)>2 then
	so=queue
	For k=1 to len(s)
	m=stackitem(s, k)
	Append  so, Len(Board(m#val(0), m#val(1))) :=m
	Next
	sort ascending so as number
	s=stack
	stack s {
		for k=0 to len(so)-1
			data so(k!)
		next
	}
	Board(i,j)=s
	end if
	Next
	Next
	Print "Done"
	s= Board(StartW, StartH)
	n=0
	BackTrack=Stack
	Moves=1
	Moves(StartW, StartH)=1
	mstep=10
	mm=mstep
	mmm=0
	Repeat
	n++
	While n>len(s) {
		if Len(BackTrack)=0 then Print "Break", moves : Break
		Moves--
		Stack BackTrack {Read s, n}
		m=stackitem(s, n)
		Moves(m#val(0), m#val(1))=HighValue
		n++
	}
	m=stackitem(s, n)
	w=m#val(0)
	h=m#val(1)
	if Moves(w, h)>=Moves then
		if Moves<last then
		s1=Board(w, h) :ii=-1
		for i=1 to len(s1){m1=stackitem(s1, i) :if Moves(m1#val(0),m1#val(1))>moves then ii=i-1 : exit
		}
		if ii>=0 then
			Moves++
			Moves(w,h)=Moves
			Stack BackTrack {Push n, s}
			s=s1: n=ii
			mm--
		end if
		else
			Moves++
			Moves(w,h)=Moves
			mmm+=mm
			mm=0
		end if
	end if
	if mm Else
		cls
		Print "Moves:";Moves
		sj=hh: sj1=1: if swapV then swap sj, sj1
		si=1: si1=ww: if swapH then swap si, si1
		For j=sj to sj1: Print :For i=si to si1
			Print If(Moves(i,j)<=Moves->Moves(i,j), 0),
		Next : Next
		Print
		mm=mstep
		mmm+=mm
		Print mmm
		refresh 10000
	end if
	if mmm>1000 then mmm=-1:  exit
	until Moves=final
		cls
		Print "Moves:";Moves
		sj=hh: sj1=1: if swapV then swap sj, sj1
		si=1: si1=ww: if swapH then swap si, si1
		For j=sj to sj1: Print :For i=si to si1
			Print If(Moves(i,j)<=Moves->Moves(i,j), 0),
		Next : Next
		Print
		Print mmm
		Print "DONE"
		refresh 5000
}
dim res(1 to 8, 1 to 8)=0
for j=8 to 1
for i=1 to 8
Experiment i, j, &res(i, j)
next
next
Print
for j=8 to 1
for i=1 to 8
Print  res(i, j),
next
Print
next
}
MODULE ABC {chessgame {rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e4 1 1
r1bqkbnr/pppppppp/2n5/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 2 2
r1bqkbnr/pppppppp/2n5/8/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 3 2
r1bqkbnr/pppp1ppp/2n5/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq e5 4 3
r1bqkbnr/pppp1ppp/2n5/4p3/2B1P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 5 3
r1bqkbnr/ppp2ppp/2n5/3pp3/2B1P3/5N2/PPPP1PPP/RNBQK2R w KQkq d5 6 4
r1bqkbnr/ppp2ppp/2n5/1B1pp3/4P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 7 4
r1bqkbnr/1pp2ppp/p1n5/1B1pp3/4P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 8 5
r1bqkbnr/1pp2ppp/p1B5/3pp3/4P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 0 5
r1bqkbnr/2p2ppp/p1p5/3pp3/4P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 0 6
r1bqkbnr/2p2ppp/p1p5/3pN3/4P3/8/PPPP1PPP/RNBQK2R b KQkq - 0 6
r1bqkbnr/2p3pp/p1p2p2/3pN3/4P3/8/PPPP1PPP/RNBQK2R w KQkq - 1 7
r1bqkbnr/2p3pp/p1N2p2/3p4/4P3/8/PPPP1PPP/RNBQK2R b KQkq - 0 7
r1b1kbnr/2pq2pp/p1N2p2/3p4/4P3/8/PPPP1PPP/RNBQK2R w KQkq - 1 8
r1b1kbnr/2pq2pp/p4p2/N2p4/4P3/8/PPPP1PPP/RNBQK2R b KQkq - 2 8
r1b1kb1r/2pqn1pp/p4p2/N2p4/4P3/8/PPPP1PPP/RNBQK2R w KQkq - 3 9
r1b1kb1r/2pqn1pp/p4p2/N2p4/4P3/8/PPPP1PPP/RNBQ1RK1 b kq - 5 9
r1b1kb1r/2p1n1pp/p4p2/Nq1p4/4P3/8/PPPP1PPP/RNBQ1RK1 w kq - 6 10
r1b1kb1r/2p1n1pp/p4p2/1q1p4/4P3/1N6/PPPP1PPP/RNBQ1RK1 b kq - 7 10
r3kb1r/1bp1n1pp/p4p2/1q1p4/4P3/1N6/PPPP1PPP/RNBQ1RK1 w kq - 8 11
r3kb1r/1bp1n1pp/p4p2/1q1p4/3PP3/1N6/PPP2PPP/RNBQ1RK1 b kq d4 9 11
r3kb1r/1bp1n1pp/p4p2/1q6/3Pp3/1N6/PPP2PPP/RNBQ1RK1 w kq - 0 12
r3kb1r/1bp1n1pp/p4p2/1q6/3Pp3/1NP5/PP3PPP/RNBQ1RK1 b kq - 1 12
r3kb1r/1bp3pp/p4p2/1q3n2/3Pp3/1NP5/PP3PPP/RNBQ1RK1 w kq - 2 13
r3kb1r/1bp3pp/p4p2/1q3n2/3Pp3/1NP5/PP3PPP/RNBQR1K1 b kq - 3 13
r3k2r/1bp1b1pp/p4p2/1q3n2/3Pp3/1NP5/PP3PPP/RNBQR1K1 w kq - 4 14
r3k2r/1bp1b1pp/p4p2/1q3n2/3Pp3/1NP2P2/PP4PP/RNBQR1K1 b kq - 5 14
r3k2r/1bp1b1pp/p4p2/1q3n2/3P4/1NP2p2/PP4PP/RNBQR1K1 w kq - 0 15
r3k2r/1bp1b1pp/p4p2/1q3n2/3P4/1NP2P2/PP5P/RNBQR1K1 b kq - 0 15
r3k2r/1bp1b1pp/p4p2/1q6/3P4/1NP2Pn1/PP5P/RNBQR1K1 w kq - 1 16
r3k2r/1bp1b1pp/p4p2/1qN5/3P4/2P2Pn1/PP5P/RNBQR1K1 b kq - 2 16
r3k2r/2p1b1pp/p4p2/1qN5/3P4/2P2bn1/PP5P/RNBQR1K1 w kq - 0 17
r3k2r/2p1b1pp/p4p2/1qN5/3P4/2P2Qn1/PP5P/RNB1R1K1 b kq - 0 17
2kr3r/2p1b1pp/p4p2/1qN5/3P4/2P2Qn1/PP5P/RNB1R1K1 w - - 2 18
2kr3r/2p1b1pp/p4p2/1qN5/3P4/2P3Q1/PP5P/RNB1R1K1 b - - 0 18
2kr3r/2p3pp/p4p2/1qb5/3P4/2P3Q1/PP5P/RNB1R1K1 w - - 0 19
2kr3r/2p3pp/p4p2/1qP5/8/2P3Q1/PP5P/RNB1R1K1 b - - 0 19
2krr3/2p3pp/p4p2/1qP5/8/2P3Q1/PP5P/RNB1R1K1 w - - 1 20
2krR3/2p3pp/p4p2/1qP5/8/2P3Q1/PP5P/RNB3K1 b - - 0 20
2krR3/2p3pp/p4p2/2q5/8/2P3Q1/PP5P/RNB3K1 w - - 0 21
2kr4/2p3pp/p4p2/2q5/8/2P1R1Q1/PP5P/RNB3K1 b - - 1 21
2k5/2p3pp/p4p2/2q5/8/2P1R1Q1/PP5P/RNBr2K1 w - - 2 22
2k5/2p3pp/p4p2/2q5/8/2P1R1Q1/PP4KP/RNBr4 b - - 3 22
2k5/2p3pp/p4p2/2q5/8/2P1R1Q1/PP4KP/RNr5 w - - 0 23
2k5/2p3pp/p4p2/2q5/8/2P1R3/PP3QKP/RNr5 b - - 1 23
2k5/2p3pp/p4p2/6q1/8/2P1R3/PP3QKP/RNr5 w - - 2 24
2k5/2p3pp/p4p2/6q1/8/2P3R1/PP3QKP/RNr5 b - - 3 24
2k5/2p3pp/p4p2/3q4/8/2P3R1/PP3QKP/RNr5 w - - 4 25
2k5/2p3pp/p4p2/3q4/8/2P2R2/PP3QKP/RNr5 b - - 5 25
1k6/2p3pp/p4p2/3q4/8/2P2R2/PP3QKP/RNr5 w - - 6 26
1k6/2p3pp/p4p2/3q4/P7/2P2R2/1P3QKP/RNr5 b - a4 7 26
1k6/2p3pp/p4p2/8/P7/2P2R2/1P3QKP/RNrq4 w - - 8 27
1k6/2p3pp/p4p2/8/P2Q4/2P2R2/1P4KP/RNrq4 b - - 9 27
1k6/2p3pp/p4p2/8/P2Q4/2P2R2/1P4KP/RNr4q w - - 10 28
1k6/2p3pp/p4p2/8/P2Q4/2P2R2/1P3K1P/RNr4q b - - 11 28
1k6/2p3pp/p4p2/8/P2Q4/2P2R2/1P3K1q/RNr5 w - - 0 29
1k6/2p3pp/p4p2/8/P2Q4/2P1KR2/1P5q/RNr5 b - - 1 29
1k6/2p3pp/p4p2/8/P2Q4/2P1KR2/1P5q/RN2r3 w - - 2 30
1k6/2p3pp/p4p2/8/P2Q4/2PK1R2/1P5q/RN2r3 b - - 3 30
1k6/2p3pp/p4p2/8/P2Q4/2PK1R2/1P2q3/RN2r3 w - - 4 31
}
}
MODULE WORKER {Καθαρό
Οθόνη 5
Πένα 14
Φόρμα 80,60
Γενικές  Σταθερές  ειναιδενειναι$="; είναι ; δεν είναι ",  εχειδενεχει$="; έχει ; δεν έχει "
Κατάσταση ΜισθωτοιΛίστα, ΝέαΛίσταΑμκα, ΝέαΛίσταΑΦΜ, ΝέαΛίσταΕπωνΟνομα
\\ Βάση πινάκων 0
Βάση 0
\\ από δω και κάτω για το τμήμα αυτό η Κατάσταsη δεν είναι πια εντολή αλλά τμήμα

Τμημα Κατάσταση {
      Διάβασε &Α
      Για Α {
            Τύπωσε .όνομ_επών$+γραφη$(.Είναι_Άνεργος(),ειναιδενειναι$)+.Λεκτικό_Άνεργος$()
            Τύπωσε .όνομ_επών$+γραφη$(.Έχει_Προϋπηρεσία(),εχειδενεχει$)+"προϋπηρεσία"
      }
}
Τμήμα Πάτα_Διάστημα {
      Τύπωσε "<<<<<<<<<<< Πάτα Ένα Πλήκτρο >>>>>>>>>>>"
      α$=κομ$
}
Τμήμα Βιογραφικό {
      \\ τροποποίηση για να διαβάζει και με αναφορά και με τιμή
      \\ Περιμένει κάτι με υπερκλάση μισθωτός
      Αν Ταύτιση("Ο") τότε {
            Διαβασε Α
      } Αλλιώς Διάβασε &Α
      Τμήμα Εμφάνιση {
            ΑΑ$=""
            Διάβασε Α
            Διάβασε ? ΑΑ$
            Για Α {
                  Τύπωσε ΑΑ$, "Επιχείρηση με ΑΦΜ:"; .ΑφμΕργοδ$
                  Τύπωσε "","Ιδιότητα:";.ΙδιότηταΕργαζομένου$
                  Τύπωσε "","Απο ";Ημέρα$(.ΗμΠρόσλ);
                  Αν .Τελική=0 Τότε { Τύπωσε } Αλλιώς Τύπωσε " Έως ";Ημέρα$(.Τελική)
            }
      }
      Για Α {
            Πένα 15 {
                  Τύπωσε "Βιογραφικό",@(20),.όνομ_επών$
                  Τύπωσε "Φύλο",@(20),γραφη$(.Φύλο,"ΆΝΔΡΑΣ;;ΓΥΝΑΙΚΑ")
                  Τύπωσε "ΑΜΚΑ",@(20),.αμκα$
                  Τύπωσε "ΑΦΜ",@(20),.αφμ$
                  Τύπωσε "Έτη ασφάλισης",@(20),Γραφή$(.έτη_ασφ, "# ")+Γραφή$(.έτη_ασφ-1, "Χρόνια;Χρόνια;Χρόνο")
            }
            Πένα 13 {
                  Τύπωσε "Κατάσταση";
                  Αν .Είναι_Άνεργος() Τότε {
                        Τύπωσε γραφη$(.Είναι_Άνεργος(),ειναιδενειναι$)+.Λεκτικό_Άνεργος$()
                 } Αλλιώς {
                       Τύπωσε " εργάζεται"
                       Σωρός Νέος {
                             Πένα 14 {
                                   Εμφάνιση .τρέχουσα(0)
                             }
                        }
                  }
            }
            Αν .Έχει_Προϋπηρεσία() τότε {
                  Τύπωσε "Προϋπηρεσία"
                  κ=Διάσταση(.προϋπηρεσία(),1)
                  Για ι=κ-1 εως 0 {
                              Εμφάνιση .προϋπηρεσία(ι), μορφη$("{0::-3})", κ-ι)
                  }
            }
      }

}
Κλάση Εργασία {
      ΑφμΕργοδ$, ΙδιότηταΕργαζομένου$, ΗμΠρόσλ, Τελική
      Τμήμα Διακοπή_Συνεργασίας {
            Διάβασε .Τελική
            Αν .Τελική < .ΗμΠρόσλ Τότε Λάθος "Αδύνατη η διακοπή σε προηγούμενη μέρα"
      }
      Συνάρτηση Στοιχεία$ {
            =Σωρός$(.ΑφμΕργοδ$, .ΙδιότηταΕργαζομένου$, .ΗμΠρόσλ, .Τελική)
      }
      Τμήμα Στοιχεία {
            Διάβασε Α$
            Σωρός Α$
            Διάβασε .ΑφμΕργοδ$, .ΙδιότηταΕργαζομένου$, .ΗμΠρόσλ, .Τελική
      }
Κλάση:
      Τμήμα Εργασία {
            Αν όχι Κενό τότε {
                  Διάβασε .ΑφμΕργοδ$, .ΙδιότηταΕργαζομένου$, .ΗμΠρόσλ
            }
      }
}
Κλάση Μισθωτός {
      αμκα$, όνομ_επων$, φύλο, αφμ$, μισθός, έτη_ασφ, κρατήσεις
      πίνακας κλιμακα() \\ φορολογική κλίμακα
      πινακας προϋπηρεσία(), τρέχουσα()
      Θέσε {
            Διάβασε Ν
            Σωρός Νέος {
            Για Ν {
                  Σειρά .αμκα$, .όνομ_επων$, .φύλο, .αφμ$, .μισθός, .έτη_ασφ, .κρατήσεις, .κλιμακα(), .προϋπηρεσία(), .τρέχουσα()
            }
            Διάβασε .αμκα$, .όνομ_επων$, .φύλο, .αφμ$, .μισθός, .έτη_ασφ, .κρατήσεις, .κλιμακα(), .προϋπηρεσία(), .τρέχουσα()
            }
      }
Κλάση:
      Τμήμα Μισθωτός {
            Αν κενό τότε έξοδος
            Διάβασε .αμκα$, .όνομ_επων$, .φύλο, .αφμ$, .έτη_ασφ, .κλιμακα()
      }     

}
Κλάση ΥπερΜισθωτός {
      Τμήμα Εισαγωγή_μισθός_κρατήσεις {
            \\ κρατήσεις ως ποσοστό π.χ. 30 σημαίνει 30%
            \\ μισθός - μεικτά - μηνιαίος
            Αν .Είναι_Ανεργος() Τότε Λάθος "Δεν έχεις δώσει εργασία"
            Διάβασε .μισθός, .κρατήσεις
      }
      Συνάρτηση Είναι_Άνεργος {
            =Διάσταση(.τρεχουσα())=0
      }
      Συνάρτηση Λεκτικό_Άνεργος$ {
            Αν .Φύλο=1 Τότε { = "άνεργος" } Αλλιώς ="άνεργη"
      }
      Συνάρτηση Έχει_Προϋπηρεσία {
            =Διάσταση(.προϋπηρεσία())<>0
      }
      Τμήμα Πρόσληψη {
            Αν Δεν .Είναι_Ανεργος() Τότε Λάθος "Δεν είναι "+.Λεκτικό_Άνεργος$()
            Πίνακας .τρέχουσα(1)
            Διάβασε .τρέχουσα(0)
      }
      Τμήμα Διακοπή_Εργασίας {
            Αν .Είναι_Ανεργος() Τότε Λάθος "Είναι "+.Λεκτικό_Άνεργος$()
            \\ αφήνουμε την ημερομηνία για το άλλο τμημα:
            .τρέχουσα(0).Διακοπή_Συνεργασίας
            κ=Διάσταση(.προϋπηρεσία())
            Αν κ=0 τότε {
                  κ=1
                  Πίνακας .προϋπηρεσία(1)=Εργασια()
             } αλλιώς {
                  κ=Διάσταση(.προϋπηρεσία(),1)+1
                  Πίνακας .προϋπηρεσία(κ)
            }
            .προϋπηρεσία(κ-1)=.τρέχουσα(0)
            Πίνακας .τρέχουσα()
      }
      Συνάρτηση Στοιχεία$ {
            Εγγραφο Α$
            Α$=Σωρός$(.αμκα$, .όνομ_επων$, .φύλο, .αφμ$, .μισθός, .έτη_ασφ, .κρατήσεις)
            κ=Διάσταση(.κλιμακα())
            Αν κ<>2 τότε {
                  Α$=Σωρός$(0)
            } Αλλιώς {
                  Α$=Σωρός$(Διάσταση(.κλιμακα(),1))
                  Για ι=0 έως Διάσταση(.κλιμακα(),1)-1 {
                        Α$=Σωρός$(.κλιμακα(ι,0),.κλιμακα(ι,1))
                  }
            }
            κ=Διάσταση(.τρέχουσα())
            Αν κ=0 τότε {
                  Α$=Σωρός$(0)
            } αλλιώς {
                  Α$=Σωρός$(Διάσταση(.τρέχουσα(),1))
                  Για ι=0 έως Διάσταση(.τρέχουσα(),1)-1 {
                        Α$=Σωρός$(.τρέχουσα(ι).στοιχεία$())
                  }
            }
            κ=Διάσταση(.προϋπηρεσία())
            Αν κ=0 τότε {
                  Α$=Σωρός$(0)
            } αλλιώς {
                  Α$=Σωρός$(Διάσταση(.προϋπηρεσία(),1))
                  Για ι=0 έως Διάσταση(.προϋπηρεσία(),1)-1 {
                        Α$=Σωρός$(.προϋπηρεσία(ι).στοιχεία$())
                  }
            }
            =Α$
      }
      Τμήμα Στοιχεία {
            Διάβασε Α$
            Σωρός Α$
            Διάβασε .αμκα$, .όνομ_επων$, .φύλο, .αφμ$, .μισθός, .έτη_ασφ, .κρατήσεις
            Διαβασε κ
            Αν κ>0 τότε {
                  Πίνακας .κλιμακα(κ,2)
                  Για ι=0 έως κ-1 {
                  Διάβασε .κλιμακα(ι,0), .κλιμακα(ι,1)
                  }
            } Αλλιώς {
                  Πίνακας .κλιμακα()
            }
            Διάβασε κ
            Αν κ>0 τότε {
                  Πίνακας .τρέχουσα(0)
                  Πίνακας .τρέχουσα(κ)=Εργασια()
                  Για ι=0 έως κ-1 {
                        .τρέχουσα(ι).στοιχεια γράμμα$
                  }
            } Αλλιώς {
                  Πίνακας .τρέχουσα(0)
            }
            Διάβασε κ
            Αν κ>0 τότε {
                  Πίνακας .προϋπηρεσία(0)
                  Πίνακας .προϋπηρεσία(κ)=Εργασια()
                  Για ι=0 έως κ-1 {
                        .προϋπηρεσία(ι).στοιχεια γράμμα$
                  }
            } Αλλιώς {
                  Πίνακας .προϋπηρεσία(0)
            }
      }
      \\ εδώ στον κατασκευαστή ορίζουμε μια κλάση
Κλάση:
      Τμήμα ΥπερΜισθωτός {
            Αν Κενό τότε {
                  Αυτό=Μισθωτός()
            } αλλιώς {
                  Διάβασε Μισθ
                  Αυτό=Μισθ
            }
      }
}

\\\\   ΚΥΡΙΟ ΠΡΑΓΜΑ  ////

Πίνακας Φορολογία(5,2)
Φορολογία(0,0)=10000,22,10000,35,10000,50
Προσθήκη ΜισθωτοιΛίστα, 12345123451:=Μισθωτός("12345123451","ΚΥΡΙΟΣ ΧΑΡΗΣ",1,"012341234", 5, Φορολογία())
Προσθήκη ΜισθωτοιΛίστα, 32345123451:=Μισθωτός("32345123451","ΑΝΕΤΗ ΧΑΡΟΥΛΑ",0,"052341234", 1, Φορολογία())
Μισθωτοι=Μήκος(ΜισθωτοιΛίστα)


\\ Η Για αντικείμενο {} ανοίγει ομάδες για επεξεργασία και στην έξοδο τα κλείνει πάλι στη θέση του
\\ αν το πειράξουμε από αλλού, "γνωρίζει" ότι έχει ανοίξει και άμεσα δουλεύουμε με το ανοιχτό.
\\ Σε όλο το πρόγραμμα δεν δουλεύουμε με δείκτες σε ομάδες (αντικείμενα)
\\ Κάθε αντικείμενο υπάρχει σε μια θέση μόνο.

\\ Στην αρχή έχουμε στη κατάσταση  ΜισθωτοιΛίστα αντικείμενα Μισθωτός
\\ Στην πορεία βάζουμε επιπλέον μέλη, από την ΥπερΜισθωτός.
\\ Στα νέα μέλη κάνουμε ενέργειες, όπως Πρόσληψη και Διακοπή
\\ Στην πρόσληψη βάζουμε ένα αντικείμενο Εργασία.
Πένα 13 {
    Οθόνη , 0
    Αναφορά "Φάση Πρώτη"
    Αναφορά "Βάζουμε στοιχεία εργασίας για κάθε μισθωτό"
    Οθόνη , 4
}
Για ΜισθωτοιΛίστα(12345123451) {
      Προσωρινό=ΥπερΜισθωτός(Αυτό)
      Για Προσωρινό {
            Κατάσταση &Προσωρινό
            Πένα 15 { Τύπωσε "Πρόσληψη 12/10/2015" }
            ..Πρόσληψη Εργασία("912341234","Ιδ. Υπάλληλος",ημερα("12/10/2015"))
            Κατάσταση &Προσωρινό
            Πένα 15 { Τύπωσε "Διακοπή 14/12/2015" }
            ..Διακοπή_Εργασίας ημερα("14/12/2015")
            Κατάσταση &Προσωρινό
            Πένα 15 { Τύπωσε "Πρόσληψη 11/1/2016" }
            ..Πρόσληψη Εργασία("992341235","Ιδ. Υπάλληλος",ημερα("11/1/2016"))
            Κατάσταση &Προσωρινό
            Πένα 15 { Τύπωσε "Διακοπή 1/2/2016" }
            ..Διακοπή_Εργασίας ημερα("1/2/2016")
            Κατάσταση &Προσωρινό
      }
      Αυτό=Προσωρινό
      \\ εδώ έχουμε ειδική = για να μην κάνει συγχώνευση στα πάντα!
      \\ κοίτα τη Θέσε στο Μισθωτρός()
      \\ η Προσωρινό περνάει στη Θέσε και από αυτήν φορτώνει ότι χρειάζεται το τρέχον αντικείμενο
      \\ Έτσι αντί να έχουμε τα πάντα στο ΜισθωτοίΛίστα
      \\ παίρνουμε το αντικείμενο και το βάζουμε σε ένα νέο αντικείμενο Υπερομισθωτός
      \\ και δουλεύουμε σε αυτό!
}
Για ΜισθωτοιΛίστα(32345123451) {
      Προσωρινό=ΥπερΜισθωτός(Αυτό)
      Για Προσωρινό {
            Κατάσταση &Προσωρινό
            Πένα 15 { Τύπωσε "Πρόσληψη 12/10/2015" }
            ..Πρόσληψη Εργασία("912341234","Διευθυντής",ημερα("12/10/2015"))
            Κατάσταση &Προσωρινό
      }
      Αυτό=Προσωρινό
}
Για ι=0 έως Μισθωτοι-1 {
      Για ΜισθωτοιΛίστα(ι!) {
            Προσωρινό=ΥπερΜισθωτός(Αυτό)
            Αν .αμκα$<>"" τότε Βιογραφικό &Προσωρινό
            \\ εδώ δεν αλλάζουμε τιμές οπότε δεν χρειάζεται η Αυτό=Προσωρινό
      }
}
Σημ {
    Για Αυτό {
          Προσωρινό2=ΥπερΜισθωτός(ΜισθωτοίΛίστα(12345123451))
          Βιογραφικό &Προσωρινό2
    }
}
Πάτα_Διάστημα
Πενα 13 {
    Οθόνη , 0
    Αναφορά "Φάση Δεύτερη"
    Αναφορά "Γράφουμε σε αρχείο"
    Οθόνη , 4
}
κ=1
Τύπωσε {Ανοιξε "αλφα.μισθ"  για ευρεια εξαγωγή ως κ}
Ανοιξε "αλφα.μισθ"  για ευρεια εξαγωγή ως κ
Για ι=0 έως 1 {
      Για ΜισθωτοίΛίστα(ι!) { \\ ο χαρακτήρας ! δηλώνει ότι το ι δεν είναι κλειδί αλλά αριθμός σειράς από το 0
            Προσωρινό=ΥπερΜισθωτός(Αυτό)
            Τύπωσε Μετάθεση(#κ), " - θέση του δρομέα του αρχείου που θα γραφτεί το παρακάτω"
            Βιογραφικό &Προσωρινό
            \\ Τύπωσε .στοιχεία$()
            Τύπωσε #κ, Προσωρινό.στοιχεία$()
      }
      Τύπωσε
}
Κλείσε #κ
Τύπωσε "Τέλος εγγραφής"
Πάτα_Διάστημα
Πενα 13 {
    Οθόνη , 0
    Αναφορά "Φάση Τρίτη"
    Αναφορά "Διαβάζουμε από αρχείο, με άμεση εμφάνιση, χωρίς να φορτώσουμε  μόνιμα όλο το αρχείο"
    Οθόνη , 4
}
Τύπωσε "Μήκος αρχείου:";αρχείου.μήκος("αλφα.μισθ")
Ανοιξε "αλφα.μισθ"  για ευρεια εισαγωγή ως κ
Ενώ όχι τέλος(#κ) {
     Τύπωσε Μετάθεση(#κ), " - θέση του δρομέα του αρχείου που διαβάστηκε το παρακάτω"
     Γραμμή Εισαγωγής #κ, α$
     Προσωρινό=ΥπερΜισθωτός()
     Προσωρινό.στοιχεία α$
     Βιογραφικό &Προσωρινό
}
Κλείσε #κ
Τύπωσε "Τέλος ανάγνωσης"
Πάτα_Διάστημα
Πενα 13 {
    Οθόνη , 0
    Αναφορά "Φάση Τέτσρτη"
    Αναφορά "Διαβάζουμε από αρχείο σε πίνακα, και βάζουμε  κλειδιά για άμεση αναζήτηση σε καταστάσεις (λίστες)"
    Οθόνη , 4
}
Τύπωσε "Μήκος αρχείου:";αρχείου.μήκος("αλφα.μισθ")
\\ στους πίνακες που ορίζουμε από μια κλάση
\\ καταχωρούνται οι συναρτήσεις/μέθοδοι μια φορά

Πίνακας άλλος(10)=ΥπερΜισθωτός()
Ανοιξε "αλφα.μισθ"  για ευρεια εισαγωγή ως κ
ι=0
Ενώ όχι τέλος(#κ) {
     Γραμμή Εισαγωγής #κ, α$
     Για Άλλος(ι) {
            .στοιχεία α$
           Προσθήκη ΝέαΛίσταΑμκα, .αμκα$:= ι
           Προσθήκη ΝέαΛίσταΑΦΜ, .αφμ$:= ι
           Προσθήκη ΝέαΛίσταΕπωνΟνομα .όνομ_επων$:=ι
           Βιογραφικό &Αυτό
           Τύπωσε "Καταχωρήθηκε..."
           ι++
     }
}
Κλείσε #κ
Τύπωσε "Τέλος ανάγνωσης"
Ταξινόμηση ΝέαΛίσταΕπωνΟνομα
Τύπωσε "Ταξινόμηση"
Πάτα_Διάστημα
Πενα 13 {
    Οθόνη , 0
    Αναφορά "Φάση Πέμπτη"
    Αναφορά "Αναζητήσεις στο αρχείο που έχουμε φορτώσει"
    Οθόνη , 4
}
Τύπωσε "Αναζήτηση αμκα: 12345123451"
Αν Υπάρχει(ΝέαΛίσταΑμκα, 12345123451) τότε {
      Τύπωσε "Βρέθηκε"
      Τύπωσε "Στό επώνυμο/όνομα: ";
      Πένα 11 { Τύπωσε άλλος(εκφρ(ΝέαΛίσταΑμκα)).όνομ_επων$}
}
Τύπωσε "Αναζήτηση ΑΦΜ: 052341234"
Αν Υπάρχει(ΝέαΛίσταΑΦΜ, "052341234") τότε {
      Τύπωσε "Βρέθηκε"
      Τύπωσε "Στό επώνυμο/όνομα: ";
      Πένα 11 { Τύπωσε άλλος(εκφρ(ΝέαΛίσταΑΦΜ)).όνομ_επων$}
}
Τύπωσε "Λίστα με αλφαβητική σειρά"
Πένα 15 {
      Επαναλήπτης=Κάθε(ΝέαΛίσταΕπωνΟνομα)
      Ενώ Επαναλήπτης {
            Τύπωσε Επαναλήπτης^+1, Άλλος(Εκφρ(ΝέαΛίσταΕπωνΟνομα)).όνομ_επών$            
      }
      Πένα 11 {
          Τύπωσε"",  "Με ανάποδη σειρά..."
      }
      Επαναλήπτης=Κάθε(ΝέαΛίσταΕπωνΟνομα Τέλος Εως Αρχη)
      Ενώ Επαναλήπτης {
            Τύπωσε Επαναλήπτης^+1, Άλλος(Εκφρ(ΝέαΛίσταΕπωνΟνομα)).όνομ_επών$            
      }
}
}
MODULE SUP {Super=Lambda -> {
    SuperClass A {
    Unique:
        counter
        Function Add2counter {
              .counter++
              =.counter
        }
    Private:
        Function Many  {
              For SuperClass {
                    =.counter
              }                  
        }
    Public:
        id=0
        stuff$=""
        Property Total {
              value {
                   link parent Many() to Many()
                   value=Many()
              }
        }
        Value (a$="") {
            if a$="" else
                .stuff$<=a$
                For this, SuperClass {
                    .id<=..Add2Counter()
                }
            end if
            =This
        }
        \\ without Set because we have value, the group  use as read only
        \\ but we want to get a copy.
        Set {
            Read tmp
            if tmp.id<>.id then Error "not allowed to copy this"
            \\ do not use  This=Group(tmp) or This = tmp
            \\ because you are in This=
            \\ so we use Let, because Let is a set of two statements:
            \\ A push and a Read, so Let This=tmp  is push tmp: read This
            \\ The Read This not call Set function
            Let This=tmp
        }
    }
    \\ A is superclass has all members inside
    \\ a superclass always return a group with a pointer to superclass
    =A
}()   ' auto execute using ()
A=Super("Babis")
A1=A
B=Super("George")
C=Super("Sofia")
Print A.id, A.stuff$
Print A1.id, A1.stuff$, " a copy of A"
Print B.id,  B.stuff$
Print C.id,  C.stuff$
Print "Total New Names:";A.total

Module Inner (Z) {
	Print  Z.id, Z.stuff$
	M=Z
	M=M("New Name")
	\\ So now we get: 4  New Name
	Print M.id,  M.stuff$
}
\\ We pass by value, bat superclass passed  using pointer
Inner B
\\ And at return from Inner
\\ We make another one the 5th
D=Super("Last Name")
Print D.id, D.stuff$
Print "Total New Names:"; A.total
Try ok  {
    Print "try to copy A to B"
    B=A
}
\\ If Ok is  False the error is in the level of Try block
\\ but we check Error if we have error deeper
If ok Then Print "Error not in Try at first level"
If Error Then
	Print "Error from something we call  in Try Block"
	Print "B=A";Error$
	Print "Error value now is 0. Each time we read Error change to "; Error
End if

}
MODULE REMTST {module test1 {
	Pen 15 {Print "test1: Deconstructor called automatic"}
	class alfa {
		remove {
			Print "remove"
		}
	}
	Dim A(10)<<Pointer(alfa())
	Print "delete 5"
	Dim A(5)
	Print "Now exit"
}
module test2 {
	Pen 15 {Print "test2: insert 8001 variables"}
	For i=1 to 8000
		local i 
	next i
	Print "now make a pointer to point a group"
	class alfa {
		remove {
			for i=1 to 10000
			local i
			next
			print "ok"
		}
	}
	m->alfa()
	Print "now module end and deconstructor make 10001 variables"
}
module test3 {
	Pen 15 {Print "test3: A class with a group and one inner group"}
	class alfa {
		remove {
			clear .zeta
			Print "top removed"
		}
		group zeta {
			remove {
				print "inner group zeta removed"
			}
		}
	}
	Print "We make a new stack for values for immediate use"
	Stack New {
		Push alfa()
		Print "now stack erased"
	}
	Print "The inner .zeta removed when we use Clear .zeta inside top deconstructor"
	Print "Now we make a tuple with one item of class alfa()"
	A=(alfa(),)
	Print "end module so tuple erased, and automatic deconstructor executed"
}
module test4 {
	Pen 15 {Print "test4: A class with a group and one pointer to group"}
	class beta {
		remove {
			Pen 11 {print "group class beta removed"}
		}
	}
	class alfa {
		remove {
			clear .zeta
			Print "top removed"
		}
		zeta=Pointer(Beta())
	}
	Print "we make K as named group, not a pointer"
	K=alfa()
	Print "we can execute top group remove function using Clear K"
	Print "but for the example we leave it as is"
	Print "so expected only the pointer to execute the remove function"
}
test1
test2
test3
test4
cursor 5
Report {
	   M2000 Interpreter start with a minimum of 3000 places for variables in an array of variants and a hash table for searching.
	Each time we need more than current variables capacity the variables array and hashtable doubled in size. The new limit may reduced when a module exit.
	When that happen at the reducing, if an object need to execute the Remove member (Deconstructor) then new variables added and a new reducing happen (becaue the member called as module).
	Hashtable has two arrays, an array of keys and other stuff, and the hash array. When we change the size of hash table a new rehashing happened.
	The hash algorithm produce two numbers, one depend from key, and the second depend from first number and size of hash table. Hash table has two times and some more items to avoid collisions. When a collision dedected the new item get the old item in linked list and placed first, as the hash table indicate.
	So when two times (or more) reender the reducing function, a static variable prevents except the first one to reduce the array, and only make a cleaning process. So expanding may happen but reducing happen once, for the first call.
	Old versions from 9.9 revision 28, cant did that, because of arrays locks. To prevent lock, was easy. We get the pointer in a variant as a copy, then we place nothing to array place, and then we place nothing to variant which fires the remove member. Also old versions have a bug when reducing the variables array, so the removing function had array index overflow error. Because interpreter compiled without index control to internal arrays, a hang was the result of that bug. The bug was not a problem in previous revisions, because never happen reentrance of the reducing function, and other part of code balanced the use of these arrays nice.
	}, width-10
}
MODULE OOP_GR_EX {Δρομέας 5
Αναφορά {
	Αποστολή λουλουδιών - Παράδειγμα από το σχολικό βιβλίο της 3ης Λυκείου
	
	Με χρήση γεγονότων, και διαδοχικών γεγονότων, προς τα πίσω
	Το παράδειγμα του βιβλίου δείχνει ενέργειες σε κουτάκια αναπαράστασης αντικειμένων. Αυτά τα κουτιά έχουν μια χρησιμότητα αλλά μικρή. Το ζήτημα εδώ είναι να φανεί πως τα αντικείμενα μπορούν να ξεχωρίσουν από το πως καταχωρούνται τα δεδομένα. Έτσι ενώ έχουμε κλάσεις που ομαδοποιούν στοιχεία, και έχουν ενσωματωμένη λογική σε μεθόδους, δεν έχουμε μια ιδέα για το που βρίσκονται τα αντικείμενα, που αποθηκεύονται και πως γίνεται μέσα από το αντικείμενο να συνδεόμαστε με μια αποθήκη άγνωστη σε αυτό!
	Εδώ τα αντικείμενα κάνουν κλήσεις σε γεγονότα. Αν δεν γράψουμε συναρτήσεις εξυπηρέτησης γεγονότων οι κλήσεις θα γίνονται σε "άδειες" συναρτήσεις.
	Τα ιδιαίτερα χαρακτηριστικά αυτών των συναρτήσεων είναι:
		1	Πρέπει να ορίσουμε ένα επώνυμο αντικείμενο για να στέλνει στο τμήμα που το ορίσαμε τις κλήσεις.
		2	Οι συναρτήσεις τρέχουν σαν να είναι κώδικας του τμήματος που γράφτηκαν.
		3	Για το λόγο (2) διαβάζουμε τιμές με την Διάβασε Νέο όταν θέλουμε μια μεταβλητή  να δημιουργηθεί οπωσδήποτε.
		4	Επίσης νέες μεταβλητές τις γράφουμε με το Τοπική ή Τοπικές. Ακόμα και πίνακες να κάνουμε θα γράψουμε Τοπική Α(10).
		5	Λόγω του (2) βλέπουμε ότι μεταβλητές, τμήματα και συναρτήσεις έχουμε ορίσει στο τμήμα.
		6	Αυτές οι συναρτήσεις γεγονότων δεν επιστρέφουν τιμή με το =
		7	Αν θέλουμε χρησιμοποιούμε πέρασμα με αναφορά με χρήση του & πριν το όνομα.
	
	Στο πρόγραμμα ορίζουμε σε μια μέθοδο του Ανθοπώλη ένα νέο αντικείμενο Ανθοπώλης με γεγονότα. Υπάρχει γεγονός που καλεί ο "εσωτερικός" Ανθοπώλης και η συνάρτηση εξυπηρέτησης καλεί το γεγονός του Ανθοπώλη που περιέχει τον εσωτερικό. Ο εσωτερικός διαλέγεται με γεγονός.
	
	Τα ονόματα Μαμά, Γιώργος, Τζιοβάνι, Αντόνιο, Πέπε, Αντόνιο βρίσκονται έξω από τα αντικείμενα. Όλο το πρόγραμμα είναι μια γραμμή:
	
	Παραγγελία("Μαμά", "Γιώργος", "Άννα")
	
	Η Παραγγελία() είναι ρουτίνα. Μέσα σε αυτήν κάνουμε όλη την εργασία, ενώ σε ένα σημείο μεταφέρεται εντός του Κύριου αντικειμένου, όπου εργάζεται ο συνεργάτης του αρχικού. Για να αντιληφθεί κανείς τον τρόπο που "μπαίνουν" αντικείμενα μέσα σε αντικείμενα:
	
	Δείτε αυτό:  Συνάρτηση ΑποδέχεταιΣυνεργασία(Πελάτης) που είναι μέλος της κλάσεως Ανθοπώλης. Εκεί δημιουργούμε ένα "κενό" Ανθοπώλη και καλούμε ένα γεγονός με πέρασμα του "κενού" με αναφορά. Αν υπάρχει ανθοπώλης για συνεργασία, θα μπει σε αυτό το "κενό". Έτσι με την επιστροφή από το γεγονός θα συμβαίνουν ένα από τα δύο:
		1	Να υπάρχει συνάρτηση εξυπηρέτησης οπότε θα έχουμε ένα όνομα τουλάχιστον μέσα στα μέλη του Ανθοπώλη
		2	Να μην υπάρχει κάτι οπότε θα γυρίσει κενός όπως τον στείλαμε. Ελέγχουμε το όνομα και ανάλογα πράττουμε.
	
	
	}, πλάτος-10
Τύπωσε
Κλάση Πελάτης {
      Όνομα$, Επώνυμο$, Διεύθυνση$,
      Τηλέφωνο$, Emali$
      Συνάρτηση ΚάνειΠαραγγελια  (&Ανθοπώλης, Εκει$){
            =Ανθοπώλης.ΔέχεταιΠαραγγελία(&Αυτό, Εκει$)
      }
      Τμήμα ΠαραλαμβάνειΑνθοδέσμη {
            Τύπωσε "Παραλήφθηκε"
      }
Κλάση:
	Τμήμα Πελάτης (.Όνομα$) {}
}
Κλάση Ανθοπώλης {
      Γεγονότα "ΒρεςΑνθοπώλη", "ΒρεςΑνθοδέτη"
      Γεγονότα "ΒρεςΤαχυμεταφορέα", "ΒρεςΠελάτη"
      Γεγονότα  "ΑνάθεσηΑνθοπώλη", "ΑνάθεσηΑνθοδέτη"
      Επωνυμία$,
      Όνομα$, Επώνυμο$,
      Διεύθυνση$, ΑΦΜ$,
      Τηλέφωνο$, Emali$,
      Τραπεζικός_Λογαρασμός$, Κωδ_Δικ_Συν
      Συνάρτηση ΔέχεταιΠαραγγελία (&Πελάτης, Εκει$) {
            Πελάτης=Πελάτης()
            Κάλεσε Γεγονός "ΒρεςΠελάτη", Αυτό, &Πελάτης, Εκει$
            Αν Πελάτης.Όνομα$="" Τότε Έξοδος
            \\ φτιάχνουμε ένα Ανθοπώλη εντός ενός Ανθοπώλη
            \\ με γεγονότα. Αρχικά είναι κενός-χωρίς στοιχεία
            \\ αλλά παρακάτω θα του βάλουμε στη ζήτηση συνεργασίας
            Ομάδα ΜεΓεγονότα Ανθοπώλης=Ανθοπώλης()
            Συνάρτηση Ανθοπώλης_ΒρεςΑνθοδέτη(Νέο &ποιος, &ανθοδέτης, Προορισμος$)  {
                  Τύπωσε "ο ";ποιος.ονομα$;" κοιτάει για Ανθοδέτη"
                  Κάλεσε Γεγονός "ΒρεςΑνθοδέτη", ποιος, &ανθοδέτης, Προορισμος$
                  Αν ανθοδέτης.Όνομα$="" Τότε Τύπωσε "Δεν βρέθηκε Ανθοδέτης": Έξοδος
                  Τύπωσε "Βρέθηκε Ανθοδέτης ο ";ανθοδέτης.Όνομα$
                  \\ εδώ μεσολαβεί κώδικας που δίνει πληροφορίες στον ανθοδέτη
                  \\ και αμέσως μετά τον καταχωρούμε πίσω στη βάση
                 Κάλεσε Γεγονός "ΑνάθεσηΑνθοδέτη", ποιος, &ανθοδέτης
            }
            Συνάρτηση Ανθοπώλης_ΒρεςΤαχυμεταφορέα {
                Πένα 15 {Τύπωσε "Διαδοχικό γεγονός"}
                Κάλεσε Γεγονος "ΒρεςΤαχυμεταφορέα" Διαδοχικό
                \\ μεταφετει τις παραμέτρους όπως τις λαμβάνει
                \\ στο παραπάνω αντικείμενο
            }
            .ΖητάΣυνεργασία &Ανθοπώλης, Πελάτης.Όνομα$
            Αν Ανθοπώλης.ΑποδέχεταιΣυνεργασία(Πελάτης) Τότε
                Τύπωσε "όλα καλά!"
                \\ πληρώνεται προκαταβολικά!
                =Αληθής
            Αλλιώς
                  Τύπωσε "Πρόβλημα συνεργασίας"
                  =Ψευδής
            Τέλος Αν
      }
      Τμήμα ΖητάΣυνεργασία (&Ανθοπώλης, Προορισμός$) {
                  Κάλεσε Γεγονος "ΒρεςΑνθοπώλη", Αυτό,  &Ανθοπώλης, Προορισμός$
      }
      Συνάρτηση ΑποδέχεταιΣυνεργασία(Πελάτης) {
            Αν .Ονομα$="" Τοτε Εξοδος
            Αν Πελάτης.Όνομα$="" Τότε Έξοδος
            Προορισμός$=Πελάτης.Όνομα$
            Ανθοδέτης=Ανθοδέτης()
            Κάλεσε Γεγονος "ΒρεςΑνθοδέτη", &Αυτό, &Ανθοδέτης, Προορισμός$
            Αν Ανθοδέτης.Όνομα$="" Τότε Έξοδος
            \\ Ανάθεση Ανθοδοσίας  Τζιοβάνι - Αντόνιο
            Αν .ΑναθέτειΑνθοδεσία(&Ανθοδέτης) Τότε
                Ποιος=Ταχυμεταφορέας()
                Κάλεσε Γεγονός "ΒρεςΤαχυμεταφορέα", Αυτο, &Ποιος, Προορισμός$
                Αν Ποιος.Ονομα$<>"" Τότε
                    Ενώ Ανθοδέτης.ΕτοιμάζειΑνθοδέσμη()
                             \\ αναμονή μέχρι να την φτιάξει
                             \\ περιμένουμε Ψευδής για να τερματίσει η Ενώ
                    Τέλος Ενώ
                    Τύπωσε "Έτοιμη η ανθοδέσμη από τον ";Ανθοδέτης.Όνομα$
                    .ΑναθέτειΠαράδοση &Ποιος, Προορισμός$
                    Τύπωσε "ο ";Ποιος.Όνομα$;" παραδίδει στο προορισμό ";Προορισμός$
                    Ενώ Ποιος.ΠαραδίδειΑνθοδέσμη(&Πελάτης)
                \\ γίνεται άμεσα!
                    Τέλος Ενώ
                    =Αληθής
                Αλλιώς
                    Τύπωσε "Ατυχία δεν έχω άτομο να την παραδόσω"
                Τελος Αν
            Τέλος Αν
      }
      Συνάρτηση ΑναθέτειΑνθοδεσία(&Ανθοδέτης) {
            \\ εδώ πρέπει να έχουμε ασύγχρονη λειτουργία
            \\ έστω ότι το κάνει άμεσα!
            \\ η Ενώ είναι σαν την Όσο της ΓΛΩΣΣΑΣ
            Τύπωσε "Ο ";Ανθοδέτης.Όνομα$;" ετοιμάζει την ανθοδέσμη άμεσα"
            =Αληθής
      }
      Τμήμα ΑναθέτειΠαράδοση (&Ταχυμεταφορέας, Εκει$) {
             \\ Την Αννα την βρίσκει από μια λίστα εκκρεμοτήτων.
             \\ Παράδοση Πέπε - Άννα
            
       }
Κλάση:
      Τμήμα Ανθοπώλης (.Όνομα$) {}
 }
Κλάση Ανθοδέτης {
      Επωνυμία$,
      Όνομα$, Επώνυμο$, Διεύθυνση$,
      ΑΦΜ$, Τηλέφωνο$,
      Emali$, Ειδικότητα$, Ωριαία_αμοιβή
      Συνάρτηση  ΕτοιμάζειΑνθοδέσμη {
            \\ όσο ετοιμάζει είναι αληθής
            \\ εδώ δίνουμε άμεσα ψευδής
            \\ την ετοίμασε σε χρόνο dt
            =Ψευδής
      }
Κλάση:
	Τμήμα Ανθοδέτης (.Όνομα$) {}
}
Κλάση Ταχυμεταφορέας {
      Επωνυμία$,
      Όνομα$, Επώνυμο$, Διεύθυνση$,
      ΑΦΜ$, Τηλέφωνο$,
      Emali$,   Τύπος$
      Συνάρτηση ΠαραδίδειΑνθοδέσμη (&Πελάτης){
          \\ με Αληθής ακόμα παραδίδει, με ψευδής παρέδωσε
                Πελάτης.ΠαραλαμβάνειΑνθοδέσμη
          =Ψευδής
      }
Κλάση:
      Τμήμα Ταχυμεταφορέας (.Όνομα$) {}
}
\\\ Καταστάσεις με αντικείμενα (όλες με κλειδί το όνομα)
Κατάσταση Πελάτες= "Μαμά":=Πελάτης("Μαμά"), "Άννα":=Πελάτης("Άννα")
Κατάσταση Ανθοδέτες="Αντόνιο":=Ανθοδέτης("Αντόνιο")
Κατάσταση Ταχυμεταφορείς="Πέπε":=Ταχυμεταφορέας("Πέπε")
Κατάσταση Ανθοπώλεις ="Γιώργος":=Ανθοπώλης("Γιώργος"), "Τζιοβάνι":=Ανθοπώλης("Τζιοβάνι")


\\ εδώ είναι η ρουτίνα που λέει ποιος κάνει παραγγελία, σε ποιον και για ποιον
\\ Ότι φτιάχνουμε στη ρουτίνα διαγραφεται στο τέλος
Παραγγελία("Μαμά", "Γιώργος", "Άννα")
\\ Οπότε σε αυτό το σημείο υπάρχουν ως μεταβλητές μόνο οι καταστάσεις ειδών
\\ οι οποίες είναι τοπικές, δηλαδή θεατές μόνο εδώ και στη Ρουτίνα.
\\ Από τμήμα/συναρτήσεις υπάρχουν οι ορισμοί των κλάσεων που χρησιμοποιούνται ως γενικές συναρτήσεις
\\ δηλαδή είναι θεατές παντού

Τέλος
\\ Οι ρουτίνες γράφονται στο τέλος
\\ ο προορισμός παραμένει όνομα μέχρι να το κάνει αντικείμενο ο ανθοπώλης
\\ διαβάζοντας την βάση
Ρουτίνα Παραγγελία(Πελάτης$, Ανθοπώλης$, Προορισμός$)
    Τοπική Μαμά=Πελάτες(Πελάτης$)
    Τοπική Ομάδα ΜεΓεγονότα Κύριος=Ανθοπώλεις(Ανθοπώλης$)
    \\ Συναρτήσεις εξυπηρέτησης γεγονότων, για το αντικείμενο Κύριος
    Συνάρτηση Κύριος_ΒρεςΠελάτη (Ποιος, &Πελάτης, Εκει$) {
        Τύπωσε "ο ";Ποιος.Όνομα$;" ψάχνει Πελάτη ";Εκεί$;" στη βάση"
        Αν Υπάρχει(Πελάτες, Εκει$) Τότε
            Πελάτης=Εκφρ(Πελάτες)
            Τύπωσε "Βρέθηκε"
        Τελος αν
    }
    Συνάρτηση Κύριος_ΒρεςΑνθοπώλη (Νέο Ποιος, &Ανθοπώλης, Εκει$) {
        Τύπωσε "ο ";Ποιος.Όνομα$;" ψάχνει Ανθοπώλη"
        Αν Υπάρχει(Πελάτες, Εκει$) Τότε
            Πελάτης=Εκφρ(Πελάτες)
            \\ υποτίθεται ότι γίνεται αναζήτηση βάσει διευθύνσεων
            Τύπωσε "Για πελάτη ";Πελάτης.Όνομα$;" θα χρειαστούμε τον Τζιοβάνι"
            \\ αν σκιάσουμε την παρακάτω γραμμή δεν θα βρεθεί ο Τζιοβάνι!
            \\ σκιάζω γραμμή σημαίνει βάζω \\ για να γίνει σημείωση
            Ανθοπώλης=Ανθοπώλεις("Τζιοβάνι")
        Τελος αν
    }
    Συνάρτηση Κύριος_ΒρεςΑνθοδέτη (Νέο Ποιος, &Ανθοδέτης, Εκεί$)  {
        Τύπωσε "ο ";Ποιος.Όνομα$;" ψάχνει Ανθοδέτη για προορισμό ";Εκεί$
        Αν Υπάρχει(Πελάτες, Εκει$) Τότε
            Πελάτης=Εκφρ(Πελάτες)
            \\ υποτίθεται ότι γίνεται αναζήτηση βάσει διευθύνσεων
            Τύπωσε "Για πελάτη ";Πελάτης.Όνομα$;" θα χρειαστούμε τον Αντόνιο"
            Ανθοδέτης=Ανθοδέτες("Αντόνιο")   
        Τελος αν
    }
    Συνάρτηση Κύριος_ΑνάθεσηΑνθοδέτη (Νέο Ποιος, &Ανθοδέτης)  {
        Τύπωσε "ο ";Ποιος.Όνομα$;" αναθέτει Ανθοδέτη:"; Ανθοδέτης.Όνομα$
        \\ εδώ απλά το δείχνω ότι μπορώ να γυρίζω τη τρέχουσα κατάσταση
        \\ στη βάση. αλλά δεν το κάνω αλλού! Δεν χρειάζεται για το παράδειγμα
        Επιστροφή Ανθοδέτες, Ανθοδέτης.Όνομα$:=Ανθοδέτης
    }
    \\  Νέο &ποιος, &μεταφορέας, Προορισμός$
    Συνάρτηση Κύριος_ΒρεςΤαχυμεταφορέα (Νέο Ποιος, &Ταχυμεταφορέας, Εκεί$){
        Τύπωσε "ο ";Ποιος.Όνομα$;" Ψάχνει Ταχυμεταφορέα για προορισμό ";Εκεί$
        Αν Υπάρχει(Πελάτες, Εκει$) Τότε
            Πελάτης=Εκφρ(Πελάτες)
            \\ υποτίθεται ότι γίνεται αναζήτηση βάσει διευθύνσεων
            Τύπωσε "Για πελάτη ";Πελάτης.Όνομα$;" θα χρειαστούμε τον Πέπε"
            Ταχυμεταφορέας=Ταχυμεταφορείς("Πέπε")
        Τελος αν
    }
    Αν Όχι Μαμά.ΚάνειΠαραγγελια(&Κύριος, Προορισμός$) τότε
        Τύπωσε "Δεν μπορεί να γίνει η παραγγελία"
    Τέλος Αν
Τέλος Ρουτίνας
}
MODULE FORMTARGET {\\ FROM 9.9 REVISION 29
\\ WE CAN PLACE TARGETS ON FORMS
\\ TARGETS ARE LIGHTWEIGHT OBJECTS
\\ WE MAKE IT ONCE

\\ STATEMENTS:
\\ TARGET  (2 VARIATIONS, ONE TO DEFINE AND ONE TO ENABLE/DISABLE)
\\ CHANGE  WE HAVE NAMED ARGUMENTS HERE
\\ TARGETS NEW  (WE CAN ERASE PER FORM)
\\ THEY DON'T NEED A SCAN STATEMENT (USED FOR CONSOLE ONLY)
\\ OLD VERSIONS OF M2000 AND THE LAST ONE CAN USE THE BASIC TARGETS

\\ FORM TARGETS VS BASIC TARGETS
\\ BASIC TARGETS CAN BE USED TO EXECUTE A LINE OF STATEMENST AT GLOBAL SCOPE
\\ FORM TARGETS EXECUTE CODE AT THE SAME SCOPE WHERE FORM DEFINED

\\ EACH TARGET HAS TWO FUNCTIONALITIES:
\\ BASIC TARGET:  SEND KEYS TO CONSOLE/EXECUTE CODE TO GLOBAL SCOPE
\\ FORM TARGET:  SEND EVENT TARGET/ EXECUTE CODE TO MODULE SCOPE
\\ EVENT TARGET IS COMMON FOR ALL TARGETS, SENDING THE HANDLER OF TARGET


\\ ONE PARAMETER BEFORE THE LASTING TEXT:
\\ CAN BE 1 TO 9 FOR POSITION OF TEXT, +10 TO USE "SEND" FUNCTION
\\ +100 TO USE PROPORTIONAL TEXT RENDERING.
\\ A 5 IS CENTER VERTICAL END HORIZONTAL.

\\ BASIC TARGETS CAN BE USED IN 34 LAYERS: BACKGROUND, CONSOLE, PLAYERS (32 MAX).
\\ TO SCAN FOR THEM WE USE SCAN STATEMENT USING A NUMBER FOR A TIME WINDOW.

\\ TARGETS VS BUTTONS ON FORMS
\\ A BUTTON IS A CONTROL, WITH METHODS AND PROPERTIES.
\\ TAB AND SHIFT TAB CAN CHOOSE ANY ENABLED BUTTON TO GET FOCUS
\\ TARGETS HAVE NO FOCUS. USED ONLY WITH MOUSE
\\ EACH TARGET IS AN ARRAY OF DATA TO BE USED FOR RENDERING AND SCANNING
\\ SCANNING HAPPEN AT THE MOUSE DOWN EVENT. SO TARGETS GET A CLICK ONLY
\\ BUTTONS GET DOUBLE CLICK, OR SHIFT CAPTION LEFT, OR ENTER, BUT NOT A SIMPLE CLICK



Declare form1 Form
m=false
Module zz {
	\\ target call zz to own object
	\\ so we have to use Layer {} to send to console
	Layer {
		print "ok", timecount
		refresh
		}
	change A, text "ok"
}
Function form1.MouseDown {
	Stack
	refresh
}
Function form1.Target {
	\\ normal events executed to console
	\\ so we have to use Layer to redirect to Form1 layer
	Print "target:", number, A
	Refresh
	Layer Form1 {
		Target A, m
		if m then
			change A, back 2
		else
			change A, back 0
		end if
	}
	m~
}
Layer form1 {
	window 12, 12000, 8000
	form 32, 20
	motion.w;  ' center window
	cls #333333, 0
	cursor 4, 4
	\\ we use immediate execution, in this module
	\\ so we call zz as this module (call local pass current scope to zz)
	target A, "call local zz", 10, 3, 2,15, 105, "press me"
	cursor 4, 8
	\\ 115 means 5 center, 10 use target event, 100 proportional font rendering
	target B,"z", 10, 3, 5,15, 115, "press me too"
}
Method form1,"show",1
Declare form1 nothing
}
MODULE MULTIASSIGN {Dim B(10)=0
(A,B$,B(1))=(100, "Yes", 4)
Print A, B$, B(1)
\\ global X, Y
Set (X,Y)=(4, 5)
Print X, Y
\\ global shadow old global
Set (New X, Y)=(5, 6)
Push (A, B(1))
\\ Set exexute in command line, so A and B(1) isn't visible
\\ we have to place values in stack, so the Set statement get the current stack
\\ and array return the array
Set (X, Y)=Array
Print X, Y
List
\\ define a multi return value as array
Function Alfa(){
	=100, 200
}
(M, N)=Alfa()
Print M, N
Dim Z()
Z()=(1,2)
(M, N)=Z()
Print M, N
}
MODULE CLASS1 {\\ update with types
Form 80,50
\\ counters supposed we provide them from a file
global LastCustomerId=100, ReportId=80
\\
class person {
Private:
	name$, address$, phone$, id
class:
	module person (.name$, .address$, .phone$) {
		LastCustomerId++
		.id<=LastCustomerId
	}	
}

class customer as person {
	Inventory sales
	Class bill {
	Private:
		day$, time$, id
	Public:
		\\ read only property (is a group inside group)
		Property euro {value}
		Function Key$ {
			=.day$+"/"+.time$+"#"+str$(.id,"")
		}
	class:
		Module bill (.day$, .time$, .id, .[euro]) {
		}
	}
	Module CustomerData {
		ReportId++
		Print "Report date:"; Date$(Today)
		Print "ReportId:";ReportId
		Print "Customer:";.id
		Print "Name",.name$
		Print "Address",.address$
		Print "Phone", .phone$
		Print "Transactions:";len(.sales)
		m=each(.sales)
		sum=0
		While m {
			bill=eval(m)
			sum+=bill.euro
		}
		Print "Total Euro:";sum
	}
	Module InsertBill (bill as bill) {
		try {
			Print "New bill:";bill.key$();" for customer ";.id
			Append .sales, bill.key$():=bill
		}
	}
Class:
	Module customer (Where, m as person) {
		this<=m
		append where, .id:=This
	}
}

Inventory Customers
Pen 15 {Print "Adding to Customers"}
For This {
	\\ this is a block for temporary definitions
	K=Customer(Customers, person("George","Athens","0912399"))
	K.CustomerData
	\\ after that group K deleted
}
Pen 15 {Print "Using key to customers to add bills"}
For Customers(LastCustomerId) {
	.InsertBill .bill("20200522", "18:33", 1023, 100)
	.InsertBill .bill("20200526", "09:10", 3129, 150)
	.InsertBill .bill("20200530", "13:20", 5418, 25)
	.CustomerData
}
Pen 15 {Print "Using Iterator 1 - working at original data"}
M=each(Customers)
While M {
	\\ we extract key using eval$(M!)
	\\ so we can work from original data
	For Customers(eval$(M!)) {
		.CustomerData
	}
}
Pen 15 {Print "Using Iterator 2  - working at a copy of data"}
M=each(Customers)
While M {
	\\ or using a copy of data
	K=Eval(M)
	For K  {
		.CustomerData
	}
}
}
MODULE JAVALIKE {\\ to bypass a function we can use this
\\ function alfa {=.beta(![])}
\\ [] is the current stack and when we read it, we get a pointer and leave an empty stack as current stack
\\ so anything we pass to alfa() passed to .beta(), the dot is This, so to This.Beta()

\\ here we use toString$() to call super.toString$() without parameters
\\ For modules is very easy because a module get the current stack
\\ so if we have a member Module alfa {.beta} calling alfa 10,20 is like calling .beta 10, 20 (and all other values the current stack have)

\\ Constructors are modules but called from functions so they get the function's stack (a new one)
\\ Also a constructor skip the erasing phase (the function which call the module do this)
\\ We need this because we can expand the This object.


Report {
	there is no super like java super in M2000 when we use inheritance through classes
	see Superclass (example SUP) which is something differnent
	}


class Shape {
private:
    super.X, super.Y
    Function super.toString$(a=10) {
        ="Shape(" + str$(.super.X,"") + ", " + str$(.super.Y,"") + ")"
    }
public:
       Module final setPosition (px, py) {
           .super.X <= px
           .super.Y <= py
       }
        Function toString$() {
        =.super.toString$()
    }
}
class MoveShape {
      Module MoveRelative(xr, yr) {
            .super.X+=xr
            .super.Y+=yr
      }
}
class Circle as MoveShape as Shape {
private:
    radius
public:
    Module setRadius (r) {
        .radius <= r
    }
    Function toString$() {
        = .super.toString$() + ": Circle(" + str$(.radius,"") + ")"
    }
}

class Rectangle as MoveShape  as Shape {
private:
    height, width
public:
      Module MoveLeftSide (p as *Rectangle) {
      \\ for same type objects private members are like public
           for This, p {
               .super.X<=..super.X+..width
               .super.Y<=..super.Y
           }
      }
    module setDimensions (h,w) {
        .height <= h
        .width <= w
    }
    Function toString$() {
       = .super.toString$() + ": Rectangle(" + str$(.height,"") + " x " + str$(.width,"") + ")"
    }
}
c =Circle()
r = Rectangle()

r.setPosition 1, 2
r.setDimensions 50, 50
c.setPosition 3, 4
c.setRadius 10
Print r.tostring$()
Print c.tostring$()
r.MoveRelative 100,100
c.MoveRelative -50,-50
Print r.tostring$()
Print c.tostring$()

Report  {
	wokring with pointers like in c++
	pointers in M2000 are objects, so null pointer (pc->0&) isn't a zero, but an empty Group (object)
	}
pc->circle()
pr->rectangle()
pr=>setPosition 1, 2
pr=>setDimensions 50, 50
pc=>setPosition 3, 4
pc=>setRadius 10
Print pr=>tostring$()
Print pc=>tostring$()
\\ we can open up to ten objects (from one to ten dots, normaly one to three)
\\ if we use nestef for object {} also we have up to ten objects in total
\\ every for object {} is an area for temporary definitions, after exit from brackets
\\ any new definition erased.
For pr, pc {
	.MoveRelative 100,100
	..MoveRelative -50,-50
	Print .tostring$()
	Print ..tostring$()
}
pr2->rectangle()
pr2=>SetDimensions 30, 30
pr2=>MoveLeftSide pr
Print pr2=>toString$()
}
MODULE ΚΛΑΣΗ1 {Κλάση Ζώο {
Ιδιωτικό:
	πόδια=0
	ήχος$="τίποτα"
Δημόσιο:
	Συνάρτηση Τελική ΠόσαΠόδια() {
		=.πόδια
	}
	Συνάρτηση ΚάνωΉχο$() {
		=.ήχος$
	}
}
Κλάση Κατοικίδιο ως Ζώο {
Ιδιωτικό:	
	όνομα$
	Μήνυμα$="Με φωνάζουν {0} και είμαι κατοικίδιο με {1} πόδια και όλη μέρα {2}"	
Δημόσιο:
	Συνάρτηση Μήνυμα$() {
		=.Μήνυμα$
	}
	Συνάρτηση ΜεΦωνάζουν$() {
		=.όνομα$
	}
Κλάση:
	Τμήμα Κατοικίδιο {
		Διάβασε .όνομα$, .ήχος$, .πόδια
	}
}
Κλάση Σκύλος ως Κατοικίδιο {
	Συνάρτηση ΜεΦωνάζουν$() {
		=.όνομα$+" και είμαι σκύλος"
	}
Κλάση:
	Τμήμα Σκύλος(.Όνομα$)	{
		.πόδια<=4
		.ήχος$<="γαβγίζω"
	}
}
Κλάση Γάτα ως Κατοικίδιο {
	Συνάρτηση ΜεΦωνάζουν$() {
		=.όνομα$+" και είμαι γάτα"
	}
Κλάση:
	Τμήμα Γάτα(.Όνομα$)	{
		.πόδια<=4
		.ήχος$<="νιαουρίζω"
	}
}
Κλάση Πουλί ως Κατοικίδιο {
Ιδιωτικό:
	τύπος$="κάτι"
	Μήνυμα$="Με φωνάζουν {0} με {1} πόδια και φτερά και όλη μέρα {2}"
Δημόσιο:
	Συνάρτηση ΜεΦωνάζουν$() {
		=.όνομα$+" και είμαι "+.τύπος$
	}
Κλάση:
	Τμήμα Πουλί(.Όνομα$, .τύπος$)	{
		.πόδια<=2
		.ήχος$<="κελαηδάω"
	}	
}
Εγγραφο ΌλαΜαζι$={Τελική Αναφορά
}
Αζορ=Σκύλος("Αζόρ")
Τι(Αζορ)
Ψιψίνα=Γάτα("Ψιψίνα")
Τι(Ψιψίνα)
Φλοξ=Πουλί("Φλοξ", "καναρίνι")
Τι(Φλοξ)
ΆλλοΚατοικίδιο=Κατοικίδιο("Ντορή", "χλιμιντρίζω", 4)
Τι(ΆλλοΚατοικίδιο)
\\ στέλνουμε στο πρόχειρο την αναφορά
Πρόχειρο ΌλαΜαζι$

Τέλος
\\ Η ρουτίνα δέχεται οτιδήποτε είναι κατοικίδιο
\\ έτσι δέχεται Κατοικίδιο, Γάτα, Σκύλος, Πουλί
Ρουτίνα Τι(Α ως Ομάδα)
	Τοπική Εξ$=Μορφή$(Α.Μήνυμα$(),Α.ΜεΦωνάζουν$(), Α.ΠόσαΠόδια(), Α.ΚάνωΉχο$())
	ΌλαΜαζι$=Εξ$+{
	}
	Αναφορά Εξ$
Τέλος Ρουτίνας
}
MODULE PRIVATE {\\ example for private class, and private group made from private class
class beta {
private:
	class alfa {
	private:
		m=10
		c=0
	public:
		group counter {
			value {
				link parent c to c
				=c
			}
		}
		value {
			=.m
			.c++
		}
		set {
			read .m
			.c++
		}
	}
	alfa M
	dim a()
Public:
	Module Doit {
		Print  .M, .M, .M, .M.counter=3
		Push 1,2,3
		Read .M, .M, .M
		Print .M.counter=6
		.M<=10
		Print .M
		Print .M.counter=8
		dim .a(5)=group(.M)
		For i=0 to 4:.a(i)=i:Next
		for i=0 to 4
			Print .a(i), .a(i).counter=10
		next
		z=list:= 1:=group(.M), 2:=group(.M)
		Print z(1), z(2)
		Print z(1).counter=9, z(2).counter=9
		Print type$(z,1)="Group"
		Return z, 1:=500
		Print type$(z,1)="Double"
		p->z(2)
		Print p=>counter=9
		p=>=1234
		Print p=>counter=10
		Print  eval(p)=1234
		Print p=>counter=11
		Print eval(z(2))=1234
		Print p=>counter=12
		k=.A()
		\\ k#eval(3) execute value { } from a copy of A(3)
		Print k#eval(3)=3
		\\ k#val(3) extract a copy of group
		MM=k#val(3)
		Print MM.counter=10
		Print .A(3)=3, .A(3).counter=11
		\\ pointers may change where points to
		p->.A(3)
		Print eval(p)=3, p=>counter=12, .a(3).counter=12
		\\ dot is This.
		Print This.a(3).counter=12
	}
}
Z=beta()
Z.Doit
List
Modules ?
}
MODULE PRV_STR {\\ a simple example 2 - class in class in class
\\ creating classes which return string value
class delta {
class:
private:
	class beta {
	Private:
		class z$ {
		private:
			what$
			val=counter
		public:
			value {
				=.what$+str$(.val)
			}
		class:
			\\ constructor
			module z (.what$) {
			counter++
			}
		}
		z$ k("hello"), m("yes")
	Public:
		module doit {
			print .k$, .m$
			print .k is type z, .m is type z
		}
		Function ExtractTwo {
			=(.k, .m)
		}
	}
	\\ constructor
public:
	module delta {
		global counter=500
		b=.beta()
		b.doit
		c=.beta()
		c.doit
		this=.beta()
	}
}
z=delta()
print z is type delta
print z is type beta
List
Modules ?
module check (k as beta) {
	k.doit
}

check z

module check2 (&k as beta) {
	k.doit
}

(A1, A2)=z.ExtractTwo()

Print A1$, A2$
Print A1 is type z, A2 is type z
\\ we make a group to have same type
Group Trait$ {
	type:z
	Value (a as z, b as z) {
		="two names: "+a.what$+"/"+b.what$
	}
}
Print Trait$(A1, A2)
\\ now with no type
Group Trait2 {
	Function Two$(a as z, b as z) {
		="two names: "+a.what$+"/"+b.what$
	}
}
A3=A1 with Trait2
Print A3 is type z
Print A3.Two$(A1, A2)


}
MODULE GROUPTYPES {\\ from revision 33 version 9.9 we have group types
Report {First Example
Theory:
	Static groups may have a type or not.
	We can add one or more types by hand, using type: Type1, Type2, ...
	If a group created by other group automatic add types from that group
	if a group merged another group  automatic add that types from that group
	The type list inside group hold uniqe names
Practice:
	Call a method passing by reference checking for type. Private variables are available as public when objects have the same type. If two objects have no type then we have no equal types by default.
	
}
Group alfa {
\\ we can place any number of types
type: mytype1, mytype2
private:
		x=10, y=50
		L=lambda (k)->k*2+5
public:
	module process (&m as mytype1) {
		m.x++
		m.y+=m.L(3)
	}
	module changeL(fun) {
		.L<=fun
	}
	function toString$ {
		=format$("x={0} y={1}", .x, .y)
	}
	
}
beta=alfa
beta.changeL (lambda->1)
alfa.process &beta
Print beta.tostring$()

Report {

Second Example

Theory:
	A class definition automatic add a type: classname
	A class can be extended using previously dedined classes
	When we extent a class we say that as inheritance at source
	When we merge a group from another we say that as ingeritance at object
	A class can be in module level, or as group/class member
	In module level a class is global, until the end of module/function/sub execution, or the statement  For <object> { }, where the definition executed.
	In a class/group the class definition can be public or private.
Pracite:
	We define a class with an inner class and a group defined from inner class, The inner group define operator "="  and when we place a same type group process the operator process the operator using the private variables from the other group (is a copy of the other group). If the type isn't the same return false.
	We define false as boolean, because in M2000 true is double -1, and false is double 0, but all comparisons return boolean true and false. Any identtifier from M2000 vocabulary can be used localy in variables and modules definitions, except for those identifiers which used for flow control (like If, Repeat, While)
}
class delta {
	class zeta {
	private:
		x=10, y=50
	public:
		operator "=" {
			def boolean false
			read other
			if other is type zeta then
				push .x=other.x and .y=other.y
			else
				push false
			end if
		}
	}
	zeta One, Two
}
delta=delta()
Print delta is type delta
Print delta.One=delta.Two
Print delta.one=delta

\\third example using pointers and types for group pointers too
Report {

Third Example

Theory:
	We can use pointers to groups. there are two kinds of pointers (this is hidden in use, except fron one condition as describe later)
	A true pointer hold the group alive. When no pointer point to a group the group deleted. We make a group pointer from any no named Group
	A false pointer hold the weak reference of a named Group (a static object). When the object erased, the false pointer hold the weak reference and nothing happen until we want to use it. Then the weak reference can't resolved to a real reference and we get an error.
	If Alfa is a group then M->Alfa or M=Pointer(Alfa) get a false pointer.
	To get a true pointer we use Parenthesis so M->(Alfa) or M=Pointer((A)) make a copy of A (as an unamed group) and the pass an object to it
	If we have an group in an array say ata A(5) then there we have an unamed group so M->A(5) give a true pointer.
	We can interchange values to pointers from any kind true or false.
	A M->0& place a pointer to an empty Group. There isn't a Null value. We can use group.count(M) to check for number of variable/arrays member.
	
	A trait: We define a group to add it to a final group, replacing a function, without a type
	We use final to those methods (modules, functions, operators) which can't changed if further merging happen at source or object ihhertitance.
	
Pracrice:
	We make class prive with private and public members. We make class epsilon as prive extenting with operator, and two functions, plus a constructor and a deconstructor. We start make some pointers from the class. The M3 is an epsilon type with a trait. So M3 has a class of types epsilon and prive, which are inheritance in code  plus a trait (with no type) which is inheritance at object level
	 We can use the pointers to operate the equal operator. From two functions add5() and sub5() we place pointer checking the type, and return a pointer for a new defined same type object, without calling the constructor because we make it using a copy of current object, and becaue has the same type we can change private variables too.
}
class prive {
private:
	x, y
public:
	function ToString$ {
		=format$("private data: x={0}, y={1}", .x, .y)
	}
}
class epsilon as prive {
public:
	operator final "=" {
			def boolean false
			\\ convert other to group if not,  for sure
			read other as group
			if other is type epsilon then
				push .x=other.x and .y=other.y
			else
				push false
			end if
	}
	
	function final add5(other as *epsilon) {
		\\ we get a pointer from a copy of this
		\\ because m is in a same type object
		\\ we have access to private variables
		m->(this)
		\\ I add some spaces for clarity
		m=>x <= other=>x + 5
		m=>y <= other=>y + 5
		=m
	}
	
	function final sub5(other as *epsilon) {
		\\ we get a copy of this
		m=this
		\\ I add some spaces for clarity
		m.x <= other=>x - 5
		m.y <= other=>y - 5
		\\ now we make a pointer from a copy of m
		->(m)
		\\ this way we make two copies
		Print "call the remove member for a named group, only using Clear"
		clear m
	}
	
	remove {
		print "epsilon removed"
	}
class:
	module epsilon (.x, .y) {
		print "epsilon created"
	}
}
\\ used as mixin  - we need it as Group, with no type
Group ReplaceTostring {
	function ToString$ {
		=format$("private data: x={0}, y={1} from replaced function", .x, .y)
	}
}
M1->epsilon(10,40)   ' create one
Print M1=>ToString$()
M2->epsilon(10, 40) '  2 created until now
M3->(epsilon(30,40)  with ReplaceToString) ' 3 created until now through constructor.
Print M3 is type epsilon
Print M3=>tostring$()
Print M1=M2, M2=M3
M4=M3=>add5(M3)  ' 4 created, the 4th without constructor.
Print M4=>tostring$()
M5=M4=>sub5(M3)  
Print M5=>tostring$()
}
MODULE TRAVERSAL2 {Report {
          Tree traversal
                   1
                  / \
                 /   \
                /     \
               2       3
              / \     /
             4   5   6
            /       / \
           7       8   9

} 
Pen 15 {Report "Using types in class Node"}
Print
Module OOP {
      Class Node {
      private:
            \\ Pointer() of Pointer(0) is the Null type pointer
            x, LeftNode=Pointer(), RightNode=Pointer()
      Public:
            Module preorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T)
                        If T is type Null Then Exit sub
                        call visitor(T=>x)
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)
                  end sub
            }
            Module inorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T)
                        If T is type Null Then Exit sub
                        printtree(T=>LeftNode)
                        call visitor(T=>x)
                        printtree(T=>RightNode)
                  end sub
            }
            Module postorder (visitor) {
                  T->This
                  printtree(T)
                  sub printtree(T)
                        If T is type Null Then Exit sub
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)            
                        call visitor(T=>x)
                  end sub
            }
            Module level_order (visitor){
                  M=stack:= Pointer(This)
                  \\ using M as FIFO
                  Stack M {
                        if empty then exit
                        Read T
                        if T is type Node Then
                              call visitor(T=>x)
                              Data T=>LeftNode, T=>RightNode
                        end if
                        Loop
                  }
            }
            remove {
                   print format$("node {0} destroyed", .x)
            }
      Class:
            Module Node {
                  Read .x, .LeftNode, .RightNode
            }
      }
      \\ Function NodeTree return a pointer to a new Node
      Function NodeTree {
            \\ ![] pass currrent stack to Node()
            ->Node(![])
      }
      \\ Tree is type Node

      Tree=NodeTree(1, NodeTree(2,NodeTree(4, NodeTree(7)), NodeTree(5)), NodeTree(3, NodeTree(6, NodeTree(8), NodeTree(9))))
 
      printnum=lambda (title$) -> {
            Print
            Print title$;
            =lambda (x)-> {
                  Print x;" ";
            }
      }
      Tree=>preorder printnum("preorder:    ")
      Tree=>inorder printnum("inorder:     ")
      Tree=>postorder printnum("postorder:   ")
      Tree=>level_order printnum("level-order: ")
      Print
      Print
}
OOP

Pen 15 {Report "Using types and  inheritance: a class Tree as a class Node, which returns a pointer to Tree object"}
Print

Module OOP {
      Class Node {
      private:
            \\ Pointer() of Pointer(0) is the Null type pointer
            x, LeftNode=Pointer(), RightNode=Pointer()
      Public:
            Module preorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T)
                        If T is type Null Then Exit sub
                        call visitor(T=>x)
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)
                  end sub
            }
            Module inorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T)
                        If T is type Null Then Exit sub
                        printtree(T=>LeftNode)
                        call visitor(T=>x)
                        printtree(T=>RightNode)
                  end sub
            }
            Module postorder (visitor) {
                  T->This
                  printtree(T)
                  sub printtree(T)
                        If T is type Null Then Exit sub
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)            
                        call visitor(T=>x)
                  end sub
            }
            Module level_order (visitor){
                  M=stack:= Pointer(This)
                  \\ using M as FIFO
                  Stack M {
                        if empty then exit
                        Read T
                        if T is type Null Else
                              call visitor(T=>x)
                              Data T=>LeftNode, T=>RightNode
                        end if
                        Loop
                  }
            }
            remove {
                   print format$("node {0} destroyed", .x)
            }
      }     
     Class Tree as Node {
            value (xval) {
                  .LeftNode<=Pointer()
                  .RightNode<=Pointer()
                  Read ? .LeftNode, .RightNode
                  .x<=xval
                  ->(This) 
            }          
	
      }
      \\ now NodeTree is a static group with value which generate other trees.
      \\ Tree is type Tree 
      NodeTree=Tree()      
      Tree=NodeTree(1, NodeTree(2,NodeTree(4, NodeTree(7)), NodeTree(5)), NodeTree(3, NodeTree(6, NodeTree(8), NodeTree(9))))

      printnum=lambda (title$) -> {
            Print
            Print title$;
            =lambda (x)-> {
                  Print x;" ";
            }
      }
      Tree=>preorder printnum("preorder:    ")
      Tree=>inorder printnum("inorder:     ")
      Tree=>postorder printnum("postorder:   ")
      Tree=>level_order printnum("level-order: ")
      Print
      Print
}
OOP

Pen 15 {Report "Using types and inner class Node in a class Tree which returns a pointer to Node object"}
Print


Module OOP {
      Class Tree {
      Private:     
            Class Node {
            private:
                  \\ Pointer() of Pointer(0) is the Null type pointer
                  x, LeftNode=Pointer(), RightNode=Pointer()
            Public:
                  Module preorder (visitor){
                        T->This
                        printtree(T)
                        sub printtree(T)
                              If T is type Null Then Exit sub
                              call visitor(T=>x)
                              printtree(T=>LeftNode)
                              printtree(T=>RightNode)
                        end sub
                  }
                  Module inorder (visitor){
                        T->This
                        printtree(T)
                        sub printtree(T)
                              If T is type Null Then Exit sub
                              printtree(T=>LeftNode)
                              call visitor(T=>x)
                              printtree(T=>RightNode)
                        end sub
                  }
                  Module postorder (visitor) {
                        T->This
                        printtree(T)
                        sub printtree(T)
                              If T is type Null Then Exit sub
                              printtree(T=>LeftNode)
                              printtree(T=>RightNode)            
                              call visitor(T=>x)
                        end sub
                  }
                  Module level_order (visitor){
                        M=stack:= Pointer(This)
                        \\ using M as FIFO
                        Stack M {
                              if empty then exit
                              Read T
                              if T is type Node Then
                                    call visitor(T=>x)
                                    Data T=>LeftNode, T=>RightNode
                              end if
                              Loop
                        }
                  }
            remove {
                   print format$("node {0} destroyed", .x)
            }
            Class:
                  Module Node {
                        Read .x, .LeftNode, .RightNode
                  }
            }
      public:
            value (xval as double) {
                  Rem {
                        LeftNode=Pointer()
                        RightNode=Pointer()
                        Read ? LeftNode, RightNode
                        ->.Node(xval,LeftNode, RightNode)
                  }
                  ->.Node(xval,![])
            }          
	
      }
      \\ now NodeTree is a static group with a private Node class
      \\ return a pointer to a Node object
      \\ Tree is type Node
      NodeTree=Tree()      
      Tree=NodeTree(1, NodeTree(2,NodeTree(4, NodeTree(7)), NodeTree(5)), NodeTree(3, NodeTree(6, NodeTree(8), NodeTree(9))))
      
      printnum=lambda (title$) -> {
            Print
            Print title$;
            =lambda (x)-> {
                  Print x;" ";
            }
      }
      Tree=>preorder printnum("preorder:    ")
      Tree=>inorder printnum("inorder:     ")
      Tree=>postorder printnum("postorder:   ")
      Tree=>level_order printnum("level-order: ")
      Print
      Print
}
OOP
}
MODULE GRTYPES {module UsingNamedObjects {
	\\ private members used as public inside a method
	\\ for any object.
	class alfa {
	private:
		dim a()
	public:
		module changethis (&p as alfa) {
			\\ m is a pointer to array (mArray object)
			\\ p.a() not work outside an alfa type method
			m=p.a()
			\\ pointer to arrays have some operators
			m+=10
			Print type$(m)
		}
		module PrintMe {
			\\ we can use .a() or this.a()
			print this.a()
		}
		Remove {
			Print "alfa type object deleted"
		}
	class:
		module alfa (n) {
			\\ redim array
			dim .a(10)=n
		}
	}
	
	b=alfa(3)
	c=alfa(6)
	b.PrintMe
	c.PrintMe
	\\ So now we pass pointer c to b.changethis
	b.changethis &b
	b.changethis &c
	b.PrintMe
	c.PrintMe
	\\ only manual we can call the remove function for named objects
	Clear b, c
}
UsingNamedObjects

module UsingPointersToObjects {
	\\ private members used as public inside a method
	\\ for any object.
	class alfa {
	private:
		dim a()
	public:
		module changethis (p as *alfa) {
			\\ m is a pointer to array (mArray object)
			\\ p=>a() not work outside an alfa type method
			m=p=>a()
			\\ pointer to arrays have some operators
			m+=10
			Print type$(m)
		}
		module PrintMe {
			\\ we can use .a() or this.a()
			print this.a()
		}
		Remove {
			Print "alfa type object deleted"
		}
	class:
		module alfa (n) {
			\\ redim array
			dim .a(10)=n
		}
	}
	
	b->alfa(3)
	c->alfa(6)
	b=>PrintMe
	c=>PrintMe
	\\ So now we pass pointer c to b.changethis
	b=>changethis b
	b=>changethis c
	b=>PrintMe
	c=>PrintMe
	\\ now b and c erased
	\\ and because no other pointers hold the objects, destroyed.
	\\ so the remove function call automatic
}
UsingPointersToObjects
}
MODULE FIRSTWINDOW {Title "Example#1"
Pen 14
Cls 5,0
Thread.plan concurrent
Function Dec3$ { =Str$(Number/1000,"####0.000")}
Function Dec$ { =Str$(Number,"####0.000")}
Declare Form1 Form
Method Form1, "FontAttr", "Tahoma", 48
Method Form1, "CtrlFontAttr", "Tahoma", 24
Layer Form1 {
      Window 14, 12000,8000
      Font "Verdana"
      Print $(4,8) \ Proportional and  8 char width for columns
}
Declare Text1 TextBox Form Form1
Method Text1,"move", 3000, 2000, 8000, 900
With Text1, "Prompt", "Name: ", "MaxCharLength", 30+6

Declare Spinner TextBox Form Form1
Def Alone as boolean
\\\ spinner values: ShowBar, MinValue , MaxValue , LargeValue.
\\Range include MinValue and MaxValue
\\ So we have integers (sign long) but we can display it like a float

Method Spinner "Spinner", True, 0,2000,30
Method Spinner "Move", 3000, 3000, 8000, 900
With Spinner, "Prompt", "A_Value: ",  "Value" as Spi, "VarText" as  Feed$, "ThisKind"," units"
\\ Spinner is a textbox with some advanced performance
\\ We use ValidString to check every new value
\\ we use SpinnerValue to format the value
\\ Inside ValidString we use "Value" as Spi, to cut off higher or lower values.

Function Spinner.SpinnerValue {
            Read val
            Feed$=Dec3$(val)
            }

Function Spinner.ValidString {
            \\ this function called direct from textbox
            Read  New &this$, &thispos
            Local Alfa
            Try {     
                  \\ Spi is an alias for Value property      
                Alfa=val(this$)*1000 : Spi= Alfa :  Alfa=Spi
            }
            if valid(Alfa) then {
                  this$=dec3$(Alfa)
            } else {
                  thispos=1000
      }
}
Feed$=Dec$(1.34)

Declare CheckBox1 CheckBox Form Form1
Method CheckBox1 "Move", 3000, 4000, 8000, 900
With CheckBox1,"Caption", "Check This Please", "Checked" as CheckGet, "CheckReset" as CheckPut
CheckPut=True


Declare Button1 Button Form Form1
Method Button1 "Move", 3000, 5000, 8000, 900
With Button1,"Caption", "Reset CheckButton"

Function Button1.Click {
      CheckPut= Not CheckGet
      \\ No Event Fired, so we make here the change
      If CheckGet Then {
            With Button1,"Caption", "Reset CheckButton"
      } Else {
            With Button1,"Caption", "Set CheckButton"
      }
}

Function CheckBox1.Changed {
      Read Val
      Layer Form1 {Print "CheckBox Value ";Val}
      If Val Then {
            With Button1,"Caption", "Reset CheckButton"
      } Else {
            With Button1,"Caption", "Set CheckButton"
      }
}
Function CheckBox1.Click {
      Read Val
      Layer Form1 {Print "CheckBox Value ";Val}    
}

With Form1, "Title", "First Window", "visible" as visible
Method Form1,"Show"
Layer Form1 {
      Cls 1,0
      Scroll Split 2  \\ scroll from 3rd line - same as Cls ,2
      Cursor 0, Height/2-1  
      Report 2, "Hello World"
}

With Text1, "VarText" as VarText$
Thread {
      Static work  \\ we use it for trash bin
      if alone then continue
           if not empty then work=ask(letter$,"Four Controls in M2000") : Flush \\ stack is empty now

} as worker interval 100
Function Text1.Click {
      Layer Form1 {Print "click" }
}
Function Text1.Enter {
      Layer Form1 {Print VarText$ }
}
Function Spinner.Enter {
      Layer Form1 {Pen 15 {Print Val(Feed$)}}
}
Function Form1.Click {
      \\ we can push values to Thread Stack for Values
      \\ Data push at bottom, Push push at top
      \\ always we pop from top we Read Variables or
      \\ immediate with Number/Letter$
      Document Doc$={Hello There 
      }
      Doc$="This is your name "+VarText$+{
      }
      Doc$="This is a value "+Feed$+{
      }
      Doc$="The CheckBox is "+Str$(CheckGet,{;"Checked";"No Checked";})+{
      }
      Thread worker Execute Data Doc$
      Clear Doc$
}

\\ some nice background tasks
kk=0
Thread {      
      kk++
      layer  {
            layer  Form1 {
                  print kk
                  part {
                      refresh 
                  } as alone
            }
            Draw To Random(Scale.x), Random(Scale.y), Random(7,15)
      }
} As Print2Form Interval 50

\\  main loop
Main.Task 50 {
       if not visible then exit
}
Threads Erase
Thread.plan sequential
Declare Form1 Nothing
}
MODULE POLYGONS {module drawPolygon {
      read n, d
      s=d*3
      d4=d/4
      for i=1 to n {
            width 4 {      
                  draw angle i*pi/(n/2), s/n
            }
      }
      step -d4, -d4
      floodfill ,,5
      step d4, d4
      step d
}
module clearScreen {
window 12, 14000,10000;
cursor 0,0
gradient 6,1
double
path  {
      report 2 , "POLYGON EXAMPLE"
};    
normal
gradient 4,13,0
\* RESET THE path
move 0,0
path {
      polygon 0, x.twips, 0,0,y.twips,-x.twips,0,0,-y.twips
};
cursor 0,0
double
width 2 {
color  {
      report 2 , "POLYGON EXAMPLE"
}
}
normal
}
clearScreen
show
s=scale.x/sqrt(87.6)
top=scale.y/sqrt(8.2)
move s, top
for i = 3 to 11 {
      drawPolygon i, s
}
move s, top+s
for i = 12 to 19 {
      drawPolygon i, s
}
move s, top+2*s
for i = 19 to 12 {
      drawPolygon i, s
}
move s, top+3*s
for i = 11 to 3 {
      drawPolygon i, s
}
copy "this.bmp"    'export to bmp
A$=KEY$ ' Wait for a keypress
if module(info) then info
}
MODULE GRAPHGR {οθόνη 1,0   \\ μπλε χρώμα, χωρίς χωριστή οθόνη
κ=0
ανανέωση 50
\\ κάνουμε την αυτόματη ανανέωση πιο αργή, ανά 5 δευτερόλεπτα
πάχος 1, 3 {  \\ αξονική γραμμή - μόνο για πάχος 1
      θέση  χ.σημεία, υ.σημεία/2
      χάραξε -χ.σημεία
      θέση  χ.σημεία/2, υ.σημεία
      χάραξε , -υ.σημεία
      }
για ν=3 έως 63 {
      α=ν/2/πι
      β=χ.σημεία/3/ν+ν*10
      \\ απόλυτη θέση
      θέση  χ.σημεία/2, υ.σημεία/2
      κ+=πι/10
      λ=1
      για ι=1 έως ν {
           πάχος λ {
                 \\ πολικές συντεταγμένες: απόλυτη γωνία σε ακτίνια, σχετική απόσταση
                 \\ η χάραξε  έχει τρεις μορφές
                 \\ χάραξε γωνία  απόλυτη_γωνία,  απόσταση  [, χρώμα]
                 \\ χάραξε απόσταση_κατά_χ [, απόσταση_κατά_ψ [, χρώμα]]
                 \\ χάραξε έως απόλυτη_θέση_χ, απόλυτη_θέση_ψ [, χρώμα]
                  χάραξε γωνία ι/α+Κ, β, χρώμα(255*ν/24, 255*ι/ν, 255-255*ι/ν)
            }
            λ=3-λ
      }
}
\\ τώρα επαναφέρουμε την αυτόματη ανανέωση ανά 0.025 δευτερόλεπτα
ανανέωση 25
}
MODULE ΓΡΑΦΙΚΟ {θεσε γρηγορα !
Ομαλά Ναι
ζβ=πι/32 \\ αν βάλουμε 48 κάνει πιο ωραία καμπύλη
ζβ1=ζβ/2 \\ αν βάλουμε αντί για 2 μεγαλύτερο θα δούμε άλλα σχέδια
ζ=πι+ζβ*8
ζ1=ζβ1*16
\\ στο μέσον!
κχ=χ.σημεια/2
κυ=υ.σημεια/2
μκ=Μικρό.Σειράς(χ.σημεια, υ.σημεια)*.3
ανανεωση 2000 \\ για να μην εμφανίσει αλλαγές της οθόνης, εκτός αν θέλουμε!
διπλα
φοντο 1,5
δρομεας 0,0
αναφορα 2,"Παράδειγμα Χρήσης Γραφικών με τη Μ2000"
κανονικα
γ(μκ,κχ,κυ,πι/4)
μκ2=μκ δια 2
Άδειασε  ' αδειάζει το σωρό
κκ=ψευδες
κρατησε   \\ σώνουμε προσωρινά την εικόνα
πάχος 3 { \\ βάζουμε πάχος στις γραμμές μας
      καθε 10 {
            αφησε  \\ αντί να σβήσουμε βάζουμε ότι έχουμε σταθερό
            θεση κχ, κυ
            βήμα γωνια (πι/2+πι/4)+ζ,μκ2 \\ η θέση του εσωτερικού κύκλου
            κ(μκ2,θέση.χ, θέση.υ, -ζ1, &κκ) \\ την πρώτη φορά απλά παίρνει τα σημεία
            \\ η κ κάθε άλλη φορά θα σώνει την οθόνη χωρίς τον εσωτερικό κύκλο
            δ(μκ2,θέση.χ,θέση.υ,-ζ1, 1) \\ τυπώνει το κύκλο
            \\ με την ανανέωση εμφανίζουμε τις αλλαγές 
            ανανεωση 2000
            αν ενκομ$<>"" η δείκτης τοτε εξοδος
            ζ+=ζβ
           αν κκ τότε{ αν ζ>4*πι τότε κκ=ψευδής} αλλιώς άδειασε
            ζ1+=ζβ1*2
      }
}
Αδειασε
Θέσε Γρήγορα
Ρουτίνα δ(α, Χ, Ψ, ζ, τρικ)
      παχος 2,3 {
            \\ άξονες  -- ενώ απ' έξω έχουμε αλλάξει το πάχος σε 2
            βημα γωνια ζ+πι/4, -α
            κυκλος α/16
            βημα γωνια ζ+πι/4, -α 
            κυκλος α/16
            χαραξε γωνια ζ+πι/4 , α*3
            κυκλος α/16 
            χαραξε γωνια ζ+πι/4 , α
            κυκλος α/16 
            θεση Χ, Ψ
            βημα γωνια ζ-πι/4,-α*2
            κυκλος α/16
            χαραξε γωνια ζ-πι/4,α*4
            κυκλος α/16
      }
      θεση Χ, Ψ
      κυκλος α
Τέλος Ρουτίνας
Ρουτίνα κ(α, Χ, Ψ, ζ, &σχεδιασε)
      θεση Χ, Ψ
      βημα γωνια ζ+πι/4, -α*2
      Σειρά θέση.χ, θεση.υ
      βημα γωνια ζ+πι/4 , α*4
      Σειρά θέση.χ, θεση.υ
      θεση Χ, Ψ
      βημα γωνια ζ-πι/4,-α*2
      Σειρά θέση.χ, θεση.υ
      βημα γωνια ζ-πι/4,α*4
      Σειρά θέση.χ, θεση.υ
      Αν σχεδίασε τοτε
            Για ι=1 εως 4
                  θεση αριθμός, αριθμός
                  πάνω 8,2   ' δυο φορές το Πάνω 8
                  χαραξε εως αριθμός, αριθμός, ι+8
            Επόμενο
            κράτησε \\ σωνει την οθόνη
      Τέλος Αν
      σχεδιασε=αληθης 
      θεση Χ,Ψ
Τέλος Ρουτίνας
Ρουτίνα Γ(α, Χ, Ψ, ζ)
      θεση Χ, Ψ
      πάχος 2 {
            κυκλος α
            κυκλος α/2,1,7 
            παχος 1,3 {
                  βημα γωνια ζ+πι/4, -α*1.05
                  χαραξε γωνια ζ+πι/4 , α*2.1
                  θεση Χ, Ψ
                  βημα γωνια ζ-πι/4,-α*1.05
                  χαραξε γωνια ζ-πι/4,α*2.1
            }
      }
Τέλος Ρουτίνας
}
UseThis : InfoBasic : Pen 15 {Print "Press F3 now"}